(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./src/main.coffee":[function(require,module,exports){
var Blueprint, BlueprintEditor, FPSCounter, Game, Hull, Person, PlayerPersonController, PlayerShipController, Ship, ShipHud;

Function.prototype.property = function(prop, desc) {
  return Object.defineProperty(this.prototype, prop, desc);
};

Blueprint = require('ship/Blueprint');

BlueprintEditor = require('BlueprintEditor');

FPSCounter = require('util/FPSCounter');

Game = require('Game');

Hull = require('ship/Hull');

Person = require('Person');

PlayerShipController = require('PlayerShipController');

PlayerPersonController = require('PlayerPersonController');

Ship = require('ship/Ship');

ShipHud = require('ShipHud');

window.onload = function() {
  var callback, game;
  console.log("loaded");
  window.game = game = new Game();
  game.start();
  callback = function(bp) {
    var controller, hud, person;
    game.camera.z = 20;
    window.ship = new Ship(bp);
    person = new Person();
    person.board(ship);
    controller = new PlayerShipController(ship);
    hud = new ShipHud(ship);
    game.addEntity(ship);
    game.addEntity(person);
    game.addEntity(controller);
    game.addEntity(hud);
    return game.camera.follow(ship);
  };
  return game.addEntity(new BlueprintEditor(new Blueprint, callback));
};



},{"BlueprintEditor":"/Users/tyemilldeveloper/space-game/src/BlueprintEditor.coffee","Game":"/Users/tyemilldeveloper/space-game/src/Game.coffee","Person":"/Users/tyemilldeveloper/space-game/src/Person.coffee","PlayerPersonController":"/Users/tyemilldeveloper/space-game/src/PlayerPersonController.coffee","PlayerShipController":"/Users/tyemilldeveloper/space-game/src/PlayerShipController.coffee","ShipHud":"/Users/tyemilldeveloper/space-game/src/ShipHud.coffee","ship/Blueprint":"/Users/tyemilldeveloper/space-game/src/ship/Blueprint.coffee","ship/Hull":"/Users/tyemilldeveloper/space-game/src/ship/Hull.coffee","ship/Ship":"/Users/tyemilldeveloper/space-game/src/ship/Ship.coffee","util/FPSCounter":"/Users/tyemilldeveloper/space-game/src/util/FPSCounter.coffee"}],"/Users/tyemilldeveloper/space-game/node_modules/browserify/node_modules/path-browserify/index.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":"/Users/tyemilldeveloper/space-game/node_modules/browserify/node_modules/process/browser.js"}],"/Users/tyemilldeveloper/space-game/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/Line.js":[function(require,module,exports){
var Scalar = require('./Scalar');

module.exports = Line;

/**
 * Container for line-related functions
 * @class Line
 */
function Line(){};

/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
Line.lineInt = function(l1,l2,precision){
    precision = precision || 0;
    var i = [0,0]; // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2*b1;
    if (!Scalar.eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
};

/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
Line.segmentsIntersect = function(p1, p2, q1, q2){
   var dx = p2[0] - p1[0];
   var dy = p2[1] - p1[1];
   var da = q2[0] - q1[0];
   var db = q2[1] - q1[1];

   // segments are parallel
   if(da*dy - db*dx == 0)
      return false;

   var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx)
   var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy)

   return (s>=0 && s<=1 && t>=0 && t<=1);
};


},{"./Scalar":"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/Scalar.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/Point.js":[function(require,module,exports){
module.exports = Point;

/**
 * Point related functions
 * @class Point
 */
function Point(){};

/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
Point.area = function(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));
};

Point.left = function(a,b,c){
    return Point.area(a,b,c) > 0;
};

Point.leftOn = function(a,b,c) {
    return Point.area(a, b, c) >= 0;
};

Point.right = function(a,b,c) {
    return Point.area(a, b, c) < 0;
};

Point.rightOn = function(a,b,c) {
    return Point.area(a, b, c) <= 0;
};

var tmpPoint1 = [],
    tmpPoint2 = [];

/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
Point.collinear = function(a,b,c,thresholdAngle) {
    if(!thresholdAngle)
        return Point.area(a, b, c) == 0;
    else {
        var ab = tmpPoint1,
            bc = tmpPoint2;

        ab[0] = b[0]-a[0];
        ab[1] = b[1]-a[1];
        bc[0] = c[0]-b[0];
        bc[1] = c[1]-b[1];

        var dot = ab[0]*bc[0] + ab[1]*bc[1],
            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),
            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),
            angle = Math.acos(dot/(magA*magB));
        return angle < thresholdAngle;
    }
};

Point.sqdist = function(a,b){
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/Polygon.js":[function(require,module,exports){
var Line = require("./Line")
,   Point = require("./Point")
,   Scalar = require("./Scalar")

module.exports = Polygon;

/**
 * Polygon class.
 * @class Polygon
 * @constructor
 */
function Polygon(){

    /**
     * Vertices that this polygon consists of. An array of array of numbers, example: [[0,0],[1,0],..]
     * @property vertices
     * @type {Array}
     */
    this.vertices = [];
}

/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
Polygon.prototype.at = function(i){
    var v = this.vertices,
        s = v.length;
    return v[i < 0 ? i % s + s : i % s];
};

/**
 * Get first vertex
 * @method first
 * @return {Array}
 */
Polygon.prototype.first = function(){
    return this.vertices[0];
};

/**
 * Get last vertex
 * @method last
 * @return {Array}
 */
Polygon.prototype.last = function(){
    return this.vertices[this.vertices.length-1];
};

/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
Polygon.prototype.clear = function(){
    this.vertices.length = 0;
};

/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
Polygon.prototype.append = function(poly,from,to){
    if(typeof(from) == "undefined") throw new Error("From is not given!");
    if(typeof(to) == "undefined")   throw new Error("To is not given!");

    if(to-1 < from)                 throw new Error("lol1");
    if(to > poly.vertices.length)   throw new Error("lol2");
    if(from < 0)                    throw new Error("lol3");

    for(var i=from; i<to; i++){
        this.vertices.push(poly.vertices[i]);
    }
};

/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
Polygon.prototype.makeCCW = function(){
    var br = 0,
        v = this.vertices;

    // find bottom right point
    for (var i = 1; i < this.vertices.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] == v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }

    // reverse poly if clockwise
    if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {
        this.reverse();
    }
};

/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
Polygon.prototype.reverse = function(){
    var tmp = [];
    for(var i=0, N=this.vertices.length; i!==N; i++){
        tmp.push(this.vertices.pop());
    }
    this.vertices = tmp;
};

/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
Polygon.prototype.isReflex = function(i){
    return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));
};

var tmpLine1=[],
    tmpLine2=[];

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
Polygon.prototype.canSee = function(a,b) {
    var p, dist, l1=tmpLine1, l2=tmpLine2;

    if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {
        return false;
    }
    dist = Point.sqdist(this.at(a), this.at(b));
    for (var i = 0; i !== this.vertices.length; ++i) { // for each edge
        if ((i + 1) % this.vertices.length === a || i === a) // ignore incident edges
            continue;
        if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) { // if diag intersects an edge
            l1[0] = this.at(a);
            l1[1] = this.at(b);
            l2[0] = this.at(i);
            l2[1] = this.at(i + 1);
            p = Line.lineInt(l1,l2);
            if (Point.sqdist(this.at(a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }

    return true;
};

/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
Polygon.prototype.copy = function(i,j,targetPoly){
    var p = targetPoly || new Polygon();
    p.clear();
    if (i < j) {
        // Insert all vertices from i to j
        for(var k=i; k<=j; k++)
            p.vertices.push(this.vertices[k]);

    } else {

        // Insert vertices 0 to j
        for(var k=0; k<=j; k++)
            p.vertices.push(this.vertices[k]);

        // Insert vertices i to end
        for(var k=i; k<this.vertices.length; k++)
            p.vertices.push(this.vertices[k]);
    }

    return p;
};

/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
Polygon.prototype.getCutEdges = function() {
    var min=[], tmp1=[], tmp2=[], tmpPoly = new Polygon();
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < this.vertices.length; ++i) {
        if (this.isReflex(i)) {
            for (var j = 0; j < this.vertices.length; ++j) {
                if (this.canSee(i, j)) {
                    tmp1 = this.copy(i, j, tmpPoly).getCutEdges();
                    tmp2 = this.copy(j, i, tmpPoly).getCutEdges();

                    for(var k=0; k<tmp2.length; k++)
                        tmp1.push(tmp2[k]);

                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        min.push([this.at(i), this.at(j)]);
                    }
                }
            }
        }
    }

    return min;
};

/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
Polygon.prototype.decomp = function(){
    var edges = this.getCutEdges();
    if(edges.length > 0)
        return this.slice(edges);
    else
        return [this];
};

/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
Polygon.prototype.slice = function(cutEdges){
    if(cutEdges.length == 0) return [this];
    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length==2 && cutEdges[0][0] instanceof Array){

        var polys = [this];

        for(var i=0; i<cutEdges.length; i++){
            var cutEdge = cutEdges[i];
            // Cut all polys
            for(var j=0; j<polys.length; j++){
                var poly = polys[j];
                var result = poly.slice(cutEdge);
                if(result){
                    // Found poly! Cut and quit
                    polys.splice(j,1);
                    polys.push(result[0],result[1]);
                    break;
                }
            }
        }

        return polys;
    } else {

        // Was given one edge
        var cutEdge = cutEdges;
        var i = this.vertices.indexOf(cutEdge[0]);
        var j = this.vertices.indexOf(cutEdge[1]);

        if(i != -1 && j != -1){
            return [this.copy(i,j),
                    this.copy(j,i)];
        } else {
            return false;
        }
    }
};

/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
Polygon.prototype.isSimple = function(){
    var path = this.vertices;
    // Check
    for(var i=0; i<path.length-1; i++){
        for(var j=0; j<i-1; j++){
            if(Line.segmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){
                return false;
            }
        }
    }

    // Check the segment between the last and the first point to all others
    for(var i=1; i<path.length-2; i++){
        if(Line.segmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){
            return false;
        }
    }

    return true;
};

function getIntersectionPoint(p1, p2, q1, q2, delta){
    delta = delta || 0;
   var a1 = p2[1] - p1[1];
   var b1 = p1[0] - p2[0];
   var c1 = (a1 * p1[0]) + (b1 * p1[1]);
   var a2 = q2[1] - q1[1];
   var b2 = q1[0] - q2[0];
   var c2 = (a2 * q1[0]) + (b2 * q1[1]);
   var det = (a1 * b2) - (a2 * b1);

   if(!Scalar.eq(det,0,delta))
      return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det]
   else
      return [0,0]
}

/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
Polygon.prototype.quickDecomp = function(result,reflexVertices,steinerPoints,delta,maxlevel,level){
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof(result)!="undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];

    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points
    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars
    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers
    var lowerPoly=new Polygon(), upperPoly=new Polygon(); // polygons
    var poly = this,
        v = this.vertices;

    if(v.length < 3) return result;

    level++;
    if(level > maxlevel){
        console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }

    for (var i = 0; i < this.vertices.length; ++i) {
        if (poly.isReflex(i)) {
            reflexVertices.push(poly.vertices[i]);
            upperDist = lowerDist = Number.MAX_VALUE;


            for (var j = 0; j < this.vertices.length; ++j) {
                if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j))
                        && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1)); // find the point of intersection
                    if (Point.right(poly.at(i + 1), poly.at(i), p)) { // make sure it's inside the poly
                        d = Point.sqdist(poly.vertices[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1))
                        && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                    p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));
                    if (Point.left(poly.at(i - 1), poly.at(i), p)) {
                        d = Point.sqdist(poly.vertices[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }

            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex == (upperIndex + 1) % this.vertices.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+this.vertices.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);

                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    lowerPoly.append(poly, i, upperIndex+1);
                    lowerPoly.vertices.push(p);
                    upperPoly.vertices.push(p);
                    if (lowerIndex != 0){
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        upperPoly.append(poly,lowerIndex,poly.vertices.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    upperPoly.append(poly,0,i+1);
                } else {
                    if (i != 0){
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        lowerPoly.append(poly,i,poly.vertices.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    lowerPoly.append(poly,0,upperIndex+1);
                    lowerPoly.vertices.push(p);
                    upperPoly.vertices.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    upperPoly.append(poly,lowerIndex,i+1);
                }
            } else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+this.vertices.length+")\n");

                if (lowerIndex > upperIndex) {
                    upperIndex += this.vertices.length;
                }
                closestDist = Number.MAX_VALUE;

                if(upperIndex < lowerIndex){
                    return result;
                }

                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j))
                            && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {
                        d = Point.sqdist(poly.at(i), poly.at(j));
                        if (d < closestDist) {
                            closestDist = d;
                            closestIndex = j % this.vertices.length;
                        }
                    }
                }

                if (i < closestIndex) {
                    lowerPoly.append(poly,i,closestIndex+1);
                    if (closestIndex != 0){
                        upperPoly.append(poly,closestIndex,v.length);
                    }
                    upperPoly.append(poly,0,i+1);
                } else {
                    if (i != 0){
                        lowerPoly.append(poly,i,v.length);
                    }
                    lowerPoly.append(poly,0,closestIndex+1);
                    upperPoly.append(poly,closestIndex,i+1);
                }
            }

            // solve smallest poly first
            if (lowerPoly.vertices.length < upperPoly.vertices.length) {
                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
            } else {
                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);
            }

            return result;
        }
    }
    result.push(this);

    return result;
};

/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
Polygon.prototype.removeCollinearPoints = function(precision){
    var num = 0;
    for(var i=this.vertices.length-1; this.vertices.length>3 && i>=0; --i){
        if(Point.collinear(this.at(i-1),this.at(i),this.at(i+1),precision)){
            // Remove the middle point
            this.vertices.splice(i%this.vertices.length,1);
            i--; // Jump one point forward. Otherwise we may get a chain removal
            num++;
        }
    }
    return num;
};

},{"./Line":"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/Line.js","./Point":"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/Point.js","./Scalar":"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/Scalar.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/Scalar.js":[function(require,module,exports){
module.exports = Scalar;

/**
 * Scalar functions
 * @class Scalar
 */
function Scalar(){}

/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
Scalar.eq = function(a,b,precision){
    precision = precision || 0;
    return Math.abs(a-b) < precision;
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/index.js":[function(require,module,exports){
module.exports = {
    Polygon : require("./Polygon"),
    Point : require("./Point"),
};

},{"./Point":"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/Point.js","./Polygon":"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/Polygon.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/package.json":[function(require,module,exports){
module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports={
  "name": "p2",
  "version": "0.6.1",
  "description": "A JavaScript 2D physics engine.",
  "author": {
    "name": "Stefan Hedman",
    "email": "schteppe@gmail.com",
    "url": "http://steffe.se"
  },
  "keywords": [
    "p2.js",
    "p2",
    "physics",
    "engine",
    "2d"
  ],
  "main": "./src/p2.js",
  "engines": {
    "node": "*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/schteppe/p2.js.git"
  },
  "bugs": {
    "url": "https://github.com/schteppe/p2.js/issues"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "devDependencies": {
    "grunt": "~0.4.0",
    "grunt-contrib-jshint": "~0.9.2",
    "grunt-contrib-nodeunit": "~0.1.2",
    "grunt-contrib-uglify": "~0.4.0",
    "grunt-contrib-watch": "~0.5.0",
    "grunt-browserify": "~2.0.1",
    "grunt-contrib-concat": "^0.4.0"
  },
  "dependencies": {
    "poly-decomp": "0.1.0"
  },
  "homepage": "https://github.com/schteppe/p2.js",
  "_id": "p2@0.6.1",
  "dist": {
    "shasum": "b26fe8bc319ef0d89c18f975dd8ca2399f876b53",
    "tarball": "http://registry.npmjs.org/p2/-/p2-0.6.1.tgz"
  },
  "_from": "p2@>=0.6.1 <0.7.0",
  "_npmVersion": "1.4.3",
  "_npmUser": {
    "name": "schteppe",
    "email": "schteppe@gmail.com"
  },
  "maintainers": [
    {
      "name": "schteppe",
      "email": "schteppe@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "b26fe8bc319ef0d89c18f975dd8ca2399f876b53",
  "_resolved": "https://registry.npmjs.org/p2/-/p2-0.6.1.tgz",
  "readme": "ERROR: No README data found!"
}

},{}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/AABB.js":[function(require,module,exports){
var vec2 = require('../math/vec2')
,   Utils = require('../utils/Utils');

module.exports = AABB;

/**
 * Axis aligned bounding box class.
 * @class AABB
 * @constructor
 * @param {Object}  [options]
 * @param {Array}   [options.upperBound]
 * @param {Array}   [options.lowerBound]
 */
function AABB(options){

    /**
     * The lower bound of the bounding box.
     * @property lowerBound
     * @type {Array}
     */
    this.lowerBound = vec2.create();
    if(options && options.lowerBound){
        vec2.copy(this.lowerBound, options.lowerBound);
    }

    /**
     * The upper bound of the bounding box.
     * @property upperBound
     * @type {Array}
     */
    this.upperBound = vec2.create();
    if(options && options.upperBound){
        vec2.copy(this.upperBound, options.upperBound);
    }
}

var tmp = vec2.create();

/**
 * Set the AABB bounds from a set of points.
 * @method setFromPoints
 * @param {Array} points An array of vec2's.
 */
AABB.prototype.setFromPoints = function(points, position, angle, skinSize){
    var l = this.lowerBound,
        u = this.upperBound;

    if(typeof(angle) !== "number"){
        angle = 0;
    }

    // Set to the first point
    if(angle !== 0){
        vec2.rotate(l, points[0], angle);
    } else {
        vec2.copy(l, points[0]);
    }
    vec2.copy(u, l);

    // Compute cosines and sines just once
    var cosAngle = Math.cos(angle),
        sinAngle = Math.sin(angle);
    for(var i = 1; i<points.length; i++){
        var p = points[i];

        if(angle !== 0){
            var x = p[0],
                y = p[1];
            tmp[0] = cosAngle * x -sinAngle * y;
            tmp[1] = sinAngle * x +cosAngle * y;
            p = tmp;
        }

        for(var j=0; j<2; j++){
            if(p[j] > u[j]){
                u[j] = p[j];
            }
            if(p[j] < l[j]){
                l[j] = p[j];
            }
        }
    }

    // Add offset
    if(position){
        vec2.add(this.lowerBound, this.lowerBound, position);
        vec2.add(this.upperBound, this.upperBound, position);
    }

    if(skinSize){
        this.lowerBound[0] -= skinSize;
        this.lowerBound[1] -= skinSize;
        this.upperBound[0] += skinSize;
        this.upperBound[1] += skinSize;
    }
};

/**
 * Copy bounds from an AABB to this AABB
 * @method copy
 * @param  {AABB} aabb
 */
AABB.prototype.copy = function(aabb){
    vec2.copy(this.lowerBound, aabb.lowerBound);
    vec2.copy(this.upperBound, aabb.upperBound);
};

/**
 * Extend this AABB so that it covers the given AABB too.
 * @method extend
 * @param  {AABB} aabb
 */
AABB.prototype.extend = function(aabb){
    // Loop over x and y
    var i = 2;
    while(i--){
        // Extend lower bound
        var l = aabb.lowerBound[i];
        if(this.lowerBound[i] > l){
            this.lowerBound[i] = l;
        }

        // Upper
        var u = aabb.upperBound[i];
        if(this.upperBound[i] < u){
            this.upperBound[i] = u;
        }
    }
};

/**
 * Returns true if the given AABB overlaps this AABB.
 * @method overlaps
 * @param  {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.overlaps = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&
           ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/Broadphase.js":[function(require,module,exports){
var vec2 = require('../math/vec2');
var Body = require('../objects/Body');

module.exports = Broadphase;

/**
 * Base class for broadphase implementations.
 * @class Broadphase
 * @constructor
 */
function Broadphase(type){

    this.type = type;

    /**
     * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().
     * @property result
     * @type {Array}
     */
    this.result = [];

    /**
     * The world to search for collision pairs in. To change it, use .setWorld()
     * @property world
     * @type {World}
     * @readOnly
     */
    this.world = null;

    /**
     * The bounding volume type to use in the broadphase algorithms.
     * @property {Number} boundingVolumeType
     */
    this.boundingVolumeType = Broadphase.AABB;
}

/**
 * Axis aligned bounding box type.
 * @static
 * @property {Number} AABB
 */
Broadphase.AABB = 1;

/**
 * Bounding circle type.
 * @static
 * @property {Number} BOUNDING_CIRCLE
 */
Broadphase.BOUNDING_CIRCLE = 2;

/**
 * Set the world that we are searching for collision pairs in
 * @method setWorld
 * @param  {World} world
 */
Broadphase.prototype.setWorld = function(world){
    this.world = world;
};

/**
 * Get all potential intersecting body pairs.
 * @method getCollisionPairs
 * @param  {World} world The world to search in.
 * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).
 */
Broadphase.prototype.getCollisionPairs = function(world){
    throw new Error("getCollisionPairs must be implemented in a subclass!");
};

var dist = vec2.create();

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.boundingRadiusCheck = function(bodyA, bodyB){
    vec2.sub(dist, bodyA.position, bodyB.position);
    var d2 = vec2.squaredLength(dist),
        r = bodyA.boundingRadius + bodyB.boundingRadius;
    return d2 <= r*r;
};

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.aabbCheck = function(bodyA, bodyB){
    return bodyA.getAABB().overlaps(bodyB.getAABB());
};

/**
 * Check whether the bounding radius of two bodies overlap.
 * @method  boundingRadiusCheck
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB){
    var result;

    switch(this.boundingVolumeType){
    case Broadphase.BOUNDING_CIRCLE:
        result =  Broadphase.boundingRadiusCheck(bodyA,bodyB);
        break;
    case Broadphase.AABB:
        result = Broadphase.aabbCheck(bodyA,bodyB);
        break;
    default:
        throw new Error('Bounding volume type not recognized: '+this.boundingVolumeType);
    }
    return result;
};

/**
 * Check whether two bodies are allowed to collide at all.
 * @method  canCollide
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Broadphase.canCollide = function(bodyA, bodyB){

    // Cannot collide static bodies
    if(bodyA.type === Body.STATIC && bodyB.type === Body.STATIC){
        return false;
    }

    // Cannot collide static vs kinematic bodies
    if( (bodyA.type === Body.KINEMATIC && bodyB.type === Body.STATIC) ||
        (bodyA.type === Body.STATIC    && bodyB.type === Body.KINEMATIC)){
        return false;
    }

    // Cannot collide kinematic vs kinematic
    if(bodyA.type === Body.KINEMATIC && bodyB.type === Body.KINEMATIC){
        return false;
    }

    // Cannot collide both sleeping bodies
    if(bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING){
        return false;
    }

    // Cannot collide if one is static and the other is sleeping
    if( (bodyA.sleepState === Body.SLEEPING && bodyB.type === Body.STATIC) ||
        (bodyB.sleepState === Body.SLEEPING && bodyA.type === Body.STATIC)){
        return false;
    }

    return true;
};

Broadphase.NAIVE = 1;
Broadphase.SAP = 2;

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../objects/Body":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/Body.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/GridBroadphase.js":[function(require,module,exports){
var Circle = require('../shapes/Circle')
,   Plane = require('../shapes/Plane')
,   Particle = require('../shapes/Particle')
,   Broadphase = require('../collision/Broadphase')
,   vec2 = require('../math/vec2')
,   Utils = require('../utils/Utils');

module.exports = GridBroadphase;

/**
 * Broadphase that uses axis-aligned bins.
 * @class GridBroadphase
 * @constructor
 * @extends Broadphase
 * @param {object} [options]
 * @param {number} [options.xmin]   Lower x bound of the grid
 * @param {number} [options.xmax]   Upper x bound
 * @param {number} [options.ymin]   Lower y bound
 * @param {number} [options.ymax]   Upper y bound
 * @param {number} [options.nx]     Number of bins along x axis
 * @param {number} [options.ny]     Number of bins along y axis
 * @todo Should have an option for dynamic scene size
 */
function GridBroadphase(options){
    Broadphase.apply(this);

    options = Utils.defaults(options,{
        xmin:   -100,
        xmax:   100,
        ymin:   -100,
        ymax:   100,
        nx:     10,
        ny:     10
    });

    this.xmin = options.xmin;
    this.ymin = options.ymin;
    this.xmax = options.xmax;
    this.ymax = options.ymax;
    this.nx = options.nx;
    this.ny = options.ny;

    this.binsizeX = (this.xmax-this.xmin) / this.nx;
    this.binsizeY = (this.ymax-this.ymin) / this.ny;
}
GridBroadphase.prototype = new Broadphase();
GridBroadphase.prototype.constructor = GridBroadphase;

/**
 * Get collision pairs.
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
GridBroadphase.prototype.getCollisionPairs = function(world){
    var result = [],
        bodies = world.bodies,
        Ncolliding = bodies.length,
        binsizeX = this.binsizeX,
        binsizeY = this.binsizeY,
        nx = this.nx,
        ny = this.ny,
        xmin = this.xmin,
        ymin = this.ymin,
        xmax = this.xmax,
        ymax = this.ymax;

    // Todo: make garbage free
    var bins=[], Nbins=nx*ny;
    for(var i=0; i<Nbins; i++){
        bins.push([]);
    }

    var xmult = nx / (xmax-xmin);
    var ymult = ny / (ymax-ymin);

    // Put all bodies into bins
    for(var i=0; i!==Ncolliding; i++){
        var bi = bodies[i];
        var aabb = bi.aabb;
        var lowerX = Math.max(aabb.lowerBound[0], xmin);
        var lowerY = Math.max(aabb.lowerBound[1], ymin);
        var upperX = Math.min(aabb.upperBound[0], xmax);
        var upperY = Math.min(aabb.upperBound[1], ymax);
        var xi1 = Math.floor(xmult * (lowerX - xmin));
        var yi1 = Math.floor(ymult * (lowerY - ymin));
        var xi2 = Math.floor(xmult * (upperX - xmin));
        var yi2 = Math.floor(ymult * (upperY - ymin));

        // Put in bin
        for(var j=xi1; j<=xi2; j++){
            for(var k=yi1; k<=yi2; k++){
                var xi = j;
                var yi = k;
                var idx = xi*(ny-1) + yi;
                if(idx >= 0 && idx < Nbins){
                    bins[ idx ].push(bi);
                }
            }
        }
    }

    // Check each bin
    for(var i=0; i!==Nbins; i++){
        var bin = bins[i];

        for(var j=0, NbodiesInBin=bin.length; j!==NbodiesInBin; j++){
            var bi = bin[j];
            for(var k=0; k!==j; k++){
                var bj = bin[k];
                if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                    result.push(bi,bj);
                }
            }
        }
    }
    return result;
};

},{"../collision/Broadphase":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/Broadphase.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../shapes/Circle":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Circle.js","../shapes/Particle":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Particle.js","../shapes/Plane":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Plane.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/NaiveBroadphase.js":[function(require,module,exports){
var Circle = require('../shapes/Circle'),
    Plane = require('../shapes/Plane'),
    Shape = require('../shapes/Shape'),
    Particle = require('../shapes/Particle'),
    Broadphase = require('../collision/Broadphase'),
    vec2 = require('../math/vec2');

module.exports = NaiveBroadphase;

/**
 * Naive broadphase implementation. Does N^2 tests.
 *
 * @class NaiveBroadphase
 * @constructor
 * @extends Broadphase
 */
function NaiveBroadphase(){
    Broadphase.call(this, Broadphase.NAIVE);
}
NaiveBroadphase.prototype = new Broadphase();
NaiveBroadphase.prototype.constructor = NaiveBroadphase;

/**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
NaiveBroadphase.prototype.getCollisionPairs = function(world){
    var bodies = world.bodies,
        result = this.result;

    result.length = 0;

    for(var i=0, Ncolliding=bodies.length; i!==Ncolliding; i++){
        var bi = bodies[i];

        for(var j=0; j<i; j++){
            var bj = bodies[j];

            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                result.push(bi,bj);
            }
        }
    }

    return result;
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    var bodies = world.bodies;
    for(var i = 0; i < bodies.length; i++){
        var b = bodies[i];

        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/Broadphase.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../shapes/Circle":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Circle.js","../shapes/Particle":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Particle.js","../shapes/Plane":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Plane.js","../shapes/Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/Narrowphase.js":[function(require,module,exports){
var vec2 = require('../math/vec2')
,   sub = vec2.sub
,   add = vec2.add
,   dot = vec2.dot
,   Utils = require('../utils/Utils')
,   TupleDictionary = require('../utils/TupleDictionary')
,   Equation = require('../equations/Equation')
,   ContactEquation = require('../equations/ContactEquation')
,   FrictionEquation = require('../equations/FrictionEquation')
,   Circle = require('../shapes/Circle')
,   Convex = require('../shapes/Convex')
,   Shape = require('../shapes/Shape')
,   Body = require('../objects/Body')
,   Rectangle = require('../shapes/Rectangle');

module.exports = Narrowphase;

// Temp things
var yAxis = vec2.fromValues(0,1);

var tmp1 = vec2.fromValues(0,0)
,   tmp2 = vec2.fromValues(0,0)
,   tmp3 = vec2.fromValues(0,0)
,   tmp4 = vec2.fromValues(0,0)
,   tmp5 = vec2.fromValues(0,0)
,   tmp6 = vec2.fromValues(0,0)
,   tmp7 = vec2.fromValues(0,0)
,   tmp8 = vec2.fromValues(0,0)
,   tmp9 = vec2.fromValues(0,0)
,   tmp10 = vec2.fromValues(0,0)
,   tmp11 = vec2.fromValues(0,0)
,   tmp12 = vec2.fromValues(0,0)
,   tmp13 = vec2.fromValues(0,0)
,   tmp14 = vec2.fromValues(0,0)
,   tmp15 = vec2.fromValues(0,0)
,   tmp16 = vec2.fromValues(0,0)
,   tmp17 = vec2.fromValues(0,0)
,   tmp18 = vec2.fromValues(0,0)
,   tmpArray = [];

/**
 * Narrowphase. Creates contacts and friction given shapes and transforms.
 * @class Narrowphase
 * @constructor
 */
function Narrowphase(){

    /**
     * @property contactEquations
     * @type {Array}
     */
    this.contactEquations = [];

    /**
     * @property frictionEquations
     * @type {Array}
     */
    this.frictionEquations = [];

    /**
     * Whether to make friction equations in the upcoming contacts.
     * @property enableFriction
     * @type {Boolean}
     */
    this.enableFriction = true;

    /**
     * Whether to make equations enabled in upcoming contacts.
     * @property enabledEquations
     * @type {Boolean}
     */
    this.enabledEquations = true;

    /**
     * The friction slip force to use when creating friction equations.
     * @property slipForce
     * @type {Number}
     */
    this.slipForce = 10.0;

    /**
     * The friction value to use in the upcoming friction equations.
     * @property frictionCoefficient
     * @type {Number}
     */
    this.frictionCoefficient = 0.3;

    /**
     * Will be the .relativeVelocity in each produced FrictionEquation.
     * @property {Number} surfaceVelocity
     */
    this.surfaceVelocity = 0;

    this.reuseObjects = true;
    this.reusableContactEquations = [];
    this.reusableFrictionEquations = [];

    /**
     * The restitution value to use in the next contact equations.
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0;

    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */
    this.stiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The stiffness value to use in the next contact equations.
     * @property {Number} stiffness
     */
    this.relaxation = Equation.DEFAULT_RELAXATION;

    /**
     * The stiffness value to use in the next friction equations.
     * @property frictionStiffness
     * @type {Number}
     */
    this.frictionStiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The relaxation value to use in the next friction equations.
     * @property frictionRelaxation
     * @type {Number}
     */
    this.frictionRelaxation = Equation.DEFAULT_RELAXATION;

    /**
     * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.
     * @property enableFrictionReduction
     * @type {Boolean}
     * @deprecated This flag will be removed when the feature is stable enough.
     * @default true
     */
    this.enableFrictionReduction = true;

    /**
     * Keeps track of the colliding bodies last step.
     * @private
     * @property collidingBodiesLastStep
     * @type {TupleDictionary}
     */
    this.collidingBodiesLastStep = new TupleDictionary();

    /**
     * Contact skin size value to use in the next contact equations.
     * @property {Number} contactSkinSize
     * @default 0.01
     */
    this.contactSkinSize = 0.01;
}

var bodiesOverlap_shapePositionA = vec2.create();
var bodiesOverlap_shapePositionB = vec2.create();

/**
 * @method bodiesOverlap
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Narrowphase.prototype.bodiesOverlap = function(bodyA, bodyB){
    var shapePositionA = bodiesOverlap_shapePositionA;
    var shapePositionB = bodiesOverlap_shapePositionB;

    // Loop over all shapes of bodyA
    for(var k=0, Nshapesi=bodyA.shapes.length; k!==Nshapesi; k++){
        var shapeA = bodyA.shapes[k],
            positionA = bodyA.shapeOffsets[k],
            angleA = bodyA.shapeAngles[k];

        bodyA.toWorldFrame(shapePositionA, positionA);

        // All shapes of body j
        for(var l=0, Nshapesj=bodyB.shapes.length; l!==Nshapesj; l++){
            var shapeB = bodyB.shapes[l],
                positionB = bodyB.shapeOffsets[l],
                angleB = bodyB.shapeAngles[l];

            bodyB.toWorldFrame(shapePositionB, positionB);

            if(this[shapeA.type | shapeB.type](
                bodyA,
                shapeA,
                shapePositionA,
                shapeA.angle + bodyA.angle,
                bodyB,
                shapeB,
                shapePositionB,
                shapeB.angle + bodyB.angle,
                true
            )){
                return true;
            }
        }
    }

    return false;
};

/**
 * Check if the bodies were in contact since the last reset().
 * @method collidedLastStep
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {Boolean}
 */
Narrowphase.prototype.collidedLastStep = function(bodyA, bodyB){
    var id1 = bodyA.id|0,
        id2 = bodyB.id|0;
    return !!this.collidingBodiesLastStep.get(id1, id2);
};

/**
 * Throws away the old equations and gets ready to create new
 * @method reset
 */
Narrowphase.prototype.reset = function(){
    this.collidingBodiesLastStep.reset();

    var eqs = this.contactEquations;
    var l = eqs.length;
    while(l--){
        var eq = eqs[l],
            id1 = eq.bodyA.id,
            id2 = eq.bodyB.id;
        this.collidingBodiesLastStep.set(id1, id2, true);
    }

    if(this.reuseObjects){
        var ce = this.contactEquations,
            fe = this.frictionEquations,
            rfe = this.reusableFrictionEquations,
            rce = this.reusableContactEquations;
        Utils.appendArray(rce,ce);
        Utils.appendArray(rfe,fe);
    }

    // Reset
    this.contactEquations.length = this.frictionEquations.length = 0;
};

/**
 * Creates a ContactEquation, either by reusing an existing object or creating a new one.
 * @method createContactEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {ContactEquation}
 */
Narrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB){
    var c = this.reusableContactEquations.length ? this.reusableContactEquations.pop() : new ContactEquation(bodyA,bodyB);
    c.bodyA = bodyA;
    c.bodyB = bodyB;
    c.shapeA = shapeA;
    c.shapeB = shapeB;
    c.restitution = this.restitution;
    c.firstImpact = !this.collidedLastStep(bodyA,bodyB);
    c.stiffness = this.stiffness;
    c.relaxation = this.relaxation;
    c.needsUpdate = true;
    c.enabled = this.enabledEquations;
    c.offset = this.contactSkinSize;

    return c;
};

/**
 * Creates a FrictionEquation, either by reusing an existing object or creating a new one.
 * @method createFrictionEquation
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {FrictionEquation}
 */
Narrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB){
    var c = this.reusableFrictionEquations.length ? this.reusableFrictionEquations.pop() : new FrictionEquation(bodyA,bodyB);
    c.bodyA = bodyA;
    c.bodyB = bodyB;
    c.shapeA = shapeA;
    c.shapeB = shapeB;
    c.setSlipForce(this.slipForce);
    c.frictionCoefficient = this.frictionCoefficient;
    c.relativeVelocity = this.surfaceVelocity;
    c.enabled = this.enabledEquations;
    c.needsUpdate = true;
    c.stiffness = this.frictionStiffness;
    c.relaxation = this.frictionRelaxation;
    c.contactEquations.length = 0;
    return c;
};

/**
 * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.
 * @method createFrictionFromContact
 * @param  {ContactEquation} contactEquation
 * @return {FrictionEquation}
 */
Narrowphase.prototype.createFrictionFromContact = function(c){
    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
    vec2.copy(eq.contactPointA, c.contactPointA);
    vec2.copy(eq.contactPointB, c.contactPointB);
    vec2.rotate90cw(eq.t, c.normalA);
    eq.contactEquations.push(c);
    return eq;
};

// Take the average N latest contact point on the plane.
Narrowphase.prototype.createFrictionFromAverage = function(numContacts){
    var c = this.contactEquations[this.contactEquations.length - 1];
    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    vec2.set(eq.contactPointA, 0, 0);
    vec2.set(eq.contactPointB, 0, 0);
    vec2.set(eq.t, 0, 0);
    for(var i=0; i!==numContacts; i++){
        c = this.contactEquations[this.contactEquations.length - 1 - i];
        if(c.bodyA === bodyA){
            vec2.add(eq.t, eq.t, c.normalA);
            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);
        } else {
            vec2.sub(eq.t, eq.t, c.normalA);
            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);
            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);
        }
        eq.contactEquations.push(c);
    }

    var invNumContacts = 1/numContacts;
    vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
    vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
    vec2.normalize(eq.t, eq.t);
    vec2.rotate90cw(eq.t, eq.t);
    return eq;
};

/**
 * Convex/line narrowphase
 * @method convexLine
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexOffset
 * @param  {Number}     convexAngle
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param {boolean}     justTest
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.CONVEX] =
Narrowphase.prototype.convexLine = function(
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

/**
 * Line/rectangle narrowphase
 * @method lineRectangle
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      lineOffset
 * @param  {Number}     lineAngle
 * @param  {Body}       rectangleBody
 * @param  {Rectangle}  rectangleShape
 * @param  {Array}      rectangleOffset
 * @param  {Number}     rectangleAngle
 * @param  {Boolean}    justTest
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.RECTANGLE] =
Narrowphase.prototype.lineRectangle = function(
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    rectangleBody,
    rectangleShape,
    rectangleOffset,
    rectangleAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

function setConvexToCapsuleShapeMiddle(convexShape, capsuleShape){
    vec2.set(convexShape.vertices[0], -capsuleShape.length * 0.5, -capsuleShape.radius);
    vec2.set(convexShape.vertices[1],  capsuleShape.length * 0.5, -capsuleShape.radius);
    vec2.set(convexShape.vertices[2],  capsuleShape.length * 0.5,  capsuleShape.radius);
    vec2.set(convexShape.vertices[3], -capsuleShape.length * 0.5,  capsuleShape.radius);
}

var convexCapsule_tempRect = new Rectangle(1,1),
    convexCapsule_tempVec = vec2.create();

/**
 * Convex/capsule narrowphase
 * @method convexCapsule
 * @param  {Body}       convexBody
 * @param  {Convex}     convexShape
 * @param  {Array}      convexPosition
 * @param  {Number}     convexAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] =
Narrowphase.prototype[Shape.CAPSULE | Shape.RECTANGLE] =
Narrowphase.prototype.convexCapsule = function(
    convexBody,
    convexShape,
    convexPosition,
    convexAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){

    // Check the circles
    // Add offsets!
    var circlePos = convexCapsule_tempVec;
    vec2.set(circlePos, capsuleShape.length/2,0);
    vec2.rotate(circlePos,circlePos,capsuleAngle);
    vec2.add(circlePos,circlePos,capsulePosition);
    var result1 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);

    vec2.set(circlePos,-capsuleShape.length/2, 0);
    vec2.rotate(circlePos,circlePos,capsuleAngle);
    vec2.add(circlePos,circlePos,capsulePosition);
    var result2 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);

    if(justTest && (result1 || result2)){
        return true;
    }

    // Check center rect
    var r = convexCapsule_tempRect;
    setConvexToCapsuleShapeMiddle(r,capsuleShape);
    var result = this.convexConvex(convexBody,convexShape,convexPosition,convexAngle, capsuleBody,r,capsulePosition,capsuleAngle, justTest);

    return result + result1 + result2;
};

/**
 * Capsule/line narrowphase
 * @method lineCapsule
 * @param  {Body}       lineBody
 * @param  {Line}       lineShape
 * @param  {Array}      linePosition
 * @param  {Number}     lineAngle
 * @param  {Body}       capsuleBody
 * @param  {Capsule}    capsuleShape
 * @param  {Array}      capsulePosition
 * @param  {Number}     capsuleAngle
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.LINE] =
Narrowphase.prototype.lineCapsule = function(
    lineBody,
    lineShape,
    linePosition,
    lineAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

var capsuleCapsule_tempVec1 = vec2.create();
var capsuleCapsule_tempVec2 = vec2.create();
var capsuleCapsule_tempRect1 = new Rectangle(1,1);

/**
 * Capsule/capsule narrowphase
 * @method capsuleCapsule
 * @param  {Body}       bi
 * @param  {Capsule}    si
 * @param  {Array}      xi
 * @param  {Number}     ai
 * @param  {Body}       bj
 * @param  {Capsule}    sj
 * @param  {Array}      xj
 * @param  {Number}     aj
 */
Narrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] =
Narrowphase.prototype.capsuleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){

    var enableFrictionBefore;

    // Check the circles
    // Add offsets!
    var circlePosi = capsuleCapsule_tempVec1,
        circlePosj = capsuleCapsule_tempVec2;

    var numContacts = 0;


    // Need 4 circle checks, between all
    for(var i=0; i<2; i++){

        vec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);
        vec2.rotate(circlePosi,circlePosi,ai);
        vec2.add(circlePosi,circlePosi,xi);

        for(var j=0; j<2; j++){

            vec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);
            vec2.rotate(circlePosj,circlePosj,aj);
            vec2.add(circlePosj,circlePosj,xj);

            // Temporarily turn off friction
            if(this.enableFrictionReduction){
                enableFrictionBefore = this.enableFriction;
                this.enableFriction = false;
            }

            var result = this.circleCircle(bi,si,circlePosi,ai, bj,sj,circlePosj,aj, justTest, si.radius, sj.radius);

            if(this.enableFrictionReduction){
                this.enableFriction = enableFrictionBefore;
            }

            if(justTest && result){
                return true;
            }

            numContacts += result;
        }
    }

    if(this.enableFrictionReduction){
        // Temporarily turn off friction
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    // Check circles against the center rectangles
    var rect = capsuleCapsule_tempRect1;
    setConvexToCapsuleShapeMiddle(rect,si);
    var result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);

    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest && result1){
        return true;
    }
    numContacts += result1;

    if(this.enableFrictionReduction){
        // Temporarily turn off friction
        var enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    setConvexToCapsuleShapeMiddle(rect,sj);
    var result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);

    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest && result2){
        return true;
    }
    numContacts += result2;

    if(this.enableFrictionReduction){
        if(numContacts && this.enableFriction){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

/**
 * Line/line narrowphase
 * @method lineLine
 * @param  {Body}       bodyA
 * @param  {Line}       shapeA
 * @param  {Array}      positionA
 * @param  {Number}     angleA
 * @param  {Body}       bodyB
 * @param  {Line}       shapeB
 * @param  {Array}      positionB
 * @param  {Number}     angleB
 * @todo Implement me!
 */
Narrowphase.prototype[Shape.LINE | Shape.LINE] =
Narrowphase.prototype.lineLine = function(
    bodyA,
    shapeA,
    positionA,
    angleA,
    bodyB,
    shapeB,
    positionB,
    angleB,
    justTest
){
    // TODO
    if(justTest){
        return false;
    } else {
        return 0;
    }
};

/**
 * Plane/line Narrowphase
 * @method planeLine
 * @param  {Body}   planeBody
 * @param  {Plane}  planeShape
 * @param  {Array}  planeOffset
 * @param  {Number} planeAngle
 * @param  {Body}   lineBody
 * @param  {Line}   lineShape
 * @param  {Array}  lineOffset
 * @param  {Number} lineAngle
 */
Narrowphase.prototype[Shape.PLANE | Shape.LINE] =
Narrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle,
                                           lineBody,  lineShape,  lineOffset,  lineAngle, justTest){
    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldVertex01 = tmp3,
        worldVertex11 = tmp4,
        worldEdge = tmp5,
        worldEdgeUnit = tmp6,
        dist = tmp7,
        worldNormal = tmp8,
        worldTangent = tmp9,
        verts = tmpArray,
        numContacts = 0;

    // Get start and end points
    vec2.set(worldVertex0, -lineShape.length/2, 0);
    vec2.set(worldVertex1,  lineShape.length/2, 0);

    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
    vec2.rotate(worldVertex11, worldVertex1, lineAngle);

    add(worldVertex01, worldVertex01, lineOffset);
    add(worldVertex11, worldVertex11, lineOffset);

    vec2.copy(worldVertex0,worldVertex01);
    vec2.copy(worldVertex1,worldVertex11);

    // Get vector along the line
    sub(worldEdge, worldVertex1, worldVertex0);
    vec2.normalize(worldEdgeUnit, worldEdge);

    // Get tangent to the edge.
    vec2.rotate90cw(worldTangent, worldEdgeUnit);

    vec2.rotate(worldNormal, yAxis, planeAngle);

    // Check line ends
    verts[0] = worldVertex0;
    verts[1] = worldVertex1;
    for(var i=0; i<verts.length; i++){
        var v = verts[i];

        sub(dist, v, planeOffset);

        var d = dot(dist,worldNormal);

        if(d < 0){

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(planeBody,lineBody,planeShape,lineShape);
            numContacts++;

            vec2.copy(c.normalA, worldNormal);
            vec2.normalize(c.normalA,c.normalA);

            // distance vector along plane normal
            vec2.scale(dist, worldNormal, d);

            // Vector from plane center to contact
            sub(c.contactPointA, v, dist);
            sub(c.contactPointA, c.contactPointA, planeBody.position);

            // From line center to contact
            sub(c.contactPointB, v,    lineOffset);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(!this.enableFrictionReduction){
                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(justTest){
        return false;
    }

    if(!this.enableFrictionReduction){
        if(numContacts && this.enableFriction){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

Narrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =
Narrowphase.prototype.particleCapsule = function(
    particleBody,
    particleShape,
    particlePosition,
    particleAngle,
    capsuleBody,
    capsuleShape,
    capsulePosition,
    capsuleAngle,
    justTest
){
    return this.circleLine(particleBody,particleShape,particlePosition,particleAngle, capsuleBody,capsuleShape,capsulePosition,capsuleAngle, justTest, capsuleShape.radius, 0);
};

/**
 * Circle/line Narrowphase
 * @method circleLine
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} lineBody
 * @param  {Line} lineShape
 * @param  {Array} lineOffset
 * @param  {Number} lineAngle
 * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.
 * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.
 * @param {Number} circleRadius If set, this value overrides the circle shape radius.
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.LINE] =
Narrowphase.prototype.circleLine = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    lineBody,
    lineShape,
    lineOffset,
    lineAngle,
    justTest,
    lineRadius,
    circleRadius
){
    var lineRadius = lineRadius || 0,
        circleRadius = typeof(circleRadius)!=="undefined" ? circleRadius : circleShape.radius,

        orthoDist = tmp1,
        lineToCircleOrthoUnit = tmp2,
        projectedPoint = tmp3,
        centerDist = tmp4,
        worldTangent = tmp5,
        worldEdge = tmp6,
        worldEdgeUnit = tmp7,
        worldVertex0 = tmp8,
        worldVertex1 = tmp9,
        worldVertex01 = tmp10,
        worldVertex11 = tmp11,
        dist = tmp12,
        lineToCircle = tmp13,
        lineEndToLineRadius = tmp14,

        verts = tmpArray;

    // Get start and end points
    vec2.set(worldVertex0, -lineShape.length/2, 0);
    vec2.set(worldVertex1,  lineShape.length/2, 0);

    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.
    vec2.rotate(worldVertex01, worldVertex0, lineAngle);
    vec2.rotate(worldVertex11, worldVertex1, lineAngle);

    add(worldVertex01, worldVertex01, lineOffset);
    add(worldVertex11, worldVertex11, lineOffset);

    vec2.copy(worldVertex0,worldVertex01);
    vec2.copy(worldVertex1,worldVertex11);

    // Get vector along the line
    sub(worldEdge, worldVertex1, worldVertex0);
    vec2.normalize(worldEdgeUnit, worldEdge);

    // Get tangent to the edge.
    vec2.rotate90cw(worldTangent, worldEdgeUnit);

    // Check distance from the plane spanned by the edge vs the circle
    sub(dist, circleOffset, worldVertex0);
    var d = dot(dist, worldTangent); // Distance from center of line to circle center
    sub(centerDist, worldVertex0, lineOffset);

    sub(lineToCircle, circleOffset, lineOffset);

    var radiusSum = circleRadius + lineRadius;

    if(Math.abs(d) < radiusSum){

        // Now project the circle onto the edge
        vec2.scale(orthoDist, worldTangent, d);
        sub(projectedPoint, circleOffset, orthoDist);

        // Add the missing line radius
        vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));
        vec2.normalize(lineToCircleOrthoUnit,lineToCircleOrthoUnit);
        vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);
        add(projectedPoint,projectedPoint,lineToCircleOrthoUnit);

        // Check if the point is within the edge span
        var pos =  dot(worldEdgeUnit, projectedPoint);
        var pos0 = dot(worldEdgeUnit, worldVertex0);
        var pos1 = dot(worldEdgeUnit, worldVertex1);

        if(pos > pos0 && pos < pos1){
            // We got contact!

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);

            vec2.scale(c.normalA, orthoDist, -1);
            vec2.normalize(c.normalA, c.normalA);

            vec2.scale( c.contactPointA, c.normalA,  circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);

            sub(c.contactPointB, projectedPoint, lineOffset);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }

            return 1;
        }
    }

    // Add corner
    verts[0] = worldVertex0;
    verts[1] = worldVertex1;

    for(var i=0; i<verts.length; i++){
        var v = verts[i];

        sub(dist, v, circleOffset);

        if(vec2.squaredLength(dist) < Math.pow(radiusSum, 2)){

            if(justTest){
                return true;
            }

            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);

            vec2.copy(c.normalA, dist);
            vec2.normalize(c.normalA,c.normalA);

            // Vector from circle to contact point is the normal times the circle radius
            vec2.scale(c.contactPointA, c.normalA, circleRadius);
            add(c.contactPointA, c.contactPointA, circleOffset);
            sub(c.contactPointA, c.contactPointA, circleBody.position);

            sub(c.contactPointB, v, lineOffset);
            vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);
            add(c.contactPointB, c.contactPointB, lineEndToLineRadius);
            add(c.contactPointB, c.contactPointB, lineOffset);
            sub(c.contactPointB, c.contactPointB, lineBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push(this.createFrictionFromContact(c));
            }

            return 1;
        }
    }

    return 0;
};

/**
 * Circle/capsule Narrowphase
 * @method circleCapsule
 * @param  {Body}   bi
 * @param  {Circle} si
 * @param  {Array}  xi
 * @param  {Number} ai
 * @param  {Body}   bj
 * @param  {Line}   sj
 * @param  {Array}  xj
 * @param  {Number} aj
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =
Narrowphase.prototype.circleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){
    return this.circleLine(bi,si,xi,ai, bj,sj,xj,aj, justTest, sj.radius);
};

/**
 * Circle/convex Narrowphase.
 * @method circleConvex
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Boolean} justTest
 * @param  {Number} circleRadius
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =
Narrowphase.prototype[Shape.CIRCLE | Shape.RECTANGLE] =
Narrowphase.prototype.circleConvex = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest,
    circleRadius
){
    var circleRadius = typeof(circleRadius)==="number" ? circleRadius : circleShape.radius;

    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldEdge = tmp3,
        worldEdgeUnit = tmp4,
        worldNormal = tmp5,
        centerDist = tmp6,
        convexToCircle = tmp7,
        orthoDist = tmp8,
        projectedPoint = tmp9,
        dist = tmp10,
        worldVertex = tmp11,

        closestEdge = -1,
        closestEdgeDistance = null,
        closestEdgeOrthoDist = tmp12,
        closestEdgeProjectedPoint = tmp13,
        candidate = tmp14,
        candidateDist = tmp15,
        minCandidate = tmp16,

        found = false,
        minCandidateDistance = Number.MAX_VALUE;

    var numReported = 0;

    // New algorithm:
    // 1. Check so center of circle is not inside the polygon. If it is, this wont work...
    // 2. For each edge
    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
    // 2. 2. Check if point is inside.

    var verts = convexShape.vertices;

    // Check all edges first
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);
        sub(worldEdge, worldVertex1, worldVertex0);

        vec2.normalize(worldEdgeUnit, worldEdge);

        // Get tangent to the edge. Points out of the Convex
        vec2.rotate90cw(worldNormal, worldEdgeUnit);

        // Get point on circle, closest to the polygon
        vec2.scale(candidate,worldNormal,-circleShape.radius);
        add(candidate,candidate,circleOffset);

        if(pointInConvex(candidate,convexShape,convexOffset,convexAngle)){

            vec2.sub(candidateDist,worldVertex0,candidate);
            var candidateDistance = Math.abs(vec2.dot(candidateDist,worldNormal));

            if(candidateDistance < minCandidateDistance){
                vec2.copy(minCandidate,candidate);
                minCandidateDistance = candidateDistance;
                vec2.scale(closestEdgeProjectedPoint,worldNormal,candidateDistance);
                vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,candidate);
                found = true;
            }
        }
    }

    if(found){

        if(justTest){
            return true;
        }

        var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);
        vec2.sub(c.normalA, minCandidate, circleOffset);
        vec2.normalize(c.normalA, c.normalA);

        vec2.scale(c.contactPointA,  c.normalA, circleRadius);
        add(c.contactPointA, c.contactPointA, circleOffset);
        sub(c.contactPointA, c.contactPointA, circleBody.position);

        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c.contactPointB, c.contactPointB, convexOffset);
        sub(c.contactPointB, c.contactPointB, convexBody.position);

        this.contactEquations.push(c);

        if(this.enableFriction){
            this.frictionEquations.push( this.createFrictionFromContact(c) );
        }

        return 1;
    }

    // Check all vertices
    if(circleRadius > 0){
        for(var i=0; i<verts.length; i++){
            var localVertex = verts[i];
            vec2.rotate(worldVertex, localVertex, convexAngle);
            add(worldVertex, worldVertex, convexOffset);

            sub(dist, worldVertex, circleOffset);
            if(vec2.squaredLength(dist) < Math.pow(circleRadius, 2)){

                if(justTest){
                    return true;
                }

                var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);

                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA,c.normalA);

                // Vector from circle to contact point is the normal times the circle radius
                vec2.scale(c.contactPointA, c.normalA, circleRadius);
                add(c.contactPointA, c.contactPointA, circleOffset);
                sub(c.contactPointA, c.contactPointA, circleBody.position);

                sub(c.contactPointB, worldVertex, convexOffset);
                add(c.contactPointB, c.contactPointB, convexOffset);
                sub(c.contactPointB, c.contactPointB, convexBody.position);

                this.contactEquations.push(c);

                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }

                return 1;
            }
        }
    }

    return 0;
};

var pic_worldVertex0 = vec2.create(),
    pic_worldVertex1 = vec2.create(),
    pic_r0 = vec2.create(),
    pic_r1 = vec2.create();

/*
 * Check if a point is in a polygon
 */
function pointInConvex(worldPoint,convexShape,convexOffset,convexAngle){
    var worldVertex0 = pic_worldVertex0,
        worldVertex1 = pic_worldVertex1,
        r0 = pic_r0,
        r1 = pic_r1,
        point = worldPoint,
        verts = convexShape.vertices,
        lastCross = null;
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        // Transform vertices to world
        // @todo The point should be transformed to local coordinates in the convex, no need to transform each vertex
        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);

        sub(r0, worldVertex0, point);
        sub(r1, worldVertex1, point);
        var cross = vec2.crossLength(r0,r1);

        if(lastCross===null){
            lastCross = cross;
        }

        // If we got a different sign of the distance vector, the point is out of the polygon
        if(cross*lastCross <= 0){
            return false;
        }
        lastCross = cross;
    }
    return true;
}

/**
 * Particle/convex Narrowphase
 * @method particleConvex
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 * @todo use pointInConvex and code more similar to circleConvex
 * @todo don't transform each vertex, but transform the particle position to convex-local instead
 */
Narrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =
Narrowphase.prototype[Shape.PARTICLE | Shape.RECTANGLE] =
Narrowphase.prototype.particleConvex = function(
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest
){
    var worldVertex0 = tmp1,
        worldVertex1 = tmp2,
        worldEdge = tmp3,
        worldEdgeUnit = tmp4,
        worldTangent = tmp5,
        centerDist = tmp6,
        convexToparticle = tmp7,
        orthoDist = tmp8,
        projectedPoint = tmp9,
        dist = tmp10,
        worldVertex = tmp11,
        closestEdge = -1,
        closestEdgeDistance = null,
        closestEdgeOrthoDist = tmp12,
        closestEdgeProjectedPoint = tmp13,
        r0 = tmp14, // vector from particle to vertex0
        r1 = tmp15,
        localPoint = tmp16,
        candidateDist = tmp17,
        minEdgeNormal = tmp18,
        minCandidateDistance = Number.MAX_VALUE;

    var numReported = 0,
        found = false,
        verts = convexShape.vertices;

    // Check if the particle is in the polygon at all
    if(!pointInConvex(particleOffset,convexShape,convexOffset,convexAngle)){
        return 0;
    }

    if(justTest){
        return true;
    }

    // Check edges first
    var lastCross = null;
    for(var i=0; i!==verts.length+1; i++){
        var v0 = verts[i%verts.length],
            v1 = verts[(i+1)%verts.length];

        // Transform vertices to world
        vec2.rotate(worldVertex0, v0, convexAngle);
        vec2.rotate(worldVertex1, v1, convexAngle);
        add(worldVertex0, worldVertex0, convexOffset);
        add(worldVertex1, worldVertex1, convexOffset);

        // Get world edge
        sub(worldEdge, worldVertex1, worldVertex0);
        vec2.normalize(worldEdgeUnit, worldEdge);

        // Get tangent to the edge. Points out of the Convex
        vec2.rotate90cw(worldTangent, worldEdgeUnit);

        // Check distance from the infinite line (spanned by the edge) to the particle
        sub(dist, particleOffset, worldVertex0);
        var d = dot(dist, worldTangent);
        sub(centerDist, worldVertex0, convexOffset);

        sub(convexToparticle, particleOffset, convexOffset);

        vec2.sub(candidateDist,worldVertex0,particleOffset);
        var candidateDistance = Math.abs(vec2.dot(candidateDist,worldTangent));

        if(candidateDistance < minCandidateDistance){
            minCandidateDistance = candidateDistance;
            vec2.scale(closestEdgeProjectedPoint,worldTangent,candidateDistance);
            vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,particleOffset);
            vec2.copy(minEdgeNormal,worldTangent);
            found = true;
        }
    }

    if(found){
        var c = this.createContactEquation(particleBody,convexBody,particleShape,convexShape);

        vec2.scale(c.normalA, minEdgeNormal, -1);
        vec2.normalize(c.normalA, c.normalA);

        // Particle has no extent to the contact point
        vec2.set(c.contactPointA,  0, 0);
        add(c.contactPointA, c.contactPointA, particleOffset);
        sub(c.contactPointA, c.contactPointA, particleBody.position);

        // From convex center to point
        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);
        add(c.contactPointB, c.contactPointB, convexOffset);
        sub(c.contactPointB, c.contactPointB, convexBody.position);

        this.contactEquations.push(c);

        if(this.enableFriction){
            this.frictionEquations.push( this.createFrictionFromContact(c) );
        }

        return 1;
    }


    return 0;
};

/**
 * Circle/circle Narrowphase
 * @method circleCircle
 * @param  {Body} bodyA
 * @param  {Circle} shapeA
 * @param  {Array} offsetA
 * @param  {Number} angleA
 * @param  {Body} bodyB
 * @param  {Circle} shapeB
 * @param  {Array} offsetB
 * @param  {Number} angleB
 * @param {Boolean} justTest
 * @param {Number} [radiusA] Optional radius to use for shapeA
 * @param {Number} [radiusB] Optional radius to use for shapeB
 */
Narrowphase.prototype[Shape.CIRCLE] =
Narrowphase.prototype.circleCircle = function(
    bodyA,
    shapeA,
    offsetA,
    angleA,
    bodyB,
    shapeB,
    offsetB,
    angleB,
    justTest,
    radiusA,
    radiusB
){

    var dist = tmp1,
        radiusA = radiusA || shapeA.radius,
        radiusB = radiusB || shapeB.radius;

    sub(dist,offsetA,offsetB);
    var r = radiusA + radiusB;
    if(vec2.squaredLength(dist) > Math.pow(r,2)){
        return 0;
    }

    if(justTest){
        return true;
    }

    var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
    sub(c.normalA, offsetB, offsetA);
    vec2.normalize(c.normalA,c.normalA);

    vec2.scale( c.contactPointA, c.normalA,  radiusA);
    vec2.scale( c.contactPointB, c.normalA, -radiusB);

    add(c.contactPointA, c.contactPointA, offsetA);
    sub(c.contactPointA, c.contactPointA, bodyA.position);

    add(c.contactPointB, c.contactPointB, offsetB);
    sub(c.contactPointB, c.contactPointB, bodyB.position);

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }
    return 1;
};

/**
 * Plane/Convex Narrowphase
 * @method planeConvex
 * @param  {Body} planeBody
 * @param  {Plane} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} convexBody
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param {Boolean} justTest
 */
Narrowphase.prototype[Shape.PLANE | Shape.CONVEX] =
Narrowphase.prototype[Shape.PLANE | Shape.RECTANGLE] =
Narrowphase.prototype.planeConvex = function(
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    convexBody,
    convexShape,
    convexOffset,
    convexAngle,
    justTest
){
    var worldVertex = tmp1,
        worldNormal = tmp2,
        dist = tmp3;

    var numReported = 0;
    vec2.rotate(worldNormal, yAxis, planeAngle);

    for(var i=0; i!==convexShape.vertices.length; i++){
        var v = convexShape.vertices[i];
        vec2.rotate(worldVertex, v, convexAngle);
        add(worldVertex, worldVertex, convexOffset);

        sub(dist, worldVertex, planeOffset);

        if(dot(dist,worldNormal) <= 0){

            if(justTest){
                return true;
            }

            // Found vertex
            numReported++;

            var c = this.createContactEquation(planeBody,convexBody,planeShape,convexShape);

            sub(dist, worldVertex, planeOffset);

            vec2.copy(c.normalA, worldNormal);

            var d = dot(dist, c.normalA);
            vec2.scale(dist, c.normalA, d);

            // rj is from convex center to contact
            sub(c.contactPointB, worldVertex, convexBody.position);


            // ri is from plane center to contact
            sub( c.contactPointA, worldVertex, dist);
            sub( c.contactPointA, c.contactPointA, planeBody.position);

            this.contactEquations.push(c);

            if(!this.enableFrictionReduction){
                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(this.enableFrictionReduction){
        if(this.enableFriction && numReported){
            this.frictionEquations.push(this.createFrictionFromAverage(numReported));
        }
    }

    return numReported;
};

/**
 * Narrowphase for particle vs plane
 * @method particlePlane
 * @param  {Body}       particleBody
 * @param  {Particle}   particleShape
 * @param  {Array}      particleOffset
 * @param  {Number}     particleAngle
 * @param  {Body}       planeBody
 * @param  {Plane}      planeShape
 * @param  {Array}      planeOffset
 * @param  {Number}     planeAngle
 * @param {Boolean}     justTest
 */
Narrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =
Narrowphase.prototype.particlePlane = function(
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    justTest
){
    var dist = tmp1,
        worldNormal = tmp2;

    planeAngle = planeAngle || 0;

    sub(dist, particleOffset, planeOffset);
    vec2.rotate(worldNormal, yAxis, planeAngle);

    var d = dot(dist, worldNormal);

    if(d > 0){
        return 0;
    }
    if(justTest){
        return true;
    }

    var c = this.createContactEquation(planeBody,particleBody,planeShape,particleShape);

    vec2.copy(c.normalA, worldNormal);
    vec2.scale( dist, c.normalA, d );
    // dist is now the distance vector in the normal direction

    // ri is the particle position projected down onto the plane, from the plane center
    sub( c.contactPointA, particleOffset, dist);
    sub( c.contactPointA, c.contactPointA, planeBody.position);

    // rj is from the body center to the particle center
    sub( c.contactPointB, particleOffset, particleBody.position );

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }
    return 1;
};

/**
 * Circle/Particle Narrowphase
 * @method circleParticle
 * @param  {Body} circleBody
 * @param  {Circle} circleShape
 * @param  {Array} circleOffset
 * @param  {Number} circleAngle
 * @param  {Body} particleBody
 * @param  {Particle} particleShape
 * @param  {Array} particleOffset
 * @param  {Number} particleAngle
 * @param  {Boolean} justTest
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =
Narrowphase.prototype.circleParticle = function(
    circleBody,
    circleShape,
    circleOffset,
    circleAngle,
    particleBody,
    particleShape,
    particleOffset,
    particleAngle,
    justTest
){
    var dist = tmp1;

    sub(dist, particleOffset, circleOffset);
    if(vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)){
        return 0;
    }
    if(justTest){
        return true;
    }

    var c = this.createContactEquation(circleBody,particleBody,circleShape,particleShape);
    vec2.copy(c.normalA, dist);
    vec2.normalize(c.normalA,c.normalA);

    // Vector from circle to contact point is the normal times the circle radius
    vec2.scale(c.contactPointA, c.normalA, circleShape.radius);
    add(c.contactPointA, c.contactPointA, circleOffset);
    sub(c.contactPointA, c.contactPointA, circleBody.position);

    // Vector from particle center to contact point is zero
    sub(c.contactPointB, particleOffset, particleBody.position);

    this.contactEquations.push(c);

    if(this.enableFriction){
        this.frictionEquations.push(this.createFrictionFromContact(c));
    }

    return 1;
};

var planeCapsule_tmpCircle = new Circle(1),
    planeCapsule_tmp1 = vec2.create(),
    planeCapsule_tmp2 = vec2.create(),
    planeCapsule_tmp3 = vec2.create();

/**
 * @method planeCapsule
 * @param  {Body} planeBody
 * @param  {Circle} planeShape
 * @param  {Array} planeOffset
 * @param  {Number} planeAngle
 * @param  {Body} capsuleBody
 * @param  {Particle} capsuleShape
 * @param  {Array} capsuleOffset
 * @param  {Number} capsuleAngle
 * @param {Boolean} justTest
 */
Narrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =
Narrowphase.prototype.planeCapsule = function(
    planeBody,
    planeShape,
    planeOffset,
    planeAngle,
    capsuleBody,
    capsuleShape,
    capsuleOffset,
    capsuleAngle,
    justTest
){
    var end1 = planeCapsule_tmp1,
        end2 = planeCapsule_tmp2,
        circle = planeCapsule_tmpCircle,
        dst = planeCapsule_tmp3;

    // Compute world end positions
    vec2.set(end1, -capsuleShape.length/2, 0);
    vec2.rotate(end1,end1,capsuleAngle);
    add(end1,end1,capsuleOffset);

    vec2.set(end2,  capsuleShape.length/2, 0);
    vec2.rotate(end2,end2,capsuleAngle);
    add(end2,end2,capsuleOffset);

    circle.radius = capsuleShape.radius;

    var enableFrictionBefore;

    // Temporarily turn off friction
    if(this.enableFrictionReduction){
        enableFrictionBefore = this.enableFriction;
        this.enableFriction = false;
    }

    // Do Narrowphase as two circles
    var numContacts1 = this.circlePlane(capsuleBody,circle,end1,0, planeBody,planeShape,planeOffset,planeAngle, justTest),
        numContacts2 = this.circlePlane(capsuleBody,circle,end2,0, planeBody,planeShape,planeOffset,planeAngle, justTest);

    // Restore friction
    if(this.enableFrictionReduction){
        this.enableFriction = enableFrictionBefore;
    }

    if(justTest){
        return numContacts1 || numContacts2;
    } else {
        var numTotal = numContacts1 + numContacts2;
        if(this.enableFrictionReduction){
            if(numTotal){
                this.frictionEquations.push(this.createFrictionFromAverage(numTotal));
            }
        }
        return numTotal;
    }
};

/**
 * Creates ContactEquations and FrictionEquations for a collision.
 * @method circlePlane
 * @param  {Body}    bi     The first body that should be connected to the equations.
 * @param  {Circle}  si     The circle shape participating in the collision.
 * @param  {Array}   xi     Extra offset to take into account for the Shape, in addition to the one in circleBody.position. Will *not* be rotated by circleBody.angle (maybe it should, for sake of homogenity?). Set to null if none.
 * @param  {Body}    bj     The second body that should be connected to the equations.
 * @param  {Plane}   sj     The Plane shape that is participating
 * @param  {Array}   xj     Extra offset for the plane shape.
 * @param  {Number}  aj     Extra angle to apply to the plane
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =
Narrowphase.prototype.circlePlane = function(   bi,si,xi,ai, bj,sj,xj,aj, justTest ){
    var circleBody = bi,
        circleShape = si,
        circleOffset = xi, // Offset from body center, rotated!
        planeBody = bj,
        shapeB = sj,
        planeOffset = xj,
        planeAngle = aj;

    planeAngle = planeAngle || 0;

    // Vector from plane to circle
    var planeToCircle = tmp1,
        worldNormal = tmp2,
        temp = tmp3;

    sub(planeToCircle, circleOffset, planeOffset);

    // World plane normal
    vec2.rotate(worldNormal, yAxis, planeAngle);

    // Normal direction distance
    var d = dot(worldNormal, planeToCircle);

    if(d > circleShape.radius){
        return 0; // No overlap. Abort.
    }

    if(justTest){
        return true;
    }

    // Create contact
    var contact = this.createContactEquation(planeBody,circleBody,sj,si);

    // ni is the plane world normal
    vec2.copy(contact.normalA, worldNormal);

    // rj is the vector from circle center to the contact point
    vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);
    add(contact.contactPointB, contact.contactPointB, circleOffset);
    sub(contact.contactPointB, contact.contactPointB, circleBody.position);

    // ri is the distance from plane center to contact.
    vec2.scale(temp, contact.normalA, d);
    sub(contact.contactPointA, planeToCircle, temp ); // Subtract normal distance vector from the distance vector
    add(contact.contactPointA, contact.contactPointA, planeOffset);
    sub(contact.contactPointA, contact.contactPointA, planeBody.position);

    this.contactEquations.push(contact);

    if(this.enableFriction){
        this.frictionEquations.push( this.createFrictionFromContact(contact) );
    }

    return 1;
};

/**
 * Convex/convex Narrowphase.See <a href="http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/">this article</a> for more info.
 * @method convexConvex
 * @param  {Body} bi
 * @param  {Convex} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Convex} sj
 * @param  {Array} xj
 * @param  {Number} aj
 */
Narrowphase.prototype[Shape.CONVEX] =
Narrowphase.prototype[Shape.CONVEX | Shape.RECTANGLE] =
Narrowphase.prototype[Shape.RECTANGLE] =
Narrowphase.prototype.convexConvex = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest, precision ){
    var sepAxis = tmp1,
        worldPoint = tmp2,
        worldPoint0 = tmp3,
        worldPoint1 = tmp4,
        worldEdge = tmp5,
        projected = tmp6,
        penetrationVec = tmp7,
        dist = tmp8,
        worldNormal = tmp9,
        numContacts = 0,
        precision = typeof(precision) === 'number' ? precision : 0;

    var found = Narrowphase.findSeparatingAxis(si,xi,ai,sj,xj,aj,sepAxis);
    if(!found){
        return 0;
    }

    // Make sure the separating axis is directed from shape i to shape j
    sub(dist,xj,xi);
    if(dot(sepAxis,dist) > 0){
        vec2.scale(sepAxis,sepAxis,-1);
    }

    // Find edges with normals closest to the separating axis
    var closestEdge1 = Narrowphase.getClosestEdge(si,ai,sepAxis,true), // Flipped axis
        closestEdge2 = Narrowphase.getClosestEdge(sj,aj,sepAxis);

    if(closestEdge1 === -1 || closestEdge2 === -1){
        return 0;
    }

    // Loop over the shapes
    for(var k=0; k<2; k++){

        var closestEdgeA = closestEdge1,
            closestEdgeB = closestEdge2,
            shapeA =  si, shapeB =  sj,
            offsetA = xi, offsetB = xj,
            angleA = ai, angleB = aj,
            bodyA = bi, bodyB = bj;

        if(k === 0){
            // Swap!
            var tmp;
            tmp = closestEdgeA;
            closestEdgeA = closestEdgeB;
            closestEdgeB = tmp;

            tmp = shapeA;
            shapeA = shapeB;
            shapeB = tmp;

            tmp = offsetA;
            offsetA = offsetB;
            offsetB = tmp;

            tmp = angleA;
            angleA = angleB;
            angleB = tmp;

            tmp = bodyA;
            bodyA = bodyB;
            bodyB = tmp;
        }

        // Loop over 2 points in convex B
        for(var j=closestEdgeB; j<closestEdgeB+2; j++){

            // Get world point
            var v = shapeB.vertices[(j+shapeB.vertices.length)%shapeB.vertices.length];
            vec2.rotate(worldPoint, v, angleB);
            add(worldPoint, worldPoint, offsetB);

            var insideNumEdges = 0;

            // Loop over the 3 closest edges in convex A
            for(var i=closestEdgeA-1; i<closestEdgeA+2; i++){

                var v0 = shapeA.vertices[(i  +shapeA.vertices.length)%shapeA.vertices.length],
                    v1 = shapeA.vertices[(i+1+shapeA.vertices.length)%shapeA.vertices.length];

                // Construct the edge
                vec2.rotate(worldPoint0, v0, angleA);
                vec2.rotate(worldPoint1, v1, angleA);
                add(worldPoint0, worldPoint0, offsetA);
                add(worldPoint1, worldPoint1, offsetA);

                sub(worldEdge, worldPoint1, worldPoint0);

                vec2.rotate90cw(worldNormal, worldEdge); // Normal points out of convex 1
                vec2.normalize(worldNormal,worldNormal);

                sub(dist, worldPoint, worldPoint0);

                var d = dot(worldNormal,dist);

                if((i === closestEdgeA && d <= precision) || (i !== closestEdgeA && d <= 0)){
                    insideNumEdges++;
                }
            }

            if(insideNumEdges >= 3){

                if(justTest){
                    return true;
                }

                // worldPoint was on the "inside" side of each of the 3 checked edges.
                // Project it to the center edge and use the projection direction as normal

                // Create contact
                var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);
                numContacts++;

                // Get center edge from body A
                var v0 = shapeA.vertices[(closestEdgeA)   % shapeA.vertices.length],
                    v1 = shapeA.vertices[(closestEdgeA+1) % shapeA.vertices.length];

                // Construct the edge
                vec2.rotate(worldPoint0, v0, angleA);
                vec2.rotate(worldPoint1, v1, angleA);
                add(worldPoint0, worldPoint0, offsetA);
                add(worldPoint1, worldPoint1, offsetA);

                sub(worldEdge, worldPoint1, worldPoint0);

                vec2.rotate90cw(c.normalA, worldEdge); // Normal points out of convex A
                vec2.normalize(c.normalA,c.normalA);

                sub(dist, worldPoint, worldPoint0); // From edge point to the penetrating point
                var d = dot(c.normalA,dist);             // Penetration
                vec2.scale(penetrationVec, c.normalA, d);     // Vector penetration

                sub(c.contactPointA, worldPoint, offsetA);
                sub(c.contactPointA, c.contactPointA, penetrationVec);
                add(c.contactPointA, c.contactPointA, offsetA);
                sub(c.contactPointA, c.contactPointA, bodyA.position);

                sub(c.contactPointB, worldPoint, offsetB);
                add(c.contactPointB, c.contactPointB, offsetB);
                sub(c.contactPointB, c.contactPointB, bodyB.position);

                this.contactEquations.push(c);

                // Todo reduce to 1 friction equation if we have 2 contact points
                if(!this.enableFrictionReduction){
                    if(this.enableFriction){
                        this.frictionEquations.push(this.createFrictionFromContact(c));
                    }
                }
            }
        }
    }

    if(this.enableFrictionReduction){
        if(this.enableFriction && numContacts){
            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));
        }
    }

    return numContacts;
};

// .projectConvex is called by other functions, need local tmp vectors
var pcoa_tmp1 = vec2.fromValues(0,0);

/**
 * Project a Convex onto a world-oriented axis
 * @method projectConvexOntoAxis
 * @static
 * @param  {Convex} convexShape
 * @param  {Array} convexOffset
 * @param  {Number} convexAngle
 * @param  {Array} worldAxis
 * @param  {Array} result
 */
Narrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result){
    var max=null,
        min=null,
        v,
        value,
        localAxis = pcoa_tmp1;

    // Convert the axis to local coords of the body
    vec2.rotate(localAxis, worldAxis, -convexAngle);

    // Get projected position of all vertices
    for(var i=0; i<convexShape.vertices.length; i++){
        v = convexShape.vertices[i];
        value = dot(v,localAxis);
        if(max === null || value > max){
            max = value;
        }
        if(min === null || value < min){
            min = value;
        }
    }

    if(min > max){
        var t = min;
        min = max;
        max = t;
    }

    // Project the position of the body onto the axis - need to add this to the result
    var offset = dot(convexOffset, worldAxis);

    vec2.set( result, min + offset, max + offset);
};

// .findSeparatingAxis is called by other functions, need local tmp vectors
var fsa_tmp1 = vec2.fromValues(0,0)
,   fsa_tmp2 = vec2.fromValues(0,0)
,   fsa_tmp3 = vec2.fromValues(0,0)
,   fsa_tmp4 = vec2.fromValues(0,0)
,   fsa_tmp5 = vec2.fromValues(0,0)
,   fsa_tmp6 = vec2.fromValues(0,0);

/**
 * Find a separating axis between the shapes, that maximizes the separating distance between them.
 * @method findSeparatingAxis
 * @static
 * @param  {Convex}     c1
 * @param  {Array}      offset1
 * @param  {Number}     angle1
 * @param  {Convex}     c2
 * @param  {Array}      offset2
 * @param  {Number}     angle2
 * @param  {Array}      sepAxis     The resulting axis
 * @return {Boolean}                Whether the axis could be found.
 */
Narrowphase.findSeparatingAxis = function(c1,offset1,angle1,c2,offset2,angle2,sepAxis){
    var maxDist = null,
        overlap = false,
        found = false,
        edge = fsa_tmp1,
        worldPoint0 = fsa_tmp2,
        worldPoint1 = fsa_tmp3,
        normal = fsa_tmp4,
        span1 = fsa_tmp5,
        span2 = fsa_tmp6;

    if(c1 instanceof Rectangle && c2 instanceof Rectangle){

        for(var j=0; j!==2; j++){
            var c = c1,
                angle = angle1;
            if(j===1){
                c = c2;
                angle = angle2;
            }

            for(var i=0; i!==2; i++){

                // Get the world edge
                if(i === 0){
                    vec2.set(normal, 0, 1);
                } else if(i === 1) {
                    vec2.set(normal, 1, 0);
                }
                if(angle !== 0){
                    vec2.rotate(normal, normal, angle);
                }

                // Project hulls onto that normal
                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);

                // Order by span position
                var a=span1,
                    b=span2,
                    swapped = false;
                if(span1[0] > span2[0]){
                    b=span1;
                    a=span2;
                    swapped = true;
                }

                // Get separating distance
                var dist = b[0] - a[1];
                overlap = (dist <= 0);

                if(maxDist===null || dist > maxDist){
                    vec2.copy(sepAxis, normal);
                    maxDist = dist;
                    found = overlap;
                }
            }
        }

    } else {

        for(var j=0; j!==2; j++){
            var c = c1,
                angle = angle1;
            if(j===1){
                c = c2;
                angle = angle2;
            }

            for(var i=0; i!==c.vertices.length; i++){
                // Get the world edge
                vec2.rotate(worldPoint0, c.vertices[i], angle);
                vec2.rotate(worldPoint1, c.vertices[(i+1)%c.vertices.length], angle);

                sub(edge, worldPoint1, worldPoint0);

                // Get normal - just rotate 90 degrees since vertices are given in CCW
                vec2.rotate90cw(normal, edge);
                vec2.normalize(normal,normal);

                // Project hulls onto that normal
                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);
                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);

                // Order by span position
                var a=span1,
                    b=span2,
                    swapped = false;
                if(span1[0] > span2[0]){
                    b=span1;
                    a=span2;
                    swapped = true;
                }

                // Get separating distance
                var dist = b[0] - a[1];
                overlap = (dist <= 0);

                if(maxDist===null || dist > maxDist){
                    vec2.copy(sepAxis, normal);
                    maxDist = dist;
                    found = overlap;
                }
            }
        }
    }


    /*
    // Needs to be tested some more
    for(var j=0; j!==2; j++){
        var c = c1,
            angle = angle1;
        if(j===1){
            c = c2;
            angle = angle2;
        }

        for(var i=0; i!==c.axes.length; i++){

            var normal = c.axes[i];

            // Project hulls onto that normal
            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);
            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);

            // Order by span position
            var a=span1,
                b=span2,
                swapped = false;
            if(span1[0] > span2[0]){
                b=span1;
                a=span2;
                swapped = true;
            }

            // Get separating distance
            var dist = b[0] - a[1];
            overlap = (dist <= Narrowphase.convexPrecision);

            if(maxDist===null || dist > maxDist){
                vec2.copy(sepAxis, normal);
                maxDist = dist;
                found = overlap;
            }
        }
    }
    */

    return found;
};

// .getClosestEdge is called by other functions, need local tmp vectors
var gce_tmp1 = vec2.fromValues(0,0)
,   gce_tmp2 = vec2.fromValues(0,0)
,   gce_tmp3 = vec2.fromValues(0,0);

/**
 * Get the edge that has a normal closest to an axis.
 * @method getClosestEdge
 * @static
 * @param  {Convex}     c
 * @param  {Number}     angle
 * @param  {Array}      axis
 * @param  {Boolean}    flip
 * @return {Number}             Index of the edge that is closest. This index and the next spans the resulting edge. Returns -1 if failed.
 */
Narrowphase.getClosestEdge = function(c,angle,axis,flip){
    var localAxis = gce_tmp1,
        edge = gce_tmp2,
        normal = gce_tmp3;

    // Convert the axis to local coords of the body
    vec2.rotate(localAxis, axis, -angle);
    if(flip){
        vec2.scale(localAxis,localAxis,-1);
    }

    var closestEdge = -1,
        N = c.vertices.length,
        maxDot = -1;
    for(var i=0; i!==N; i++){
        // Get the edge
        sub(edge, c.vertices[(i+1)%N], c.vertices[i%N]);

        // Get normal - just rotate 90 degrees since vertices are given in CCW
        vec2.rotate90cw(normal, edge);
        vec2.normalize(normal,normal);

        var d = dot(normal,localAxis);
        if(closestEdge === -1 || d > maxDot){
            closestEdge = i % N;
            maxDot = d;
        }
    }

    return closestEdge;
};

var circleHeightfield_candidate = vec2.create(),
    circleHeightfield_dist = vec2.create(),
    circleHeightfield_v0 = vec2.create(),
    circleHeightfield_v1 = vec2.create(),
    circleHeightfield_minCandidate = vec2.create(),
    circleHeightfield_worldNormal = vec2.create(),
    circleHeightfield_minCandidateNormal = vec2.create();

/**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */
Narrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =
Narrowphase.prototype.circleHeightfield = function( circleBody,circleShape,circlePos,circleAngle,
                                                    hfBody,hfShape,hfPos,hfAngle, justTest, radius ){
    var data = hfShape.data,
        radius = radius || circleShape.radius,
        w = hfShape.elementWidth,
        dist = circleHeightfield_dist,
        candidate = circleHeightfield_candidate,
        minCandidate = circleHeightfield_minCandidate,
        minCandidateNormal = circleHeightfield_minCandidateNormal,
        worldNormal = circleHeightfield_worldNormal,
        v0 = circleHeightfield_v0,
        v1 = circleHeightfield_v1;

    // Get the index of the points to test against
    var idxA = Math.floor( (circlePos[0] - radius - hfPos[0]) / w ),
        idxB = Math.ceil(  (circlePos[0] + radius - hfPos[0]) / w );

    /*if(idxB < 0 || idxA >= data.length)
        return justTest ? false : 0;*/

    if(idxA < 0){
        idxA = 0;
    }
    if(idxB >= data.length){
        idxB = data.length-1;
    }

    // Get max and min
    var max = data[idxA],
        min = data[idxB];
    for(var i=idxA; i<idxB; i++){
        if(data[i] < min){
            min = data[i];
        }
        if(data[i] > max){
            max = data[i];
        }
    }

    if(circlePos[1]-radius > max){
        return justTest ? false : 0;
    }

    /*
    if(circlePos[1]+radius < min){
        // Below the minimum point... We can just guess.
        // TODO
    }
    */

    // 1. Check so center of circle is not inside the field. If it is, this wont work...
    // 2. For each edge
    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)
    // 2. 2. Check if point is inside.

    var found = false;

    // Check all edges first
    for(var i=idxA; i<idxB; i++){

        // Get points
        vec2.set(v0,     i*w, data[i]  );
        vec2.set(v1, (i+1)*w, data[i+1]);
        vec2.add(v0,v0,hfPos);
        vec2.add(v1,v1,hfPos);

        // Get normal
        vec2.sub(worldNormal, v1, v0);
        vec2.rotate(worldNormal, worldNormal, Math.PI/2);
        vec2.normalize(worldNormal,worldNormal);

        // Get point on circle, closest to the edge
        vec2.scale(candidate,worldNormal,-radius);
        vec2.add(candidate,candidate,circlePos);

        // Distance from v0 to the candidate point
        vec2.sub(dist,candidate,v0);

        // Check if it is in the element "stick"
        var d = vec2.dot(dist,worldNormal);
        if(candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0){

            if(justTest){
                return true;
            }

            found = true;

            // Store the candidate point, projected to the edge
            vec2.scale(dist,worldNormal,-d);
            vec2.add(minCandidate,candidate,dist);
            vec2.copy(minCandidateNormal,worldNormal);

            var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);

            // Normal is out of the heightfield
            vec2.copy(c.normalA, minCandidateNormal);

            // Vector from circle to heightfield
            vec2.scale(c.contactPointB,  c.normalA, -radius);
            add(c.contactPointB, c.contactPointB, circlePos);
            sub(c.contactPointB, c.contactPointB, circleBody.position);

            vec2.copy(c.contactPointA, minCandidate);
            vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);

            this.contactEquations.push(c);

            if(this.enableFriction){
                this.frictionEquations.push( this.createFrictionFromContact(c) );
            }
        }
    }

    // Check all vertices
    found = false;
    if(radius > 0){
        for(var i=idxA; i<=idxB; i++){

            // Get point
            vec2.set(v0, i*w, data[i]);
            vec2.add(v0,v0,hfPos);

            vec2.sub(dist, circlePos, v0);

            if(vec2.squaredLength(dist) < Math.pow(radius, 2)){

                if(justTest){
                    return true;
                }

                found = true;

                var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);

                // Construct normal - out of heightfield
                vec2.copy(c.normalA, dist);
                vec2.normalize(c.normalA,c.normalA);

                vec2.scale(c.contactPointB, c.normalA, -radius);
                add(c.contactPointB, c.contactPointB, circlePos);
                sub(c.contactPointB, c.contactPointB, circleBody.position);

                sub(c.contactPointA, v0, hfPos);
                add(c.contactPointA, c.contactPointA, hfPos);
                sub(c.contactPointA, c.contactPointA, hfBody.position);

                this.contactEquations.push(c);

                if(this.enableFriction){
                    this.frictionEquations.push(this.createFrictionFromContact(c));
                }
            }
        }
    }

    if(found){
        return 1;
    }

    return 0;

};

var convexHeightfield_v0 = vec2.create(),
    convexHeightfield_v1 = vec2.create(),
    convexHeightfield_tilePos = vec2.create(),
    convexHeightfield_tempConvexShape = new Convex([vec2.create(),vec2.create(),vec2.create(),vec2.create()]);
/**
 * @method circleHeightfield
 * @param  {Body}           bi
 * @param  {Circle}         si
 * @param  {Array}          xi
 * @param  {Body}           bj
 * @param  {Heightfield}    sj
 * @param  {Array}          xj
 * @param  {Number}         aj
 */
Narrowphase.prototype[Shape.RECTANGLE | Shape.HEIGHTFIELD] =
Narrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =
Narrowphase.prototype.convexHeightfield = function( convexBody,convexShape,convexPos,convexAngle,
                                                    hfBody,hfShape,hfPos,hfAngle, justTest ){
    var data = hfShape.data,
        w = hfShape.elementWidth,
        v0 = convexHeightfield_v0,
        v1 = convexHeightfield_v1,
        tilePos = convexHeightfield_tilePos,
        tileConvex = convexHeightfield_tempConvexShape;

    // Get the index of the points to test against
    var idxA = Math.floor( (convexBody.aabb.lowerBound[0] - hfPos[0]) / w ),
        idxB = Math.ceil(  (convexBody.aabb.upperBound[0] - hfPos[0]) / w );

    if(idxA < 0){
        idxA = 0;
    }
    if(idxB >= data.length){
        idxB = data.length-1;
    }

    // Get max and min
    var max = data[idxA],
        min = data[idxB];
    for(var i=idxA; i<idxB; i++){
        if(data[i] < min){
            min = data[i];
        }
        if(data[i] > max){
            max = data[i];
        }
    }

    if(convexBody.aabb.lowerBound[1] > max){
        return justTest ? false : 0;
    }

    var found = false;
    var numContacts = 0;

    // Loop over all edges
    // TODO: If possible, construct a convex from several data points (need o check if the points make a convex shape)
    for(var i=idxA; i<idxB; i++){

        // Get points
        vec2.set(v0,     i*w, data[i]  );
        vec2.set(v1, (i+1)*w, data[i+1]);
        vec2.add(v0,v0,hfPos);
        vec2.add(v1,v1,hfPos);

        // Construct a convex
        var tileHeight = 100; // todo
        vec2.set(tilePos, (v1[0] + v0[0])*0.5, (v1[1] + v0[1] - tileHeight)*0.5);

        vec2.sub(tileConvex.vertices[0], v1, tilePos);
        vec2.sub(tileConvex.vertices[1], v0, tilePos);
        vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);
        vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);
        tileConvex.vertices[2][1] -= tileHeight;
        tileConvex.vertices[3][1] -= tileHeight;

        // Do convex collision
        numContacts += this.convexConvex(   convexBody, convexShape, convexPos, convexAngle,
                                            hfBody, tileConvex, tilePos, 0, justTest);
    }

    return numContacts;
};
},{"../equations/ContactEquation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/ContactEquation.js","../equations/Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js","../equations/FrictionEquation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/FrictionEquation.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../objects/Body":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/Body.js","../shapes/Circle":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Circle.js","../shapes/Convex":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Convex.js","../shapes/Rectangle":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Rectangle.js","../shapes/Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js","../utils/TupleDictionary":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/TupleDictionary.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/Ray.js":[function(require,module,exports){
module.exports = Ray;

var vec2 = require('../math/vec2');
var RaycastResult = require('../collision/RaycastResult');
var Shape = require('../shapes/Shape');
var AABB = require('../collision/AABB');

/**
 * A line with a start and end point that is used to intersect shapes.
 * @class Ray
 * @constructor
 */
function Ray(options){
    options = options || {};

    /**
     * @property {array} from
     */
    this.from = options.from ? vec2.fromValues(options.from[0], options.from[1]) : vec2.create();

    /**
     * @property {array} to
     */
    this.to = options.to ? vec2.fromValues(options.to[0], options.to[1]) : vec2.create();

    /**
     * @private
     * @property {array} _direction
     */
    this._direction = vec2.create();

    /**
     * The precision of the ray. Used when checking parallelity etc.
     * @property {Number} precision
     */
    this.precision = 0.0001;

    /**
     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
     * @property {Boolean} checkCollisionResponse
     */
    this.checkCollisionResponse = true;

    /**
     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
     * @property {Boolean} skipBackfaces
     */
    this.skipBackfaces = false;

    /**
     * @property {number} collisionMask
     * @default -1
     */
    this.collisionMask = -1;

    /**
     * @property {number} collisionGroup
     * @default -1
     */
    this.collisionGroup = -1;

    /**
     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
     * @property {number} mode
     */
    this.mode = Ray.ANY;

    /**
     * Current result object.
     * @property {RaycastResult} result
     */
    this.result = new RaycastResult();

    /**
     * Will be set to true during intersectWorld() if the ray hit anything.
     * @property {Boolean} hasHit
     */
    this.hasHit = false;

    /**
     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
     * @property {Function} callback
     */
    this.callback = function(result){};
}
Ray.prototype.constructor = Ray;

Ray.CLOSEST = 1;
Ray.ANY = 2;
Ray.ALL = 4;

var tmpAABB = new AABB();
var tmpArray = [];

/**
 * Do itersection against all bodies in the given World.
 * @method intersectWorld
 * @param  {World} world
 * @param  {object} options
 * @return {Boolean} True if the ray hit anything, otherwise false.
 */
Ray.prototype.intersectWorld = function (world, options) {
    this.mode = options.mode || Ray.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionMask = typeof(options.collisionMask) !== 'undefined' ? options.collisionMask : -1;
    this.collisionGroup = typeof(options.collisionGroup) !== 'undefined' ? options.collisionGroup : -1;
    if(options.from){
        vec2.copy(this.from, options.from);
    }
    if(options.to){
        vec2.copy(this.to, options.to);
    }
    this.callback = options.callback || function(){};
    this.hasHit = false;

    this.result.reset();
    this._updateDirection();

    this.getAABB(tmpAABB);
    tmpArray.length = 0;
    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
    this.intersectBodies(tmpArray);

    return this.hasHit;
};

var v1 = vec2.create(),
    v2 = vec2.create();

var intersectBody_worldPosition = vec2.create();

/**
 * Shoot a ray at a body, get back information about the hit.
 * @method intersectBody
 * @private
 * @param {Body} body
 * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
 */
Ray.prototype.intersectBody = function (body, result) {

    if(result){
        this.result = result;
        this._updateDirection();
    }
    var checkCollisionResponse = this.checkCollisionResponse;

    if(checkCollisionResponse && !body.collisionResponse){
        return;
    }

    // if((this.collisionGroup & body.collisionMask)===0 || (body.collisionGroup & this.collisionMask)===0){
    //     return;
    // }

    var worldPosition = intersectBody_worldPosition;

    for (var i = 0, N = body.shapes.length; i < N; i++) {
        var shape = body.shapes[i];

        if(checkCollisionResponse && !shape.collisionResponse){
            continue; // Skip
        }

        // Get world angle and position of the shape
        vec2.copy(worldPosition, body.shapeOffsets[i]);
        vec2.rotate(worldPosition, worldPosition, body.angle);
        vec2.add(worldPosition, worldPosition, body.position);
        var worldAngle = body.shapeAngles[i] + body.angle;

        this.intersectShape(
            shape,
            worldAngle,
            worldPosition,
            body
        );

        if(this.result._shouldStop){
            break;
        }
    }
};

/**
 * @method intersectBodies
 * @param {Array} bodies An array of Body objects.
 * @param {RaycastResult} [result] Deprecated
 */
Ray.prototype.intersectBodies = function (bodies, result) {
    if(result){
        this.result = result;
        this._updateDirection();
    }

    for ( var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i ++ ) {
        this.intersectBody(bodies[i]);
    }
};

/**
 * Updates the _direction vector.
 * @private
 * @method _updateDirection
 */
Ray.prototype._updateDirection = function(){
    var d = this._direction;
    vec2.sub(d, this.to, this.from); // this.to.vsub(this.from, this._direction);
    vec2.normalize(d, d); // this._direction.normalize();
};

/**
 * @method intersectShape
 * @private
 * @param {Shape} shape
 * @param {number} angle
 * @param {array} position
 * @param {Body} body
 */
Ray.prototype.intersectShape = function(shape, angle, position, body){
    var from = this.from;


    // Checking boundingSphere
    var distance = distanceFromIntersection(from, this._direction, position);
    if ( distance > shape.boundingSphereRadius ) {
        return;
    }

    var method = this[shape.type];
    if(method){
        method.call(this, shape, angle, position, body);
    }
};

var vector = vec2.create();
var normal = vec2.create();
var intersectPoint = vec2.create();

var a = vec2.create();
var b = vec2.create();
var c = vec2.create();
var d = vec2.create();

var tmpRaycastResult = new RaycastResult();
var intersectRectangle_direction = vec2.create();
var intersectRectangle_rayStart = vec2.create();
var intersectRectangle_worldNormalMin = vec2.create();
var intersectRectangle_worldNormalMax = vec2.create();
var intersectRectangle_hitPointWorld = vec2.create();
var intersectRectangle_boxMin = vec2.create();
var intersectRectangle_boxMax = vec2.create();

/**
 * @method intersectRectangle
 * @private
 * @param  {Shape} shape
 * @param  {number} angle
 * @param  {array} position
 * @param  {Body} body
 */
Ray.prototype.intersectRectangle = function(shape, angle, position, body){
    var tmin = -Number.MAX_VALUE;
    var tmax = Number.MAX_VALUE;

    var direction = intersectRectangle_direction;
    var rayStart = intersectRectangle_rayStart;
    var worldNormalMin = intersectRectangle_worldNormalMin;
    var worldNormalMax = intersectRectangle_worldNormalMax;
    var hitPointWorld = intersectRectangle_hitPointWorld;
    var boxMin = intersectRectangle_boxMin;
    var boxMax = intersectRectangle_boxMax;

    vec2.set(boxMin, -shape.width * 0.5, -shape.height * 0.5);
    vec2.set(boxMax, shape.width * 0.5, shape.height * 0.5);

    // Transform the ray direction and start to local space
    vec2.rotate(direction, this._direction, -angle);
    body.toLocalFrame(rayStart, this.from);

    if (direction[0] !== 0) {
        var tx1 = (boxMin[0] - rayStart[0]) / direction[0];
        var tx2 = (boxMax[0] - rayStart[0]) / direction[0];

        var tminOld = tmin;
        tmin = Math.max(tmin, Math.min(tx1, tx2));
        if(tmin !== tminOld){
            vec2.set(worldNormalMin, tx1 > tx2 ? 1 : -1, 0);
        }

        var tmaxOld = tmax;
        tmax = Math.min(tmax, Math.max(tx1, tx2));
        if(tmax !== tmaxOld){
            vec2.set(worldNormalMax, tx1 < tx2 ? 1 : -1, 0);
        }
    }

    if (direction[1] !== 0) {
        var ty1 = (boxMin[1] - rayStart[1]) / direction[1];
        var ty2 = (boxMax[1] - rayStart[1]) / direction[1];

        var tminOld = tmin;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        if(tmin !== tminOld){
            vec2.set(worldNormalMin, 0, ty1 > ty2 ? 1 : -1);
        }

        var tmaxOld = tmax;
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        if(tmax !== tmaxOld){
            vec2.set(worldNormalMax, 0, ty1 < ty2 ? 1 : -1);
        }
    }

    if(tmax >= tmin){
        // Hit point
        vec2.set(
            hitPointWorld,
            rayStart[0] + direction[0] * tmin,
            rayStart[1] + direction[1] * tmin
        );

        vec2.rotate(worldNormalMin, worldNormalMin, angle);

        body.toWorldFrame(hitPointWorld, hitPointWorld);

        this.reportIntersection(worldNormalMin, hitPointWorld, shape, body, -1);
        if(this._shouldStop){
            return;
        }

        vec2.rotate(worldNormalMax, worldNormalMax, angle);

        // Hit point
        vec2.set(
            hitPointWorld,
            rayStart[0] + direction[0] * tmax,
            rayStart[1] + direction[1] * tmax
        );
        body.toWorldFrame(hitPointWorld, hitPointWorld);

        this.reportIntersection(worldNormalMax, hitPointWorld, shape, body, -1);
    }
};
Ray.prototype[Shape.RECTANGLE] = Ray.prototype.intersectRectangle;

var intersectPlane_planePointToFrom = vec2.create();
var intersectPlane_dir_scaled_with_t = vec2.create();
var intersectPlane_hitPointWorld = vec2.create();
var intersectPlane_worldNormal = vec2.create();
var intersectPlane_len = vec2.create();

/**
 * @method intersectPlane
 * @private
 * @param  {Shape} shape
 * @param  {number} angle
 * @param  {array} position
 * @param  {Body} body
 */
Ray.prototype.intersectPlane = function(shape, angle, position, body){
    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    var planePointToFrom = intersectPlane_planePointToFrom;
    var dir_scaled_with_t = intersectPlane_dir_scaled_with_t;
    var hitPointWorld = intersectPlane_hitPointWorld;
    var worldNormal = intersectPlane_worldNormal;
    var len = intersectPlane_len;

    // Get plane normal
    vec2.set(worldNormal, 0, 1);
    vec2.rotate(worldNormal, worldNormal, angle);

    vec2.sub(len, from, position); //from.vsub(position, len);
    var planeToFrom = vec2.dot(len, worldNormal); // len.dot(worldNormal);
    vec2.sub(len, to, position); // to.vsub(position, len);
    var planeToTo = vec2.dot(len, worldNormal); // len.dot(worldNormal);

    if(planeToFrom * planeToTo > 0){
        // "from" and "to" are on the same side of the plane... bail out
        return;
    }

    if(vec2.distance(from, to) /* from.distanceTo(to) */ < planeToFrom){
        return;
    }

    var n_dot_dir = vec2.dot(worldNormal, direction); // worldNormal.dot(direction);

    // if (Math.abs(n_dot_dir) < this.precision) {
    //     // No intersection
    //     return;
    // }

    vec2.sub(planePointToFrom, from, position); // from.vsub(position, planePointToFrom);
    var t = -vec2.dot(worldNormal, planePointToFrom) / n_dot_dir; // - worldNormal.dot(planePointToFrom) / n_dot_dir;
    vec2.scale(dir_scaled_with_t, direction, t); // direction.scale(t, dir_scaled_with_t);
    vec2.add(hitPointWorld, from, dir_scaled_with_t); // from.vadd(dir_scaled_with_t, hitPointWorld);

    this.reportIntersection(worldNormal, hitPointWorld, shape, body, -1);
};
Ray.prototype[Shape.PLANE] = Ray.prototype.intersectPlane;

var Ray_intersectSphere_intersectionPoint = vec2.create();
var Ray_intersectSphere_normal = vec2.create();
Ray.prototype.intersectCircle = function(shape, angle, position, body){
    var from = this.from,
        to = this.to,
        r = shape.radius;

    var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);
    var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));
    var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);

    var delta = Math.pow(b, 2) - 4 * a * c;

    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
    var normal = Ray_intersectSphere_normal;

    if(delta < 0){
        // No intersection
        return;

    } else if(delta === 0){
        // single intersection point
        vec2.lerp(intersectionPoint, from, to, delta); // from.lerp(to, delta, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

    } else {
        var d1 = (- b - Math.sqrt(delta)) / (2 * a);
        var d2 = (- b + Math.sqrt(delta)) / (2 * a);

        vec2.lerp(intersectionPoint, from, to, d1); // from.lerp(to, d1, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

        if(this.result._shouldStop){
            return;
        }

        vec2.lerp(intersectionPoint, from, to, d2); // from.lerp(to, d2, intersectionPoint);

        vec2.sub(normal, intersectionPoint, position); // intersectionPoint.vsub(position, normal);
        vec2.normalize(normal,normal); //normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);
    }
};
Ray.prototype[Shape.CIRCLE] = Ray.prototype.intersectCircle;

/**
 * Get the AABB of the ray.
 * @method getAABB
 * @param  {AABB} aabb
 */
Ray.prototype.getAABB = function(result){
    var to = this.to;
    var from = this.from;
    result.lowerBound[0] = Math.min(to[0], from[0]);
    result.lowerBound[1] = Math.min(to[1], from[1]);
    result.upperBound[0] = Math.max(to[0], from[0]);
    result.upperBound[1] = Math.max(to[1], from[1]);
};

/**
 * @method reportIntersection
 * @private
 * @param  {array} normal
 * @param  {array} hitPointWorld
 * @param  {Shape} shape
 * @param  {Body} body
 * @return {boolean} True if the intersections should continue
 */
Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex){
    var from = this.from;
    var to = this.to;
    var distance = vec2.distance(from, hitPointWorld); // from.distanceTo(hitPointWorld);
    var result = this.result;

    // Skip back faces?
    if(this.skipBackfaces && /* normal.dot(this._direction) */ vec2.dot(normal, this._direction) > 0){
        return;
    }

    result.hitFaceIndex = typeof(hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;

    switch(this.mode){
    case Ray.ALL:
        this.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result.hasHit = true;
        this.callback(result);
        break;

    case Ray.CLOSEST:

        // Store if closer than current closest
        if(distance < result.distance || !result.hasHit){
            this.hasHit = true;
            result.hasHit = true;
            result.set(
                from,
                to,
                normal,
                hitPointWorld,
                shape,
                body,
                distance
            );
        }
        break;

    case Ray.ANY:

        // Report and stop.
        this.hasHit = true;
        result.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result._shouldStop = true;
        break;
    }
};

var v0 = vec2.create(),
    intersect = vec2.create();
function distanceFromIntersection(from, direction, position) {

    // v0 is vector from from to position
    vec2.sub(v0, position, from); // position.vsub(from,v0);
    var dot = vec2.dot(v0, direction); // v0.dot(direction);

    // intersect = direction*dot + from
    vec2.scale(intersect, direction, dot); //direction.mult(dot,intersect);
    vec2.add(intersect, intersect, from); // intersect.vadd(from, intersect);

    var distance = vec2.distance(position, intersect); // position.distanceTo(intersect);

    return distance;
}


},{"../collision/AABB":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/AABB.js","../collision/RaycastResult":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/RaycastResult.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../shapes/Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/RaycastResult.js":[function(require,module,exports){
var vec2 = require('../math/vec2');

module.exports = RaycastResult;

/**
 * Storage for Ray casting data.
 * @class RaycastResult
 * @constructor
 */
function RaycastResult(){

	/**
	 * @property {array} rayFromWorld
	 */
	this.rayFromWorld = vec2.create();

	/**
	 * @property {array} rayToWorld
	 */
	this.rayToWorld = vec2.create();

	/**
	 * @property {array} hitNormalWorld
	 */
	this.hitNormalWorld = vec2.create();

	/**
	 * @property {array} hitPointWorld
	 */
	this.hitPointWorld = vec2.create();

	/**
	 * @property {boolean} hasHit
	 */
	this.hasHit = false;

	/**
	 * The hit shape, or null.
	 * @property {Shape} shape
	 */
	this.shape = null;

	/**
	 * The hit body, or null.
	 * @property {Body} body
	 */
	this.body = null;

	/**
	 * The index of the hit triangle, if the hit shape was a trimesh.
	 * @property {number} hitFaceIndex
	 * @default -1
	 */
	this.hitFaceIndex = -1;

	/**
	 * Distance to the hit. Will be set to -1 if there was no hit.
	 * @property {number} distance
	 * @default -1
	 */
	this.distance = -1;

	/**
	 * If the ray should stop traversing the bodies.
	 * @private
	 * @property {Boolean} _shouldStop
	 * @default false
	 */
	this._shouldStop = false;
}

/**
 * Reset all result data.
 * @method reset
 */
RaycastResult.prototype.reset = function () {
	vec2.set(this.rayFromWorld, 0, 0);
	vec2.set(this.rayToWorld, 0, 0);
	vec2.set(this.hitNormalWorld, 0, 0);
	vec2.set(this.hitPointWorld, 0, 0);
	this.hasHit = false;
	this.shape = null;
	this.body = null;
	this.hitFaceIndex = -1;
	this.distance = -1;
	this._shouldStop = false;
};

/**
 * @method abort
 */
RaycastResult.prototype.abort = function(){
	this._shouldStop = true;
};

/**
 * @method set
 * @param {array} rayFromWorld
 * @param {array} rayToWorld
 * @param {array} hitNormalWorld
 * @param {array} hitPointWorld
 * @param {Shape} shape
 * @param {Body} body
 * @param {number} distance
 */
RaycastResult.prototype.set = function(
	rayFromWorld,
	rayToWorld,
	hitNormalWorld,
	hitPointWorld,
	shape,
	body,
	distance
){
	vec2.copy(this.rayFromWorld, rayFromWorld);
	vec2.copy(this.rayToWorld, rayToWorld);
	vec2.copy(this.hitNormalWorld, hitNormalWorld);
	vec2.copy(this.hitPointWorld, hitPointWorld);
	this.shape = shape;
	this.body = body;
	this.distance = distance;
};
},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/SAPBroadphase.js":[function(require,module,exports){
var Utils = require('../utils/Utils')
,   Broadphase = require('../collision/Broadphase');

module.exports = SAPBroadphase;

/**
 * Sweep and prune broadphase along one axis.
 *
 * @class SAPBroadphase
 * @constructor
 * @extends Broadphase
 */
function SAPBroadphase(){
    Broadphase.call(this,Broadphase.SAP);

    /**
     * List of bodies currently in the broadphase.
     * @property axisList
     * @type {Array}
     */
    this.axisList = [];

    /**
     * The axis to sort along. 0 means x-axis and 1 y-axis. If your bodies are more spread out over the X axis, set axisIndex to 0, and you will gain some performance.
     * @property axisIndex
     * @type {Number}
     */
    this.axisIndex = 0;

    var that = this;
    this._addBodyHandler = function(e){
        that.axisList.push(e.body);
    };

    this._removeBodyHandler = function(e){
        // Remove from list
        var idx = that.axisList.indexOf(e.body);
        if(idx !== -1){
            that.axisList.splice(idx,1);
        }
    };
}
SAPBroadphase.prototype = new Broadphase();
SAPBroadphase.prototype.constructor = SAPBroadphase;

/**
 * Change the world
 * @method setWorld
 * @param {World} world
 */
SAPBroadphase.prototype.setWorld = function(world){
    // Clear the old axis array
    this.axisList.length = 0;

    // Add all bodies from the new world
    Utils.appendArray(this.axisList, world.bodies);

    // Remove old handlers, if any
    world
        .off("addBody",this._addBodyHandler)
        .off("removeBody",this._removeBodyHandler);

    // Add handlers to update the list of bodies.
    world.on("addBody",this._addBodyHandler).on("removeBody",this._removeBodyHandler);

    this.world = world;
};

/**
 * Sorts bodies along an axis.
 * @method sortAxisList
 * @param {Array} a
 * @param {number} axisIndex
 * @return {Array}
 */
SAPBroadphase.sortAxisList = function(a, axisIndex){
    axisIndex = axisIndex|0;
    for(var i=1,l=a.length; i<l; i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

SAPBroadphase.prototype.sortList = function(){
    var bodies = this.axisList,
    axisIndex = this.axisIndex;

    // Sort the lists
    SAPBroadphase.sortAxisList(bodies, axisIndex);
};

/**
 * Get the colliding pairs
 * @method getCollisionPairs
 * @param  {World} world
 * @return {Array}
 */
SAPBroadphase.prototype.getCollisionPairs = function(world){
    var bodies = this.axisList,
        result = this.result,
        axisIndex = this.axisIndex;

    result.length = 0;

    // Update all AABBs if needed
    var l = bodies.length;
    while(l--){
        var b = bodies[l];
        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }
    }

    // Sort the lists
    this.sortList();

    // Look through the X list
    for(var i=0, N=bodies.length|0; i!==N; i++){
        var bi = bodies[i];

        for(var j=i+1; j<N; j++){
            var bj = bodies[j];

            // Bounds overlap?
            var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);
            if(!overlaps){
                break;
            }

            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){
                result.push(bi,bj);
            }
        }
    }

    return result;
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    this.sortList();

    var axisIndex = this.axisIndex;
    var axis = 'x';
    if(axisIndex === 1){ axis = 'y'; }
    if(axisIndex === 2){ axis = 'z'; }

    var axisList = this.axisList;
    var lower = aabb.lowerBound[axis];
    var upper = aabb.upperBound[axis];
    for(var i = 0; i < axisList.length; i++){
        var b = axisList[i];

        if(b.aabbNeedsUpdate){
            b.updateAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/Broadphase.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/Constraint.js":[function(require,module,exports){
module.exports = Constraint;

var Utils = require('../utils/Utils');

/**
 * Base constraint class.
 *
 * @class Constraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} type
 * @param {Object} [options]
 * @param {Object} [options.collideConnected=true]
 */
function Constraint(bodyA, bodyB, type, options){

    /**
     * The type of constraint. May be one of Constraint.DISTANCE, Constraint.GEAR, Constraint.LOCK, Constraint.PRISMATIC or Constraint.REVOLUTE.
     * @property {number} type
     */
    this.type = type;

    options = Utils.defaults(options,{
        collideConnected : true,
        wakeUpBodies : true,
    });

    /**
     * Equations to be solved in this constraint
     *
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * First body participating in the constraint.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second body participating in the constraint.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * Set to true if you want the connected bodies to collide.
     * @property collideConnected
     * @type {Boolean}
     * @default true
     */
    this.collideConnected = options.collideConnected;

    // Wake up bodies when connected
    if(options.wakeUpBodies){
        if(bodyA){
            bodyA.wakeUp();
        }
        if(bodyB){
            bodyB.wakeUp();
        }
    }
}

/**
 * Updates the internal constraint parameters before solve.
 * @method update
 */
Constraint.prototype.update = function(){
    throw new Error("method update() not implmemented in this Constraint subclass!");
};

/**
 * @static
 * @property {number} DISTANCE
 */
Constraint.DISTANCE = 1;

/**
 * @static
 * @property {number} GEAR
 */
Constraint.GEAR = 2;

/**
 * @static
 * @property {number} LOCK
 */
Constraint.LOCK = 3;

/**
 * @static
 * @property {number} PRISMATIC
 */
Constraint.PRISMATIC = 4;

/**
 * @static
 * @property {number} REVOLUTE
 */
Constraint.REVOLUTE = 5;

/**
 * Set stiffness for this constraint.
 * @method setStiffness
 * @param {Number} stiffness
 */
Constraint.prototype.setStiffness = function(stiffness){
    var eqs = this.equations;
    for(var i=0; i !== eqs.length; i++){
        var eq = eqs[i];
        eq.stiffness = stiffness;
        eq.needsUpdate = true;
    }
};

/**
 * Set relaxation for this constraint.
 * @method setRelaxation
 * @param {Number} relaxation
 */
Constraint.prototype.setRelaxation = function(relaxation){
    var eqs = this.equations;
    for(var i=0; i !== eqs.length; i++){
        var eq = eqs[i];
        eq.relaxation = relaxation;
        eq.needsUpdate = true;
    }
};

},{"../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/DistanceConstraint.js":[function(require,module,exports){
var Constraint = require('./Constraint')
,   Equation = require('../equations/Equation')
,   vec2 = require('../math/vec2')
,   Utils = require('../utils/Utils');

module.exports = DistanceConstraint;

/**
 * Constraint that tries to keep the distance between two bodies constant.
 *
 * @class DistanceConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.
 * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].
 * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].
 * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.
 * @extends Constraint
 *
 * @example
 *     // If distance is not given as an option, then the current distance between the bodies is used.
 *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new DistanceConstraint(bodyA, bodyB);
 *
 * @example
 *     var constraint = new DistanceConstraint(bodyA, bodyB, {
 *         distance: 1,          // Distance to keep between the points
 *         localAnchorA: [1, 0], // Point on bodyA
 *         localAnchorB: [-1, 0] // Point on bodyB
 *     });
 */
function DistanceConstraint(bodyA,bodyB,options){
    options = Utils.defaults(options,{
        localAnchorA:[0,0],
        localAnchorB:[0,0]
    });

    Constraint.call(this,bodyA,bodyB,Constraint.DISTANCE,options);

    /**
     * Local anchor in body A.
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);

    /**
     * Local anchor in body B.
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);

    var localAnchorA = this.localAnchorA;
    var localAnchorB = this.localAnchorB;

    /**
     * The distance to keep.
     * @property distance
     * @type {Number}
     */
    this.distance = 0;

    if(typeof(options.distance) === 'number'){
        this.distance = options.distance;
    } else {
        // Use the current world distance between the world anchor points.
        var worldAnchorA = vec2.create(),
            worldAnchorB = vec2.create(),
            r = vec2.create();

        // Transform local anchors to world
        vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);
        vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);

        vec2.add(r, bodyB.position, worldAnchorB);
        vec2.sub(r, r, worldAnchorA);
        vec2.sub(r, r, bodyA.position);

        this.distance = vec2.length(r);
    }

    var maxForce;
    if(typeof(options.maxForce)==="undefined" ){
        maxForce = Number.MAX_VALUE;
    } else {
        maxForce = options.maxForce;
    }

    var normal = new Equation(bodyA,bodyB,-maxForce,maxForce); // Just in the normal direction
    this.equations = [ normal ];

    /**
     * Max force to apply.
     * @property {number} maxForce
     */
    this.maxForce = maxForce;

    // g = (xi - xj).dot(n)
    // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'

    // ...and if we were to include offset points (TODO for now):
    // g =
    //      (xj + rj - xi - ri).dot(n) - distance
    //
    // dg/dt =
    //      (vj + wj x rj - vi - wi x ri).dot(n) =
    //      { term 2 is near zero } =
    //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =
    //      G * W
    //
    // => G = [-n -rixn n rjxn]

    var r = vec2.create();
    var ri = vec2.create(); // worldAnchorA
    var rj = vec2.create(); // worldAnchorB
    var that = this;
    normal.computeGq = function(){
        var bodyA = this.bodyA,
            bodyB = this.bodyB,
            xi = bodyA.position,
            xj = bodyB.position;

        // Transform local anchors to world
        vec2.rotate(ri, localAnchorA, bodyA.angle);
        vec2.rotate(rj, localAnchorB, bodyB.angle);

        vec2.add(r, xj, rj);
        vec2.sub(r, r, ri);
        vec2.sub(r, r, xi);

        //vec2.sub(r, bodyB.position, bodyA.position);
        return vec2.length(r) - that.distance;
    };

    // Make the contact constraint bilateral
    this.setMaxForce(maxForce);

    /**
     * If the upper limit is enabled or not.
     * @property {Boolean} upperLimitEnabled
     */
    this.upperLimitEnabled = false;

    /**
     * The upper constraint limit.
     * @property {number} upperLimit
     */
    this.upperLimit = 1;

    /**
     * If the lower limit is enabled or not.
     * @property {Boolean} lowerLimitEnabled
     */
    this.lowerLimitEnabled = false;

    /**
     * The lower constraint limit.
     * @property {number} lowerLimit
     */
    this.lowerLimit = 0;

    /**
     * Current constraint position. This is equal to the current distance between the world anchor points.
     * @property {number} position
     */
    this.position = 0;
}
DistanceConstraint.prototype = new Constraint();
DistanceConstraint.prototype.constructor = DistanceConstraint;

/**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */
var n = vec2.create();
var ri = vec2.create(); // worldAnchorA
var rj = vec2.create(); // worldAnchorB
DistanceConstraint.prototype.update = function(){
    var normal = this.equations[0],
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        distance = this.distance,
        xi = bodyA.position,
        xj = bodyB.position,
        normalEquation = this.equations[0],
        G = normal.G;

    // Transform local anchors to world
    vec2.rotate(ri, this.localAnchorA, bodyA.angle);
    vec2.rotate(rj, this.localAnchorB, bodyB.angle);

    // Get world anchor points and normal
    vec2.add(n, xj, rj);
    vec2.sub(n, n, ri);
    vec2.sub(n, n, xi);
    this.position = vec2.length(n);

    var violating = false;
    if(this.upperLimitEnabled){
        if(this.position > this.upperLimit){
            normalEquation.maxForce = 0;
            normalEquation.minForce = -this.maxForce;
            this.distance = this.upperLimit;
            violating = true;
        }
    }

    if(this.lowerLimitEnabled){
        if(this.position < this.lowerLimit){
            normalEquation.maxForce = this.maxForce;
            normalEquation.minForce = 0;
            this.distance = this.lowerLimit;
            violating = true;
        }
    }

    if((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating){
        // No constraint needed.
        normalEquation.enabled = false;
        return;
    }

    normalEquation.enabled = true;

    vec2.normalize(n,n);

    // Caluclate cross products
    var rixn = vec2.crossLength(ri, n),
        rjxn = vec2.crossLength(rj, n);

    // G = [-n -rixn n rjxn]
    G[0] = -n[0];
    G[1] = -n[1];
    G[2] = -rixn;
    G[3] = n[0];
    G[4] = n[1];
    G[5] = rjxn;
};

/**
 * Set the max force to be used
 * @method setMaxForce
 * @param {Number} f
 */
DistanceConstraint.prototype.setMaxForce = function(f){
    var normal = this.equations[0];
    normal.minForce = -f;
    normal.maxForce =  f;
};

/**
 * Get the max force
 * @method getMaxForce
 * @return {Number}
 */
DistanceConstraint.prototype.getMaxForce = function(f){
    var normal = this.equations[0];
    return normal.maxForce;
};

},{"../equations/Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js","./Constraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/Constraint.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/GearConstraint.js":[function(require,module,exports){
var Constraint = require('./Constraint')
,   Equation = require('../equations/Equation')
,   AngleLockEquation = require('../equations/AngleLockEquation')
,   vec2 = require('../math/vec2');

module.exports = GearConstraint;

/**
 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
 * @class GearConstraint
 * @constructor
 * @author schteppe
 * @param {Body}            bodyA
 * @param {Body}            bodyB
 * @param {Object}          [options]
 * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).
 * @param {Number}          [options.ratio=1] Gear ratio.
 * @param {Number}          [options.maxTorque] Maximum torque to apply.
 * @extends Constraint
 * @todo Ability to specify world points
 */
function GearConstraint(bodyA, bodyB, options){
    options = options || {};

    Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);

    /**
     * The gear ratio.
     * @property ratio
     * @type {Number}
     */
    this.ratio = typeof(options.ratio) === "number" ? options.ratio : 1;

    /**
     * The relative angle
     * @property angle
     * @type {Number}
     */
    this.angle = typeof(options.angle) === "number" ? options.angle : bodyB.angle - this.ratio * bodyA.angle;

    // Send same parameters to the equation
    options.angle = this.angle;
    options.ratio = this.ratio;

    this.equations = [
        new AngleLockEquation(bodyA,bodyB,options),
    ];

    // Set max torque
    if(typeof(options.maxTorque) === "number"){
        this.setMaxTorque(options.maxTorque);
    }
}
GearConstraint.prototype = new Constraint();
GearConstraint.prototype.constructor = GearConstraint;

GearConstraint.prototype.update = function(){
    var eq = this.equations[0];
    if(eq.ratio !== this.ratio){
        eq.setRatio(this.ratio);
    }
    eq.angle = this.angle;
};

/**
 * Set the max torque for the constraint.
 * @method setMaxTorque
 * @param {Number} torque
 */
GearConstraint.prototype.setMaxTorque = function(torque){
    this.equations[0].setMaxTorque(torque);
};

/**
 * Get the max torque for the constraint.
 * @method getMaxTorque
 * @return {Number}
 */
GearConstraint.prototype.getMaxTorque = function(torque){
    return this.equations[0].maxForce;
};
},{"../equations/AngleLockEquation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/AngleLockEquation.js","../equations/Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Constraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/Constraint.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/LockConstraint.js":[function(require,module,exports){
var Constraint = require('./Constraint')
,   vec2 = require('../math/vec2')
,   Equation = require('../equations/Equation');

module.exports = LockConstraint;

/**
 * Locks the relative position between two bodies.
 *
 * @class LockConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.
 * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.
 * @param {number} [options.maxForce]
 * @extends Constraint
 */
function LockConstraint(bodyA, bodyB, options){
    options = options || {};

    Constraint.call(this,bodyA,bodyB,Constraint.LOCK,options);

    var maxForce = ( typeof(options.maxForce)==="undefined" ? Number.MAX_VALUE : options.maxForce );

    var localAngleB = options.localAngleB || 0;

    // Use 3 equations:
    // gx =   (xj - xi - l) * xhat = 0
    // gy =   (xj - xi - l) * yhat = 0
    // gr =   (xi - xj + r) * that = 0
    //
    // ...where:
    //   l is the localOffsetB vector rotated to world in bodyA frame
    //   r is the same vector but reversed and rotated from bodyB frame
    //   xhat, yhat are world axis vectors
    //   that is the tangent of r
    //
    // For the first two constraints, we get
    // G*W = (vj - vi - ldot  ) * xhat
    //     = (vj - vi - wi x l) * xhat
    //
    // Since (wi x l) * xhat = (l x xhat) * wi, we get
    // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]
    //
    // The last constraint gives
    // GW = (vi - vj + wj x r) * that
    //    = [  that   0  -that  (r x t) ]

    var x =     new Equation(bodyA,bodyB,-maxForce,maxForce),
        y =     new Equation(bodyA,bodyB,-maxForce,maxForce),
        rot =   new Equation(bodyA,bodyB,-maxForce,maxForce);

    var l = vec2.create(),
        g = vec2.create(),
        that = this;
    x.computeGq = function(){
        vec2.rotate(l, that.localOffsetB, bodyA.angle);
        vec2.sub(g, bodyB.position, bodyA.position);
        vec2.sub(g, g, l);
        return g[0];
    };
    y.computeGq = function(){
        vec2.rotate(l, that.localOffsetB, bodyA.angle);
        vec2.sub(g, bodyB.position, bodyA.position);
        vec2.sub(g, g, l);
        return g[1];
    };
    var r = vec2.create(),
        t = vec2.create();
    rot.computeGq = function(){
        vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);
        vec2.scale(r,r,-1);
        vec2.sub(g,bodyA.position,bodyB.position);
        vec2.add(g,g,r);
        vec2.rotate(t,r,-Math.PI/2);
        vec2.normalize(t,t);
        return vec2.dot(g,t);
    };

    /**
     * The offset of bodyB in bodyA's frame.
     * @property {Array} localOffsetB
     */
    this.localOffsetB = vec2.create();
    if(options.localOffsetB){
        vec2.copy(this.localOffsetB, options.localOffsetB);
    } else {
        // Construct from current positions
        vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);
        vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);
    }

    /**
     * The offset angle of bodyB in bodyA's frame.
     * @property {Number} localAngleB
     */
    this.localAngleB = 0;
    if(typeof(options.localAngleB) === 'number'){
        this.localAngleB = options.localAngleB;
    } else {
        // Construct
        this.localAngleB = bodyB.angle - bodyA.angle;
    }

    this.equations.push(x, y, rot);
    this.setMaxForce(maxForce);
}
LockConstraint.prototype = new Constraint();
LockConstraint.prototype.constructor = LockConstraint;

/**
 * Set the maximum force to be applied.
 * @method setMaxForce
 * @param {Number} force
 */
LockConstraint.prototype.setMaxForce = function(force){
    var eqs = this.equations;
    for(var i=0; i<this.equations.length; i++){
        eqs[i].maxForce =  force;
        eqs[i].minForce = -force;
    }
};

/**
 * Get the max force.
 * @method getMaxForce
 * @return {Number}
 */
LockConstraint.prototype.getMaxForce = function(){
    return this.equations[0].maxForce;
};

var l = vec2.create();
var r = vec2.create();
var t = vec2.create();
var xAxis = vec2.fromValues(1,0);
var yAxis = vec2.fromValues(0,1);
LockConstraint.prototype.update = function(){
    var x =   this.equations[0],
        y =   this.equations[1],
        rot = this.equations[2],
        bodyA = this.bodyA,
        bodyB = this.bodyB;

    vec2.rotate(l,this.localOffsetB,bodyA.angle);
    vec2.rotate(r,this.localOffsetB,bodyB.angle - this.localAngleB);
    vec2.scale(r,r,-1);

    vec2.rotate(t,r,Math.PI/2);
    vec2.normalize(t,t);

    x.G[0] = -1;
    x.G[1] =  0;
    x.G[2] = -vec2.crossLength(l,xAxis);
    x.G[3] =  1;

    y.G[0] =  0;
    y.G[1] = -1;
    y.G[2] = -vec2.crossLength(l,yAxis);
    y.G[4] =  1;

    rot.G[0] =  -t[0];
    rot.G[1] =  -t[1];
    rot.G[3] =  t[0];
    rot.G[4] =  t[1];
    rot.G[5] =  vec2.crossLength(r,t);
};

},{"../equations/Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Constraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/Constraint.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/PrismaticConstraint.js":[function(require,module,exports){
var Constraint = require('./Constraint')
,   ContactEquation = require('../equations/ContactEquation')
,   Equation = require('../equations/Equation')
,   vec2 = require('../math/vec2')
,   RotationalLockEquation = require('../equations/RotationalLockEquation');

module.exports = PrismaticConstraint;

/**
 * Constraint that only allows bodies to move along a line, relative to each other. See <a href="http://www.iforce2d.net/b2dtut/joints-prismatic">this tutorial</a>.
 *
 * @class PrismaticConstraint
 * @constructor
 * @extends Constraint
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Number}  [options.maxForce]                Max force to be applied by the constraint
 * @param {Array}   [options.localAnchorA]            Body A's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAnchorB]            Body B's anchor point, defined in its own local frame.
 * @param {Array}   [options.localAxisA]              An axis, defined in body A frame, that body B's anchor point may slide along.
 * @param {Boolean} [options.disableRotationalLock]   If set to true, bodyB will be free to rotate around its anchor point.
 * @param {Number}  [options.upperLimit]
 * @param {Number}  [options.lowerLimit]
 * @todo Ability to create using only a point and a worldAxis
 */
function PrismaticConstraint(bodyA, bodyB, options){
    options = options || {};
    Constraint.call(this,bodyA,bodyB,Constraint.PRISMATIC,options);

    // Get anchors
    var localAnchorA = vec2.fromValues(0,0),
        localAxisA = vec2.fromValues(1,0),
        localAnchorB = vec2.fromValues(0,0);
    if(options.localAnchorA){ vec2.copy(localAnchorA, options.localAnchorA); }
    if(options.localAxisA){ vec2.copy(localAxisA,   options.localAxisA); }
    if(options.localAnchorB){ vec2.copy(localAnchorB, options.localAnchorB); }

    /**
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = localAnchorA;

    /**
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = localAnchorB;

    /**
     * @property localAxisA
     * @type {Array}
     */
    this.localAxisA = localAxisA;

    /*

    The constraint violation for the common axis point is

        g = ( xj + rj - xi - ri ) * t   :=  gg*t

    where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.

        gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )

    Note the use of the chain rule. Now we identify the jacobian

        G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]

    The rotational part is just a rotation lock.

     */

    var maxForce = this.maxForce = typeof(options.maxForce)!=="undefined" ? options.maxForce : Number.MAX_VALUE;

    // Translational part
    var trans = new Equation(bodyA,bodyB,-maxForce,maxForce);
    var ri = new vec2.create(),
        rj = new vec2.create(),
        gg = new vec2.create(),
        t =  new vec2.create();
    trans.computeGq = function(){
        // g = ( xj + rj - xi - ri ) * t
        return vec2.dot(gg,t);
    };
    trans.updateJacobian = function(){
        var G = this.G,
            xi = bodyA.position,
            xj = bodyB.position;
        vec2.rotate(ri,localAnchorA,bodyA.angle);
        vec2.rotate(rj,localAnchorB,bodyB.angle);
        vec2.add(gg,xj,rj);
        vec2.sub(gg,gg,xi);
        vec2.sub(gg,gg,ri);
        vec2.rotate(t,localAxisA,bodyA.angle+Math.PI/2);

        G[0] = -t[0];
        G[1] = -t[1];
        G[2] = -vec2.crossLength(ri,t) + vec2.crossLength(t,gg);
        G[3] = t[0];
        G[4] = t[1];
        G[5] = vec2.crossLength(rj,t);
    };
    this.equations.push(trans);

    // Rotational part
    if(!options.disableRotationalLock){
        var rot = new RotationalLockEquation(bodyA,bodyB,-maxForce,maxForce);
        this.equations.push(rot);
    }

    /**
     * The position of anchor A relative to anchor B, along the constraint axis.
     * @property position
     * @type {Number}
     */
    this.position = 0;

    // Is this one used at all?
    this.velocity = 0;

    /**
     * Set to true to enable lower limit.
     * @property lowerLimitEnabled
     * @type {Boolean}
     */
    this.lowerLimitEnabled = typeof(options.lowerLimit)!=="undefined" ? true : false;

    /**
     * Set to true to enable upper limit.
     * @property upperLimitEnabled
     * @type {Boolean}
     */
    this.upperLimitEnabled = typeof(options.upperLimit)!=="undefined" ? true : false;

    /**
     * Lower constraint limit. The constraint position is forced to be larger than this value.
     * @property lowerLimit
     * @type {Number}
     */
    this.lowerLimit = typeof(options.lowerLimit)!=="undefined" ? options.lowerLimit : 0;

    /**
     * Upper constraint limit. The constraint position is forced to be smaller than this value.
     * @property upperLimit
     * @type {Number}
     */
    this.upperLimit = typeof(options.upperLimit)!=="undefined" ? options.upperLimit : 1;

    // Equations used for limits
    this.upperLimitEquation = new ContactEquation(bodyA,bodyB);
    this.lowerLimitEquation = new ContactEquation(bodyA,bodyB);

    // Set max/min forces
    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;

    /**
     * Equation used for the motor.
     * @property motorEquation
     * @type {Equation}
     */
    this.motorEquation = new Equation(bodyA,bodyB);

    /**
     * The current motor state. Enable or disable the motor using .enableMotor
     * @property motorEnabled
     * @type {Boolean}
     */
    this.motorEnabled = false;

    /**
     * Set the target speed for the motor.
     * @property motorSpeed
     * @type {Number}
     */
    this.motorSpeed = 0;

    var that = this;
    var motorEquation = this.motorEquation;
    var old = motorEquation.computeGW;
    motorEquation.computeGq = function(){ return 0; };
    motorEquation.computeGW = function(){
        var G = this.G,
            bi = this.bodyA,
            bj = this.bodyB,
            vi = bi.velocity,
            vj = bj.velocity,
            wi = bi.angularVelocity,
            wj = bj.angularVelocity;
        return this.gmult(G,vi,wi,vj,wj) + that.motorSpeed;
    };
}

PrismaticConstraint.prototype = new Constraint();
PrismaticConstraint.prototype.constructor = PrismaticConstraint;

var worldAxisA = vec2.create(),
    worldAnchorA = vec2.create(),
    worldAnchorB = vec2.create(),
    orientedAnchorA = vec2.create(),
    orientedAnchorB = vec2.create(),
    tmp = vec2.create();

/**
 * Update the constraint equations. Should be done if any of the bodies changed position, before solving.
 * @method update
 */
PrismaticConstraint.prototype.update = function(){
    var eqs = this.equations,
        trans = eqs[0],
        upperLimit = this.upperLimit,
        lowerLimit = this.lowerLimit,
        upperLimitEquation = this.upperLimitEquation,
        lowerLimitEquation = this.lowerLimitEquation,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        localAxisA = this.localAxisA,
        localAnchorA = this.localAnchorA,
        localAnchorB = this.localAnchorB;

    trans.updateJacobian();

    // Transform local things to world
    vec2.rotate(worldAxisA,      localAxisA,      bodyA.angle);
    vec2.rotate(orientedAnchorA, localAnchorA,    bodyA.angle);
    vec2.add(worldAnchorA,       orientedAnchorA, bodyA.position);
    vec2.rotate(orientedAnchorB, localAnchorB,    bodyB.angle);
    vec2.add(worldAnchorB,       orientedAnchorB, bodyB.position);

    var relPosition = this.position = vec2.dot(worldAnchorB,worldAxisA) - vec2.dot(worldAnchorA,worldAxisA);

    // Motor
    if(this.motorEnabled){
        // G = [ a     a x ri   -a   -a x rj ]
        var G = this.motorEquation.G;
        G[0] = worldAxisA[0];
        G[1] = worldAxisA[1];
        G[2] = vec2.crossLength(worldAxisA,orientedAnchorB);
        G[3] = -worldAxisA[0];
        G[4] = -worldAxisA[1];
        G[5] = -vec2.crossLength(worldAxisA,orientedAnchorA);
    }

    /*
        Limits strategy:
        Add contact equation, with normal along the constraint axis.
        min/maxForce is set so the constraint is repulsive in the correct direction.
        Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.

                 ^
                 |
      upperLimit x
                 |    ------
         anchorB x<---|  B |
                 |    |    |
        ------   |    ------
        |    |   |
        |  A |-->x anchorA
        ------   |
                 x lowerLimit
                 |
                axis
     */


    if(this.upperLimitEnabled && relPosition > upperLimit){
        // Update contact constraint normal, etc
        vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);
        vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);
        vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);
        vec2.scale(tmp,worldAxisA,upperLimit);
        vec2.add(upperLimitEquation.contactPointA,upperLimitEquation.contactPointA,tmp);
        if(eqs.indexOf(upperLimitEquation) === -1){
            eqs.push(upperLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(upperLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    if(this.lowerLimitEnabled && relPosition < lowerLimit){
        // Update contact constraint normal, etc
        vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);
        vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);
        vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);
        vec2.scale(tmp,worldAxisA,lowerLimit);
        vec2.sub(lowerLimitEquation.contactPointB,lowerLimitEquation.contactPointB,tmp);
        if(eqs.indexOf(lowerLimitEquation) === -1){
            eqs.push(lowerLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(lowerLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }
};

/**
 * Enable the motor
 * @method enableMotor
 */
PrismaticConstraint.prototype.enableMotor = function(){
    if(this.motorEnabled){
        return;
    }
    this.equations.push(this.motorEquation);
    this.motorEnabled = true;
};

/**
 * Disable the rotational motor
 * @method disableMotor
 */
PrismaticConstraint.prototype.disableMotor = function(){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations.splice(i,1);
    this.motorEnabled = false;
};

/**
 * Set the constraint limits.
 * @method setLimits
 * @param {number} lower Lower limit.
 * @param {number} upper Upper limit.
 */
PrismaticConstraint.prototype.setLimits = function (lower, upper) {
    if(typeof(lower) === 'number'){
        this.lowerLimit = lower;
        this.lowerLimitEnabled = true;
    } else {
        this.lowerLimit = lower;
        this.lowerLimitEnabled = false;
    }

    if(typeof(upper) === 'number'){
        this.upperLimit = upper;
        this.upperLimitEnabled = true;
    } else {
        this.upperLimit = upper;
        this.upperLimitEnabled = false;
    }
};


},{"../equations/ContactEquation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/ContactEquation.js","../equations/Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js","../equations/RotationalLockEquation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/RotationalLockEquation.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Constraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/Constraint.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/RevoluteConstraint.js":[function(require,module,exports){
var Constraint = require('./Constraint')
,   Equation = require('../equations/Equation')
,   RotationalVelocityEquation = require('../equations/RotationalVelocityEquation')
,   RotationalLockEquation = require('../equations/RotationalLockEquation')
,   vec2 = require('../math/vec2');

module.exports = RevoluteConstraint;

var worldPivotA = vec2.create(),
    worldPivotB = vec2.create(),
    xAxis = vec2.fromValues(1,0),
    yAxis = vec2.fromValues(0,1),
    g = vec2.create();

/**
 * Connects two bodies at given offset points, letting them rotate relative to each other around this point.
 * @class RevoluteConstraint
 * @constructor
 * @author schteppe
 * @param {Body}    bodyA
 * @param {Body}    bodyB
 * @param {Object}  [options]
 * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.
 * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.
 * @param {Array}   [options.localPivotB] See localPivotA.
 * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.
 * @extends Constraint
 *
 * @example
 *     // This will create a revolute constraint between two bodies with pivot point in between them.
 *     var bodyA = new Body({ mass: 1, position: [-1, 0] });
 *     var bodyB = new Body({ mass: 1, position: [1, 0] });
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         worldPivot: [0, 0]
 *     });
 *     world.addConstraint(constraint);
 *
 *     // Using body-local pivot points, the constraint could have been constructed like this:
 *     var constraint = new RevoluteConstraint(bodyA, bodyB, {
 *         localPivotA: [1, 0],
 *         localPivotB: [-1, 0]
 *     });
 */
function RevoluteConstraint(bodyA, bodyB, options){
    options = options || {};
    Constraint.call(this,bodyA,bodyB,Constraint.REVOLUTE,options);

    var maxForce = this.maxForce = typeof(options.maxForce) !== "undefined" ? options.maxForce : Number.MAX_VALUE;

    /**
     * @property {Array} pivotA
     */
    this.pivotA = vec2.create();

    /**
     * @property {Array} pivotB
     */
    this.pivotB = vec2.create();

    if(options.worldPivot){
        // Compute pivotA and pivotB
        vec2.sub(this.pivotA, options.worldPivot, bodyA.position);
        vec2.sub(this.pivotB, options.worldPivot, bodyB.position);
        // Rotate to local coordinate system
        vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);
        vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);
    } else {
        // Get pivotA and pivotB
        vec2.copy(this.pivotA, options.localPivotA);
        vec2.copy(this.pivotB, options.localPivotB);
    }

    // Equations to be fed to the solver
    var eqs = this.equations = [
        new Equation(bodyA,bodyB,-maxForce,maxForce),
        new Equation(bodyA,bodyB,-maxForce,maxForce),
    ];

    var x = eqs[0];
    var y = eqs[1];
    var that = this;

    x.computeGq = function(){
        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
        vec2.add(g, bodyB.position, worldPivotB);
        vec2.sub(g, g, bodyA.position);
        vec2.sub(g, g, worldPivotA);
        return vec2.dot(g,xAxis);
    };

    y.computeGq = function(){
        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);
        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);
        vec2.add(g, bodyB.position, worldPivotB);
        vec2.sub(g, g, bodyA.position);
        vec2.sub(g, g, worldPivotA);
        return vec2.dot(g,yAxis);
    };

    y.minForce = x.minForce = -maxForce;
    y.maxForce = x.maxForce =  maxForce;

    this.motorEquation = new RotationalVelocityEquation(bodyA,bodyB);

    /**
     * Indicates whether the motor is enabled. Use .enableMotor() to enable the constraint motor.
     * @property {Boolean} motorEnabled
     * @readOnly
     */
    this.motorEnabled = false;

    /**
     * The constraint position.
     * @property angle
     * @type {Number}
     * @readOnly
     */
    this.angle = 0;

    /**
     * Set to true to enable lower limit
     * @property lowerLimitEnabled
     * @type {Boolean}
     */
    this.lowerLimitEnabled = false;

    /**
     * Set to true to enable upper limit
     * @property upperLimitEnabled
     * @type {Boolean}
     */
    this.upperLimitEnabled = false;

    /**
     * The lower limit on the constraint angle.
     * @property lowerLimit
     * @type {Boolean}
     */
    this.lowerLimit = 0;

    /**
     * The upper limit on the constraint angle.
     * @property upperLimit
     * @type {Boolean}
     */
    this.upperLimit = 0;

    this.upperLimitEquation = new RotationalLockEquation(bodyA,bodyB);
    this.lowerLimitEquation = new RotationalLockEquation(bodyA,bodyB);
    this.upperLimitEquation.minForce = 0;
    this.lowerLimitEquation.maxForce = 0;
}
RevoluteConstraint.prototype = new Constraint();
RevoluteConstraint.prototype.constructor = RevoluteConstraint;

/**
 * Set the constraint angle limits.
 * @method setLimits
 * @param {number} lower Lower angle limit.
 * @param {number} upper Upper angle limit.
 */
RevoluteConstraint.prototype.setLimits = function (lower, upper) {
    if(typeof(lower) === 'number'){
        this.lowerLimit = lower;
        this.lowerLimitEnabled = true;
    } else {
        this.lowerLimit = lower;
        this.lowerLimitEnabled = false;
    }

    if(typeof(upper) === 'number'){
        this.upperLimit = upper;
        this.upperLimitEnabled = true;
    } else {
        this.upperLimit = upper;
        this.upperLimitEnabled = false;
    }
};

RevoluteConstraint.prototype.update = function(){
    var bodyA =  this.bodyA,
        bodyB =  this.bodyB,
        pivotA = this.pivotA,
        pivotB = this.pivotB,
        eqs =    this.equations,
        normal = eqs[0],
        tangent= eqs[1],
        x = eqs[0],
        y = eqs[1],
        upperLimit = this.upperLimit,
        lowerLimit = this.lowerLimit,
        upperLimitEquation = this.upperLimitEquation,
        lowerLimitEquation = this.lowerLimitEquation;

    var relAngle = this.angle = bodyB.angle - bodyA.angle;

    if(this.upperLimitEnabled && relAngle > upperLimit){
        upperLimitEquation.angle = upperLimit;
        if(eqs.indexOf(upperLimitEquation) === -1){
            eqs.push(upperLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(upperLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    if(this.lowerLimitEnabled && relAngle < lowerLimit){
        lowerLimitEquation.angle = lowerLimit;
        if(eqs.indexOf(lowerLimitEquation) === -1){
            eqs.push(lowerLimitEquation);
        }
    } else {
        var idx = eqs.indexOf(lowerLimitEquation);
        if(idx !== -1){
            eqs.splice(idx,1);
        }
    }

    /*

    The constraint violation is

        g = xj + rj - xi - ri

    ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:

        gdot = vj + wj x rj - vi - wi x ri

    We split this into x and y directions. (let x and y be unit vectors along the respective axes)

        gdot * x = ( vj + wj x rj - vi - wi x ri ) * x
                 = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x
                 = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi
                 = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]
                 = G*W

    ...and similar for y. We have then identified the jacobian entries for x and y directions:

        Gx = [ x   (rj x x)   -x   -(ri x x)]
        Gy = [ y   (rj x y)   -y   -(ri x y)]

     */

    vec2.rotate(worldPivotA, pivotA, bodyA.angle);
    vec2.rotate(worldPivotB, pivotB, bodyB.angle);

    // todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc

    x.G[0] = -1;
    x.G[1] =  0;
    x.G[2] = -vec2.crossLength(worldPivotA,xAxis);
    x.G[3] =  1;
    x.G[4] =  0;
    x.G[5] =  vec2.crossLength(worldPivotB,xAxis);

    y.G[0] =  0;
    y.G[1] = -1;
    y.G[2] = -vec2.crossLength(worldPivotA,yAxis);
    y.G[3] =  0;
    y.G[4] =  1;
    y.G[5] =  vec2.crossLength(worldPivotB,yAxis);
};

/**
 * Enable the rotational motor
 * @method enableMotor
 */
RevoluteConstraint.prototype.enableMotor = function(){
    if(this.motorEnabled){
        return;
    }
    this.equations.push(this.motorEquation);
    this.motorEnabled = true;
};

/**
 * Disable the rotational motor
 * @method disableMotor
 */
RevoluteConstraint.prototype.disableMotor = function(){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations.splice(i,1);
    this.motorEnabled = false;
};

/**
 * Check if the motor is enabled.
 * @method motorIsEnabled
 * @deprecated use property motorEnabled instead.
 * @return {Boolean}
 */
RevoluteConstraint.prototype.motorIsEnabled = function(){
    return !!this.motorEnabled;
};

/**
 * Set the speed of the rotational constraint motor
 * @method setMotorSpeed
 * @param  {Number} speed
 */
RevoluteConstraint.prototype.setMotorSpeed = function(speed){
    if(!this.motorEnabled){
        return;
    }
    var i = this.equations.indexOf(this.motorEquation);
    this.equations[i].relativeVelocity = speed;
};

/**
 * Get the speed of the rotational constraint motor
 * @method getMotorSpeed
 * @return {Number} The current speed, or false if the motor is not enabled.
 */
RevoluteConstraint.prototype.getMotorSpeed = function(){
    if(!this.motorEnabled){
        return false;
    }
    return this.motorEquation.relativeVelocity;
};

},{"../equations/Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js","../equations/RotationalLockEquation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/RotationalLockEquation.js","../equations/RotationalVelocityEquation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/RotationalVelocityEquation.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Constraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/Constraint.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/AngleLockEquation.js":[function(require,module,exports){
var Equation = require("./Equation"),
    vec2 = require('../math/vec2');

module.exports = AngleLockEquation;

/**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class AngleLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in body A.
 * @param {Number} [options.ratio] Gear ratio
 */
function AngleLockEquation(bodyA, bodyB, options){
    options = options || {};
    Equation.call(this,bodyA,bodyB,-Number.MAX_VALUE,Number.MAX_VALUE);
    this.angle = options.angle || 0;

    /**
     * The gear ratio.
     * @property {Number} ratio
     * @private
     * @see setRatio
     */
    this.ratio = typeof(options.ratio)==="number" ? options.ratio : 1;

    this.setRatio(this.ratio);
}
AngleLockEquation.prototype = new Equation();
AngleLockEquation.prototype.constructor = AngleLockEquation;

AngleLockEquation.prototype.computeGq = function(){
    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
};

/**
 * Set the gear ratio for this equation
 * @method setRatio
 * @param {Number} ratio
 */
AngleLockEquation.prototype.setRatio = function(ratio){
    var G = this.G;
    G[2] =  ratio;
    G[5] = -1;
    this.ratio = ratio;
};

/**
 * Set the max force for the equation.
 * @method setMaxTorque
 * @param {Number} torque
 */
AngleLockEquation.prototype.setMaxTorque = function(torque){
    this.maxForce =  torque;
    this.minForce = -torque;
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/ContactEquation.js":[function(require,module,exports){
var Equation = require("./Equation"),
    vec2 = require('../math/vec2');

module.exports = ContactEquation;

/**
 * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.
 *
 * @class ContactEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function ContactEquation(bodyA, bodyB){
    Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);

    /**
     * Vector from body i center of mass to the contact point.
     * @property contactPointA
     * @type {Array}
     */
    this.contactPointA = vec2.create();
    this.penetrationVec = vec2.create();

    /**
     * World-oriented vector from body A center of mass to the contact point.
     * @property contactPointB
     * @type {Array}
     */
    this.contactPointB = vec2.create();

    /**
     * The normal vector, pointing out of body i
     * @property normalA
     * @type {Array}
     */
    this.normalA = vec2.create();

    /**
     * The restitution to use (0=no bounciness, 1=max bounciness).
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0;

    /**
     * This property is set to true if this is the first impact between the bodies (not persistant contact).
     * @property firstImpact
     * @type {Boolean}
     * @readOnly
     */
    this.firstImpact = false;

    /**
     * The shape in body i that triggered this contact.
     * @property shapeA
     * @type {Shape}
     */
    this.shapeA = null;

    /**
     * The shape in body j that triggered this contact.
     * @property shapeB
     * @type {Shape}
     */
    this.shapeB = null;
}
ContactEquation.prototype = new Equation();
ContactEquation.prototype.constructor = ContactEquation;
ContactEquation.prototype.computeB = function(a,b,h){
    var bi = this.bodyA,
        bj = this.bodyB,
        ri = this.contactPointA,
        rj = this.contactPointB,
        xi = bi.position,
        xj = bj.position;

    var penetrationVec = this.penetrationVec,
        n = this.normalA,
        G = this.G;

    // Caluclate cross products
    var rixn = vec2.crossLength(ri,n),
        rjxn = vec2.crossLength(rj,n);

    // G = [-n -rixn n rjxn]
    G[0] = -n[0];
    G[1] = -n[1];
    G[2] = -rixn;
    G[3] = n[0];
    G[4] = n[1];
    G[5] = rjxn;

    // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector
    vec2.add(penetrationVec,xj,rj);
    vec2.sub(penetrationVec,penetrationVec,xi);
    vec2.sub(penetrationVec,penetrationVec,ri);

    // Compute iteration
    var GW, Gq;
    if(this.firstImpact && this.restitution !== 0){
        Gq = 0;
        GW = (1/b)*(1+this.restitution) * this.computeGW();
    } else {
        Gq = vec2.dot(n,penetrationVec) + this.offset;
        GW = this.computeGW();
    }

    var GiMf = this.computeGiMf();
    var B = - Gq * a - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js":[function(require,module,exports){
module.exports = Equation;

var vec2 = require('../math/vec2'),
    Utils = require('../utils/Utils'),
    Body = require('../objects/Body');

/**
 * Base class for constraint equations.
 * @class Equation
 * @constructor
 * @param {Body} bodyA First body participating in the equation
 * @param {Body} bodyB Second body participating in the equation
 * @param {number} minForce Minimum force to apply. Default: -Number.MAX_VALUE
 * @param {number} maxForce Maximum force to apply. Default: Number.MAX_VALUE
 */
function Equation(bodyA, bodyB, minForce, maxForce){

    /**
     * Minimum force to apply when solving.
     * @property minForce
     * @type {Number}
     */
    this.minForce = typeof(minForce)==="undefined" ? -Number.MAX_VALUE : minForce;

    /**
     * Max force to apply when solving.
     * @property maxForce
     * @type {Number}
     */
    this.maxForce = typeof(maxForce)==="undefined" ? Number.MAX_VALUE : maxForce;

    /**
     * First body participating in the constraint
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second body participating in the constraint
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.
     * @property stiffness
     * @type {Number}
     */
    this.stiffness = Equation.DEFAULT_STIFFNESS;

    /**
     * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.
     * @property relaxation
     * @type {Number}
     */
    this.relaxation = Equation.DEFAULT_RELAXATION;

    /**
     * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).
     * @property G
     * @type {Array}
     */
    this.G = new Utils.ARRAY_TYPE(6);
    for(var i=0; i<6; i++){
        this.G[i]=0;
    }

    this.offset = 0;

    this.a = 0;
    this.b = 0;
    this.epsilon = 0;
    this.timeStep = 1/60;

    /**
     * Indicates if stiffness or relaxation was changed.
     * @property {Boolean} needsUpdate
     */
    this.needsUpdate = true;

    /**
     * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.
     * @property multiplier
     * @type {Number}
     */
    this.multiplier = 0;

    /**
     * Relative velocity.
     * @property {Number} relativeVelocity
     */
    this.relativeVelocity = 0;

    /**
     * Whether this equation is enabled or not. If true, it will be added to the solver.
     * @property {Boolean} enabled
     */
    this.enabled = true;
}
Equation.prototype.constructor = Equation;

/**
 * The default stiffness when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_STIFFNESS
 * @default 1e6
 */
Equation.DEFAULT_STIFFNESS = 1e6;

/**
 * The default relaxation when creating a new Equation.
 * @static
 * @property {Number} DEFAULT_RELAXATION
 * @default 4
 */
Equation.DEFAULT_RELAXATION = 4;

/**
 * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href="http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf">SPOOK notes</a>.
 * @method update
 */
Equation.prototype.update = function(){
    var k = this.stiffness,
        d = this.relaxation,
        h = this.timeStep;

    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = (4.0 * d) / (1 + 4 * d);
    this.epsilon = 4.0 / (h * h * k * (1 + 4 * d));

    this.needsUpdate = false;
};

/**
 * Multiply a jacobian entry with corresponding positions or velocities
 * @method gmult
 * @return {Number}
 */
Equation.prototype.gmult = function(G,vi,wi,vj,wj){
    return  G[0] * vi[0] +
            G[1] * vi[1] +
            G[2] * wi +
            G[3] * vj[0] +
            G[4] * vj[1] +
            G[5] * wj;
};

/**
 * Computes the RHS of the SPOOK equation
 * @method computeB
 * @return {Number}
 */
Equation.prototype.computeB = function(a,b,h){
    var GW = this.computeGW();
    var Gq = this.computeGq();
    var GiMf = this.computeGiMf();
    return - Gq * a - GW * b - GiMf*h;
};

/**
 * Computes G\*q, where q are the generalized body coordinates
 * @method computeGq
 * @return {Number}
 */
var qi = vec2.create(),
    qj = vec2.create();
Equation.prototype.computeGq = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        xi = bi.position,
        xj = bj.position,
        ai = bi.angle,
        aj = bj.angle;

    return this.gmult(G, qi, ai, qj, aj) + this.offset;
};

/**
 * Computes G\*W, where W are the body velocities
 * @method computeGW
 * @return {Number}
 */
Equation.prototype.computeGW = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        vi = bi.velocity,
        vj = bj.velocity,
        wi = bi.angularVelocity,
        wj = bj.angularVelocity;
    return this.gmult(G,vi,wi,vj,wj) + this.relativeVelocity;
};

/**
 * Computes G\*Wlambda, where W are the body velocities
 * @method computeGWlambda
 * @return {Number}
 */
Equation.prototype.computeGWlambda = function(){
    var G = this.G,
        bi = this.bodyA,
        bj = this.bodyB,
        vi = bi.vlambda,
        vj = bj.vlambda,
        wi = bi.wlambda,
        wj = bj.wlambda;
    return this.gmult(G,vi,wi,vj,wj);
};

/**
 * Computes G\*inv(M)\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
 * @method computeGiMf
 * @return {Number}
 */
var iMfi = vec2.create(),
    iMfj = vec2.create();
Equation.prototype.computeGiMf = function(){
    var bi = this.bodyA,
        bj = this.bodyB,
        fi = bi.force,
        ti = bi.angularForce,
        fj = bj.force,
        tj = bj.angularForce,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        G = this.G;

    vec2.scale(iMfi, fi,invMassi);
    vec2.scale(iMfj, fj,invMassj);

    return this.gmult(G,iMfi,ti*invIi,iMfj,tj*invIj);
};

/**
 * Computes G\*inv(M)\*G'
 * @method computeGiMGt
 * @return {Number}
 */
Equation.prototype.computeGiMGt = function(){
    var bi = this.bodyA,
        bj = this.bodyB,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        G = this.G;

    return  G[0] * G[0] * invMassi +
            G[1] * G[1] * invMassi +
            G[2] * G[2] *    invIi +
            G[3] * G[3] * invMassj +
            G[4] * G[4] * invMassj +
            G[5] * G[5] *    invIj;
};

var addToWlambda_temp = vec2.create(),
    addToWlambda_Gi = vec2.create(),
    addToWlambda_Gj = vec2.create(),
    addToWlambda_ri = vec2.create(),
    addToWlambda_rj = vec2.create(),
    addToWlambda_Mdiag = vec2.create();

/**
 * Add constraint velocity to the bodies.
 * @method addToWlambda
 * @param {Number} deltalambda
 */
Equation.prototype.addToWlambda = function(deltalambda){
    var bi = this.bodyA,
        bj = this.bodyB,
        temp = addToWlambda_temp,
        Gi = addToWlambda_Gi,
        Gj = addToWlambda_Gj,
        ri = addToWlambda_ri,
        rj = addToWlambda_rj,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaSolve,
        invIj = bj.invInertiaSolve,
        Mdiag = addToWlambda_Mdiag,
        G = this.G;

    Gi[0] = G[0];
    Gi[1] = G[1];
    Gj[0] = G[3];
    Gj[1] = G[4];

    // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G
    vec2.scale(temp, Gi, invMassi*deltalambda);
    vec2.add( bi.vlambda, bi.vlambda, temp);
    // This impulse is in the offset frame
    // Also add contribution to angular
    //bi.wlambda -= vec2.crossLength(temp,ri);
    bi.wlambda += invIi * G[2] * deltalambda;


    vec2.scale(temp, Gj, invMassj*deltalambda);
    vec2.add( bj.vlambda, bj.vlambda, temp);
    //bj.wlambda -= vec2.crossLength(temp,rj);
    bj.wlambda += invIj * G[5] * deltalambda;
};

/**
 * Compute the denominator part of the SPOOK equation: C = G\*inv(M)\*G' + eps
 * @method computeInvC
 * @param  {Number} eps
 * @return {Number}
 */
Equation.prototype.computeInvC = function(eps){
    return 1.0 / (this.computeGiMGt() + eps);
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../objects/Body":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/Body.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/FrictionEquation.js":[function(require,module,exports){
var vec2 = require('../math/vec2')
,   Equation = require('./Equation')
,   Utils = require('../utils/Utils');

module.exports = FrictionEquation;

/**
 * Constrains the slipping in a contact along a tangent
 *
 * @class FrictionEquation
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} slipForce
 * @extends Equation
 */
function FrictionEquation(bodyA, bodyB, slipForce){
    Equation.call(this, bodyA, bodyB, -slipForce, slipForce);

    /**
     * Relative vector from center of body A to the contact point, world oriented.
     * @property contactPointA
     * @type {Array}
     */
    this.contactPointA = vec2.create();

    /**
     * Relative vector from center of body B to the contact point, world oriented.
     * @property contactPointB
     * @type {Array}
     */
    this.contactPointB = vec2.create();

    /**
     * Tangent vector that the friction force will act along. World oriented.
     * @property t
     * @type {Array}
     */
    this.t = vec2.create();

    /**
     * A ContactEquation connected to this friction. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.
     * @property contactEquations
     * @type {ContactEquation}
     */
    this.contactEquations = [];

    /**
     * The shape in body i that triggered this friction.
     * @property shapeA
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeA...
     */
    this.shapeA = null;

    /**
     * The shape in body j that triggered this friction.
     * @property shapeB
     * @type {Shape}
     * @todo Needed? The shape can be looked up via contactEquation.shapeB...
     */
    this.shapeB = null;

    /**
     * The friction coefficient to use.
     * @property frictionCoefficient
     * @type {Number}
     */
    this.frictionCoefficient = 0.3;
}
FrictionEquation.prototype = new Equation();
FrictionEquation.prototype.constructor = FrictionEquation;

/**
 * Set the slipping condition for the constraint. The friction force cannot be
 * larger than this value.
 * @method setSlipForce
 * @param  {Number} slipForce
 */
FrictionEquation.prototype.setSlipForce = function(slipForce){
    this.maxForce = slipForce;
    this.minForce = -slipForce;
};

/**
 * Get the max force for the constraint.
 * @method getSlipForce
 * @return {Number}
 */
FrictionEquation.prototype.getSlipForce = function(){
    return this.maxForce;
};

FrictionEquation.prototype.computeB = function(a,b,h){
    var bi = this.bodyA,
        bj = this.bodyB,
        ri = this.contactPointA,
        rj = this.contactPointB,
        t = this.t,
        G = this.G;

    // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!
    G[0] = -t[0];
    G[1] = -t[1];
    G[2] = -vec2.crossLength(ri,t);
    G[3] = t[0];
    G[4] = t[1];
    G[5] = vec2.crossLength(rj,t);

    var GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = /* - g * a  */ - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js","./Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/RotationalLockEquation.js":[function(require,module,exports){
var Equation = require("./Equation"),
    vec2 = require('../math/vec2');

module.exports = RotationalLockEquation;

/**
 * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.
 *
 * @class RotationalLockEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {Number} [options.angle] Angle to add to the local vector in bodyA.
 */
function RotationalLockEquation(bodyA, bodyB, options){
    options = options || {};
    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);

    /**
     * @property {number} angle
     */
    this.angle = options.angle || 0;

    var G = this.G;
    G[2] =  1;
    G[5] = -1;
}
RotationalLockEquation.prototype = new Equation();
RotationalLockEquation.prototype.constructor = RotationalLockEquation;

var worldVectorA = vec2.create(),
    worldVectorB = vec2.create(),
    xAxis = vec2.fromValues(1,0),
    yAxis = vec2.fromValues(0,1);
RotationalLockEquation.prototype.computeGq = function(){
    vec2.rotate(worldVectorA,xAxis,this.bodyA.angle+this.angle);
    vec2.rotate(worldVectorB,yAxis,this.bodyB.angle);
    return vec2.dot(worldVectorA,worldVectorB);
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/RotationalVelocityEquation.js":[function(require,module,exports){
var Equation = require("./Equation"),
    vec2 = require('../math/vec2');

module.exports = RotationalVelocityEquation;

/**
 * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).
 *
 * @class RotationalVelocityEquation
 * @constructor
 * @extends Equation
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function RotationalVelocityEquation(bodyA, bodyB){
    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);
    this.relativeVelocity = 1;
    this.ratio = 1;
}
RotationalVelocityEquation.prototype = new Equation();
RotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;
RotationalVelocityEquation.prototype.computeB = function(a,b,h){
    var G = this.G;
    G[2] = -1;
    G[5] = this.ratio;

    var GiMf = this.computeGiMf();
    var GW = this.computeGW();
    var B = - GW * b - h*GiMf;

    return B;
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/events/EventEmitter.js":[function(require,module,exports){
/**
 * Base class for objects that dispatches events.
 * @class EventEmitter
 * @constructor
 */
var EventEmitter = function () {};

module.exports = EventEmitter;

EventEmitter.prototype = {
    constructor: EventEmitter,

    /**
     * Add an event listener
     * @method on
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */
    on: function ( type, listener, context ) {
        listener.context = context || this;
        if ( this._listeners === undefined ){
            this._listeners = {};
        }
        var listeners = this._listeners;
        if ( listeners[ type ] === undefined ) {
            listeners[ type ] = [];
        }
        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
            listeners[ type ].push( listener );
        }
        return this;
    },

    /**
     * Check if an event listener is added
     * @method has
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    has: function ( type, listener ) {
        if ( this._listeners === undefined ){
            return false;
        }
        var listeners = this._listeners;
        if(listener){
            if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
                return true;
            }
        } else {
            if ( listeners[ type ] !== undefined ) {
                return true;
            }
        }

        return false;
    },

    /**
     * Remove an event listener
     * @method off
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventEmitter} The self object, for chainability.
     */
    off: function ( type, listener ) {
        if ( this._listeners === undefined ){
            return this;
        }
        var listeners = this._listeners;
        var index = listeners[ type ].indexOf( listener );
        if ( index !== - 1 ) {
            listeners[ type ].splice( index, 1 );
        }
        return this;
    },

    /**
     * Emit an event.
     * @method emit
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventEmitter} The self object, for chainability.
     */
    emit: function ( event ) {
        if ( this._listeners === undefined ){
            return this;
        }
        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];
        if ( listenerArray !== undefined ) {
            event.target = this;
            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
                var listener = listenerArray[ i ];
                listener.call( listener.context, event );
            }
        }
        return this;
    }
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/material/ContactMaterial.js":[function(require,module,exports){
var Material = require('./Material');
var Equation = require('../equations/Equation');

module.exports = ContactMaterial;

/**
 * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters.
 * @class ContactMaterial
 * @constructor
 * @param {Material} materialA
 * @param {Material} materialB
 * @param {Object}   [options]
 * @param {Number}   [options.friction=0.3]       Friction coefficient.
 * @param {Number}   [options.restitution=0]      Restitution coefficient aka "bounciness".
 * @param {Number}   [options.stiffness]          ContactEquation stiffness.
 * @param {Number}   [options.relaxation]         ContactEquation relaxation.
 * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.
 * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.
 * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.
 * @author schteppe
 */
function ContactMaterial(materialA, materialB, options){
    options = options || {};

    if(!(materialA instanceof Material) || !(materialB instanceof Material)){
        throw new Error("First two arguments must be Material instances.");
    }

    /**
     * The contact material identifier
     * @property id
     * @type {Number}
     */
    this.id = ContactMaterial.idCounter++;

    /**
     * First material participating in the contact material
     * @property materialA
     * @type {Material}
     */
    this.materialA = materialA;

    /**
     * Second material participating in the contact material
     * @property materialB
     * @type {Material}
     */
    this.materialB = materialB;

    /**
     * Friction to use in the contact of these two materials
     * @property friction
     * @type {Number}
     */
    this.friction    =  typeof(options.friction)    !== "undefined" ?   Number(options.friction)    : 0.3;

    /**
     * Restitution to use in the contact of these two materials
     * @property restitution
     * @type {Number}
     */
    this.restitution =  typeof(options.restitution) !== "undefined" ?   Number(options.restitution) : 0.0;

    /**
     * Stiffness of the resulting ContactEquation that this ContactMaterial generate
     * @property stiffness
     * @type {Number}
     */
    this.stiffness =            typeof(options.stiffness)           !== "undefined" ?   Number(options.stiffness)   : Equation.DEFAULT_STIFFNESS;

    /**
     * Relaxation of the resulting ContactEquation that this ContactMaterial generate
     * @property relaxation
     * @type {Number}
     */
    this.relaxation =           typeof(options.relaxation)          !== "undefined" ?   Number(options.relaxation)  : Equation.DEFAULT_RELAXATION;

    /**
     * Stiffness of the resulting FrictionEquation that this ContactMaterial generate
     * @property frictionStiffness
     * @type {Number}
     */
    this.frictionStiffness =    typeof(options.frictionStiffness)   !== "undefined" ?   Number(options.frictionStiffness)   : Equation.DEFAULT_STIFFNESS;

    /**
     * Relaxation of the resulting FrictionEquation that this ContactMaterial generate
     * @property frictionRelaxation
     * @type {Number}
     */
    this.frictionRelaxation =   typeof(options.frictionRelaxation)  !== "undefined" ?   Number(options.frictionRelaxation)  : Equation.DEFAULT_RELAXATION;

    /**
     * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.
     * @property {Number} surfaceVelocity
     */
    this.surfaceVelocity = typeof(options.surfaceVelocity)    !== "undefined" ?   Number(options.surfaceVelocity)    : 0;

    /**
     * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka "cure for nervous contacts".
     * @property contactSkinSize
     * @type {Number}
     */
    this.contactSkinSize = 0.005;
}

ContactMaterial.idCounter = 0;

},{"../equations/Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js","./Material":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/material/Material.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/material/Material.js":[function(require,module,exports){
module.exports = Material;

/**
 * Defines a physics material.
 * @class Material
 * @constructor
 * @param {number} id Material identifier
 * @author schteppe
 */
function Material(id){
    /**
     * The material identifier
     * @property id
     * @type {Number}
     */
    this.id = id || Material.idCounter++;
}

Material.idCounter = 0;

},{}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/polyk.js":[function(require,module,exports){

    /*
        PolyK library
        url: http://polyk.ivank.net
        Released under MIT licence.

        Copyright (c) 2012 Ivan Kuckir

        Permission is hereby granted, free of charge, to any person
        obtaining a copy of this software and associated documentation
        files (the "Software"), to deal in the Software without
        restriction, including without limitation the rights to use,
        copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the
        Software is furnished to do so, subject to the following
        conditions:

        The above copyright notice and this permission notice shall be
        included in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
        OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
        OTHER DEALINGS IN THE SOFTWARE.
    */

    var PolyK = {};

    /*
        Is Polygon self-intersecting?

        O(n^2)
    */
    /*
    PolyK.IsSimple = function(p)
    {
        var n = p.length>>1;
        if(n<4) return true;
        var a1 = new PolyK._P(), a2 = new PolyK._P();
        var b1 = new PolyK._P(), b2 = new PolyK._P();
        var c = new PolyK._P();

        for(var i=0; i<n; i++)
        {
            a1.x = p[2*i  ];
            a1.y = p[2*i+1];
            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }
            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }

            for(var j=0; j<n; j++)
            {
                if(Math.abs(i-j) < 2) continue;
                if(j==n-1 && i==0) continue;
                if(i==n-1 && j==0) continue;

                b1.x = p[2*j  ];
                b1.y = p[2*j+1];
                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }
                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }

                if(PolyK._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;
            }
        }
        return true;
    }

    PolyK.IsConvex = function(p)
    {
        if(p.length<6) return true;
        var l = p.length - 4;
        for(var i=0; i<l; i+=2)
            if(!PolyK._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;
        if(!PolyK._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;
        if(!PolyK._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;
        return true;
    }
    */
    PolyK.GetArea = function(p)
    {
        if(p.length <6) return 0;
        var l = p.length - 2;
        var sum = 0;
        for(var i=0; i<l; i+=2)
            sum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);
        sum += (p[0]-p[l]) * (p[l+1]+p[1]);
        return - sum * 0.5;
    }
    /*
    PolyK.GetAABB = function(p)
    {
        var minx = Infinity;
        var miny = Infinity;
        var maxx = -minx;
        var maxy = -miny;
        for(var i=0; i<p.length; i+=2)
        {
            minx = Math.min(minx, p[i  ]);
            maxx = Math.max(maxx, p[i  ]);
            miny = Math.min(miny, p[i+1]);
            maxy = Math.max(maxy, p[i+1]);
        }
        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};
    }
    */

    PolyK.Triangulate = function(p)
    {
        var n = p.length>>1;
        if(n<3) return [];
        var tgs = [];
        var avl = [];
        for(var i=0; i<n; i++) avl.push(i);

        var i = 0;
        var al = n;
        while(al > 3)
        {
            var i0 = avl[(i+0)%al];
            var i1 = avl[(i+1)%al];
            var i2 = avl[(i+2)%al];

            var ax = p[2*i0],  ay = p[2*i0+1];
            var bx = p[2*i1],  by = p[2*i1+1];
            var cx = p[2*i2],  cy = p[2*i2+1];

            var earFound = false;
            if(PolyK._convex(ax, ay, bx, by, cx, cy))
            {
                earFound = true;
                for(var j=0; j<al; j++)
                {
                    var vi = avl[j];
                    if(vi==i0 || vi==i1 || vi==i2) continue;
                    if(PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}
                }
            }
            if(earFound)
            {
                tgs.push(i0, i1, i2);
                avl.splice((i+1)%al, 1);
                al--;
                i= 0;
            }
            else if(i++ > 3*al) break;      // no convex angles :(
        }
        tgs.push(avl[0], avl[1], avl[2]);
        return tgs;
    }
    /*
    PolyK.ContainsPoint = function(p, px, py)
    {
        var n = p.length>>1;
        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;
        var depth = 0;
        for(var i=0; i<n; i++)
        {
            ax = bx;  ay = by;
            bx = p[2*i  ] - px;
            by = p[2*i+1] - py;
            if(ay< 0 && by< 0) continue;    // both "up" or both "donw"
            if(ay>=0 && by>=0) continue;    // both "up" or both "donw"
            if(ax< 0 && bx< 0) continue;

            var lx = ax + (bx-ax)*(-ay)/(by-ay);
            if(lx>0) depth++;
        }
        return (depth & 1) == 1;
    }

    PolyK.Slice = function(p, ax, ay, bx, by)
    {
        if(PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by)) return [p.slice(0)];

        var a = new PolyK._P(ax, ay);
        var b = new PolyK._P(bx, by);
        var iscs = [];  // intersections
        var ps = [];    // points
        for(var i=0; i<p.length; i+=2) ps.push(new PolyK._P(p[i], p[i+1]));

        for(var i=0; i<ps.length; i++)
        {
            var isc = new PolyK._P(0,0);
            isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);

            if(isc)
            {
                isc.flag = true;
                iscs.push(isc);
                ps.splice(i+1,0,isc);
                i++;
            }
        }
        if(iscs.length == 0) return [p.slice(0)];
        var comp = function(u,v) {return PolyK._P.dist(a,u) - PolyK._P.dist(a,v); }
        iscs.sort(comp);

        var pgs = [];
        var dir = 0;
        while(iscs.length > 0)
        {
            var n = ps.length;
            var i0 = iscs[0];
            var i1 = iscs[1];
            var ind0 = ps.indexOf(i0);
            var ind1 = ps.indexOf(i1);
            var solved = false;

            if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            else
            {
                i0 = iscs[1];
                i1 = iscs[0];
                ind0 = ps.indexOf(i0);
                ind1 = ps.indexOf(i1);
                if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;
            }
            if(solved)
            {
                dir--;
                var pgn = PolyK._getPoints(ps, ind0, ind1);
                pgs.push(pgn);
                ps = PolyK._getPoints(ps, ind1, ind0);
                i0.flag = i1.flag = false;
                iscs.splice(0,2);
                if(iscs.length == 0) pgs.push(ps);
            }
            else { dir++; iscs.reverse(); }
            if(dir>1) break;
        }
        var result = [];
        for(var i=0; i<pgs.length; i++)
        {
            var pg = pgs[i];
            var npg = [];
            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);
            result.push(npg);
        }
        return result;
    }

    PolyK.Raycast = function(p, x, y, dx, dy, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0], a2 = tp[1],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;
        a2.x = x+dx; a2.y = y+dy;

        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
            if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);
        if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);

        return (isc.dist != Infinity) ? isc : null;
    }

    PolyK.ClosestEdge = function(p, x, y, isc)
    {
        var l = p.length - 2;
        var tp = PolyK._tp;
        var a1 = tp[0],
        b1 = tp[2], b2 = tp[3], c = tp[4];
        a1.x = x; a1.y = y;

        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};
        isc.dist = Infinity;

        for(var i=0; i<l; i+=2)
        {
            b1.x = p[i  ];  b1.y = p[i+1];
            b2.x = p[i+2];  b2.y = p[i+3];
            PolyK._pointLineDist(a1, b1, b2, i>>1, isc);
        }
        b1.x = b2.x;  b1.y = b2.y;
        b2.x = p[0];  b2.y = p[1];
        PolyK._pointLineDist(a1, b1, b2, l>>1, isc);

        var idst = 1/isc.dist;
        isc.norm.x = (x-isc.point.x)*idst;
        isc.norm.y = (y-isc.point.y)*idst;
        return isc;
    }

    PolyK._pointLineDist = function(p, a, b, edge, isc)
    {
        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;

        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;

        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var param = dot / len_sq;

        var xx, yy;

        if (param < 0 || (x1 == x2 && y1 == y2)) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        var dx = x - xx;
        var dy = y - yy;
        var dst = Math.sqrt(dx * dx + dy * dy);
        if(dst<isc.dist)
        {
            isc.dist = dst;
            isc.edge = edge;
            isc.point.x = xx;
            isc.point.y = yy;
        }
    }

    PolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)
    {
        var nrl = PolyK._P.dist(a1, c);
        if(nrl<isc.dist)
        {
            var ibl = 1/PolyK._P.dist(b1, b2);
            var nx = -(b2.y-b1.y)*ibl;
            var ny =  (b2.x-b1.x)*ibl;
            var ddot = 2*(dx*nx+dy*ny);
            isc.dist = nrl;
            isc.norm.x = nx;
            isc.norm.y = ny;
            isc.refl.x = -ddot*nx+dx;
            isc.refl.y = -ddot*ny+dy;
            isc.edge = edge;
        }
    }

    PolyK._getPoints = function(ps, ind0, ind1)
    {
        var n = ps.length;
        var nps = [];
        if(ind1<ind0) ind1 += n;
        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);
        return nps;
    }

    PolyK._firstWithFlag = function(ps, ind)
    {
        var n = ps.length;
        while(true)
        {
            ind = (ind+1)%n;
            if(ps[ind].flag) return ind;
        }
    }
    */
    PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)
    {
        var v0x = cx-ax;
        var v0y = cy-ay;
        var v1x = bx-ax;
        var v1y = by-ay;
        var v2x = px-ax;
        var v2y = py-ay;

        var dot00 = v0x*v0x+v0y*v0y;
        var dot01 = v0x*v1x+v0y*v1y;
        var dot02 = v0x*v2x+v0y*v2y;
        var dot11 = v1x*v1x+v1y*v1y;
        var dot12 = v1x*v2x+v1y*v2y;

        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

        // Check if point is in triangle
        return (u >= 0) && (v >= 0) && (u + v < 1);
    }
    /*
    PolyK._RayLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        var iDen = 1/Den;
        I.x = ( A*dbx - dax*B ) * iDen;
        I.y = ( A*dby - day*B ) * iDen;

        if(!PolyK._InRect(I, b1, b2)) return null;
        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;
        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;
        return I;
    }

    PolyK._GetLineIntersection = function(a1, a2, b1, b2, c)
    {
        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);
        var day = (a1.y-a2.y), dby = (b1.y-b2.y);

        var Den = dax*dby - day*dbx;
        if (Den == 0) return null;  // parallel

        var A = (a1.x * a2.y - a1.y * a2.x);
        var B = (b1.x * b2.y - b1.y * b2.x);

        var I = c;
        I.x = ( A*dbx - dax*B ) / Den;
        I.y = ( A*dby - day*B ) / Den;

        if(PolyK._InRect(I, a1, a2) && PolyK._InRect(I, b1, b2)) return I;
        return null;
    }

    PolyK._InRect = function(a, b, c)
    {
        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));
        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));

        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)
        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))
        return true;
        return false;
    }
    */
    PolyK._convex = function(ax, ay, bx, by, cx, cy)
    {
        return (ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0;
    }
    /*
    PolyK._P = function(x,y)
    {
        this.x = x;
        this.y = y;
        this.flag = false;
    }
    PolyK._P.prototype.toString = function()
    {
        return "Point ["+this.x+", "+this.y+"]";
    }
    PolyK._P.dist = function(a,b)
    {
        var dx = b.x-a.x;
        var dy = b.y-a.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    PolyK._tp = [];
    for(var i=0; i<10; i++) PolyK._tp.push(new PolyK._P(0,0));
        */

module.exports = PolyK;

},{}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js":[function(require,module,exports){
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.
 * @class vec2
 */

var vec2 = module.exports = {};

var Utils = require('../utils/Utils');

/**
 * Make a cross product and only return the z component
 * @method crossLength
 * @static
 * @param  {Array} a
 * @param  {Array} b
 * @return {Number}
 */
vec2.crossLength = function(a,b){
    return a[0] * b[1] - a[1] * b[0];
};

/**
 * Cross product between a vector and the Z component of a vector
 * @method crossVZ
 * @static
 * @param  {Array} out
 * @param  {Array} vec
 * @param  {Number} zcomp
 * @return {Number}
 */
vec2.crossVZ = function(out, vec, zcomp){
    vec2.rotate(out,vec,-Math.PI/2);// Rotate according to the right hand rule
    vec2.scale(out,out,zcomp);      // Scale with z
    return out;
};

/**
 * Cross product between a vector and the Z component of a vector
 * @method crossZV
 * @static
 * @param  {Array} out
 * @param  {Number} zcomp
 * @param  {Array} vec
 * @return {Number}
 */
vec2.crossZV = function(out, zcomp, vec){
    vec2.rotate(out,vec,Math.PI/2); // Rotate according to the right hand rule
    vec2.scale(out,out,zcomp);      // Scale with z
    return out;
};

/**
 * Rotate a vector by an angle
 * @method rotate
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */
vec2.rotate = function(out,a,angle){
    if(angle !== 0){
        var c = Math.cos(angle),
            s = Math.sin(angle),
            x = a[0],
            y = a[1];
        out[0] = c*x -s*y;
        out[1] = s*x +c*y;
    } else {
        out[0] = a[0];
        out[1] = a[1];
    }
};

/**
 * Rotate a vector 90 degrees clockwise
 * @method rotate90cw
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Number} angle
 */
vec2.rotate90cw = function(out, a) {
    var x = a[0];
    var y = a[1];
    out[0] = y;
    out[1] = -x;
};

/**
 * Transform a point position to local frame.
 * @method toLocalFrame
 * @param  {Array} out
 * @param  {Array} worldPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */
vec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle){
    vec2.copy(out, worldPoint);
    vec2.sub(out, out, framePosition);
    vec2.rotate(out, out, -frameAngle);
};

/**
 * Transform a point position to global frame.
 * @method toGlobalFrame
 * @param  {Array} out
 * @param  {Array} localPoint
 * @param  {Array} framePosition
 * @param  {Number} frameAngle
 */
vec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle){
    vec2.copy(out, localPoint);
    vec2.rotate(out, out, frameAngle);
    vec2.add(out, out, framePosition);
};

/**
 * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php
 * @method centroid
 * @static
 * @param  {Array} out
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return  {Array} The out object
 */
vec2.centroid = function(out, a, b, c){
    vec2.add(out, a, b);
    vec2.add(out, out, c);
    vec2.scale(out, out, 1/3);
    return out;
};

/**
 * Creates a new, empty vec2
 * @static
 * @method create
 * @return {Array} a new 2D vector
 */
vec2.create = function() {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 * @static
 * @method clone
 * @param {Array} a vector to clone
 * @return {Array} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 * @static
 * @method fromValues
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new Utils.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 * @static
 * @method copy
 * @param {Array} out the receiving vector
 * @param {Array} a the source vector
 * @return {Array} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 * @static
 * @method set
 * @param {Array} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @return {Array} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 * @static
 * @method add
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts two vec2's
 * @static
 * @method subtract
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for vec2.subtract
 * @static
 * @method sub
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 * @static
 * @method multiply
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for vec2.multiply
 * @static
 * @method mul
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 * @static
 * @method divide
 * @param {Array} out the receiving vector
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Array} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for vec2.divide
 * @static
 * @method div
 */
vec2.div = vec2.divide;

/**
 * Scales a vec2 by a scalar number
 * @static
 * @method scale
 * @param {Array} out the receiving vector
 * @param {Array} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @return {Array} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 * @static
 * @method distance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for vec2.distance
 * @static
 * @method dist
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 * @static
 * @method squaredDistance
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for vec2.squaredDistance
 * @static
 * @method sqrDist
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 * @static
 * @method length
 * @param {Array} a vector to calculate length of
 * @return {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for vec2.length
 * @method len
 * @static
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 * @static
 * @method squaredLength
 * @param {Array} a vector to calculate squared length of
 * @return {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for vec2.squaredLength
 * @static
 * @method sqrLen
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 * @static
 * @method negate
 * @param {Array} out the receiving vector
 * @param {Array} a vector to negate
 * @return {Array} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 * @static
 * @method normalize
 * @param {Array} out the receiving vector
 * @param {Array} a vector to normalize
 * @return {Array} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 * @static
 * @method dot
 * @param {Array} a the first operand
 * @param {Array} b the second operand
 * @return {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Returns a string representation of a vector
 * @static
 * @method str
 * @param {Array} vec vector to represent as a string
 * @return {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

},{"../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/Body.js":[function(require,module,exports){
var vec2 = require('../math/vec2')
,   decomp = require('poly-decomp')
,   Convex = require('../shapes/Convex')
,   AABB = require('../collision/AABB')
,   EventEmitter = require('../events/EventEmitter');

module.exports = Body;

/**
 * A rigid body. Has got a center of mass, position, velocity and a number of
 * shapes that are used for collisions.
 *
 * @class Body
 * @constructor
 * @extends EventEmitter
 * @param {Object}              [options]
 * @param {Number}              [options.mass=0]    A number >= 0. If zero, the .type will be set to Body.STATIC.
 * @param {Array}               [options.position]
 * @param {Array}               [options.velocity]
 * @param {Number}              [options.angle=0]
 * @param {Number}              [options.angularVelocity=0]
 * @param {Array}               [options.force]
 * @param {Number}              [options.angularForce=0]
 * @param {Number}              [options.fixedRotation=false]
 * @param {Number}              [options.ccdSpeedThreshold=-1]
 * @param {Number}              [options.ccdIterations=10]
 *
 * @example
 *
 *     // Create a typical dynamic body
 *     var body = new Body({
 *         mass: 1,
 *         position: [0, 0],
 *         angle: 0,
 *         velocity: [0, 0],
 *         angularVelocity: 0
 *     });
 *
 *     // Add a circular shape to the body
 *     body.addShape(new Circle(1));
 *
 *     // Add the body to the world
 *     world.addBody(body);
 */
function Body(options){
    options = options || {};

    EventEmitter.call(this);

    /**
     * The body identifyer
     * @property id
     * @type {Number}
     */
    this.id = ++Body._idCounter;

    /**
     * The world that this body is added to. This property is set to NULL if the body is not added to any world.
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * The shapes of the body. The local transform of the shape in .shapes[i] is
     * defined by .shapeOffsets[i] and .shapeAngles[i].
     *
     * @property shapes
     * @type {Array}
     */
    this.shapes = [];

    /**
     * The local shape offsets, relative to the body center of mass. This is an
     * array of Array.
     * @property shapeOffsets
     * @type {Array}
     */
    this.shapeOffsets = [];

    /**
     * The body-local shape angle transforms. This is an array of numbers (angles).
     * @property shapeAngles
     * @type {Array}
     */
    this.shapeAngles = [];

    /**
     * The mass of the body.
     * @property mass
     * @type {number}
     */
    this.mass = options.mass || 0;

    /**
     * The inverse mass of the body.
     * @property invMass
     * @type {number}
     */
    this.invMass = 0;

    /**
     * The inertia of the body around the Z axis.
     * @property inertia
     * @type {number}
     */
    this.inertia = 0;

    /**
     * The inverse inertia of the body.
     * @property invInertia
     * @type {number}
     */
    this.invInertia = 0;

    this.invMassSolve = 0;
    this.invInertiaSolve = 0;

    /**
     * Set to true if you want to fix the rotation of the body.
     * @property fixedRotation
     * @type {Boolean}
     */
    this.fixedRotation = !!options.fixedRotation;

    /**
     * The position of the body
     * @property position
     * @type {Array}
     */
    this.position = vec2.fromValues(0,0);
    if(options.position){
        vec2.copy(this.position, options.position);
    }

    /**
     * The interpolated position of the body.
     * @property interpolatedPosition
     * @type {Array}
     */
    this.interpolatedPosition = vec2.fromValues(0,0);

    /**
     * The interpolated angle of the body.
     * @property interpolatedAngle
     * @type {Number}
     */
    this.interpolatedAngle = 0;

    /**
     * The previous position of the body.
     * @property previousPosition
     * @type {Array}
     */
    this.previousPosition = vec2.fromValues(0,0);

    /**
     * The previous angle of the body.
     * @property previousAngle
     * @type {Number}
     */
    this.previousAngle = 0;

    /**
     * The velocity of the body
     * @property velocity
     * @type {Array}
     */
    this.velocity = vec2.fromValues(0,0);
    if(options.velocity){
        vec2.copy(this.velocity, options.velocity);
    }

    /**
     * Constraint velocity that was added to the body during the last step.
     * @property vlambda
     * @type {Array}
     */
    this.vlambda = vec2.fromValues(0,0);

    /**
     * Angular constraint velocity that was added to the body during last step.
     * @property wlambda
     * @type {Array}
     */
    this.wlambda = 0;

    /**
     * The angle of the body, in radians.
     * @property angle
     * @type {number}
     * @example
     *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.
     *     // If you need a value between 0 and 2*pi, use the following function to normalize it.
     *     function normalizeAngle(angle){
     *         angle = angle % (2*Math.PI);
     *         if(angle < 0){
     *             angle += (2*Math.PI);
     *         }
     *         return angle;
     *     }
     */
    this.angle = options.angle || 0;

    /**
     * The angular velocity of the body, in radians per second.
     * @property angularVelocity
     * @type {number}
     */
    this.angularVelocity = options.angularVelocity || 0;

    /**
     * The force acting on the body. Since the body force (and {{#crossLink "Body/angularForce:property"}}{{/crossLink}}) will be zeroed after each step, so you need to set the force before each step.
     * @property force
     * @type {Array}
     *
     * @example
     *     // This produces a forcefield of 1 Newton in the positive x direction.
     *     for(var i=0; i<numSteps; i++){
     *         body.force[0] = 1;
     *         world.step(1/60);
     *     }
     *
     * @example
     *     // This will apply a rotational force on the body
     *     for(var i=0; i<numSteps; i++){
     *         body.angularForce = -3;
     *         world.step(1/60);
     *     }
     */
    this.force = vec2.create();
    if(options.force){
        vec2.copy(this.force, options.force);
    }

    /**
     * The angular force acting on the body. See {{#crossLink "Body/force:property"}}{{/crossLink}}.
     * @property angularForce
     * @type {number}
     */
    this.angularForce = options.angularForce || 0;

    /**
     * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.
     * @property damping
     * @type {Number}
     * @default 0.1
     */
    this.damping = typeof(options.damping) === "number" ? options.damping : 0.1;

    /**
     * The angular force acting on the body. Should be a value between 0 and 1.
     * @property angularDamping
     * @type {Number}
     * @default 0.1
     */
    this.angularDamping = typeof(options.angularDamping) === "number" ? options.angularDamping : 0.1;

    /**
     * The type of motion this body has. Should be one of: {{#crossLink "Body/STATIC:property"}}Body.STATIC{{/crossLink}}, {{#crossLink "Body/DYNAMIC:property"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink "Body/KINEMATIC:property"}}Body.KINEMATIC{{/crossLink}}.
     *
     * * Static bodies do not move, and they do not respond to forces or collision.
     * * Dynamic bodies body can move and respond to collisions and forces.
     * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.
     *
     * @property type
     * @type {number}
     *
     * @example
     *     // Bodies are static by default. Static bodies will never move.
     *     var body = new Body();
     *     console.log(body.type == Body.STATIC); // true
     *
     * @example
     *     // By setting the mass of a body to a nonzero number, the body
     *     // will become dynamic and will move and interact with other bodies.
     *     var dynamicBody = new Body({
     *         mass : 1
     *     });
     *     console.log(dynamicBody.type == Body.DYNAMIC); // true
     *
     * @example
     *     // Kinematic bodies will only move if you change their velocity.
     *     var kinematicBody = new Body({
     *         type: Body.KINEMATIC // Type can be set via the options object.
     *     });
     */
    this.type = Body.STATIC;

    if(typeof(options.type) !== 'undefined'){
        this.type = options.type;
    } else if(!options.mass){
        this.type = Body.STATIC;
    } else {
        this.type = Body.DYNAMIC;
    }

    /**
     * Bounding circle radius.
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    /**
     * Bounding box of this body.
     * @property aabb
     * @type {AABB}
     */
    this.aabb = new AABB();

    /**
     * Indicates if the AABB needs update. Update it with {{#crossLink "Body/updateAABB:method"}}.updateAABB(){{/crossLink}}.
     * @property aabbNeedsUpdate
     * @type {Boolean}
     * @see updateAABB
     *
     * @example
     *     // Force update the AABB
     *     body.aabbNeedsUpdate = true;
     *     body.updateAABB();
     *     console.log(body.aabbNeedsUpdate); // false
     */
    this.aabbNeedsUpdate = true;

    /**
     * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink "World"}}{{/crossLink}} before anything will happen.
     * @property allowSleep
     * @type {Boolean}
     * @default true
     */
    this.allowSleep = true;

    this.wantsToSleep = false;

    /**
     * One of {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}}, {{#crossLink "Body/SLEEPY:property"}}Body.SLEEPY{{/crossLink}} and {{#crossLink "Body/SLEEPING:property"}}Body.SLEEPING{{/crossLink}}.
     *
     * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).
     *
     * @property sleepState
     * @type {Number}
     * @default Body.AWAKE
     */
    this.sleepState = Body.AWAKE;

    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @property sleepSpeedLimit
     * @type {Number}
     * @default 0.2
     */
    this.sleepSpeedLimit = 0.2;

    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @property sleepTimeLimit
     * @type {Number}
     * @default 1
     */
    this.sleepTimeLimit = 1;

    /**
     * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.
     * @property {Number} gravityScale
     * @default 1
     */
    this.gravityScale = 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * How long the body has been sleeping.
     * @property {Number} idleTime
     */
    this.idleTime = 0;

    /**
     * The last time when the body went to SLEEPY state.
     * @property {Number} timeLastSleepy
     * @private
     */
    this.timeLastSleepy = 0;

    /**
     * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.
     * @property {number} ccdSpeedThreshold
     * @default -1
     */
    this.ccdSpeedThreshold = options.ccdSpeedThreshold !== undefined ? options.ccdSpeedThreshold : -1;

    /**
     * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.
     * @property {number} ccdIterations
     * @default 10
     */
    this.ccdIterations = options.ccdIterations !== undefined ? options.ccdIterations : 10;

    this.concavePath = null;

    this._wakeUpAfterNarrowphase = false;

    this.updateMassProperties();
}
Body.prototype = new EventEmitter();
Body.prototype.constructor = Body;

Body._idCounter = 0;

Body.prototype.updateSolveMassProperties = function(){
    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
        this.invMassSolve = 0;
        this.invInertiaSolve = 0;
    } else {
        this.invMassSolve = this.invMass;
        this.invInertiaSolve = this.invInertia;
    }
};

/**
 * Set the total density of the body
 * @method setDensity
 */
Body.prototype.setDensity = function(density) {
    var totalArea = this.getArea();
    this.mass = totalArea * density;
    this.updateMassProperties();
};

/**
 * Get the total area of all shapes in the body
 * @method getArea
 * @return {Number}
 */
Body.prototype.getArea = function() {
    var totalArea = 0;
    for(var i=0; i<this.shapes.length; i++){
        totalArea += this.shapes[i].area;
    }
    return totalArea;
};

/**
 * Get the AABB from the body. The AABB is updated if necessary.
 * @method getAABB
 */
Body.prototype.getAABB = function(){
    if(this.aabbNeedsUpdate){
        this.updateAABB();
    }
    return this.aabb;
};

var shapeAABB = new AABB(),
    tmp = vec2.create();

/**
 * Updates the AABB of the Body
 * @method updateAABB
 */
Body.prototype.updateAABB = function() {
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        shapeAngles = this.shapeAngles,
        N = shapes.length,
        offset = tmp,
        bodyAngle = this.angle;

    for(var i=0; i!==N; i++){
        var shape = shapes[i],
            angle = shapeAngles[i] + bodyAngle;

        // Get shape world offset
        vec2.rotate(offset, shapeOffsets[i], bodyAngle);
        vec2.add(offset, offset, this.position);

        // Get shape AABB
        shape.computeAABB(shapeAABB, offset, angle);

        if(i===0){
            this.aabb.copy(shapeAABB);
        } else {
            this.aabb.extend(shapeAABB);
        }
    }

    this.aabbNeedsUpdate = false;
};

/**
 * Update the bounding radius of the body. Should be done if any of the shapes
 * are changed.
 * @method updateBoundingRadius
 */
Body.prototype.updateBoundingRadius = function(){
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        N = shapes.length,
        radius = 0;

    for(var i=0; i!==N; i++){
        var shape = shapes[i],
            offset = vec2.length(shapeOffsets[i]),
            r = shape.boundingRadius;
        if(offset + r > radius){
            radius = offset + r;
        }
    }

    this.boundingRadius = radius;
};

/**
 * Add a shape to the body. You can pass a local transform when adding a shape,
 * so that the shape gets an offset and angle relative to the body center of mass.
 * Will automatically update the mass properties and bounding radius.
 *
 * @method addShape
 * @param  {Shape}              shape
 * @param  {Array} [offset] Local body offset of the shape.
 * @param  {Number}             [angle]  Local body angle.
 *
 * @example
 *     var body = new Body(),
 *         shape = new Circle();
 *
 *     // Add the shape to the body, positioned in the center
 *     body.addShape(shape);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.
 *     body.addShape(shape,[1,0]);
 *
 *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.
 *     body.addShape(shape,[0,1],Math.PI/2);
 */
Body.prototype.addShape = function(shape,offset,angle){
    angle = angle || 0.0;

    // Copy the offset vector
    if(offset){
        offset = vec2.fromValues(offset[0],offset[1]);
    } else {
        offset = vec2.fromValues(0,0);
    }

    this.shapes      .push(shape);
    this.shapeOffsets.push(offset);
    this.shapeAngles .push(angle);
    this.updateMassProperties();
    this.updateBoundingRadius();

    this.aabbNeedsUpdate = true;
};

/**
 * Remove a shape
 * @method removeShape
 * @param  {Shape}  shape
 * @return {Boolean}       True if the shape was found and removed, else false.
 */
Body.prototype.removeShape = function(shape){
    var idx = this.shapes.indexOf(shape);

    if(idx !== -1){
        this.shapes.splice(idx,1);
        this.shapeOffsets.splice(idx,1);
        this.shapeAngles.splice(idx,1);
        this.aabbNeedsUpdate = true;
        return true;
    } else {
        return false;
    }
};

/**
 * Updates .inertia, .invMass, .invInertia for this Body. Should be called when
 * changing the structure or mass of the Body.
 *
 * @method updateMassProperties
 *
 * @example
 *     body.mass += 1;
 *     body.updateMassProperties();
 */
Body.prototype.updateMassProperties = function(){
    if(this.type === Body.STATIC || this.type === Body.KINEMATIC){

        this.mass = Number.MAX_VALUE;
        this.invMass = 0;
        this.inertia = Number.MAX_VALUE;
        this.invInertia = 0;

    } else {

        var shapes = this.shapes,
            N = shapes.length,
            m = this.mass / N,
            I = 0;

        if(!this.fixedRotation){
            for(var i=0; i<N; i++){
                var shape = shapes[i],
                    r2 = vec2.squaredLength(this.shapeOffsets[i]),
                    Icm = shape.computeMomentOfInertia(m);
                I += Icm + m*r2;
            }
            this.inertia = I;
            this.invInertia = I>0 ? 1/I : 0;

        } else {
            this.inertia = Number.MAX_VALUE;
            this.invInertia = 0;
        }

        // Inverse mass properties are easy
        this.invMass = 1/this.mass;// > 0 ? 1/this.mass : 0;
    }
};

var Body_applyForce_r = vec2.create();

/**
 * Apply force to a world point. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce.
 * @method applyForce
 * @param {Array} force The force to add.
 * @param {Array} worldPoint A world point to apply the force on.
 */
Body.prototype.applyForce = function(force,worldPoint){
    // Compute point position relative to the body center
    var r = Body_applyForce_r;
    vec2.sub(r,worldPoint,this.position);

    // Add linear force
    vec2.add(this.force,this.force,force);

    // Compute produced rotational force
    var rotForce = vec2.crossLength(r,force);

    // Add rotational force
    this.angularForce += rotForce;
};

/**
 * Transform a world point to local body frame.
 * @method toLocalFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} worldPoint   The input world vector
 */
Body.prototype.toLocalFrame = function(out, worldPoint){
    vec2.toLocalFrame(out, worldPoint, this.position, this.angle);
};

/**
 * Transform a local point to world frame.
 * @method toWorldFrame
 * @param  {Array} out          The vector to store the result in
 * @param  {Array} localPoint   The input local vector
 */
Body.prototype.toWorldFrame = function(out, localPoint){
    vec2.toGlobalFrame(out, localPoint, this.position, this.angle);
};

/**
 * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.
 * @method fromPolygon
 * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.
 * @param {Object} [options]
 * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.
 * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.
 * @param {Boolean|Number} [options.removeCollinearPoints=false] Set to a number (angle threshold value) to remove collinear points, or false to keep all points.
 * @return {Boolean} True on success, else false.
 */
Body.prototype.fromPolygon = function(path,options){
    options = options || {};

    // Remove all shapes
    for(var i=this.shapes.length; i>=0; --i){
        this.removeShape(this.shapes[i]);
    }

    var p = new decomp.Polygon();
    p.vertices = path;

    // Make it counter-clockwise
    p.makeCCW();

    if(typeof(options.removeCollinearPoints) === "number"){
        p.removeCollinearPoints(options.removeCollinearPoints);
    }

    // Check if any line segment intersects the path itself
    if(typeof(options.skipSimpleCheck) === "undefined"){
        if(!p.isSimple()){
            return false;
        }
    }

    // Save this path for later
    this.concavePath = p.vertices.slice(0);
    for(var i=0; i<this.concavePath.length; i++){
        var v = [0,0];
        vec2.copy(v,this.concavePath[i]);
        this.concavePath[i] = v;
    }

    // Slow or fast decomp?
    var convexes;
    if(options.optimalDecomp){
        convexes = p.decomp();
    } else {
        convexes = p.quickDecomp();
    }

    var cm = vec2.create();

    // Add convexes
    for(var i=0; i!==convexes.length; i++){
        // Create convex
        var c = new Convex(convexes[i].vertices);

        // Move all vertices so its center of mass is in the local center of the convex
        for(var j=0; j!==c.vertices.length; j++){
            var v = c.vertices[j];
            vec2.sub(v,v,c.centerOfMass);
        }

        vec2.scale(cm,c.centerOfMass,1);
        c.updateTriangles();
        c.updateCenterOfMass();
        c.updateBoundingRadius();

        // Add the shape
        this.addShape(c,cm);
    }

    this.adjustCenterOfMass();

    this.aabbNeedsUpdate = true;

    return true;
};

var adjustCenterOfMass_tmp1 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp2 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp3 = vec2.fromValues(0,0),
    adjustCenterOfMass_tmp4 = vec2.fromValues(0,0);

/**
 * Moves the shape offsets so their center of mass becomes the body center of mass.
 * @method adjustCenterOfMass
 */
Body.prototype.adjustCenterOfMass = function(){
    var offset_times_area = adjustCenterOfMass_tmp2,
        sum =               adjustCenterOfMass_tmp3,
        cm =                adjustCenterOfMass_tmp4,
        totalArea =         0;
    vec2.set(sum,0,0);

    for(var i=0; i!==this.shapes.length; i++){
        var s = this.shapes[i],
            offset = this.shapeOffsets[i];
        vec2.scale(offset_times_area,offset,s.area);
        vec2.add(sum,sum,offset_times_area);
        totalArea += s.area;
    }

    vec2.scale(cm,sum,1/totalArea);

    // Now move all shapes
    for(var i=0; i!==this.shapes.length; i++){
        var s = this.shapes[i],
            offset = this.shapeOffsets[i];

        // Offset may be undefined. Fix that.
        if(!offset){
            offset = this.shapeOffsets[i] = vec2.create();
        }

        vec2.sub(offset,offset,cm);
    }

    // Move the body position too
    vec2.add(this.position,this.position,cm);

    // And concave path
    for(var i=0; this.concavePath && i<this.concavePath.length; i++){
        vec2.sub(this.concavePath[i], this.concavePath[i], cm);
    }

    this.updateMassProperties();
    this.updateBoundingRadius();
};

/**
 * Sets the force on the body to zero.
 * @method setZeroForce
 */
Body.prototype.setZeroForce = function(){
    vec2.set(this.force,0.0,0.0);
    this.angularForce = 0.0;
};

Body.prototype.resetConstraintVelocity = function(){
    var b = this,
        vlambda = b.vlambda;
    vec2.set(vlambda,0,0);
    b.wlambda = 0;
};

Body.prototype.addConstraintVelocity = function(){
    var b = this,
        v = b.velocity;
    vec2.add( v, v, b.vlambda);
    b.angularVelocity += b.wlambda;
};

/**
 * Apply damping, see <a href="http://code.google.com/p/bullet/issues/detail?id=74">this</a> for details.
 * @method applyDamping
 * @param  {number} dt Current time step
 */
Body.prototype.applyDamping = function(dt){
    if(this.type === Body.DYNAMIC){ // Only for dynamic bodies
        var v = this.velocity;
        vec2.scale(v, v, Math.pow(1.0 - this.damping,dt));
        this.angularVelocity *= Math.pow(1.0 - this.angularDamping,dt);
    }
};

/**
 * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.
 * Sets the sleepState to {{#crossLink "Body/AWAKE:property"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.
 * @method wakeUp
 */
Body.prototype.wakeUp = function(){
    var s = this.sleepState;
    this.sleepState = Body.AWAKE;
    this.idleTime = 0;
    if(s !== Body.AWAKE){
        this.emit(Body.wakeUpEvent);
    }
};

/**
 * Force body sleep
 * @method sleep
 */
Body.prototype.sleep = function(){
    this.sleepState = Body.SLEEPING;
    this.angularVelocity = 0;
    this.angularForce = 0;
    vec2.set(this.velocity,0,0);
    vec2.set(this.force,0,0);
    this.emit(Body.sleepEvent);
};

/**
 * Called every timestep to update internal sleep timer and change sleep state if needed.
 * @method sleepTick
 * @param {number} time The world time in seconds
 * @param {boolean} dontSleep
 * @param {number} dt
 */
Body.prototype.sleepTick = function(time, dontSleep, dt){
    if(!this.allowSleep || this.type === Body.SLEEPING){
        return;
    }

    this.wantsToSleep = false;

    var sleepState = this.sleepState,
        speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity,2),
        speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);

    // Add to idle time
    if(speedSquared >= speedLimitSquared){
        this.idleTime = 0;
        this.sleepState = Body.AWAKE;
    } else {
        this.idleTime += dt;
        this.sleepState = Body.SLEEPY;
    }
    if(this.idleTime > this.sleepTimeLimit){
        if(!dontSleep){
            this.sleep();
        } else {
            this.wantsToSleep = true;
        }
    }

    /*
    if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){
        this.sleepState = Body.SLEEPY; // Sleepy
        this.timeLastSleepy = time;
        this.emit(Body.sleepyEvent);
    } else if(sleepState===Body.SLEEPY && speedSquared >= speedLimitSquared){
        this.wakeUp(); // Wake up
    } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){
        this.wantsToSleep = true;
        if(!dontSleep){
            this.sleep();
        }
    }
    */
};

Body.prototype.getVelocityFromPosition = function(store, timeStep){
    store = store || vec2.create();
    vec2.sub(store, this.position, this.previousPosition);
    vec2.scale(store, store, 1/timeStep);
    return store;
};

Body.prototype.getAngularVelocityFromPosition = function(timeStep){
    return (this.angle - this.previousAngle) / timeStep;
};

/**
 * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.
 * @method overlaps
 * @param  {Body} body
 * @return {boolean}
 */
Body.prototype.overlaps = function(body){
    return this.world.overlapKeeper.bodiesAreOverlapping(this, body);
};

var integrate_fhMinv = vec2.create();
var integrate_velodt = vec2.create();

/**
 * Move the body forward in time given its current velocity.
 * @method integrate
 * @param  {Number} dt
 */
Body.prototype.integrate = function(dt){
    var minv = this.invMass,
        f = this.force,
        pos = this.position,
        velo = this.velocity;

    // Save old position
    vec2.copy(this.previousPosition, this.position);
    this.previousAngle = this.angle;

    // Velocity update
    if(!this.fixedRotation){
        this.angularVelocity += this.angularForce * this.invInertia * dt;
    }
    vec2.scale(integrate_fhMinv, f, dt * minv);
    vec2.add(velo, integrate_fhMinv, velo);

    // CCD
    if(!this.integrateToTimeOfImpact(dt)){

        // Regular position update
        vec2.scale(integrate_velodt, velo, dt);
        vec2.add(pos, pos, integrate_velodt);
        if(!this.fixedRotation){
            this.angle += this.angularVelocity * dt;
        }
    }

    this.aabbNeedsUpdate = true;
};

var direction = vec2.create();
var end = vec2.create();
var startToEnd = vec2.create();
var rememberPosition = vec2.create();
Body.prototype.integrateToTimeOfImpact = function(dt){

    if(this.ccdSpeedThreshold < 0 || vec2.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)){
        return false;
    }

    vec2.normalize(direction, this.velocity);

    vec2.scale(end, this.velocity, dt);
    vec2.add(end, end, this.position);

    vec2.sub(startToEnd, end, this.position);
    var startToEndAngle = this.angularVelocity * dt;
    var len = vec2.length(startToEnd);

    var timeOfImpact = 1;

    var hit;
    var that = this;
    this.world.raycastAll(this.position, end, {}, function (result) {
        if(result.body === that){
            return;
        }
        hit = result.body;
        vec2.copy(end, result.hitPointWorld);
        vec2.sub(startToEnd, result.hitPointWorld, that.position);
        timeOfImpact = vec2.length(startToEnd) / len;
        result.abort();
    });

    if(!hit){
        return false;
    }

    var rememberAngle = this.angle;
    vec2.copy(rememberPosition, this.position);

    // Got a start and end point. Approximate time of impact using binary search
    var iter = 0;
    var tmin = 0;
    var tmid = 0;
    var tmax = timeOfImpact;
    while (tmax >= tmin && iter < this.ccdIterations) {
        iter++;

        // calculate the midpoint
        tmid = (tmax - tmin) / 2;

        // Move the body to that point
        vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
        vec2.add(this.position, rememberPosition, integrate_velodt);
        this.angle = rememberAngle + startToEndAngle * timeOfImpact;
        this.updateAABB();

        // check overlap
        var overlaps = this.aabb.overlaps(hit.aabb) && this.world.narrowphase.bodiesOverlap(this, hit);

        if (overlaps) {
            // change min to search upper interval
            tmin = tmid;
        } else {
            // change max to search lower interval
            tmax = tmid;
        }
    }

    timeOfImpact = tmid;

    vec2.copy(this.position, rememberPosition);
    this.angle = rememberAngle;

    // move to TOI
    vec2.scale(integrate_velodt, startToEnd, timeOfImpact);
    vec2.add(this.position, this.position, integrate_velodt);
    if(!this.fixedRotation){
        this.angle += startToEndAngle * timeOfImpact;
    }

    return true;
};

/**
 * @event sleepy
 */
Body.sleepyEvent = {
    type: "sleepy"
};

/**
 * @event sleep
 */
Body.sleepEvent = {
    type: "sleep"
};

/**
 * @event wakeup
 */
Body.wakeUpEvent = {
    type: "wakeup"
};

/**
 * Dynamic body.
 * @property DYNAMIC
 * @type {Number}
 * @static
 */
Body.DYNAMIC = 1;

/**
 * Static body.
 * @property STATIC
 * @type {Number}
 * @static
 */
Body.STATIC = 2;

/**
 * Kinematic body.
 * @property KINEMATIC
 * @type {Number}
 * @static
 */
Body.KINEMATIC = 4;

/**
 * @property AWAKE
 * @type {Number}
 * @static
 */
Body.AWAKE = 0;

/**
 * @property SLEEPY
 * @type {Number}
 * @static
 */
Body.SLEEPY = 1;

/**
 * @property SLEEPING
 * @type {Number}
 * @static
 */
Body.SLEEPING = 2;


},{"../collision/AABB":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/AABB.js","../events/EventEmitter":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/events/EventEmitter.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../shapes/Convex":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Convex.js","poly-decomp":"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/LinearSpring.js":[function(require,module,exports){
var vec2 = require('../math/vec2');
var Spring = require('./Spring');
var Utils = require('../utils/Utils');

module.exports = LinearSpring;

/**
 * A spring, connecting two bodies.
 *
 * The Spring explicitly adds force and angularForce to the bodies.
 *
 * @class LinearSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 */
function LinearSpring(bodyA,bodyB,options){
    options = options || {};

    Spring.call(this, bodyA, bodyB, options);

    /**
     * Anchor for bodyA in local bodyA coordinates.
     * @property localAnchorA
     * @type {Array}
     */
    this.localAnchorA = vec2.fromValues(0,0);

    /**
     * Anchor for bodyB in local bodyB coordinates.
     * @property localAnchorB
     * @type {Array}
     */
    this.localAnchorB = vec2.fromValues(0,0);

    if(options.localAnchorA){ vec2.copy(this.localAnchorA, options.localAnchorA); }
    if(options.localAnchorB){ vec2.copy(this.localAnchorB, options.localAnchorB); }
    if(options.worldAnchorA){ this.setWorldAnchorA(options.worldAnchorA); }
    if(options.worldAnchorB){ this.setWorldAnchorB(options.worldAnchorB); }

    var worldAnchorA = vec2.create();
    var worldAnchorB = vec2.create();
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);
    var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);

    /**
     * Rest length of the spring.
     * @property restLength
     * @type {number}
     */
    this.restLength = typeof(options.restLength) === "number" ? options.restLength : worldDistance;
}
LinearSpring.prototype = new Spring();
LinearSpring.prototype.constructor = LinearSpring;

/**
 * Set the anchor point on body A, using world coordinates.
 * @method setWorldAnchorA
 * @param {Array} worldAnchorA
 */
LinearSpring.prototype.setWorldAnchorA = function(worldAnchorA){
    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);
};

/**
 * Set the anchor point on body B, using world coordinates.
 * @method setWorldAnchorB
 * @param {Array} worldAnchorB
 */
LinearSpring.prototype.setWorldAnchorB = function(worldAnchorB){
    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);
};

/**
 * Get the anchor point on body A, in world coordinates.
 * @method getWorldAnchorA
 * @param {Array} result The vector to store the result in.
 */
LinearSpring.prototype.getWorldAnchorA = function(result){
    this.bodyA.toWorldFrame(result, this.localAnchorA);
};

/**
 * Get the anchor point on body B, in world coordinates.
 * @method getWorldAnchorB
 * @param {Array} result The vector to store the result in.
 */
LinearSpring.prototype.getWorldAnchorB = function(result){
    this.bodyB.toWorldFrame(result, this.localAnchorB);
};

var applyForce_r =              vec2.create(),
    applyForce_r_unit =         vec2.create(),
    applyForce_u =              vec2.create(),
    applyForce_f =              vec2.create(),
    applyForce_worldAnchorA =   vec2.create(),
    applyForce_worldAnchorB =   vec2.create(),
    applyForce_ri =             vec2.create(),
    applyForce_rj =             vec2.create(),
    applyForce_tmp =            vec2.create();

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
LinearSpring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restLength,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        r = applyForce_r,
        r_unit = applyForce_r_unit,
        u = applyForce_u,
        f = applyForce_f,
        tmp = applyForce_tmp;

    var worldAnchorA = applyForce_worldAnchorA,
        worldAnchorB = applyForce_worldAnchorB,
        ri = applyForce_ri,
        rj = applyForce_rj;

    // Get world anchors
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);

    // Get offset points
    vec2.sub(ri, worldAnchorA, bodyA.position);
    vec2.sub(rj, worldAnchorB, bodyB.position);

    // Compute distance vector between world anchor points
    vec2.sub(r, worldAnchorB, worldAnchorA);
    var rlen = vec2.len(r);
    vec2.normalize(r_unit,r);

    //console.log(rlen)
    //console.log("A",vec2.str(worldAnchorA),"B",vec2.str(worldAnchorB))

    // Compute relative velocity of the anchor points, u
    vec2.sub(u, bodyB.velocity, bodyA.velocity);
    vec2.crossZV(tmp, bodyB.angularVelocity, rj);
    vec2.add(u, u, tmp);
    vec2.crossZV(tmp, bodyA.angularVelocity, ri);
    vec2.sub(u, u, tmp);

    // F = - k * ( x - L ) - D * ( u )
    vec2.scale(f, r_unit, -k*(rlen-l) - d*vec2.dot(u,r_unit));

    // Add forces to bodies
    vec2.sub( bodyA.force, bodyA.force, f);
    vec2.add( bodyB.force, bodyB.force, f);

    // Angular force
    var ri_x_f = vec2.crossLength(ri, f);
    var rj_x_f = vec2.crossLength(rj, f);
    bodyA.angularForce -= ri_x_f;
    bodyB.angularForce += rj_x_f;
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js","./Spring":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/Spring.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/RotationalSpring.js":[function(require,module,exports){
var vec2 = require('../math/vec2');
var Spring = require('./Spring');

module.exports = RotationalSpring;

/**
 * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.
 *
 * The spring can be combined with a {{#crossLink "RevoluteConstraint"}}{{/crossLink}} to make, for example, a mouse trap.
 *
 * @class RotationalSpring
 * @extends Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.
 * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1] A number >= 0.
 */
function RotationalSpring(bodyA, bodyB, options){
    options = options || {};

    Spring.call(this, bodyA, bodyB, options);

    /**
     * Rest angle of the spring.
     * @property restAngle
     * @type {number}
     */
    this.restAngle = typeof(options.restAngle) === "number" ? options.restAngle : bodyB.angle - bodyA.angle;
}
RotationalSpring.prototype = new Spring();
RotationalSpring.prototype.constructor = RotationalSpring;

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
RotationalSpring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restAngle,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        x = bodyB.angle - bodyA.angle,
        u = bodyB.angularVelocity - bodyA.angularVelocity;

    var torque = - k * (x - l) - d * u * 0;

    bodyA.angularForce -= torque;
    bodyB.angularForce += torque;
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Spring":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/Spring.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/Spring.js":[function(require,module,exports){
var vec2 = require('../math/vec2');
var Utils = require('../utils/Utils');

module.exports = Spring;

/**
 * A spring, connecting two bodies. The Spring explicitly adds force and angularForce to the bodies and does therefore not put load on the constraint solver.
 *
 * @class Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.
 * @param {number} [options.damping=1]      A number >= 0. Default: 1
 * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.
 * @param {Array}  [options.localAnchorB]
 * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option "localAnchorA" if given.
 * @param {Array}  [options.worldAnchorB]
 */
function Spring(bodyA, bodyB, options){
    options = Utils.defaults(options,{
        stiffness: 100,
        damping: 1,
    });

    /**
     * Stiffness of the spring.
     * @property stiffness
     * @type {number}
     */
    this.stiffness = options.stiffness;

    /**
     * Damping of the spring.
     * @property damping
     * @type {number}
     */
    this.damping = options.damping;

    /**
     * First connected body.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second connected body.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;
}

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
Spring.prototype.applyForce = function(){
    // To be implemented by subclasses
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/p2.js":[function(require,module,exports){
// Export p2 classes
module.exports = {
    AABB :                          require('./collision/AABB'),
    AngleLockEquation :             require('./equations/AngleLockEquation'),
    Body :                          require('./objects/Body'),
    Broadphase :                    require('./collision/Broadphase'),
    Capsule :                       require('./shapes/Capsule'),
    Circle :                        require('./shapes/Circle'),
    Constraint :                    require('./constraints/Constraint'),
    ContactEquation :               require('./equations/ContactEquation'),
    ContactMaterial :               require('./material/ContactMaterial'),
    Convex :                        require('./shapes/Convex'),
    DistanceConstraint :            require('./constraints/DistanceConstraint'),
    Equation :                      require('./equations/Equation'),
    EventEmitter :                  require('./events/EventEmitter'),
    FrictionEquation :              require('./equations/FrictionEquation'),
    GearConstraint :                require('./constraints/GearConstraint'),
    GridBroadphase :                require('./collision/GridBroadphase'),
    GSSolver :                      require('./solver/GSSolver'),
    Heightfield :                   require('./shapes/Heightfield'),
    Line :                          require('./shapes/Line'),
    LockConstraint :                require('./constraints/LockConstraint'),
    Material :                      require('./material/Material'),
    Narrowphase :                   require('./collision/Narrowphase'),
    NaiveBroadphase :               require('./collision/NaiveBroadphase'),
    Particle :                      require('./shapes/Particle'),
    Plane :                         require('./shapes/Plane'),
    RevoluteConstraint :            require('./constraints/RevoluteConstraint'),
    PrismaticConstraint :           require('./constraints/PrismaticConstraint'),
    Ray :                           require('./collision/Ray'),
    RaycastResult :                 require('./collision/RaycastResult'),
    Rectangle :                     require('./shapes/Rectangle'),
    RotationalVelocityEquation :    require('./equations/RotationalVelocityEquation'),
    SAPBroadphase :                 require('./collision/SAPBroadphase'),
    Shape :                         require('./shapes/Shape'),
    Solver :                        require('./solver/Solver'),
    Spring :                        require('./objects/Spring'),
    LinearSpring :                  require('./objects/LinearSpring'),
    RotationalSpring :              require('./objects/RotationalSpring'),
    Utils :                         require('./utils/Utils'),
    World :                         require('./world/World'),
    vec2 :                          require('./math/vec2'),
    version :                       require('../package.json').version,
};

},{"../package.json":"/Users/tyemilldeveloper/space-game/node_modules/p2/package.json","./collision/AABB":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/AABB.js","./collision/Broadphase":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/Broadphase.js","./collision/GridBroadphase":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/GridBroadphase.js","./collision/NaiveBroadphase":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/NaiveBroadphase.js","./collision/Narrowphase":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/Narrowphase.js","./collision/Ray":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/Ray.js","./collision/RaycastResult":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/RaycastResult.js","./collision/SAPBroadphase":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/SAPBroadphase.js","./constraints/Constraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/Constraint.js","./constraints/DistanceConstraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/DistanceConstraint.js","./constraints/GearConstraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/GearConstraint.js","./constraints/LockConstraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/LockConstraint.js","./constraints/PrismaticConstraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/PrismaticConstraint.js","./constraints/RevoluteConstraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/RevoluteConstraint.js","./equations/AngleLockEquation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/AngleLockEquation.js","./equations/ContactEquation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/ContactEquation.js","./equations/Equation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/Equation.js","./equations/FrictionEquation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/FrictionEquation.js","./equations/RotationalVelocityEquation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/RotationalVelocityEquation.js","./events/EventEmitter":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/events/EventEmitter.js","./material/ContactMaterial":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/material/ContactMaterial.js","./material/Material":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/material/Material.js","./math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./objects/Body":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/Body.js","./objects/LinearSpring":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/LinearSpring.js","./objects/RotationalSpring":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/RotationalSpring.js","./objects/Spring":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/Spring.js","./shapes/Capsule":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Capsule.js","./shapes/Circle":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Circle.js","./shapes/Convex":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Convex.js","./shapes/Heightfield":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Heightfield.js","./shapes/Line":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Line.js","./shapes/Particle":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Particle.js","./shapes/Plane":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Plane.js","./shapes/Rectangle":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Rectangle.js","./shapes/Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js","./solver/GSSolver":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/solver/GSSolver.js","./solver/Solver":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/solver/Solver.js","./utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js","./world/World":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/world/World.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Capsule.js":[function(require,module,exports){
var Shape = require('./Shape')
,   vec2 = require('../math/vec2');

module.exports = Capsule;

/**
 * Capsule shape class.
 * @class Capsule
 * @constructor
 * @extends Shape
 * @param {Number} [length=1] The distance between the end points
 * @param {Number} [radius=1] Radius of the capsule
 * @example
 *     var radius = 1;
 *     var length = 2;
 *     var capsuleShape = new Capsule(length, radius);
 *     body.addShape(capsuleShape);
 */
function Capsule(length, radius){

    /**
     * The distance between the end points.
     * @property {Number} length
     */
    this.length = length || 1;

    /**
     * The radius of the capsule.
     * @property {Number} radius
     */
    this.radius = radius || 1;

    Shape.call(this,Shape.CAPSULE);
}
Capsule.prototype = new Shape();
Capsule.prototype.constructor = Capsule;

/**
 * Compute the mass moment of inertia of the Capsule.
 * @method conputeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @todo
 */
Capsule.prototype.computeMomentOfInertia = function(mass){
    // Approximate with rectangle
    var r = this.radius,
        w = this.length + r, // 2*r is too much, 0 is too little
        h = r*2;
    return mass * (h*h + w*w) / 12;
};

/**
 * @method updateBoundingRadius
 */
Capsule.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.radius + this.length/2;
};

/**
 * @method updateArea
 */
Capsule.prototype.updateArea = function(){
    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;
};

var r = vec2.create();

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Capsule.prototype.computeAABB = function(out, position, angle){
    var radius = this.radius;

    // Compute center position of one of the the circles, world oriented, but with local offset
    vec2.set(r,this.length / 2,0);
    if(angle !== 0){
        vec2.rotate(r,r,angle);
    }

    // Get bounds
    vec2.set(out.upperBound,  Math.max(r[0]+radius, -r[0]+radius),
                              Math.max(r[1]+radius, -r[1]+radius));
    vec2.set(out.lowerBound,  Math.min(r[0]-radius, -r[0]-radius),
                              Math.min(r[1]-radius, -r[1]-radius));

    // Add offset
    vec2.add(out.lowerBound, out.lowerBound, position);
    vec2.add(out.upperBound, out.upperBound, position);
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Circle.js":[function(require,module,exports){
var Shape = require('./Shape')
,    vec2 = require('../math/vec2');

module.exports = Circle;

/**
 * Circle shape class.
 * @class Circle
 * @extends Shape
 * @constructor
 * @param {number} [radius=1] The radius of this circle
 *
 * @example
 *     var radius = 1;
 *     var circleShape = new Circle(radius);
 *     body.addShape(circleShape);
 */
function Circle(radius){

    /**
     * The radius of the circle.
     * @property radius
     * @type {number}
     */
    this.radius = radius || 1;

    Shape.call(this,Shape.CIRCLE);
}
Circle.prototype = new Shape();
Circle.prototype.constructor = Circle;

/**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Circle.prototype.computeMomentOfInertia = function(mass){
    var r = this.radius;
    return mass * r * r / 2;
};

/**
 * @method updateBoundingRadius
 * @return {Number}
 */
Circle.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.radius;
};

/**
 * @method updateArea
 * @return {Number}
 */
Circle.prototype.updateArea = function(){
    this.area = Math.PI * this.radius * this.radius;
};

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Circle.prototype.computeAABB = function(out, position, angle){
    var r = this.radius;
    vec2.set(out.upperBound,  r,  r);
    vec2.set(out.lowerBound, -r, -r);
    if(position){
        vec2.add(out.lowerBound, out.lowerBound, position);
        vec2.add(out.upperBound, out.upperBound, position);
    }
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Convex.js":[function(require,module,exports){
var Shape = require('./Shape')
,   vec2 = require('../math/vec2')
,   polyk = require('../math/polyk')
,   decomp = require('poly-decomp');

module.exports = Convex;

/**
 * Convex shape class.
 * @class Convex
 * @constructor
 * @extends Shape
 * @param {Array} vertices An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.
 * @param {Array} [axes] An array of unit length vectors, representing the symmetry axes in the convex.
 * @example
 *     // Create a box
 *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];
 *     var convexShape = new Convex(vertices);
 *     body.addShape(convexShape);
 */
function Convex(vertices, axes){

    /**
     * Vertices defined in the local frame.
     * @property vertices
     * @type {Array}
     */
    this.vertices = [];

    /**
     * Axes defined in the local frame.
     * @property axes
     * @type {Array}
     */
    this.axes = [];

    // Copy the verts
    for(var i=0; i<vertices.length; i++){
        var v = vec2.create();
        vec2.copy(v,vertices[i]);
        this.vertices.push(v);
    }

    if(axes){
        // Copy the axes
        for(var i=0; i < axes.length; i++){
            var axis = vec2.create();
            vec2.copy(axis, axes[i]);
            this.axes.push(axis);
        }
    } else {
        // Construct axes from the vertex data
        for(var i = 0; i < vertices.length; i++){
            // Get the world edge
            var worldPoint0 = vertices[i];
            var worldPoint1 = vertices[(i+1) % vertices.length];

            var normal = vec2.create();
            vec2.sub(normal, worldPoint1, worldPoint0);

            // Get normal - just rotate 90 degrees since vertices are given in CCW
            vec2.rotate90cw(normal, normal);
            vec2.normalize(normal, normal);

            this.axes.push(normal);
        }
    }

    /**
     * The center of mass of the Convex
     * @property centerOfMass
     * @type {Array}
     */
    this.centerOfMass = vec2.fromValues(0,0);

    /**
     * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.
     * @property triangles
     * @type {Array}
     */
    this.triangles = [];

    if(this.vertices.length){
        this.updateTriangles();
        this.updateCenterOfMass();
    }

    /**
     * The bounding radius of the convex
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    Shape.call(this, Shape.CONVEX);

    this.updateBoundingRadius();
    this.updateArea();
    if(this.area < 0){
        throw new Error("Convex vertices must be given in conter-clockwise winding.");
    }
}
Convex.prototype = new Shape();
Convex.prototype.constructor = Convex;

var tmpVec1 = vec2.create();
var tmpVec2 = vec2.create();

/**
 * Project a Convex onto a world-oriented axis
 * @method projectOntoAxis
 * @static
 * @param  {Array} offset
 * @param  {Array} localAxis
 * @param  {Array} result
 */
Convex.prototype.projectOntoLocalAxis = function(localAxis, result){
    var max=null,
        min=null,
        v,
        value,
        localAxis = tmpVec1;

    // Get projected position of all vertices
    for(var i=0; i<this.vertices.length; i++){
        v = this.vertices[i];
        value = vec2.dot(v, localAxis);
        if(max === null || value > max){
            max = value;
        }
        if(min === null || value < min){
            min = value;
        }
    }

    if(min > max){
        var t = min;
        min = max;
        max = t;
    }

    vec2.set(result, min, max);
};

Convex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result){
    var worldAxis = tmpVec2;

    this.projectOntoLocalAxis(localAxis, result);

    // Project the position of the body onto the axis - need to add this to the result
    if(shapeAngle !== 0){
        vec2.rotate(worldAxis, localAxis, shapeAngle);
    } else {
        worldAxis = localAxis;
    }
    var offset = vec2.dot(shapeOffset, worldAxis);

    vec2.set(result, result[0] + offset, result[1] + offset);
};


/**
 * Update the .triangles property
 * @method updateTriangles
 */
Convex.prototype.updateTriangles = function(){

    this.triangles.length = 0;

    // Rewrite on polyk notation, array of numbers
    var polykVerts = [];
    for(var i=0; i<this.vertices.length; i++){
        var v = this.vertices[i];
        polykVerts.push(v[0],v[1]);
    }

    // Triangulate
    var triangles = polyk.Triangulate(polykVerts);

    // Loop over all triangles, add their inertia contributions to I
    for(var i=0; i<triangles.length; i+=3){
        var id1 = triangles[i],
            id2 = triangles[i+1],
            id3 = triangles[i+2];

        // Add to triangles
        this.triangles.push([id1,id2,id3]);
    }
};

var updateCenterOfMass_centroid = vec2.create(),
    updateCenterOfMass_centroid_times_mass = vec2.create(),
    updateCenterOfMass_a = vec2.create(),
    updateCenterOfMass_b = vec2.create(),
    updateCenterOfMass_c = vec2.create(),
    updateCenterOfMass_ac = vec2.create(),
    updateCenterOfMass_ca = vec2.create(),
    updateCenterOfMass_cb = vec2.create(),
    updateCenterOfMass_n = vec2.create();

/**
 * Update the .centerOfMass property.
 * @method updateCenterOfMass
 */
Convex.prototype.updateCenterOfMass = function(){
    var triangles = this.triangles,
        verts = this.vertices,
        cm = this.centerOfMass,
        centroid = updateCenterOfMass_centroid,
        n = updateCenterOfMass_n,
        a = updateCenterOfMass_a,
        b = updateCenterOfMass_b,
        c = updateCenterOfMass_c,
        ac = updateCenterOfMass_ac,
        ca = updateCenterOfMass_ca,
        cb = updateCenterOfMass_cb,
        centroid_times_mass = updateCenterOfMass_centroid_times_mass;

    vec2.set(cm,0,0);
    var totalArea = 0;

    for(var i=0; i!==triangles.length; i++){
        var t = triangles[i],
            a = verts[t[0]],
            b = verts[t[1]],
            c = verts[t[2]];

        vec2.centroid(centroid,a,b,c);

        // Get mass for the triangle (density=1 in this case)
        // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors
        var m = Convex.triangleArea(a,b,c);
        totalArea += m;

        // Add to center of mass
        vec2.scale(centroid_times_mass, centroid, m);
        vec2.add(cm, cm, centroid_times_mass);
    }

    vec2.scale(cm,cm,1/totalArea);
};

/**
 * Compute the mass moment of inertia of the Convex.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/
 */
Convex.prototype.computeMomentOfInertia = function(mass){
    var denom = 0.0,
        numer = 0.0,
        N = this.vertices.length;
    for(var j = N-1, i = 0; i < N; j = i, i ++){
        var p0 = this.vertices[j];
        var p1 = this.vertices[i];
        var a = Math.abs(vec2.crossLength(p0,p1));
        var b = vec2.dot(p1,p1) + vec2.dot(p1,p0) + vec2.dot(p0,p0);
        denom += a * b;
        numer += a;
    }
    return (mass / 6.0) * (denom / numer);
};

/**
 * Updates the .boundingRadius property
 * @method updateBoundingRadius
 */
Convex.prototype.updateBoundingRadius = function(){
    var verts = this.vertices,
        r2 = 0;

    for(var i=0; i!==verts.length; i++){
        var l2 = vec2.squaredLength(verts[i]);
        if(l2 > r2){
            r2 = l2;
        }
    }

    this.boundingRadius = Math.sqrt(r2);
};

/**
 * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.
 * @static
 * @method triangleArea
 * @param {Array} a
 * @param {Array} b
 * @param {Array} c
 * @return {Number}
 */
Convex.triangleArea = function(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1]))) * 0.5;
};

/**
 * Update the .area
 * @method updateArea
 */
Convex.prototype.updateArea = function(){
    this.updateTriangles();
    this.area = 0;

    var triangles = this.triangles,
        verts = this.vertices;
    for(var i=0; i!==triangles.length; i++){
        var t = triangles[i],
            a = verts[t[0]],
            b = verts[t[1]],
            c = verts[t[2]];

        // Get mass for the triangle (density=1 in this case)
        var m = Convex.triangleArea(a,b,c);
        this.area += m;
    }
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Convex.prototype.computeAABB = function(out, position, angle){
    out.setFromPoints(this.vertices, position, angle, 0);
};

},{"../math/polyk":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/polyk.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js","poly-decomp":"/Users/tyemilldeveloper/space-game/node_modules/p2/node_modules/poly-decomp/src/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Heightfield.js":[function(require,module,exports){
var Shape = require('./Shape')
,    vec2 = require('../math/vec2')
,    Utils = require('../utils/Utils');

module.exports = Heightfield;

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance "elementWidth".
 * @class Heightfield
 * @extends Shape
 * @constructor
 * @param {Array} data An array of Y values that will be used to construct the terrain.
 * @param {object} options
 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
 * @param {Number} [options.maxValue] Maximum value.
 * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.
 * @todo Should be possible to use along all axes, not just y
 *
 * @example
 *     // Generate some height data (y-values).
 *     var data = [];
 *     for(var i = 0; i < 1000; i++){
 *         var y = 0.5 * Math.cos(0.2 * i);
 *         data.push(y);
 *     }
 *
 *     // Create the heightfield shape
 *     var heightfieldShape = new Heightfield(data, {
 *         elementWidth: 1 // Distance between the data points in X direction
 *     });
 *     var heightfieldBody = new Body();
 *     heightfieldBody.addShape(heightfieldShape);
 *     world.addBody(heightfieldBody);
 */
function Heightfield(data, options){
    options = Utils.defaults(options, {
        maxValue : null,
        minValue : null,
        elementWidth : 0.1
    });

    if(options.minValue === null || options.maxValue === null){
        options.maxValue = data[0];
        options.minValue = data[0];
        for(var i=0; i !== data.length; i++){
            var v = data[i];
            if(v > options.maxValue){
                options.maxValue = v;
            }
            if(v < options.minValue){
                options.minValue = v;
            }
        }
    }

    /**
     * An array of numbers, or height values, that are spread out along the x axis.
     * @property {array} data
     */
    this.data = data;

    /**
     * Max value of the data
     * @property {number} maxValue
     */
    this.maxValue = options.maxValue;

    /**
     * Max value of the data
     * @property {number} minValue
     */
    this.minValue = options.minValue;

    /**
     * The width of each element
     * @property {number} elementWidth
     */
    this.elementWidth = options.elementWidth;

    Shape.call(this,Shape.HEIGHTFIELD);
}
Heightfield.prototype = new Shape();
Heightfield.prototype.constructor = Heightfield;

/**
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Heightfield.prototype.computeMomentOfInertia = function(mass){
    return Number.MAX_VALUE;
};

Heightfield.prototype.updateBoundingRadius = function(){
    this.boundingRadius = Number.MAX_VALUE;
};

Heightfield.prototype.updateArea = function(){
    var data = this.data,
        area = 0;
    for(var i=0; i<data.length-1; i++){
        area += (data[i]+data[i+1]) / 2 * this.elementWidth;
    }
    this.area = area;
};

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Heightfield.prototype.computeAABB = function(out, position, angle){
    // Use the max data rectangle
    out.upperBound[0] = this.elementWidth * this.data.length + position[0];
    out.upperBound[1] = this.maxValue + position[1];
    out.lowerBound[0] = position[0];
    out.lowerBound[1] = -Number.MAX_VALUE; // Infinity
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js","./Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Line.js":[function(require,module,exports){
var Shape = require('./Shape')
,   vec2 = require('../math/vec2');

module.exports = Line;

/**
 * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
 * @class Line
 * @param {Number} [length=1] The total length of the line
 * @extends Shape
 * @constructor
 */
function Line(length){

    /**
     * Length of this line
     * @property length
     * @type {Number}
     */
    this.length = length || 1;

    Shape.call(this,Shape.LINE);
}
Line.prototype = new Shape();
Line.prototype.constructor = Line;

Line.prototype.computeMomentOfInertia = function(mass){
    return mass * Math.pow(this.length,2) / 12;
};

Line.prototype.updateBoundingRadius = function(){
    this.boundingRadius = this.length/2;
};

var points = [vec2.create(),vec2.create()];

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Line.prototype.computeAABB = function(out, position, angle){
    var l2 = this.length / 2;
    vec2.set(points[0], -l2,  0);
    vec2.set(points[1],  l2,  0);
    out.setFromPoints(points,position,angle,0);
};


},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Particle.js":[function(require,module,exports){
var Shape = require('./Shape')
,   vec2 = require('../math/vec2');

module.exports = Particle;

/**
 * Particle shape class.
 * @class Particle
 * @constructor
 * @extends Shape
 */
function Particle(){
    Shape.call(this,Shape.PARTICLE);
}
Particle.prototype = new Shape();
Particle.prototype.constructor = Particle;

Particle.prototype.computeMomentOfInertia = function(mass){
    return 0; // Can't rotate a particle
};

Particle.prototype.updateBoundingRadius = function(){
    this.boundingRadius = 0;
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Particle.prototype.computeAABB = function(out, position, angle){
    vec2.copy(out.lowerBound, position);
    vec2.copy(out.upperBound, position);
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Plane.js":[function(require,module,exports){
var Shape =  require('./Shape')
,    vec2 =  require('../math/vec2')
,    Utils = require('../utils/Utils');

module.exports = Plane;

/**
 * Plane shape class. The plane is facing in the Y direction.
 * @class Plane
 * @extends Shape
 * @constructor
 */
function Plane(){
    Shape.call(this,Shape.PLANE);
}
Plane.prototype = new Shape();
Plane.prototype.constructor = Plane;

/**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 */
Plane.prototype.computeMomentOfInertia = function(mass){
    return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here
};

/**
 * Update the bounding radius
 * @method updateBoundingRadius
 */
Plane.prototype.updateBoundingRadius = function(){
    this.boundingRadius = Number.MAX_VALUE;
};

/**
 * @method computeAABB
 * @param  {AABB}   out
 * @param  {Array}  position
 * @param  {Number} angle
 */
Plane.prototype.computeAABB = function(out, position, angle){
    var a = 0,
        set = vec2.set;
    if(typeof(angle) === "number"){
        a = angle % (2*Math.PI);
    }

    if(a === 0){
        // y goes from -inf to 0
        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
        set(out.upperBound,  Number.MAX_VALUE,  0);
    } else if(a === Math.PI / 2){
        // x goes from 0 to inf
        set(out.lowerBound, 0, -Number.MAX_VALUE);
        set(out.upperBound,      Number.MAX_VALUE,  Number.MAX_VALUE);
    } else if(a === Math.PI){
        // y goes from 0 to inf
        set(out.lowerBound, -Number.MAX_VALUE, 0);
        set(out.upperBound,  Number.MAX_VALUE, Number.MAX_VALUE);
    } else if(a === 3*Math.PI/2){
        // x goes from -inf to 0
        set(out.lowerBound, -Number.MAX_VALUE,     -Number.MAX_VALUE);
        set(out.upperBound,  0,  Number.MAX_VALUE);
    } else {
        // Set max bounds
        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);
        set(out.upperBound,  Number.MAX_VALUE,  Number.MAX_VALUE);
    }

    vec2.add(out.lowerBound, out.lowerBound, position);
    vec2.add(out.upperBound, out.upperBound, position);
};

Plane.prototype.updateArea = function(){
    this.area = Number.MAX_VALUE;
};


},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js","./Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Rectangle.js":[function(require,module,exports){
var vec2 = require('../math/vec2')
,   Shape = require('./Shape')
,   Convex = require('./Convex');

module.exports = Rectangle;

/**
 * Rectangle shape class.
 * @class Rectangle
 * @constructor
 * @param {Number} [width=1] Width
 * @param {Number} [height=1] Height
 * @extends Convex
 */
function Rectangle(width, height){

    /**
     * Total width of the rectangle
     * @property width
     * @type {Number}
     */
    this.width = width || 1;

    /**
     * Total height of the rectangle
     * @property height
     * @type {Number}
     */
    this.height = height || 1;

    var verts = [   vec2.fromValues(-width/2, -height/2),
                    vec2.fromValues( width/2, -height/2),
                    vec2.fromValues( width/2,  height/2),
                    vec2.fromValues(-width/2,  height/2)];
    var axes = [vec2.fromValues(1, 0), vec2.fromValues(0, 1)];

    Convex.call(this, verts, axes);

    this.type = Shape.RECTANGLE;
}
Rectangle.prototype = new Convex([]);
Rectangle.prototype.constructor = Rectangle;

/**
 * Compute moment of inertia
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number}
 */
Rectangle.prototype.computeMomentOfInertia = function(mass){
    var w = this.width,
        h = this.height;
    return mass * (h*h + w*w) / 12;
};

/**
 * Update the bounding radius
 * @method updateBoundingRadius
 */
Rectangle.prototype.updateBoundingRadius = function(){
    var w = this.width,
        h = this.height;
    this.boundingRadius = Math.sqrt(w*w + h*h) / 2;
};

var corner1 = vec2.create(),
    corner2 = vec2.create(),
    corner3 = vec2.create(),
    corner4 = vec2.create();

/**
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Rectangle.prototype.computeAABB = function(out, position, angle){
    out.setFromPoints(this.vertices,position,angle,0);
};

Rectangle.prototype.updateArea = function(){
    this.area = this.width * this.height;
};


},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","./Convex":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Convex.js","./Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js":[function(require,module,exports){
module.exports = Shape;

/**
 * Base class for shapes.
 * @class Shape
 * @constructor
 * @param {Number} type
 */
function Shape(type){

    /**
     * The type of the shape. One of:
     *
     * * {{#crossLink "Shape/CIRCLE:property"}}Shape.CIRCLE{{/crossLink}}
     * * {{#crossLink "Shape/PARTICLE:property"}}Shape.PARTICLE{{/crossLink}}
     * * {{#crossLink "Shape/PLANE:property"}}Shape.PLANE{{/crossLink}}
     * * {{#crossLink "Shape/CONVEX:property"}}Shape.CONVEX{{/crossLink}}
     * * {{#crossLink "Shape/LINE:property"}}Shape.LINE{{/crossLink}}
     * * {{#crossLink "Shape/RECTANGLE:property"}}Shape.RECTANGLE{{/crossLink}}
     * * {{#crossLink "Shape/CAPSULE:property"}}Shape.CAPSULE{{/crossLink}}
     * * {{#crossLink "Shape/HEIGHTFIELD:property"}}Shape.HEIGHTFIELD{{/crossLink}}
     *
     * @property {number} type
     */
    this.type = type;

    /**
     * Shape object identifier.
     * @type {Number}
     * @property id
     */
    this.id = Shape.idCounter++;

    /**
     * Bounding circle radius of this shape
     * @property boundingRadius
     * @type {Number}
     */
    this.boundingRadius = 0;

    /**
     * Collision group that this shape belongs to (bit mask). See <a href="http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/">this tutorial</a>.
     * @property collisionGroup
     * @type {Number}
     * @example
     *     // Setup bits for each available group
     *     var PLAYER = Math.pow(2,0),
     *         ENEMY =  Math.pow(2,1),
     *         GROUND = Math.pow(2,2)
     *
     *     // Put shapes into their groups
     *     player1Shape.collisionGroup = PLAYER;
     *     player2Shape.collisionGroup = PLAYER;
     *     enemyShape  .collisionGroup = ENEMY;
     *     groundShape .collisionGroup = GROUND;
     *
     *     // Assign groups that each shape collide with.
     *     // Note that the players can collide with ground and enemies, but not with other players.
     *     player1Shape.collisionMask = ENEMY | GROUND;
     *     player2Shape.collisionMask = ENEMY | GROUND;
     *     enemyShape  .collisionMask = PLAYER | GROUND;
     *     groundShape .collisionMask = PLAYER | ENEMY;
     *
     * @example
     *     // How collision check is done
     *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){
     *         // The shapes will collide
     *     }
     */
    this.collisionGroup = 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this shape will move through other body shapes, but it will still trigger contact events, etc.
     * @property {Boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * Collision mask of this shape. See .collisionGroup.
     * @property collisionMask
     * @type {Number}
     */
    this.collisionMask =  1;
    if(type){
        this.updateBoundingRadius();
    }

    /**
     * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.
     * @property material
     * @type {Material}
     */
    this.material = null;

    /**
     * Area of this shape.
     * @property area
     * @type {Number}
     */
    this.area = 0;

    /**
     * Set to true if you want this shape to be a sensor. A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.
     * @property {Boolean} sensor
     */
    this.sensor = false;

    this.updateArea();
}

Shape.idCounter = 0;

/**
 * @static
 * @property {Number} CIRCLE
 */
Shape.CIRCLE =      1;

/**
 * @static
 * @property {Number} PARTICLE
 */
Shape.PARTICLE =    2;

/**
 * @static
 * @property {Number} PLANE
 */
Shape.PLANE =       4;

/**
 * @static
 * @property {Number} CONVEX
 */
Shape.CONVEX =      8;

/**
 * @static
 * @property {Number} LINE
 */
Shape.LINE =        16;

/**
 * @static
 * @property {Number} RECTANGLE
 */
Shape.RECTANGLE =   32;

/**
 * @static
 * @property {Number} CAPSULE
 */
Shape.CAPSULE =     64;

/**
 * @static
 * @property {Number} HEIGHTFIELD
 */
Shape.HEIGHTFIELD = 128;

/**
 * Should return the moment of inertia around the Z axis of the body given the total mass. See <a href="http://en.wikipedia.org/wiki/List_of_moments_of_inertia">Wikipedia's list of moments of inertia</a>.
 * @method computeMomentOfInertia
 * @param  {Number} mass
 * @return {Number} If the inertia is infinity or if the object simply isn't possible to rotate, return 0.
 */
Shape.prototype.computeMomentOfInertia = function(mass){
    throw new Error("Shape.computeMomentOfInertia is not implemented in this Shape...");
};

/**
 * Returns the bounding circle radius of this shape.
 * @method updateBoundingRadius
 * @return {Number}
 */
Shape.prototype.updateBoundingRadius = function(){
    throw new Error("Shape.updateBoundingRadius is not implemented in this Shape...");
};

/**
 * Update the .area property of the shape.
 * @method updateArea
 */
Shape.prototype.updateArea = function(){
    // To be implemented in all subclasses
};

/**
 * Compute the world axis-aligned bounding box (AABB) of this shape.
 * @method computeAABB
 * @param  {AABB}   out      The resulting AABB.
 * @param  {Array}  position
 * @param  {Number} angle
 */
Shape.prototype.computeAABB = function(out, position, angle){
    // To be implemented in each subclass
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/solver/GSSolver.js":[function(require,module,exports){
var vec2 = require('../math/vec2')
,   Solver = require('./Solver')
,   Utils = require('../utils/Utils')
,   FrictionEquation = require('../equations/FrictionEquation');

module.exports = GSSolver;

/**
 * Iterative Gauss-Seidel constraint equation solver.
 *
 * @class GSSolver
 * @constructor
 * @extends Solver
 * @param {Object} [options]
 * @param {Number} [options.iterations=10]
 * @param {Number} [options.tolerance=0]
 */
function GSSolver(options){
    Solver.call(this,options,Solver.GS);
    options = options || {};

    /**
     * The number of iterations to do when solving. More gives better results, but is more expensive.
     * @property iterations
     * @type {Number}
     */
    this.iterations = options.iterations || 10;

    /**
     * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.
     * @property tolerance
     * @type {Number}
     */
    this.tolerance = options.tolerance || 1e-10;

    this.arrayStep = 30;
    this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);
    this.Bs =     new Utils.ARRAY_TYPE(this.arrayStep);
    this.invCs =  new Utils.ARRAY_TYPE(this.arrayStep);

    /**
     * Set to true to set all right hand side terms to zero when solving. Can be handy for a few applications.
     * @property useZeroRHS
     * @type {Boolean}
     */
    this.useZeroRHS = false;

    /**
     * Number of solver iterations that are done to approximate normal forces. When these iterations are done, friction force will be computed from the contact normal forces. These friction forces will override any other friction forces set from the World for example.
     * The solver will use less iterations if the solution is below the .tolerance.
     * @property frictionIterations
     * @type {Number}
     */
    this.frictionIterations = 0;

    /**
     * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.
     * @property {Number} usedIterations
     */
    this.usedIterations = 0;
}
GSSolver.prototype = new Solver();
GSSolver.prototype.constructor = GSSolver;

function setArrayZero(array){
    var l = array.length;
    while(l--){
        array[l] = +0.0;
    }
}

/**
 * Solve the system of equations
 * @method solve
 * @param  {Number}  h       Time step
 * @param  {World}   world    World to solve
 */
GSSolver.prototype.solve = function(h, world){

    this.sortEquations();

    var iter = 0,
        maxIter = this.iterations,
        maxFrictionIter = this.frictionIterations,
        equations = this.equations,
        Neq = equations.length,
        tolSquared = Math.pow(this.tolerance*Neq, 2),
        bodies = world.bodies,
        Nbodies = world.bodies.length,
        add = vec2.add,
        set = vec2.set,
        useZeroRHS = this.useZeroRHS,
        lambda = this.lambda;

    this.usedIterations = 0;

    if(Neq){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i];

            // Update solve mass
            b.updateSolveMassProperties();
        }
    }

    // Things that does not change during iteration can be computed once
    if(lambda.length < Neq){
        lambda = this.lambda =  new Utils.ARRAY_TYPE(Neq + this.arrayStep);
        this.Bs =               new Utils.ARRAY_TYPE(Neq + this.arrayStep);
        this.invCs =            new Utils.ARRAY_TYPE(Neq + this.arrayStep);
    }
    setArrayZero(lambda);
    var invCs = this.invCs,
        Bs = this.Bs,
        lambda = this.lambda;

    for(var i=0; i!==equations.length; i++){
        var c = equations[i];
        if(c.timeStep !== h || c.needsUpdate){
            c.timeStep = h;
            c.update();
        }
        Bs[i] =     c.computeB(c.a,c.b,h);
        invCs[i] =  c.computeInvC(c.epsilon);
    }

    var q, B, c, deltalambdaTot,i,j;

    if(Neq !== 0){

        for(i=0; i!==Nbodies; i++){
            var b = bodies[i];

            // Reset vlambda
            b.resetConstraintVelocity();
        }

        if(maxFrictionIter){
            // Iterate over contact equations to get normal forces
            for(iter=0; iter!==maxFrictionIter; iter++){

                // Accumulate the total error for each iteration.
                deltalambdaTot = 0.0;

                for(j=0; j!==Neq; j++){
                    c = equations[j];

                    var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
                    deltalambdaTot += Math.abs(deltalambda);
                }

                this.usedIterations++;

                // If the total error is small enough - stop iterate
                if(deltalambdaTot*deltalambdaTot <= tolSquared){
                    break;
                }
            }

            GSSolver.updateMultipliers(equations, lambda, 1/h);

            // Set computed friction force
            for(j=0; j!==Neq; j++){
                var eq = equations[j];
                if(eq instanceof FrictionEquation){
                    var f = 0.0;
                    for(var k=0; k!==eq.contactEquations.length; k++){
                        f += eq.contactEquations[k].multiplier;
                    }
                    f *= eq.frictionCoefficient / eq.contactEquations.length;
                    eq.maxForce =  f;
                    eq.minForce = -f;
                }
            }
        }

        // Iterate over all equations
        for(iter=0; iter!==maxIter; iter++){

            // Accumulate the total error for each iteration.
            deltalambdaTot = 0.0;

            for(j=0; j!==Neq; j++){
                c = equations[j];

                var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);
                deltalambdaTot += Math.abs(deltalambda);
            }

            this.usedIterations++;

            // If the total error is small enough - stop iterate
            if(deltalambdaTot*deltalambdaTot <= tolSquared){
                break;
            }
        }

        // Add result to velocity
        for(i=0; i!==Nbodies; i++){
            bodies[i].addConstraintVelocity();
        }

        GSSolver.updateMultipliers(equations, lambda, 1/h);
    }
};

// Sets the .multiplier property of each equation
GSSolver.updateMultipliers = function(equations, lambda, invDt){
    // Set the .multiplier property of each equation
    var l = equations.length;
    while(l--){
        equations[l].multiplier = lambda[l] * invDt;
    }
};

GSSolver.iterateEquation = function(j,eq,eps,Bs,invCs,lambda,useZeroRHS,dt,iter){
    // Compute iteration
    var B = Bs[j],
        invC = invCs[j],
        lambdaj = lambda[j],
        GWlambda = eq.computeGWlambda();

    var maxForce = eq.maxForce,
        minForce = eq.minForce;

    if(useZeroRHS){
        B = 0;
    }

    var deltalambda = invC * ( B - GWlambda - eps * lambdaj );

    // Clamp if we are not within the min/max interval
    var lambdaj_plus_deltalambda = lambdaj + deltalambda;
    if(lambdaj_plus_deltalambda < minForce*dt){
        deltalambda = minForce*dt - lambdaj;
    } else if(lambdaj_plus_deltalambda > maxForce*dt){
        deltalambda = maxForce*dt - lambdaj;
    }
    lambda[j] += deltalambda;
    eq.addToWlambda(deltalambda);

    return deltalambda;
};

},{"../equations/FrictionEquation":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/equations/FrictionEquation.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js","./Solver":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/solver/Solver.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/solver/Solver.js":[function(require,module,exports){
var Utils = require('../utils/Utils')
,   EventEmitter = require('../events/EventEmitter');

module.exports = Solver;

/**
 * Base class for constraint solvers.
 * @class Solver
 * @constructor
 * @extends EventEmitter
 */
function Solver(options,type){
    options = options || {};

    EventEmitter.call(this);

    this.type = type;

    /**
     * Current equations in the solver.
     *
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * Function that is used to sort all equations before each solve.
     * @property equationSortFunction
     * @type {function|boolean}
     */
    this.equationSortFunction = options.equationSortFunction || false;
}
Solver.prototype = new EventEmitter();
Solver.prototype.constructor = Solver;

/**
 * Method to be implemented in each subclass
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
Solver.prototype.solve = function(dt,world){
    throw new Error("Solver.solve should be implemented by subclasses!");
};

var mockWorld = {bodies:[]};

/**
 * Solves all constraints in an island.
 * @method solveIsland
 * @param  {Number} dt
 * @param  {Island} island
 */
Solver.prototype.solveIsland = function(dt,island){

    this.removeAllEquations();

    if(island.equations.length){
        // Add equations to solver
        this.addEquations(island.equations);
        mockWorld.bodies.length = 0;
        island.getBodies(mockWorld.bodies);

        // Solve
        if(mockWorld.bodies.length){
            this.solve(dt,mockWorld);
        }
    }
};

/**
 * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.
 * @method sortEquations
 */
Solver.prototype.sortEquations = function(){
    if(this.equationSortFunction){
        this.equations.sort(this.equationSortFunction);
    }
};

/**
 * Add an equation to be solved.
 *
 * @method addEquation
 * @param {Equation} eq
 */
Solver.prototype.addEquation = function(eq){
    if(eq.enabled){
        this.equations.push(eq);
    }
};

/**
 * Add equations. Same as .addEquation, but this time the argument is an array of Equations
 *
 * @method addEquations
 * @param {Array} eqs
 */
Solver.prototype.addEquations = function(eqs){
    //Utils.appendArray(this.equations,eqs);
    for(var i=0, N=eqs.length; i!==N; i++){
        var eq = eqs[i];
        if(eq.enabled){
            this.equations.push(eq);
        }
    }
};

/**
 * Remove an equation.
 *
 * @method removeEquation
 * @param {Equation} eq
 */
Solver.prototype.removeEquation = function(eq){
    var i = this.equations.indexOf(eq);
    if(i !== -1){
        this.equations.splice(i,1);
    }
};

/**
 * Remove all currently added equations.
 *
 * @method removeAllEquations
 */
Solver.prototype.removeAllEquations = function(){
    this.equations.length=0;
};

Solver.GS = 1;
Solver.ISLAND = 2;

},{"../events/EventEmitter":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/events/EventEmitter.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/OverlapKeeper.js":[function(require,module,exports){
var TupleDictionary = require('./TupleDictionary');
var Utils = require('./Utils');

module.exports = OverlapKeeper;

/**
 * Keeps track of overlaps in the current state and the last step state.
 * @class OverlapKeeper
 * @constructor
 */
function OverlapKeeper() {
    this.overlappingShapesLastState = new TupleDictionary();
    this.overlappingShapesCurrentState = new TupleDictionary();
    this.recordPool = [];
    this.tmpDict = new TupleDictionary();
    this.tmpArray1 = [];
}

/**
 * Ticks one step forward in time. This will move the current overlap state to the "old" overlap state, and create a new one as current.
 * @method tick
 */
OverlapKeeper.prototype.tick = function() {
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;

    // Save old objects into pool
    var l = last.keys.length;
    while(l--){
        var key = last.keys[l];
        var lastObject = last.getByKey(key);
        var currentObject = current.getByKey(key);
        if(lastObject && !currentObject){
            // The record is only used in the "last" dict, and will be removed. We might as well pool it.
            this.recordPool.push(lastObject);
        }
    }

    // Clear last object
    last.reset();

    // Transfer from new object to old
    last.copy(current);

    // Clear current object
    current.reset();
};

/**
 * @method setOverlapping
 * @param {Body} bodyA
 * @param {Body} shapeA
 * @param {Body} bodyB
 * @param {Body} shapeB
 */
OverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;

    // Store current contact state
    if(!current.get(shapeA.id, shapeB.id)){

        var data;
        if(this.recordPool.length){
            data = this.recordPool.pop();
            data.set(bodyA, shapeA, bodyB, shapeB);
        } else {
            data = new OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB);
        }

        current.set(shapeA.id, shapeB.id, data);
    }
};

OverlapKeeper.prototype.getNewOverlaps = function(result){
    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);
};

OverlapKeeper.prototype.getEndOverlaps = function(result){
    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);
};

/**
 * Checks if two bodies are currently overlapping.
 * @method bodiesAreOverlapping
 * @param  {Body} bodyA
 * @param  {Body} bodyB
 * @return {boolean}
 */
OverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB){
    var current = this.overlappingShapesCurrentState;
    var l = current.keys.length;
    while(l--){
        var key = current.keys[l];
        var data = current.data[key];
        if((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA){
            return true;
        }
    }
    return false;
};

OverlapKeeper.prototype.getDiff = function(dictA, dictB, result){
    var result = result || [];
    var last = dictA;
    var current = dictB;

    result.length = 0;

    var l = current.keys.length;
    while(l--){
        var key = current.keys[l];
        var data = current.data[key];

        if(!data){
            throw new Error('Key '+key+' had no data!');
        }

        var lastData = last.data[key];
        if(!lastData){
            // Not overlapping in last state, but in current.
            result.push(data);
        }
    }

    return result;
};

OverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB){
    var idA = shapeA.id|0,
        idB = shapeB.id|0;
    var last = this.overlappingShapesLastState;
    var current = this.overlappingShapesCurrentState;
    // Not in last but in new
    return !!!last.get(idA, idB) && !!current.get(idA, idB);
};

OverlapKeeper.prototype.getNewBodyOverlaps = function(result){
    this.tmpArray1.length = 0;
    var overlaps = this.getNewOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
};

OverlapKeeper.prototype.getEndBodyOverlaps = function(result){
    this.tmpArray1.length = 0;
    var overlaps = this.getEndOverlaps(this.tmpArray1);
    return this.getBodyDiff(overlaps, result);
};

OverlapKeeper.prototype.getBodyDiff = function(overlaps, result){
    result = result || [];
    var accumulator = this.tmpDict;

    var l = overlaps.length;

    while(l--){
        var data = overlaps[l];

        // Since we use body id's for the accumulator, these will be a subset of the original one
        accumulator.set(data.bodyA.id|0, data.bodyB.id|0, data);
    }

    l = accumulator.keys.length;
    while(l--){
        var data = accumulator.getByKey(accumulator.keys[l]);
        if(data){
            result.push(data.bodyA, data.bodyB);
        }
    }

    accumulator.reset();

    return result;
};

/**
 * Overlap data container for the OverlapKeeper
 * @class OverlapKeeperRecord
 * @constructor
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */
function OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB){
    /**
     * @property {Shape} shapeA
     */
    this.shapeA = shapeA;
    /**
     * @property {Shape} shapeB
     */
    this.shapeB = shapeB;
    /**
     * @property {Body} bodyA
     */
    this.bodyA = bodyA;
    /**
     * @property {Body} bodyB
     */
    this.bodyB = bodyB;
}

/**
 * Set the data for the record
 * @method set
 * @param {Body} bodyA
 * @param {Shape} shapeA
 * @param {Body} bodyB
 * @param {Shape} shapeB
 */
OverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB){
    OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);
};

},{"./TupleDictionary":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/TupleDictionary.js","./Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/TupleDictionary.js":[function(require,module,exports){
var Utils = require('./Utils');

module.exports = TupleDictionary;

/**
 * @class TupleDictionary
 * @constructor
 */
function TupleDictionary() {

    /**
     * The data storage
     * @property data
     * @type {Object}
     */
    this.data = {};

    /**
     * Keys that are currently used.
     * @property {Array} keys
     */
    this.keys = [];
}

/**
 * Generate a key given two integers
 * @method getKey
 * @param  {number} i
 * @param  {number} j
 * @return {string}
 */
TupleDictionary.prototype.getKey = function(id1, id2) {
    id1 = id1|0;
    id2 = id2|0;

    if ( (id1|0) === (id2|0) ){
        return -1;
    }

    // valid for values < 2^16
    return ((id1|0) > (id2|0) ?
        (id1 << 16) | (id2 & 0xFFFF) :
        (id2 << 16) | (id1 & 0xFFFF))|0
        ;
};

/**
 * @method getByKey
 * @param  {Number} key
 * @return {Object}
 */
TupleDictionary.prototype.getByKey = function(key) {
    key = key|0;
    return this.data[key];
};

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
TupleDictionary.prototype.get = function(i, j) {
    return this.data[this.getKey(i, j)];
};

/**
 * Set a value.
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
TupleDictionary.prototype.set = function(i, j, value) {
    if(!value){
        throw new Error("No data!");
    }

    var key = this.getKey(i, j);

    // Check if key already exists
    if(!this.data[key]){
        this.keys.push(key);
    }

    this.data[key] = value;

    return key;
};

/**
 * Remove all data.
 * @method reset
 */
TupleDictionary.prototype.reset = function() {
    var data = this.data,
        keys = this.keys;

    var l = keys.length;
    while(l--) {
        delete data[keys[l]];
    }

    keys.length = 0;
};

/**
 * Copy another TupleDictionary. Note that all data in this dictionary will be removed.
 * @method copy
 * @param {TupleDictionary} dict The TupleDictionary to copy into this one.
 */
TupleDictionary.prototype.copy = function(dict) {
    this.reset();
    Utils.appendArray(this.keys, dict.keys);
    var l = dict.keys.length;
    while(l--){
        var key = dict.keys[l];
        this.data[key] = dict.data[key];
    }
};

},{"./Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js":[function(require,module,exports){
/* global P2_ARRAY_TYPE */

module.exports = Utils;

/**
 * Misc utility functions
 * @class Utils
 * @constructor
 */
function Utils(){}

/**
 * Append the values in array b to the array a. See <a href="http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131">this</a> for an explanation.
 * @method appendArray
 * @static
 * @param  {Array} a
 * @param  {Array} b
 */
Utils.appendArray = function(a,b){
    if (b.length < 150000) {
        a.push.apply(a, b);
    } else {
        for (var i = 0, len = b.length; i !== len; ++i) {
            a.push(b[i]);
        }
    }
};

/**
 * Garbage free Array.splice(). Does not allocate a new array.
 * @method splice
 * @static
 * @param  {Array} array
 * @param  {Number} index
 * @param  {Number} howmany
 */
Utils.splice = function(array,index,howmany){
    howmany = howmany || 1;
    for (var i=index, len=array.length-howmany; i < len; i++){
        array[i] = array[i + howmany];
    }
    array.length = len;
};

/**
 * The array type to use for internal numeric computations throughout the library. Float32Array is used if it is available, but falls back on Array. If you want to set array type manually, inject it via the global variable P2_ARRAY_TYPE. See example below.
 * @static
 * @property {function} ARRAY_TYPE
 * @example
 *     <script>
 *         <!-- Inject your preferred array type before loading p2.js -->
 *         P2_ARRAY_TYPE = Array;
 *     </script>
 *     <script src="p2.js"></script>
 */
if(typeof P2_ARRAY_TYPE !== 'undefined') {
    Utils.ARRAY_TYPE = P2_ARRAY_TYPE;
} else if (typeof Float32Array !== 'undefined'){
    Utils.ARRAY_TYPE = Float32Array;
} else {
    Utils.ARRAY_TYPE = Array;
}

/**
 * Extend an object with the properties of another
 * @static
 * @method extend
 * @param  {object} a
 * @param  {object} b
 */
Utils.extend = function(a,b){
    for(var key in b){
        a[key] = b[key];
    }
};

/**
 * Extend an options object with default values.
 * @static
 * @method defaults
 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
 * @param  {object} defaults An object containing default values.
 * @return {object} The modified options object.
 */
Utils.defaults = function(options, defaults){
    options = options || {};
    for(var key in defaults){
        if(!(key in options)){
            options[key] = defaults[key];
        }
    }
    return options;
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/world/Island.js":[function(require,module,exports){
var Body = require('../objects/Body');

module.exports = Island;

/**
 * An island of bodies connected with equations.
 * @class Island
 * @constructor
 */
function Island(){

    /**
     * Current equations in this island.
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * Current bodies in this island.
     * @property bodies
     * @type {Array}
     */
    this.bodies = [];
}

/**
 * Clean this island from bodies and equations.
 * @method reset
 */
Island.prototype.reset = function(){
    this.equations.length = this.bodies.length = 0;
};

var bodyIds = [];

/**
 * Get all unique bodies in this island.
 * @method getBodies
 * @return {Array} An array of Body
 */
Island.prototype.getBodies = function(result){
    var bodies = result || [],
        eqs = this.equations;
    bodyIds.length = 0;
    for(var i=0; i!==eqs.length; i++){
        var eq = eqs[i];
        if(bodyIds.indexOf(eq.bodyA.id)===-1){
            bodies.push(eq.bodyA);
            bodyIds.push(eq.bodyA.id);
        }
        if(bodyIds.indexOf(eq.bodyB.id)===-1){
            bodies.push(eq.bodyB);
            bodyIds.push(eq.bodyB.id);
        }
    }
    return bodies;
};

/**
 * Check if the entire island wants to sleep.
 * @method wantsToSleep
 * @return {Boolean}
 */
Island.prototype.wantsToSleep = function(){
    for(var i=0; i<this.bodies.length; i++){
        var b = this.bodies[i];
        if(b.type === Body.DYNAMIC && !b.wantsToSleep){
            return false;
        }
    }
    return true;
};

/**
 * Make all bodies in the island sleep.
 * @method sleep
 */
Island.prototype.sleep = function(){
    for(var i=0; i<this.bodies.length; i++){
        var b = this.bodies[i];
        b.sleep();
    }
    return true;
};

},{"../objects/Body":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/Body.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/world/IslandManager.js":[function(require,module,exports){
var vec2 = require('../math/vec2')
,   Island = require('./Island')
,   IslandNode = require('./IslandNode')
,   Body = require('../objects/Body');

module.exports = IslandManager;

/**
 * Splits the system of bodies and equations into independent islands
 *
 * @class IslandManager
 * @constructor
 * @param {Object} [options]
 * @extends Solver
 */
function IslandManager(options){

    // Pooling of node objects saves some GC load
    this._nodePool = [];
    this._islandPool = [];

    /**
     * The equations to split. Manually fill this array before running .split().
     * @property {Array} equations
     */
    this.equations = [];

    /**
     * The resulting {{#crossLink "Island"}}{{/crossLink}}s.
     * @property {Array} islands
     */
    this.islands = [];

    /**
     * The resulting graph nodes.
     * @property {Array} nodes
     */
    this.nodes = [];

    /**
     * The node queue, used when traversing the graph of nodes.
     * @private
     * @property {Array} queue
     */
    this.queue = [];
}

/**
 * Get an unvisited node from a list of nodes.
 * @static
 * @method getUnvisitedNode
 * @param  {Array} nodes
 * @return {IslandNode|boolean} The node if found, else false.
 */
IslandManager.getUnvisitedNode = function(nodes){
    var Nnodes = nodes.length;
    for(var i=0; i!==Nnodes; i++){
        var node = nodes[i];
        if(!node.visited && node.body.type === Body.DYNAMIC){
            return node;
        }
    }
    return false;
};

/**
 * Visit a node.
 * @method visit
 * @param  {IslandNode} node
 * @param  {Array} bds
 * @param  {Array} eqs
 */
IslandManager.prototype.visit = function (node,bds,eqs){
    bds.push(node.body);
    var Neqs = node.equations.length;
    for(var i=0; i!==Neqs; i++){
        var eq = node.equations[i];
        if(eqs.indexOf(eq) === -1){ // Already added?
            eqs.push(eq);
        }
    }
};

/**
 * Runs the search algorithm, starting at a root node. The resulting bodies and equations will be stored in the provided arrays.
 * @method bfs
 * @param  {IslandNode} root The node to start from
 * @param  {Array} bds  An array to append resulting Bodies to.
 * @param  {Array} eqs  An array to append resulting Equations to.
 */
IslandManager.prototype.bfs = function(root,bds,eqs){

    // Reset the visit queue
    var queue = this.queue;
    queue.length = 0;

    // Add root node to queue
    queue.push(root);
    root.visited = true;
    this.visit(root,bds,eqs);

    // Process all queued nodes
    while(queue.length) {

        // Get next node in the queue
        var node = queue.pop();

        // Visit unvisited neighboring nodes
        var child;
        while((child = IslandManager.getUnvisitedNode(node.neighbors))) {
            child.visited = true;
            this.visit(child,bds,eqs);

            // Only visit the children of this node if it's dynamic
            if(child.body.type === Body.DYNAMIC){
                queue.push(child);
            }
        }
    }
};

/**
 * Split the world into independent islands. The result is stored in .islands.
 * @method split
 * @param  {World} world
 * @return {Array} The generated islands
 */
IslandManager.prototype.split = function(world){
    var bodies = world.bodies,
        nodes = this.nodes,
        equations = this.equations;

    // Move old nodes to the node pool
    while(nodes.length){
        this._nodePool.push(nodes.pop());
    }

    // Create needed nodes, reuse if possible
    for(var i=0; i!==bodies.length; i++){
        if(this._nodePool.length){
            var node = this._nodePool.pop();
            node.reset();
            node.body = bodies[i];
            nodes.push(node);
        } else {
            nodes.push(new IslandNode(bodies[i]));
        }
    }

    // Add connectivity data. Each equation connects 2 bodies.
    for(var k=0; k!==equations.length; k++){
        var eq=equations[k],
            i=bodies.indexOf(eq.bodyA),
            j=bodies.indexOf(eq.bodyB),
            ni=nodes[i],
            nj=nodes[j];
        ni.neighbors.push(nj);
        nj.neighbors.push(ni);
        ni.equations.push(eq);
        nj.equations.push(eq);
    }

    // Move old islands to the island pool
    var islands = this.islands;
    while(islands.length){
        var island = islands.pop();
        island.reset();
        this._islandPool.push(island);
    }

    // Get islands
    var child;
    while((child = IslandManager.getUnvisitedNode(nodes))){

        // Create new island
        var island = this._islandPool.length ? this._islandPool.pop() : new Island();

        // Get all equations and bodies in this island
        this.bfs(child, island.bodies, island.equations);

        islands.push(island);
    }

    return islands;
};

},{"../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../objects/Body":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/Body.js","./Island":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/world/Island.js","./IslandNode":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/world/IslandNode.js"}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/world/IslandNode.js":[function(require,module,exports){
module.exports = IslandNode;

/**
 * Holds a body and keeps track of some additional properties needed for graph traversal.
 * @class IslandNode
 * @constructor
 * @param {Body} body
 */
function IslandNode(body){

	/**
	 * The body that is contained in this node.
	 * @property {Body} body
	 */
    this.body = body;

    /**
     * Neighboring IslandNodes
     * @property {Array} neighbors
     */
    this.neighbors = [];

    /**
     * Equations connected to this node.
     * @property {Array} equations
     */
    this.equations = [];

    /**
     * If this node was visiting during the graph traversal.
     * @property visited
     * @type {Boolean}
     */
    this.visited = false;
}

/**
 * Clean this node from bodies and equations.
 * @method reset
 */
IslandNode.prototype.reset = function(){
    this.equations.length = 0;
    this.neighbors.length = 0;
    this.visited = false;
    this.body = null;
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/p2/src/world/World.js":[function(require,module,exports){
/* global performance */
/*jshint -W020 */

var  GSSolver = require('../solver/GSSolver')
,    Solver = require('../solver/Solver')
,    NaiveBroadphase = require('../collision/NaiveBroadphase')
,    Ray = require('../collision/Ray')
,    vec2 = require('../math/vec2')
,    Circle = require('../shapes/Circle')
,    Rectangle = require('../shapes/Rectangle')
,    Convex = require('../shapes/Convex')
,    Line = require('../shapes/Line')
,    Plane = require('../shapes/Plane')
,    Capsule = require('../shapes/Capsule')
,    Particle = require('../shapes/Particle')
,    EventEmitter = require('../events/EventEmitter')
,    Body = require('../objects/Body')
,    Shape = require('../shapes/Shape')
,    LinearSpring = require('../objects/LinearSpring')
,    Material = require('../material/Material')
,    ContactMaterial = require('../material/ContactMaterial')
,    DistanceConstraint = require('../constraints/DistanceConstraint')
,    Constraint = require('../constraints/Constraint')
,    LockConstraint = require('../constraints/LockConstraint')
,    RevoluteConstraint = require('../constraints/RevoluteConstraint')
,    PrismaticConstraint = require('../constraints/PrismaticConstraint')
,    GearConstraint = require('../constraints/GearConstraint')
,    pkg = require('../../package.json')
,    Broadphase = require('../collision/Broadphase')
,    SAPBroadphase = require('../collision/SAPBroadphase')
,    Narrowphase = require('../collision/Narrowphase')
,    Utils = require('../utils/Utils')
,    OverlapKeeper = require('../utils/OverlapKeeper')
,    IslandManager = require('./IslandManager')
,    RotationalSpring = require('../objects/RotationalSpring');

module.exports = World;

if(typeof performance === 'undefined'){
    performance = {};
}
if(!performance.now){
    var nowOffset = Date.now();
    if (performance.timing && performance.timing.navigationStart){
        nowOffset = performance.timing.navigationStart;
    }
    performance.now = function(){
        return Date.now() - nowOffset;
    };
}

/**
 * The dynamics world, where all bodies and constraints lives.
 *
 * @class World
 * @constructor
 * @param {Object}          [options]
 * @param {Solver}          [options.solver]            Defaults to GSSolver.
 * @param {Array}           [options.gravity]           Defaults to [0,-9.78]
 * @param {Broadphase}      [options.broadphase]        Defaults to NaiveBroadphase
 * @param {Boolean}         [options.islandSplit=false]
 * @param {Boolean}         [options.doProfiling=false]
 * @extends EventEmitter
 *
 * @example
 *     var world = new World({
 *         gravity: [0, -9.81],
 *         broadphase: new SAPBroadphase()
 *     });
 */
function World(options){
    EventEmitter.apply(this);

    options = options || {};

    /**
     * All springs in the world. To add a spring to the world, use {{#crossLink "World/addSpring:method"}}{{/crossLink}}.
     *
     * @property springs
     * @type {Array}
     */
    this.springs = [];

    /**
     * All bodies in the world. To add a body to the world, use {{#crossLink "World/addBody:method"}}{{/crossLink}}.
     * @property {Array} bodies
     */
    this.bodies = [];

    /**
     * Disabled body collision pairs. See {{#crossLink "World/disableBodyCollision:method"}}.
     * @private
     * @property {Array} disabledBodyCollisionPairs
     */
    this.disabledBodyCollisionPairs = [];

    /**
     * The solver used to satisfy constraints and contacts. Default is {{#crossLink "GSSolver"}}{{/crossLink}}.
     * @property {Solver} solver
     */
    this.solver = options.solver || new GSSolver();

    /**
     * The narrowphase to use to generate contacts.
     *
     * @property narrowphase
     * @type {Narrowphase}
     */
    this.narrowphase = new Narrowphase(this);

    /**
     * The island manager of this world.
     * @property {IslandManager} islandManager
     */
    this.islandManager = new IslandManager();

    /**
     * Gravity in the world. This is applied on all bodies in the beginning of each step().
     *
     * @property gravity
     * @type {Array}
     */
    this.gravity = vec2.fromValues(0, -9.78);
    if(options.gravity){
        vec2.copy(this.gravity, options.gravity);
    }

    /**
     * Gravity to use when approximating the friction max force (mu*mass*gravity).
     * @property {Number} frictionGravity
     */
    this.frictionGravity = vec2.length(this.gravity) || 10;

    /**
     * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.
     * @property {Boolean} useWorldGravityAsFrictionGravity
     */
    this.useWorldGravityAsFrictionGravity = true;

    /**
     * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.
     * @property {Boolean} useFrictionGravityOnZeroGravity
     */
    this.useFrictionGravityOnZeroGravity = true;

    /**
     * Whether to do timing measurements during the step() or not.
     *
     * @property doPofiling
     * @type {Boolean}
     */
    this.doProfiling = options.doProfiling || false;

    /**
     * How many millisecconds the last step() took. This is updated each step if .doProfiling is set to true.
     *
     * @property lastStepTime
     * @type {Number}
     */
    this.lastStepTime = 0.0;

    /**
     * The broadphase algorithm to use.
     *
     * @property broadphase
     * @type {Broadphase}
     */
    this.broadphase = options.broadphase || new SAPBroadphase();
    this.broadphase.setWorld(this);

    /**
     * User-added constraints.
     *
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    /**
     * Dummy default material in the world, used in .defaultContactMaterial
     * @property {Material} defaultMaterial
     */
    this.defaultMaterial = new Material();

    /**
     * The default contact material to use, if no contact material was set for the colliding materials.
     * @property {ContactMaterial} defaultContactMaterial
     */
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial,this.defaultMaterial);

    /**
     * For keeping track of what time step size we used last step
     * @property lastTimeStep
     * @type {Number}
     */
    this.lastTimeStep = 1/60;

    /**
     * Enable to automatically apply spring forces each step.
     * @property applySpringForces
     * @type {Boolean}
     */
    this.applySpringForces = true;

    /**
     * Enable to automatically apply body damping each step.
     * @property applyDamping
     * @type {Boolean}
     */
    this.applyDamping = true;

    /**
     * Enable to automatically apply gravity each step.
     * @property applyGravity
     * @type {Boolean}
     */
    this.applyGravity = true;

    /**
     * Enable/disable constraint solving in each step.
     * @property solveConstraints
     * @type {Boolean}
     */
    this.solveConstraints = true;

    /**
     * The ContactMaterials added to the World.
     * @property contactMaterials
     * @type {Array}
     */
    this.contactMaterials = [];

    /**
     * World time.
     * @property time
     * @type {Number}
     */
    this.time = 0.0;

    /**
     * Is true during the step().
     * @property {Boolean} stepping
     */
    this.stepping = false;

    /**
     * Bodies that are scheduled to be removed at the end of the step.
     * @property {Array} bodiesToBeRemoved
     * @private
     */
    this.bodiesToBeRemoved = [];

    this.fixedStepTime = 0.0;

    /**
     * Whether to enable island splitting. Island splitting can be an advantage for many things, including solver performance. See {{#crossLink "IslandManager"}}{{/crossLink}}.
     * @property {Boolean} islandSplit
     */
    this.islandSplit = typeof(options.islandSplit)!=="undefined" ? !!options.islandSplit : false;

    /**
     * Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
     * @property emitImpactEvent
     * @type {Boolean}
     */
    this.emitImpactEvent = true;

    // Id counters
    this._constraintIdCounter = 0;
    this._bodyIdCounter = 0;

    /**
     * Fired after the step().
     * @event postStep
     */
    this.postStepEvent = {
        type : "postStep",
    };

    /**
     * Fired when a body is added to the world.
     * @event addBody
     * @param {Body} body
     */
    this.addBodyEvent = {
        type : "addBody",
        body : null
    };

    /**
     * Fired when a body is removed from the world.
     * @event removeBody
     * @param {Body} body
     */
    this.removeBodyEvent = {
        type : "removeBody",
        body : null
    };

    /**
     * Fired when a spring is added to the world.
     * @event addSpring
     * @param {Spring} spring
     */
    this.addSpringEvent = {
        type : "addSpring",
        spring : null,
    };

    /**
     * Fired when a first contact is created between two bodies. This event is fired after the step has been done.
     * @event impact
     * @param {Body} bodyA
     * @param {Body} bodyB
     */
    this.impactEvent = {
        type: "impact",
        bodyA : null,
        bodyB : null,
        shapeA : null,
        shapeB : null,
        contactEquation : null,
    };

    /**
     * Fired after the Broadphase has collected collision pairs in the world.
     * Inside the event handler, you can modify the pairs array as you like, to
     * prevent collisions between objects that you don't want.
     * @event postBroadphase
     * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.
     */
    this.postBroadphaseEvent = {
        type:"postBroadphase",
        pairs:null,
    };

    /**
     * How to deactivate bodies during simulation. Possible modes are: {{#crossLink "World/NO_SLEEPING:property"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink "World/BODY_SLEEPING:property"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink "World/ISLAND_SLEEPING:property"}}World.ISLAND_SLEEPING{{/crossLink}}.
     * If sleeping is enabled, you might need to {{#crossLink "Body/wakeUp:method"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink "Body/allowSleep:property"}}Body.allowSleep{{/crossLink}}.
     * @property sleepMode
     * @type {number}
     * @default World.NO_SLEEPING
     */
    this.sleepMode = World.NO_SLEEPING;

    /**
     * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.
     * @event beginContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     * @param {Array} contactEquations
     */
    this.beginContactEvent = {
        type:"beginContact",
        shapeA : null,
        shapeB : null,
        bodyA : null,
        bodyB : null,
        contactEquations : [],
    };

    /**
     * Fired when two shapes stop overlapping, after the narrowphase (during step).
     * @event endContact
     * @param {Shape} shapeA
     * @param {Shape} shapeB
     * @param {Body}  bodyA
     * @param {Body}  bodyB
     * @param {Array} contactEquations
     */
    this.endContactEvent = {
        type:"endContact",
        shapeA : null,
        shapeB : null,
        bodyA : null,
        bodyB : null,
    };

    /**
     * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.
     * @event preSolve
     * @param {Array} contactEquations  An array of contacts to be solved.
     * @param {Array} frictionEquations An array of friction equations to be solved.
     */
    this.preSolveEvent = {
        type:"preSolve",
        contactEquations:null,
        frictionEquations:null,
    };

    // For keeping track of overlapping shapes
    this.overlappingShapesLastState = { keys:[] };
    this.overlappingShapesCurrentState = { keys:[] };

    this.overlapKeeper = new OverlapKeeper();
}
World.prototype = new Object(EventEmitter.prototype);
World.prototype.constructor = World;

/**
 * Never deactivate bodies.
 * @static
 * @property {number} NO_SLEEPING
 */
World.NO_SLEEPING = 1;

/**
 * Deactivate individual bodies if they are sleepy.
 * @static
 * @property {number} BODY_SLEEPING
 */
World.BODY_SLEEPING = 2;

/**
 * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink "World/islandSplit:property"}}.islandSplit{{/crossLink}} for this to work.
 * @static
 * @property {number} ISLAND_SLEEPING
 */
World.ISLAND_SLEEPING = 4;

/**
 * Add a constraint to the simulation.
 *
 * @method addConstraint
 * @param {Constraint} c
 */
World.prototype.addConstraint = function(c){
    this.constraints.push(c);
};

/**
 * Add a ContactMaterial to the simulation.
 * @method addContactMaterial
 * @param {ContactMaterial} contactMaterial
 */
World.prototype.addContactMaterial = function(contactMaterial){
    this.contactMaterials.push(contactMaterial);
};

/**
 * Removes a contact material
 *
 * @method removeContactMaterial
 * @param {ContactMaterial} cm
 */
World.prototype.removeContactMaterial = function(cm){
    var idx = this.contactMaterials.indexOf(cm);
    if(idx!==-1){
        Utils.splice(this.contactMaterials,idx,1);
    }
};

/**
 * Get a contact material given two materials
 * @method getContactMaterial
 * @param {Material} materialA
 * @param {Material} materialB
 * @return {ContactMaterial} The matching ContactMaterial, or false on fail.
 * @todo Use faster hash map to lookup from material id's
 */
World.prototype.getContactMaterial = function(materialA,materialB){
    var cmats = this.contactMaterials;
    for(var i=0, N=cmats.length; i!==N; i++){
        var cm = cmats[i];
        if( (cm.materialA.id === materialA.id) && (cm.materialB.id === materialB.id) ||
            (cm.materialA.id === materialB.id) && (cm.materialB.id === materialA.id) ){
            return cm;
        }
    }
    return false;
};

/**
 * Removes a constraint
 *
 * @method removeConstraint
 * @param {Constraint} c
 */
World.prototype.removeConstraint = function(c){
    var idx = this.constraints.indexOf(c);
    if(idx!==-1){
        Utils.splice(this.constraints,idx,1);
    }
};

var step_r = vec2.create(),
    step_runit = vec2.create(),
    step_u = vec2.create(),
    step_f = vec2.create(),
    step_fhMinv = vec2.create(),
    step_velodt = vec2.create(),
    step_mg = vec2.create(),
    xiw = vec2.fromValues(0,0),
    xjw = vec2.fromValues(0,0),
    zero = vec2.fromValues(0,0),
    interpvelo = vec2.fromValues(0,0);

/**
 * Step the physics world forward in time.
 *
 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
 *
 * @method step
 * @param {Number} dt                       The fixed time step size to use.
 * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.
 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
 *
 * @example
 *     // fixed timestepping without interpolation
 *     var world = new World();
 *     world.step(0.01);
 *
 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
 */
World.prototype.step = function(dt,timeSinceLastCalled,maxSubSteps){
    maxSubSteps = maxSubSteps || 10;
    timeSinceLastCalled = timeSinceLastCalled || 0;

    if(timeSinceLastCalled === 0){ // Fixed, simple stepping

        this.internalStep(dt);

        // Increment time
        this.time += dt;

    } else {

        // Compute the number of fixed steps we should have taken since the last step
        var internalSteps = Math.floor( (this.time+timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
        internalSteps = Math.min(internalSteps,maxSubSteps);

        // Do some fixed steps to catch up
        var t0 = performance.now();
        for(var i=0; i!==internalSteps; i++){
            this.internalStep(dt);
            if(performance.now() - t0 > dt*1000){
                // We are slower than real-time. Better bail out.
                break;
            }
        }

        // Increment internal clock
        this.time += timeSinceLastCalled;

        // Compute "Left over" time step
        var h = this.time % dt;
        var h_div_dt = h/dt;

        for(var j=0; j!==this.bodies.length; j++){
            var b = this.bodies[j];
            if(b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING){
                // Interpolate
                vec2.sub(interpvelo, b.position, b.previousPosition);
                vec2.scale(interpvelo, interpvelo, h_div_dt);
                vec2.add(b.interpolatedPosition, b.position, interpvelo);

                b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;
            } else {
                // For static bodies, just copy. Who else will do it?
                vec2.copy(b.interpolatedPosition, b.position);
                b.interpolatedAngle = b.angle;
            }
        }
    }
};

var endOverlaps = [];

/**
 * Make a fixed step.
 * @method internalStep
 * @param  {number} dt
 * @private
 */
World.prototype.internalStep = function(dt){
    this.stepping = true;

    var that = this,
        doProfiling = this.doProfiling,
        Nsprings = this.springs.length,
        springs = this.springs,
        bodies = this.bodies,
        g = this.gravity,
        solver = this.solver,
        Nbodies = this.bodies.length,
        broadphase = this.broadphase,
        np = this.narrowphase,
        constraints = this.constraints,
        t0, t1,
        fhMinv = step_fhMinv,
        velodt = step_velodt,
        mg = step_mg,
        scale = vec2.scale,
        add = vec2.add,
        rotate = vec2.rotate,
        islandManager = this.islandManager;

    this.overlapKeeper.tick();

    this.lastTimeStep = dt;

    if(doProfiling){
        t0 = performance.now();
    }

    // Update approximate friction gravity.
    if(this.useWorldGravityAsFrictionGravity){
        var gravityLen = vec2.length(this.gravity);
        if(!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)){
            // Nonzero gravity. Use it.
            this.frictionGravity = gravityLen;
        }
    }

    // Add gravity to bodies
    if(this.applyGravity){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i],
                fi = b.force;
            if(b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING){
                continue;
            }
            vec2.scale(mg,g,b.mass*b.gravityScale); // F=m*g
            add(fi,fi,mg);
        }
    }

    // Add spring forces
    if(this.applySpringForces){
        for(var i=0; i!==Nsprings; i++){
            var s = springs[i];
            s.applyForce();
        }
    }

    if(this.applyDamping){
        for(var i=0; i!==Nbodies; i++){
            var b = bodies[i];
            if(b.type === Body.DYNAMIC){
                b.applyDamping(dt);
            }
        }
    }

    // Broadphase
    var result = broadphase.getCollisionPairs(this);

    // Remove ignored collision pairs
    var ignoredPairs = this.disabledBodyCollisionPairs;
    for(var i=ignoredPairs.length-2; i>=0; i-=2){
        for(var j=result.length-2; j>=0; j-=2){
            if( (ignoredPairs[i]   === result[j] && ignoredPairs[i+1] === result[j+1]) ||
                (ignoredPairs[i+1] === result[j] && ignoredPairs[i]   === result[j+1])){
                result.splice(j,2);
            }
        }
    }

    // Remove constrained pairs with collideConnected == false
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        if(!c.collideConnected){
            for(var j=result.length-2; j>=0; j-=2){
                if( (c.bodyA === result[j] && c.bodyB === result[j+1]) ||
                    (c.bodyB === result[j] && c.bodyA === result[j+1])){
                    result.splice(j,2);
                }
            }
        }
    }

    // postBroadphase event
    this.postBroadphaseEvent.pairs = result;
    this.emit(this.postBroadphaseEvent);

    // Narrowphase
    np.reset(this);
    for(var i=0, Nresults=result.length; i!==Nresults; i+=2){
        var bi = result[i],
            bj = result[i+1];

        // Loop over all shapes of body i
        for(var k=0, Nshapesi=bi.shapes.length; k!==Nshapesi; k++){
            var si = bi.shapes[k],
                xi = bi.shapeOffsets[k],
                ai = bi.shapeAngles[k];

            // All shapes of body j
            for(var l=0, Nshapesj=bj.shapes.length; l!==Nshapesj; l++){
                var sj = bj.shapes[l],
                    xj = bj.shapeOffsets[l],
                    aj = bj.shapeAngles[l];

                var cm = this.defaultContactMaterial;
                if(si.material && sj.material){
                    var tmp = this.getContactMaterial(si.material,sj.material);
                    if(tmp){
                        cm = tmp;
                    }
                }

                this.runNarrowphase(np,bi,si,xi,ai,bj,sj,xj,aj,cm,this.frictionGravity);
            }
        }
    }

    // Wake up bodies
    for(var i=0; i!==Nbodies; i++){
        var body = bodies[i];
        if(body._wakeUpAfterNarrowphase){
            body.wakeUp();
            body._wakeUpAfterNarrowphase = false;
        }
    }

    // Emit end overlap events
    if(this.has('endContact')){
        this.overlapKeeper.getEndOverlaps(endOverlaps);
        var e = this.endContactEvent;
        var l = endOverlaps.length;
        while(l--){
            var data = endOverlaps[l];
            e.shapeA = data.shapeA;
            e.shapeB = data.shapeB;
            e.bodyA = data.bodyA;
            e.bodyB = data.bodyB;
            this.emit(e);
        }
    }

    var preSolveEvent = this.preSolveEvent;
    preSolveEvent.contactEquations = np.contactEquations;
    preSolveEvent.frictionEquations = np.frictionEquations;
    this.emit(preSolveEvent);

    // update constraint equations
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        constraints[i].update();
    }

    if(np.contactEquations.length || np.frictionEquations.length || constraints.length){
        if(this.islandSplit){
            // Split into islands
            islandManager.equations.length = 0;
            Utils.appendArray(islandManager.equations, np.contactEquations);
            Utils.appendArray(islandManager.equations, np.frictionEquations);
            for(i=0; i!==Nconstraints; i++){
                Utils.appendArray(islandManager.equations, constraints[i].equations);
            }
            islandManager.split(this);

            for(var i=0; i!==islandManager.islands.length; i++){
                var island = islandManager.islands[i];
                if(island.equations.length){
                    solver.solveIsland(dt,island);
                }
            }

        } else {

            // Add contact equations to solver
            solver.addEquations(np.contactEquations);
            solver.addEquations(np.frictionEquations);

            // Add user-defined constraint equations
            for(i=0; i!==Nconstraints; i++){
                solver.addEquations(constraints[i].equations);
            }

            if(this.solveConstraints){
                solver.solve(dt,this);
            }

            solver.removeAllEquations();
        }
    }

    // Step forward
    for(var i=0; i!==Nbodies; i++){
        var body = bodies[i];

        if(body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC){
            body.integrate(dt);
        }
    }

    // Reset force
    for(var i=0; i!==Nbodies; i++){
        bodies[i].setZeroForce();
    }

    if(doProfiling){
        t1 = performance.now();
        that.lastStepTime = t1-t0;
    }

    // Emit impact event
    if(this.emitImpactEvent && this.has('impact')){
        var ev = this.impactEvent;
        for(var i=0; i!==np.contactEquations.length; i++){
            var eq = np.contactEquations[i];
            if(eq.firstImpact){
                ev.bodyA = eq.bodyA;
                ev.bodyB = eq.bodyB;
                ev.shapeA = eq.shapeA;
                ev.shapeB = eq.shapeB;
                ev.contactEquation = eq;
                this.emit(ev);
            }
        }
    }

    // Sleeping update
    if(this.sleepMode === World.BODY_SLEEPING){
        for(i=0; i!==Nbodies; i++){
            bodies[i].sleepTick(this.time, false, dt);
        }
    } else if(this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit){

        // Tell all bodies to sleep tick but dont sleep yet
        for(i=0; i!==Nbodies; i++){
            bodies[i].sleepTick(this.time, true, dt);
        }

        // Sleep islands
        for(var i=0; i<this.islandManager.islands.length; i++){
            var island = this.islandManager.islands[i];
            if(island.wantsToSleep()){
                island.sleep();
            }
        }
    }

    this.stepping = false;

    // Remove bodies that are scheduled for removal
    if(this.bodiesToBeRemoved.length){
        for(var i=0; i!==this.bodiesToBeRemoved.length; i++){
            this.removeBody(this.bodiesToBeRemoved[i]);
        }
        this.bodiesToBeRemoved.length = 0;
    }

    this.emit(this.postStepEvent);
};

/**
 * Runs narrowphase for the shape pair i and j.
 * @method runNarrowphase
 * @param  {Narrowphase} np
 * @param  {Body} bi
 * @param  {Shape} si
 * @param  {Array} xi
 * @param  {Number} ai
 * @param  {Body} bj
 * @param  {Shape} sj
 * @param  {Array} xj
 * @param  {Number} aj
 * @param  {Number} mu
 */
World.prototype.runNarrowphase = function(np,bi,si,xi,ai,bj,sj,xj,aj,cm,glen){

    // Check collision groups and masks
    if(!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)){
        return;
    }

    // Get world position and angle of each shape
    vec2.rotate(xiw, xi, bi.angle);
    vec2.rotate(xjw, xj, bj.angle);
    vec2.add(xiw, xiw, bi.position);
    vec2.add(xjw, xjw, bj.position);
    var aiw = ai + bi.angle;
    var ajw = aj + bj.angle;

    np.enableFriction = cm.friction > 0;
    np.frictionCoefficient = cm.friction;
    var reducedMass;
    if(bi.type === Body.STATIC || bi.type === Body.KINEMATIC){
        reducedMass = bj.mass;
    } else if(bj.type === Body.STATIC || bj.type === Body.KINEMATIC){
        reducedMass = bi.mass;
    } else {
        reducedMass = (bi.mass*bj.mass)/(bi.mass+bj.mass);
    }
    np.slipForce = cm.friction*glen*reducedMass;
    np.restitution = cm.restitution;
    np.surfaceVelocity = cm.surfaceVelocity;
    np.frictionStiffness = cm.frictionStiffness;
    np.frictionRelaxation = cm.frictionRelaxation;
    np.stiffness = cm.stiffness;
    np.relaxation = cm.relaxation;
    np.contactSkinSize = cm.contactSkinSize;
    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

    var resolver = np[si.type | sj.type],
        numContacts = 0;
    if (resolver) {
        var sensor = si.sensor || sj.sensor;
        var numFrictionBefore = np.frictionEquations.length;
        if (si.type < sj.type) {
            numContacts = resolver.call(np, bi,si,xiw,aiw, bj,sj,xjw,ajw, sensor);
        } else {
            numContacts = resolver.call(np, bj,sj,xjw,ajw, bi,si,xiw,aiw, sensor);
        }
        var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;

        if(numContacts){

            if( bi.allowSleep &&
                bi.type === Body.DYNAMIC &&
                bi.sleepState  === Body.SLEEPING &&
                bj.sleepState  === Body.AWAKE &&
                bj.type !== Body.STATIC
            ){
                var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity,2);
                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
                if(speedSquaredB >= speedLimitSquaredB*2){
                    bi._wakeUpAfterNarrowphase = true;
                }
            }

            if( bj.allowSleep &&
                bj.type === Body.DYNAMIC &&
                bj.sleepState  === Body.SLEEPING &&
                bi.sleepState  === Body.AWAKE &&
                bi.type !== Body.STATIC
            ){
                var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity,2);
                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
                if(speedSquaredA >= speedLimitSquaredA*2){
                    bj._wakeUpAfterNarrowphase = true;
                }
            }

            this.overlapKeeper.setOverlapping(bi, si, bj, sj);
            if(this.has('beginContact') && this.overlapKeeper.isNewOverlap(si, sj)){

                // Report new shape overlap
                var e = this.beginContactEvent;
                e.shapeA = si;
                e.shapeB = sj;
                e.bodyA = bi;
                e.bodyB = bj;

                // Reset contact equations
                e.contactEquations.length = 0;

                if(typeof(numContacts)==="number"){
                    for(var i=np.contactEquations.length-numContacts; i<np.contactEquations.length; i++){
                        e.contactEquations.push(np.contactEquations[i]);
                    }
                }

                this.emit(e);
            }

            // divide the max friction force by the number of contacts
            if(typeof(numContacts)==="number" && numFrictionEquations > 1){ // Why divide by 1?
                for(var i=np.frictionEquations.length-numFrictionEquations; i<np.frictionEquations.length; i++){
                    var f = np.frictionEquations[i];
                    f.setSlipForce(f.getSlipForce() / numFrictionEquations);
                }
            }
        }
    }

};

/**
 * Add a spring to the simulation
 *
 * @method addSpring
 * @param {Spring} s
 */
World.prototype.addSpring = function(s){
    this.springs.push(s);
    this.addSpringEvent.spring = s;
    this.emit(this.addSpringEvent);
};

/**
 * Remove a spring
 *
 * @method removeSpring
 * @param {Spring} s
 */
World.prototype.removeSpring = function(s){
    var idx = this.springs.indexOf(s);
    if(idx!==-1){
        Utils.splice(this.springs,idx,1);
    }
};

/**
 * Add a body to the simulation
 *
 * @method addBody
 * @param {Body} body
 *
 * @example
 *     var world = new World(),
 *         body = new Body();
 *     world.addBody(body);
 * @todo What if this is done during step?
 */
World.prototype.addBody = function(body){
    if(this.bodies.indexOf(body) === -1){
        this.bodies.push(body);
        body.world = this;
        this.addBodyEvent.body = body;
        this.emit(this.addBodyEvent);
    }
};

/**
 * Remove a body from the simulation. If this method is called during step(), the body removal is scheduled to after the step.
 *
 * @method removeBody
 * @param {Body} body
 */
World.prototype.removeBody = function(body){
    if(this.stepping){
        this.bodiesToBeRemoved.push(body);
    } else {
        body.world = null;
        var idx = this.bodies.indexOf(body);
        if(idx!==-1){
            Utils.splice(this.bodies,idx,1);
            this.removeBodyEvent.body = body;
            body.resetConstraintVelocity();
            this.emit(this.removeBodyEvent);
        }
    }
};

/**
 * Get a body by its id.
 * @method getBodyById
 * @return {Body|Boolean} The body, or false if it was not found.
 */
World.prototype.getBodyById = function(id){
    var bodies = this.bodies;
    for(var i=0; i<bodies.length; i++){
        var b = bodies[i];
        if(b.id === id){
            return b;
        }
    }
    return false;
};

/**
 * Disable collision between two bodies
 * @method disableCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
World.prototype.disableBodyCollision = function(bodyA,bodyB){
    this.disabledBodyCollisionPairs.push(bodyA,bodyB);
};

/**
 * Enable collisions between the given two bodies
 * @method enableCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
World.prototype.enableBodyCollision = function(bodyA,bodyB){
    var pairs = this.disabledBodyCollisionPairs;
    for(var i=0; i<pairs.length; i+=2){
        if((pairs[i] === bodyA && pairs[i+1] === bodyB) || (pairs[i+1] === bodyA && pairs[i] === bodyB)){
            pairs.splice(i,2);
            return;
        }
    }
};


function v2a(v){
    if(!v){
        return v;
    }
    return [v[0],v[1]];
}

function extend(a,b){
    for(var key in b){
        a[key] = b[key];
    }
}

function contactMaterialToJSON(cm){
    return {
        id : cm.id,
        materialA :             cm.materialA.id,
        materialB :             cm.materialB.id,
        friction :              cm.friction,
        restitution :           cm.restitution,
        stiffness :             cm.stiffness,
        relaxation :            cm.relaxation,
        frictionStiffness :     cm.frictionStiffness,
        frictionRelaxation :    cm.frictionRelaxation,
    };
}

/**
 * Resets the World, removes all bodies, constraints and springs.
 *
 * @method clear
 */
World.prototype.clear = function(){

    this.time = 0;
    this.fixedStepTime = 0;

    // Remove all solver equations
    if(this.solver && this.solver.equations.length){
        this.solver.removeAllEquations();
    }

    // Remove all constraints
    var cs = this.constraints;
    for(var i=cs.length-1; i>=0; i--){
        this.removeConstraint(cs[i]);
    }

    // Remove all bodies
    var bodies = this.bodies;
    for(var i=bodies.length-1; i>=0; i--){
        this.removeBody(bodies[i]);
    }

    // Remove all springs
    var springs = this.springs;
    for(var i=springs.length-1; i>=0; i--){
        this.removeSpring(springs[i]);
    }

    // Remove all contact materials
    var cms = this.contactMaterials;
    for(var i=cms.length-1; i>=0; i--){
        this.removeContactMaterial(cms[i]);
    }

    World.apply(this);
};

/**
 * Get a copy of this World instance
 * @method clone
 * @return {World}
 */
World.prototype.clone = function(){
    var world = new World();
    world.fromJSON(this.toJSON());
    return world;
};

var hitTest_tmp1 = vec2.create(),
    hitTest_zero = vec2.fromValues(0,0),
    hitTest_tmp2 = vec2.fromValues(0,0);

/**
 * Test if a world point overlaps bodies
 * @method hitTest
 * @param  {Array}  worldPoint  Point to use for intersection tests
 * @param  {Array}  bodies      A list of objects to check for intersection
 * @param  {Number} precision   Used for matching against particles and lines. Adds some margin to these infinitesimal objects.
 * @return {Array}              Array of bodies that overlap the point
 */
World.prototype.hitTest = function(worldPoint,bodies,precision){
    precision = precision || 0;

    // Create a dummy particle body with a particle shape to test against the bodies
    var pb = new Body({ position:worldPoint }),
        ps = new Particle(),
        px = worldPoint,
        pa = 0,
        x = hitTest_tmp1,
        zero = hitTest_zero,
        tmp = hitTest_tmp2;
    pb.addShape(ps);

    var n = this.narrowphase,
        result = [];

    // Check bodies
    for(var i=0, N=bodies.length; i!==N; i++){
        var b = bodies[i];
        for(var j=0, NS=b.shapes.length; j!==NS; j++){
            var s = b.shapes[j],
                offset = b.shapeOffsets[j] || zero,
                angle = b.shapeAngles[j] || 0.0;

            // Get shape world position + angle
            vec2.rotate(x, offset, b.angle);
            vec2.add(x, x, b.position);
            var a = angle + b.angle;

            if( (s instanceof Circle    && n.circleParticle  (b,s,x,a,     pb,ps,px,pa, true)) ||
                (s instanceof Convex    && n.particleConvex  (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Plane     && n.particlePlane   (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Capsule   && n.particleCapsule (pb,ps,px,pa, b,s,x,a,     true)) ||
                (s instanceof Particle  && vec2.squaredLength(vec2.sub(tmp,x,worldPoint)) < precision*precision)
                ){
                result.push(b);
            }
        }
    }

    return result;
};

/**
 * Sets the Equation parameters for all constraints and contact materials.
 * @method setGlobalEquationParameters
 * @param {object} [parameters]
 * @param {Number} [parameters.relaxation]
 * @param {Number} [parameters.stiffness]
 */
World.prototype.setGlobalEquationParameters = function(parameters){
    parameters = parameters || {};

    // Set for all constraints
    for(var i=0; i !== this.constraints.length; i++){
        var c = this.constraints[i];
        for(var j=0; j !== c.equations.length; j++){
            var eq = c.equations[j];
            if(typeof(parameters.stiffness) !== "undefined"){
                eq.stiffness = parameters.stiffness;
            }
            if(typeof(parameters.relaxation) !== "undefined"){
                eq.relaxation = parameters.relaxation;
            }
            eq.needsUpdate = true;
        }
    }

    // Set for all contact materials
    for(var i=0; i !== this.contactMaterials.length; i++){
        var c = this.contactMaterials[i];
        if(typeof(parameters.stiffness) !== "undefined"){
            c.stiffness = parameters.stiffness;
            c.frictionStiffness = parameters.stiffness;
        }
        if(typeof(parameters.relaxation) !== "undefined"){
            c.relaxation = parameters.relaxation;
            c.frictionRelaxation = parameters.relaxation;
        }
    }

    // Set for default contact material
    var c = this.defaultContactMaterial;
    if(typeof(parameters.stiffness) !== "undefined"){
        c.stiffness = parameters.stiffness;
        c.frictionStiffness = parameters.stiffness;
    }
    if(typeof(parameters.relaxation) !== "undefined"){
        c.relaxation = parameters.relaxation;
        c.frictionRelaxation = parameters.relaxation;
    }
};

/**
 * Set the stiffness for all equations and contact materials.
 * @method setGlobalStiffness
 * @param {Number} stiffness
 */
World.prototype.setGlobalStiffness = function(stiffness){
    this.setGlobalEquationParameters({
        stiffness: stiffness
    });
};

/**
 * Set the relaxation for all equations and contact materials.
 * @method setGlobalRelaxation
 * @param {Number} relaxation
 */
World.prototype.setGlobalRelaxation = function(relaxation){
    this.setGlobalEquationParameters({
        relaxation: relaxation
    });
};

var tmpRay = new Ray();

/**
 * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
 * @method raycastAll
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {Function} callback
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAll = function(from, to, options, callback){
    options.mode = Ray.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
 * @method raycastAny
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAny = function(from, to, options, result){
    options.mode = Ray.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and return information of the closest hit.
 * @method raycastClosest
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionMask=-1]
 * @param  {number} [options.collisionGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastClosest = function(from, to, options, result){
    options.mode = Ray.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};
},{"../../package.json":"/Users/tyemilldeveloper/space-game/node_modules/p2/package.json","../collision/Broadphase":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/Broadphase.js","../collision/NaiveBroadphase":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/NaiveBroadphase.js","../collision/Narrowphase":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/Narrowphase.js","../collision/Ray":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/Ray.js","../collision/SAPBroadphase":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/collision/SAPBroadphase.js","../constraints/Constraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/Constraint.js","../constraints/DistanceConstraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/DistanceConstraint.js","../constraints/GearConstraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/GearConstraint.js","../constraints/LockConstraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/LockConstraint.js","../constraints/PrismaticConstraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/PrismaticConstraint.js","../constraints/RevoluteConstraint":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/constraints/RevoluteConstraint.js","../events/EventEmitter":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/events/EventEmitter.js","../material/ContactMaterial":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/material/ContactMaterial.js","../material/Material":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/material/Material.js","../math/vec2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/math/vec2.js","../objects/Body":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/Body.js","../objects/LinearSpring":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/LinearSpring.js","../objects/RotationalSpring":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/objects/RotationalSpring.js","../shapes/Capsule":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Capsule.js","../shapes/Circle":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Circle.js","../shapes/Convex":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Convex.js","../shapes/Line":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Line.js","../shapes/Particle":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Particle.js","../shapes/Plane":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Plane.js","../shapes/Rectangle":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Rectangle.js","../shapes/Shape":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/shapes/Shape.js","../solver/GSSolver":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/solver/GSSolver.js","../solver/Solver":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/solver/Solver.js","../utils/OverlapKeeper":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/OverlapKeeper.js","../utils/Utils":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/utils/Utils.js","./IslandManager":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/world/IslandManager.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/async/lib/async.js":[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":"/Users/tyemilldeveloper/space-game/node_modules/browserify/node_modules/process/browser.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/eventemitter3/index.js":[function(require,module,exports){
'use strict';

/**
 * Representation of a single EventEmitter function.
 *
 * @param {Function} fn Event handler to be called.
 * @param {Mixed} context Context for function execution.
 * @param {Boolean} once Only emit once
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal EventEmitter interface that is molded against the Node.js
 * EventEmitter interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() { /* Nothing to set */ }

/**
 * Holds the assigned EventEmitters by name.
 *
 * @type {Object}
 * @private
 */
EventEmitter.prototype._events = undefined;

/**
 * Return a list of assigned event listeners.
 *
 * @param {String} event The events that should be listed.
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  if (!this._events || !this._events[event]) return [];
  if (this._events[event].fn) return [this._events[event].fn];

  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {
    ee[i] = this._events[event][i].fn;
  }

  return ee;
};

/**
 * Emit an event to all registered event listeners.
 *
 * @param {String} event The name of the event.
 * @returns {Boolean} Indication if we've emitted an event.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  if (!this._events || !this._events[event]) return false;

  var listeners = this._events[event]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Register a new EventListener for the given event.
 *
 * @param {String} event Name of the event.
 * @param {Functon} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this);

  if (!this._events) this._events = {};
  if (!this._events[event]) this._events[event] = listener;
  else {
    if (!this._events[event].fn) this._events[event].push(listener);
    else this._events[event] = [
      this._events[event], listener
    ];
  }

  return this;
};

/**
 * Add an EventListener that's only called once.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true);

  if (!this._events) this._events = {};
  if (!this._events[event]) this._events[event] = listener;
  else {
    if (!this._events[event].fn) this._events[event].push(listener);
    else this._events[event] = [
      this._events[event], listener
    ];
  }

  return this;
};

/**
 * Remove event listeners.
 *
 * @param {String} event The event we want to remove.
 * @param {Function} fn The listener that we need to find.
 * @param {Boolean} once Only remove once listeners.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, once) {
  if (!this._events || !this._events[event]) return this;

  var listeners = this._events[event]
    , events = [];

  if (fn) {
    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {
      events.push(listeners);
    }
    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {
      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {
        events.push(listeners[i]);
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[event] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[event];
  }

  return this;
};

/**
 * Remove all listeners or only the listeners for the specified event.
 *
 * @param {String} event The event want to remove all listeners for.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[event];
  else this._events = {};

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the module.
//
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.EventEmitter2 = EventEmitter;
EventEmitter.EventEmitter3 = EventEmitter;

//
// Expose the module.
//
module.exports = EventEmitter;

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/object-assign/index.js":[function(require,module,exports){
'use strict';

function ToObject(val) {
	if (val == null) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var keys;
	var to = ToObject(target);

	for (var s = 1; s < arguments.length; s++) {
		from = arguments[s];
		keys = Object.keys(Object(from));

		for (var i = 0; i < keys.length; i++) {
			to[keys[i]] = from[keys[i]];
		}
	}

	return to;
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/Loader.js":[function(require,module,exports){
var async = require('async'),
    Resource = require('./Resource'),
    EventEmitter = require('eventemitter3').EventEmitter;

/**
 * Manages the state and loading of multiple resources to load.
 *
 * @class
 * @param [baseUrl=''] {string} The base url for all resources loaded by this loader.
 * @param [concurrency=10] {number} The number of resources to load concurrently.
 */
function Loader(baseUrl, concurrency) {
    EventEmitter.call(this);

    concurrency = concurrency || 10;

    /**
     * The base url for all resources loaded by this loader.
     *
     * @member {string}
     */
    this.baseUrl = baseUrl || '';

    /**
     * The progress percent of the loader going through the queue.
     *
     * @member {number}
     */
    this.progress = 0;

    /**
     * Loading state of the loader, true if it is currently loading resources.
     *
     * @member {boolean}
     */
    this.loading = false;

    /**
     * The percentage of total progress that a single resource represents.
     *
     * @member {number}
     */
    this._progressChunk = 0;

    /**
     * The middleware to run before loading each resource.
     *
     * @member {function[]}
     */
    this._beforeMiddleware = [];

    /**
     * The middleware to run after loading each resource.
     *
     * @member {function[]}
     */
    this._afterMiddleware = [];

    /**
     * The `_loadResource` function bound with this object context.
     *
     * @private
     * @member {function}
     */
    this._boundLoadResource = this._loadResource.bind(this);

    /**
     * The `_onLoad` function bound with this object context.
     *
     * @private
     * @member {function}
     */
    this._boundOnLoad = this._onLoad.bind(this);

    /**
     * The resource buffer that fills until `load` is called to start loading resources.
     *
     * @private
     * @member {Resource[]}
     */
    this._buffer = [];

    /**
     * Used to track load completion.
     *
     * @private
     * @member {number}
     */
    this._numToLoad = 0;

    /**
     * The resources waiting to be loaded.
     *
     * @private
     * @member {Resource[]}
     */
    this._queue = async.queue(this._boundLoadResource, concurrency);

    /**
     * All the resources for this loader keyed by name.
     *
     * @member {object<string, Resource>}
     */
    this.resources = {};

    /**
     * Emitted once per loaded or errored resource.
     *
     * @event progress
     * @memberof Loader#
     */

    /**
     * Emitted once per errored resource.
     *
     * @event error
     * @memberof Loader#
     */

    /**
     * Emitted once per loaded resource.
     *
     * @event load
     * @memberof Loader#
     */

    /**
     * Emitted when the loader begins to process the queue.
     *
     * @event start
     * @memberof Loader#
     */

    /**
     * Emitted when the queued resources all load.
     *
     * @event complete
     * @memberof Loader#
     */
}

Loader.prototype = Object.create(EventEmitter.prototype);
Loader.prototype.constructor = Loader;
module.exports = Loader;

/**
 * Adds a resource (or multiple resources) to the loader queue.
 *
 * This function can take a wide variety of different parameters. The only thing that is always
 * required the url to load. All the following will work:
 *
 * ```js
 * loader
 *     // normal param syntax
 *     .add('key', 'http://...', function () {})
 *     .add('http://...', function () {})
 *     .add('http://...')
 *
 *     // object syntax
 *     .add({
 *         name: 'key2',
 *         url: 'http://...'
 *     }, function () {})
 *     .add({
 *         url: 'http://...'
 *     }, function () {})
 *     .add({
 *         name: 'key3',
 *         url: 'http://...'
 *         onComplete: function () {}
 *     })
 *     .add({
 *         url: 'https://...',
 *         onComplete: function () {},
 *         crossOrigin: true
 *     })
 *
 *     // you can also pass an array of objects or urls or both
 *     .add([
 *         { name: 'key4', url: 'http://...', onComplete: function () {} },
 *         { url: 'http://...', onComplete: function () {} },
 *         'http://...'
 *     ]);
 * ```
 *
 * @alias enqueue
 * @param [name] {string} The name of the resource to load, if not passed the url is used.
 * @param url {string} The url for this resource, relative to the baseUrl of this loader.
 * @param [options] {object} The options for the load.
 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.XHR_LOAD_TYPE} How should this resource be loaded?
 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
 *      loaded be interpreted when using XHR?
 * @param [callback] {function} Function to call when this specific resource completes loading.
 * @return {Loader}
 */
Loader.prototype.add = Loader.prototype.enqueue = function (name, url, options, cb) {
    // special case of an array of objects or urls
    if (Array.isArray(name)) {
        for (var i = 0; i < name.length; ++i) {
            this.add(name[i]);
        }

        return this;
    }

    // if an object is passed instead of params
    if (typeof name === 'object') {
        cb = url || name.callback || name.onComplete;
        options = name;
        url = name.url;
        name = name.name || name.key || name.url;
    }

    // case where no name is passed shift all args over by one.
    if (typeof url !== 'string') {
        cb = options;
        options = url;
        url = name;
    }

    // now that we shifted make sure we have a proper url.
    if (typeof url !== 'string') {
        throw new Error('No url passed to add resource to loader.');
    }

    // options are optional so people might pass a function and no options
    if (typeof options === 'function') {
        cb = options;
        options = null;
    }

    // check if resource already exists.
    if (this.resources[name]) {
        throw new Error('Resource with name "' + name + '" already exists.');
    }

    // add base url if this isn't a data url
    if (url.indexOf('data:') !== 0) {
        url = this.baseUrl + url;
    }

    // create the store the resource
    this.resources[name] = new Resource(name, url, options);

    if (typeof cb === 'function') {
        this.resources[name].once('afterMiddleware', cb);
    }

    this._numToLoad++;

    // if already loading add it to the worker queue
    if (this._queue.started) {
        this._queue.push(this.resources[name]);
        this._progressChunk = (100 - this.progress) / (this._queue.length() + this._queue.running());
    }
    // otherwise buffer it to be added to the queue later
    else {
        this._buffer.push(this.resources[name]);
        this._progressChunk = 100 / this._buffer.length;
    }

    return this;
};


/**
 * Sets up a middleware function that will run *before* the
 * resource is loaded.
 *
 * @alias pre
 * @param middleware {function} The middleware function to register.
 * @return {Loader}
 */
Loader.prototype.before = Loader.prototype.pre = function (fn) {
    this._beforeMiddleware.push(fn);

    return this;
};

/**
 * Sets up a middleware function that will run *after* the
 * resource is loaded.
 *
 * @alias use
 * @param middleware {function} The middleware function to register.
 * @return {Loader}
 */
Loader.prototype.after = Loader.prototype.use = function (fn) {
    this._afterMiddleware.push(fn);

    return this;
};

/**
 * Resets the queue of the loader to prepare for a new load.
 *
 * @return {Loader}
 */
Loader.prototype.reset = function () {
    this._buffer.length = 0;

    this._queue.kill();
    this._queue.started = false;

    this.progress = 0;
    this._progressChunk = 0;
    this.loading = false;
};

/**
 * Starts loading the queued resources.
 *
 * @fires start
 * @param [callback] {function} Optional callback that will be bound to the `complete` event.
 * @return {Loader}
 */
Loader.prototype.load = function (cb) {
    // register complete callback if they pass one
    if (typeof cb === 'function') {
        this.once('complete', cb);
    }

    // if the queue has already started we are done here
    if (this._queue.started) {
        return this;
    }

    // notify of start
    this.emit('start', this);

    // start the internal queue
    for (var i = 0; i < this._buffer.length; ++i) {
        this._queue.push(this._buffer[i]);
    }

    // empty the buffer
    this._buffer.length = 0;

    return this;
};

/**
 * Loads a single resource.
 *
 * @fires progress
 * @private
 */
Loader.prototype._loadResource = function (resource, dequeue) {
    var self = this;

    resource._dequeue = dequeue;

    this._runMiddleware(resource, this._beforeMiddleware, function () {
        // resource.on('progress', self.emit.bind(self, 'progress'));

        resource.load(self._boundOnLoad);
    });
};

/**
 * Called once each resource has loaded.
 *
 * @fires complete
 * @private
 */
Loader.prototype._onComplete = function () {
    this.emit('complete', this, this.resources);
};

/**
 * Called each time a resources is loaded.
 *
 * @fires progress
 * @fires error
 * @fires load
 * @private
 */
Loader.prototype._onLoad = function (resource) {
    this.progress += this._progressChunk;

    this.emit('progress', this, resource);

    if (resource.error) {
        this.emit('error', resource.error, this, resource);
    }
    else {
        this.emit('load', this, resource);
    }

    // run middleware, this *must* happen before dequeue so sub-assets get added properly
    this._runMiddleware(resource, this._afterMiddleware, function () {
        resource.emit('afterMiddleware', resource);

        this._numToLoad--;

        // do completion check
        if (this._numToLoad === 0) {
            this._onComplete();
        }
    });

    // remove this resource from the async queue
    resource._dequeue();
};

/**
 * Run middleware functions on a resource.
 *
 * @private
 */
Loader.prototype._runMiddleware = function (resource, fns, cb) {
    var self = this;

    async.eachSeries(fns, function (fn, next) {
        fn.call(self, resource, next);
    }, cb.bind(this, resource));
};

Loader.LOAD_TYPE = Resource.LOAD_TYPE;
Loader.XHR_READY_STATE = Resource.XHR_READY_STATE;
Loader.XHR_RESPONSE_TYPE = Resource.XHR_RESPONSE_TYPE;

},{"./Resource":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/Resource.js","async":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/async/lib/async.js","eventemitter3":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/eventemitter3/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/Resource.js":[function(require,module,exports){
var EventEmitter = require('eventemitter3').EventEmitter,
    // tests is CORS is supported in XHR, if not we need to use XDR
    useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest())));

/**
 * Manages the state and loading of a single resource represented by
 * a single URL.
 *
 * @class
 * @param name {string} The name of the resource to load.
 * @param url {string|string[]} The url for this resource, for audio/video loads you can pass an array of sources.
 * @param [options] {object} The options for the load.
 * @param [options.crossOrigin] {boolean} Is this request cross-origin? Default is to determine automatically.
 * @param [options.loadType=Resource.LOAD_TYPE.XHR] {Resource.LOAD_TYPE} How should this resource be loaded?
 * @param [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] {Resource.XHR_RESPONSE_TYPE} How should the data being
 *      loaded be interpreted when using XHR?
 */
function Resource(name, url, options) {
    EventEmitter.call(this);

    options = options || {};

    if (typeof name !== 'string' || typeof url !== 'string') {
        throw new Error('Both name and url are required for constructing a resource.');
    }

    /**
     * The name of this resource.
     *
     * @member {string}
     * @readonly
     */
    this.name = name;

    /**
     * The url used to load this resource.
     *
     * @member {string}
     * @readonly
     */
    this.url = url;

    /**
     * The data that was loaded by the resource.
     *
     * @member {any}
     */
    this.data = null;

    /**
     * Is this request cross-origin? If unset, determined automatically.
     *
     * @member {string}
     */
    this.crossOrigin = options.crossOrigin;

    /**
     * The method of loading to use for this resource.
     *
     * @member {Resource.LOAD_TYPE}
     */
    this.loadType = options.loadType || this._determineLoadType();

    /**
     * The type used to load the resource via XHR. If unset, determined automatically.
     *
     * @member {string}
     */
    this.xhrType = options.xhrType;

    /**
     * The error that occurred while loading (if any).
     *
     * @member {Error}
     * @readonly
     */
    this.error = null;

    /**
     * The XHR object that was used to load this resource. This is only set
     * when `loadType` is `Resource.LOAD_TYPE.XHR`.
     *
     * @member {XMLHttpRequest}
     */
    this.xhr = null;

    /**
     * The `dequeue` method that will be used a storage place for the async queue dequeue method
     * used privately by the loader.
     *
     * @member {function}
     * @private
     */
    this._dequeue = null;

    /**
     * The `complete` function bound to this resource's context.
     *
     * @member {function}
     * @private
     */
    this._boundComplete = this.complete.bind(this);

    /**
     * The `_onError` function bound to this resource's context.
     *
     * @member {function}
     * @private
     */
    this._boundOnError = this._onError.bind(this);

    /**
     * The `_onProgress` function bound to this resource's context.
     *
     * @member {function}
     * @private
     */
    this._boundOnProgress = this._onProgress.bind(this);

    // xhr callbacks
    this._boundXhrOnError = this._xhrOnError.bind(this);
    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
    this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);

    /**
     * Emitted when the resource beings to load.
     *
     * @event start
     * @memberof Resource#
     */

    /**
     * Emitted each time progress of this resource load updates.
     * Not all resources types and loader systems can support this event
     * so sometimes it may not be available. If the resource
     * is being loaded on a modern browser, using XHR, and the remote server
     * properly sets Content-Length headers, then this will be available.
     *
     * @event progress
     * @memberof Resource#
     */

    /**
     * Emitted once this resource has loaded, if there was an error it will
     * be in the `error` property.
     *
     * @event complete
     * @memberof Resource#
     */
}

Resource.prototype = Object.create(EventEmitter.prototype);
Resource.prototype.constructor = Resource;
module.exports = Resource;

/**
 * Marks the resource as complete.
 *
 * @fires complete
 */
Resource.prototype.complete = function () {
    // TODO: Clean this up in a wrapper or something...gross....
    if (this.data && this.data.removeEventListener) {
        this.data.removeEventListener('error', this._boundOnError);
        this.data.removeEventListener('load', this._boundComplete);
        this.data.removeEventListener('progress', this._boundOnProgress);
        this.data.removeEventListener('canplaythrough', this._boundComplete);
    }

    if (this.xhr) {
        if (this.xhr.removeEventListener) {
            this.xhr.removeEventListener('error', this._boundXhrOnError);
            this.xhr.removeEventListener('abort', this._boundXhrOnAbort);
            this.xhr.removeEventListener('progress', this._boundOnProgress);
            this.xhr.removeEventListener('load', this._boundXhrOnLoad);
        }
        else {
            this.xhr.onerror = null;
            this.xhr.ontimeout = null;
            this.xhr.onprogress = null;
            this.xhr.onload = null;
        }
    }

    this.emit('complete', this);
};

/**
 * Kicks off loading of this resource.
 *
 * @fires start
 * @param [callback] {function} Optional callback to call once the resource is loaded.
 */
Resource.prototype.load = function (cb) {
    this.emit('start', this);

    // if a callback is set, listen for complete event
    if (cb) {
        this.once('complete', cb);
    }

    // if unset, determine the value
    if (typeof this.crossOrigin !== 'string') {
        this.crossOrigin = this._determineCrossOrigin();
    }

    switch(this.loadType) {
        case Resource.LOAD_TYPE.IMAGE:
            this._loadImage();
            break;

        case Resource.LOAD_TYPE.AUDIO:
            this._loadElement('audio');
            break;

        case Resource.LOAD_TYPE.VIDEO:
            this._loadElement('video');
            break;

        case Resource.LOAD_TYPE.XHR:
            /* falls through */
        default:
            if (useXdr) {
                this._loadXdr();
            }
            else {
                this._loadXhr();
            }
            break;
    }
};

/**
 * Loads this resources using an Image object.
 *
 * @private
 */
Resource.prototype._loadImage = function () {
    this.data = new Image();

    if (this.crossOrigin) {
        this.data.crossOrigin = '';
    }

    this.data.src = this.url;

    this.data.addEventListener('error', this._boundOnError, false);
    this.data.addEventListener('load', this._boundComplete, false);
    this.data.addEventListener('progress', this._boundOnProgress, false);
};

/**
 * Loads this resources using an HTMLAudioElement or HTMLVideoElement.
 *
 * @private
 */
Resource.prototype._loadElement = function (type) {
    this.data = document.createElement(type);

    if (Array.isArray(this.url)) {
        for (var i = 0; i < this.url.length; ++i) {
            this.data.appendChild(this._createSource(type, this.url[i]));
        }
    }
    else {
        this.data.appendChild(this._createSource(type, this.url));
    }

    this.data.addEventListener('error', this._boundOnError, false);
    this.data.addEventListener('load', this._boundComplete, false);
    this.data.addEventListener('progress', this._boundOnProgress, false);
    this.data.addEventListener('canplaythrough', this._boundComplete, false);

    this.data.load();
};

/**
 * Loads this resources using an XMLHttpRequest.
 *
 * @private
 */
Resource.prototype._loadXhr = function () {
    // if unset, determine the value
    if (typeof this.xhrType !== 'string') {
        this.xhrType = this._determineXhrType();
    }

    var xhr = this.xhr = new XMLHttpRequest();

    // set the request type and url
    xhr.open('GET', this.url, true);

    // load json as text and parse it ourselves. We do this because some browsers
    // *cough* safari *cough* can't deal with it.
    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
        xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;
    }
    else {
        xhr.responseType = this.xhrType;
    }

    xhr.addEventListener('error', this._boundXhrOnError, false);
    xhr.addEventListener('abort', this._boundXhrOnAbort, false);
    xhr.addEventListener('progress', this._boundOnProgress, false);
    xhr.addEventListener('load', this._boundXhrOnLoad, false);

    xhr.send();
};

/**
 * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
 *
 * @private
 */
Resource.prototype._loadXdr = function () {
    var xdr = this.xhr = new XDomainRequest();

    // XDomainRequest has a few quirks. Occasionally it will abort requests
    // A way to avoid this is to make sure ALL callbacks are set even if not used
    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
    xdr.timeout = 5000;

    xdr.onerror = this._boundXhrOnError;
    xdr.ontimeout = this._boundXdrOnTimeout;
    xdr.onprogress = this._boundOnProgress;
    xdr.onload = this._boundXhrOnLoad;

    xdr.open('GET', this.url, true);

    //  Note: The xdr.send() call is wrapped in a timeout to prevent an issue with the interface where some requests are lost
    //  if multiple XDomainRequests are being sent at the same time.
    // Some info here: https://github.com/photonstorm/phaser/issues/1248
    setTimeout(function () {
        xdr.send();
    }, 0);
};

/**
 * Creates a source used in loading via an element.
 *
 * @param type {string} The element type (video or audio).
 * @param url {string} The source URL to load from.
 * @param [mime] {string} The mime type of the video
 * @private
 */
Resource.prototype._createSource = function (type, url, mime) {
    if (!mime) {
        mime = type + '/' + url.substr(url.lastIndexOf('.') + 1);
    }

    var source = document.createElement('source');

    source.src = url;
    source.type = mime;

    return source;
};

/**
 * Called if a load errors out.
 *
 * @param error {Error} The error that happened.
 * @private
 */
Resource.prototype._onError = function (event) {
    this.error = new Error('Failed to load element using ' + event.target.nodeName);
    this.complete();
};

/**
 * Called if a load progress event fires for xhr/xdr.
 *
 * @fires progress
 * @param event {XMLHttpRequestProgressEvent|Event}
 * @private
 */
Resource.prototype._onProgress =  function (event) {
    if (event.lengthComputable) {
        this.emit('progress', this, event.loaded / event.total);
    }
};

/**
 * Called if an error event fires for xhr/xdr.
 *
 * @param event {XMLHttpRequestErrorEvent|Event}
 * @private
 */
Resource.prototype._xhrOnError = function (event) {
    this.error = new Error(
        reqType(event.target) + ' Request failed. ' +
        'Status: ' + event.target.status + ', text: "' + event.target.statusText + '"'
    );

    this.complete();
};

/**
 * Called if an abort event fires for xhr.
 *
 * @param event {XMLHttpRequestAbortEvent}
 * @private
 */
Resource.prototype._xhrOnAbort = function (event) {
    this.error = new Error(reqType(event.target) + ' Request was aborted by the user.');
    this.complete();
};

/**
 * Called if a timeout event fires for xdr.
 *
 * @param event {Event}
 * @private
 */
Resource.prototype._xdrOnTimeout = function (event) {
    this.error = new Error(reqType(event.target) + ' Request timed out.');
    this.complete();
};

/**
 * Called when data successfully loads from an xhr/xdr request.
 *
 * @param event {XMLHttpRequestLoadEvent|Event}
 * @private
 */
Resource.prototype._xhrOnLoad = function (event) {
    var xhr = event.target;

    if (xhr.status === 200) {
        // if text, just return it
        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {
            this.data = xhr.responseText;
        }
        // if json, parse into json object
        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {
            try {
                this.data = JSON.parse(xhr.responseText);
            } catch(e) {
                this.error = new Error('Error trying to parse loaded json:', e);
            }
        }
        // if xml, parse into an xml document or div element
        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
            try {
                if (window.DOMParser) {
                    var domparser = new DOMParser();
                    this.data = domparser.parseFromString(xhr.responseText, 'text/xml');
                }
                else {
                    var div = document.createElement('div');
                    div.innerHTML = xhr.responseText;
                    this.data = div;
                }
            } catch (e) {
                this.error = new Error('Error trying to parse loaded xml:', e);
            }
        }
        // other types just return the response
        else {
            this.data = xhr.response;
        }
    }
    else {
        this.error = new Error('[' + xhr.status + ']' + xhr.statusText + ':' + xhr.responseURL);
    }

    this.complete();
};

function reqType(xhr) {
    return xhr.toString().replace('object ', '');
}

/**
 * Sets the `crossOrigin` property for this resource based on if the url
 * for this resource is cross-origin. If crossOrigin was manually set, this
 * function does nothing.
 *
 * @private
 * @return {string} The crossOrigin value to use (or empty string for none).
 */
Resource.prototype._determineCrossOrigin = function () {
    // data: and javascript: urls are considered same-origin
    if (this.url.indexOf('data:') === 0) {
        return '';
    }

    // check if this is a cross-origin url
    var loc = window.location,
        a = document.createElement('a');

    a.href = this.url;

    // if cross origin
    if (a.hostname !== loc.hostname || a.port !== loc.port || a.protocol !== loc.protocol) {
        return 'anonymous';
    }

    return '';
};

/**
 * Determines the responseType of an XHR request based on the extension of the
 * resource being loaded.
 *
 * @private
 * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
 */
Resource.prototype._determineXhrType = function () {
    var ext = this.url.substr(this.url.lastIndexOf('.') + 1);

    switch(ext) {
        // xml
        case 'xhtml':
        case 'html':
        case 'htm':
        case 'xml':
        case 'tmx':
        case 'tsx':
        case 'svg':
            return Resource.XHR_RESPONSE_TYPE.DOCUMENT;

        // images
        case 'gif':
        case 'png':
        case 'bmp':
        case 'jpg':
        case 'jpeg':
        case 'tif':
        case 'tiff':
        case 'webp':
            return Resource.XHR_RESPONSE_TYPE.BLOB;

        // json
        case 'json':
            return Resource.XHR_RESPONSE_TYPE.JSON;

        // text
        case 'text':
        case 'txt':
            /* falls through */
        default:
            return Resource.XHR_RESPONSE_TYPE.TEXT;
    }
};

Resource.prototype._determineLoadType = function () {
    var ext = this.url.substr(this.url.lastIndexOf('.') + 1);

    switch(ext) {
        // images
        case 'gif':
        case 'png':
        case 'bmp':
        case 'jpg':
        case 'jpeg':
        case 'tif':
        case 'tiff':
        case 'webp':
            return Resource.LOAD_TYPE.IMAGE;

        default:
            return Resource.LOAD_TYPE.XHR;
    }
};

/**
 * Determines the mime type of an XHR request based on the responseType of
 * resource being loaded.
 *
 * @private
 * @return {string} The mime type to use.
 */
Resource.prototype._getMimeFromXhrType = function (type) {
    switch(type) {
        case Resource.XHR_RESPONSE_TYPE.BUFFER:
            return 'application/octet-binary';

        case Resource.XHR_RESPONSE_TYPE.BLOB:
            return 'application/blob';

        case Resource.XHR_RESPONSE_TYPE.DOCUMENT:
            return 'application/xml';

        case Resource.XHR_RESPONSE_TYPE.JSON:
            return 'application/json';

        case Resource.XHR_RESPONSE_TYPE.DEFAULT:
        case Resource.XHR_RESPONSE_TYPE.TEXT:
            /* falls through */
        default:
            return 'text/plain';

    }
};

/**
 * The types of loading a resource can use.
 *
 * @static
 * @constant
 * @property {object} LOAD_TYPE
 * @property {number} LOAD_TYPE.XHR - Uses XMLHttpRequest to load the resource.
 * @property {number} LOAD_TYPE.IMAGE - Uses an `Image` object to load the resource.
 * @property {number} LOAD_TYPE.AUDIO - Uses an `Audio` object to load the resource.
 * @property {number} LOAD_TYPE.VIDEO - Uses a `Video` object to load the resource.
 */
Resource.LOAD_TYPE = {
    XHR:    1,
    IMAGE:  2,
    AUDIO:  3,
    VIDEO:  4
};

/**
 * The XHR ready states, used internally.
 *
 * @static
 * @constant
 * @property {object} XHR_READY_STATE
 * @property {number} XHR_READY_STATE.UNSENT - open()has not been called yet.
 * @property {number} XHR_READY_STATE.OPENED - send()has not been called yet.
 * @property {number} XHR_READY_STATE.HEADERS_RECEIVED - send() has been called, and headers and status are available.
 * @property {number} XHR_READY_STATE.LOADING - Downloading; responseText holds partial data.
 * @property {number} XHR_READY_STATE.DONE - The operation is complete.
 */
Resource.XHR_READY_STATE = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
};

/**
 * The XHR ready states, used internally.
 *
 * @static
 * @constant
 * @property {object} XHR_RESPONSE_TYPE
 * @property {string} XHR_RESPONSE_TYPE.DEFAULT - defaults to text
 * @property {string} XHR_RESPONSE_TYPE.BUFFER - ArrayBuffer
 * @property {string} XHR_RESPONSE_TYPE.BLOB - Blob
 * @property {string} XHR_RESPONSE_TYPE.DOCUMENT - Document
 * @property {string} XHR_RESPONSE_TYPE.JSON - Object
 * @property {string} XHR_RESPONSE_TYPE.TEXT - String
 */
Resource.XHR_RESPONSE_TYPE = {
    DEFAULT:    'text',
    BUFFER:     'arraybuffer',
    BLOB:       'blob',
    DOCUMENT:   'document',
    JSON:       'json',
    TEXT:       'text'
};

},{"eventemitter3":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/eventemitter3/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/b64.js":[function(require,module,exports){
module.exports = {

    // private property
    _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    encodeBinary: function (input) {
        var output = "";
        var bytebuffer;
        var encodedCharIndexes = new Array(4);
        var inx = 0;
        var jnx = 0;
        var paddingBytes = 0;

        while (inx < input.length) {
            // Fill byte buffer array
            bytebuffer = new Array(3);
            for (jnx = 0; jnx < bytebuffer.length; jnx++) {
                if (inx < input.length) {
                    // throw away high-order byte, as documented at:
                    // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
                    bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;
                }
                else {
                    bytebuffer[jnx] = 0;
                }
            }

            // Get each encoded character, 6 bits at a time
            // index 1: first 6 bits
            encodedCharIndexes[0] = bytebuffer[0] >> 2;
            // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)
            encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);
            // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)
            encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);
            // index 3: forth 6 bits (6 least significant bits from input byte 3)
            encodedCharIndexes[3] = bytebuffer[2] & 0x3f;

            // Determine whether padding happened, and adjust accordingly
            paddingBytes = inx - (input.length - 1);
            switch (paddingBytes) {
                case 2:
                    // Set last 2 characters to padding char
                    encodedCharIndexes[3] = 64;
                    encodedCharIndexes[2] = 64;
                    break;

                case 1:
                    // Set last character to padding char
                    encodedCharIndexes[3] = 64;
                    break;

                default:
                    break; // No padding - proceed
            }

            // Now we will grab each appropriate character out of our keystring
            // based on our index array and append it to the output string
            for (jnx = 0; jnx < encodedCharIndexes.length; jnx++) {
                output += this._keyStr.charAt(encodedCharIndexes[jnx]);
            }
        }
        return output;
    }
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/index.js":[function(require,module,exports){
module.exports = require('./Loader');

module.exports.Resource = require('./Resource');

module.exports.middleware = {
    caching: {
        memory: require('./middlewares/caching/memory')
    },
    parsing: {
        blob: require('./middlewares/parsing/blob')
    }
};

},{"./Loader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/Loader.js","./Resource":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/Resource.js","./middlewares/caching/memory":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/middlewares/caching/memory.js","./middlewares/parsing/blob":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/middlewares/parsing/blob.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/middlewares/caching/memory.js":[function(require,module,exports){
// a simple in-memory cache for resources
var cache = {};

module.exports = function () {
    return function (resource, next) {
        // if cached, then set data and complete the resource
        if (cache[resource.url]) {
            resource.data = cache[resource.url];
            resource.complete();
        }
        // if not cached, wait for complete and store it in the cache.
        else {
            resource.once('complete', function () {
               cache[this.url] = this.data;
            });

            next();
        }
    };
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/middlewares/parsing/blob.js":[function(require,module,exports){
var Resource = require('../../Resource'),
    b64 = require('../../b64');

window.URL = window.URL || window.webkitURL;

// a middleware for transforming XHR loaded Blobs into more useful objects

module.exports = function () {
    return function (resource, next) {
        if (!resource.data) {
            return next();
        }

        // if this was an XHR load of a blob
        if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {
            // if there is no blob support we probably got a binary string back
            if (!window.Blob || typeof resource.data === 'string') {
                var type = resource.xhr.getResponseHeader('content-type');

                // this is an image, convert the binary string into a data url
                if (type && type.indexOf('image') === 0) {
                    resource.data = new Image();
                    resource.data.src = 'data:' + type + ';base64,' + b64.encodeBinary(resource.xhr.responseText);

                    next();
                }
            }
            // if content type says this is an image, then we should transform the blob into an Image object
            else if (resource.data.type.indexOf('image') === 0) {
                var src = URL.createObjectURL(resource.data);

                resource.blob = resource.data;
                resource.data = new Image();
                resource.data.src = src;

                // cleanup the no longer used blob after the image loads
                resource.data.onload = function () {
                    URL.revokeObjectURL(src);
                    resource.data.onload = null;

                    next();
                };
            }
        }
        else {
            next();
        }
    };
};

},{"../../Resource":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/Resource.js","../../b64":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/b64.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/package.json":[function(require,module,exports){
module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports={
  "name": "pixi.js",
  "version": "3.0.0-rc4",
  "description": "Pixi.js is a fast lightweight 2D library that works across all devices.",
  "author": {
    "name": "Mat Groves"
  },
  "contributors": [
    {
      "name": "Chad Engler",
      "email": "chad@pantherdev.com"
    },
    {
      "name": "Richard Davey",
      "email": "rdavey@gmail.com"
    }
  ],
  "main": "./src/index.js",
  "homepage": "http://goodboydigital.com/",
  "bugs": {
    "url": "https://github.com/GoodBoyDigital/pixi.js/issues"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/GoodBoyDigital/pixi.js.git"
  },
  "scripts": {
    "test": "gulp test",
    "docs": "jsdoc -c ./gulp/util/jsdoc.conf.json -R README.md"
  },
  "dependencies": {
    "async": "^0.9.0",
    "brfs": "^1.2.0",
    "eventemitter3": "^0.1.6",
    "object-assign": "^2.0.0",
    "resource-loader": "^1.3.2"
  },
  "devDependencies": {
    "browserify": "^8.0.2",
    "chai": "^1.10.0",
    "del": "^1.1.0",
    "gulp": "^3.8.10",
    "gulp-cached": "^1.0.1",
    "gulp-concat": "^2.5.2",
    "gulp-debug": "^2.0.0",
    "gulp-jshint": "^1.9.0",
    "gulp-mirror": "^0.4.0",
    "gulp-plumber": "^0.6.6",
    "gulp-rename": "^1.2.0",
    "gulp-sourcemaps": "^1.5.0",
    "gulp-uglify": "^1.0.2",
    "gulp-util": "^3.0.1",
    "ink-docstrap": "git+https://github.com/Pilatch/docstrap.git",
    "jsdoc": "^3.3.0-alpha13",
    "jshint-summary": "^0.4.0",
    "karma": "^0.12.28",
    "karma-firefox-launcher": "^0.1.0",
    "karma-mocha": "^0.1.10",
    "karma-spec-reporter": "^0.0.16",
    "minimist": "^1.1.0",
    "mocha": "^2.1.0",
    "require-dir": "^0.1.0",
    "run-sequence": "^1.0.2",
    "vinyl-buffer": "^1.0.0",
    "vinyl-source-stream": "^1.0.0",
    "watchify": "^2.2.1"
  },
  "browserify": {
    "transform": [
      "brfs"
    ]
  },
  "gitHead": "34c8db0ecf8089b61fa492f63f33de605e557eb9",
  "_id": "pixi.js@3.0.0-rc4",
  "_shasum": "add51749cd1662020e76702285c5975b182110d2",
  "_from": "pixi.js@>=3.0.0-rc4 <4.0.0",
  "_npmVersion": "1.4.23",
  "_npmUser": {
    "name": "englercj",
    "email": "englercj@live.com"
  },
  "maintainers": [
    {
      "name": "englercj",
      "email": "englercj@live.com"
    }
  ],
  "dist": {
    "shasum": "add51749cd1662020e76702285c5975b182110d2",
    "tarball": "http://registry.npmjs.org/pixi.js/-/pixi.js-3.0.0-rc4.tgz"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/pixi.js/-/pixi.js-3.0.0-rc4.tgz",
  "readme": "ERROR: No README data found!"
}

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js":[function(require,module,exports){
/**
 * Constant values used in pixi
 *
 * @memberof PIXI
 */
module.exports = {
    /**
     * String of the current PIXI version
     *
     * @static
     * @constant
     * @property {string} VERSION
     */
    VERSION: require('../../package.json').version,

    /**
     * @property {number} PI_2 - Two Pi
     * @constant
     * @static
     */
    PI_2: Math.PI * 2,

    /**
     * @property {number} RAD_TO_DEG - Constant conversion factor for converting radians to degrees
     * @constant
     * @static
     */
    RAD_TO_DEG: 180 / Math.PI,

    /**
     * @property {Number} DEG_TO_RAD - Constant conversion factor for converting degrees to radians
     * @constant
     * @static
     */
    DEG_TO_RAD: Math.PI / 180,

    /**
     * Constant to identify the Renderer Type.
     *
     * @static
     * @constant
     * @property {object} RENDERER_TYPE
     * @property {number} RENDERER_TYPE.UNKNOWN
     * @property {number} RENDERER_TYPE.WEBGL
     * @property {number} RENDERER_TYPE.CANVAS
     */
    RENDERER_TYPE: {
        UNKNOWN:    0,
        WEBGL:      1,
        CANVAS:     2
    },

    /**
     * Various blend modes supported by PIXI. IMPORTANT - The WebGL renderer only supports
     * the NORMAL, ADD, MULTIPLY and SCREEN blend modes. Anything else will silently act like
     * NORMAL.
     *
     * @static
     * @constant
     * @property {object} BLEND_MODES
     * @property {number} BLEND_MODES.NORMAL
     * @property {number} BLEND_MODES.ADD
     * @property {number} BLEND_MODES.MULTIPLY
     * @property {number} BLEND_MODES.SCREEN
     * @property {number} BLEND_MODES.OVERLAY
     * @property {number} BLEND_MODES.DARKEN
     * @property {number} BLEND_MODES.LIGHTEN
     * @property {number} BLEND_MODES.COLOR_DODGE
     * @property {number} BLEND_MODES.COLOR_BURN
     * @property {number} BLEND_MODES.HARD_LIGHT
     * @property {number} BLEND_MODES.SOFT_LIGHT
     * @property {number} BLEND_MODES.DIFFERENCE
     * @property {number} BLEND_MODES.EXCLUSION
     * @property {number} BLEND_MODES.HUE
     * @property {number} BLEND_MODES.SATURATION
     * @property {number} BLEND_MODES.COLOR
     * @property {number} BLEND_MODES.LUMINOSITY
     */
    BLEND_MODES: {
        NORMAL:         0,
        ADD:            1,
        MULTIPLY:       2,
        SCREEN:         3,
        OVERLAY:        4,
        DARKEN:         5,
        LIGHTEN:        6,
        COLOR_DODGE:    7,
        COLOR_BURN:     8,
        HARD_LIGHT:     9,
        SOFT_LIGHT:     10,
        DIFFERENCE:     11,
        EXCLUSION:      12,
        HUE:            13,
        SATURATION:     14,
        COLOR:          15,
        LUMINOSITY:     16
    },

    /**
     * The scale modes that are supported by pixi.
     *
     * The DEFAULT scale mode affects the default scaling mode of future operations.
     * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.
     *
     * @static
     * @constant
     * @property {object} SCALE_MODES
     * @property {number} SCALE_MODES.DEFAULT=LINEAR
     * @property {number} SCALE_MODES.LINEAR Smooth scaling
     * @property {number} SCALE_MODES.NEAREST Pixelating scaling
     */
    SCALE_MODES: {
        DEFAULT:    0,
        LINEAR:     0,
        NEAREST:    1
    },

    /**
     * The prefix that denotes a URL is for a retina asset
     *
     * @static
     * @constant
     * @property {string} RETINA_PREFIX
     */
    //example: '@2x',
    RETINA_PREFIX: /@(.+)x/,

    RESOLUTION:1,

    FILTER_RESOLUTION:1,

    /**
     * The default render options if none are supplied to {@link PIXI.WebGLRenderer}
     * or {@link PIXI.CanvasRenderer}.
     *
     * @static
     * @constant
     * @property {object} DEFAULT_RENDER_OPTIONS
     * @property {HTMLCanvasElement} DEFAULT_RENDER_OPTIONS.view=null
     * @property {boolean} DEFAULT_RENDER_OPTIONS.transparent=false
     * @property {boolean} DEFAULT_RENDER_OPTIONS.antialias=false
     * @property {boolean} DEFAULT_RENDER_OPTIONS.forceFXAA=false
     * @property {boolean} DEFAULT_RENDER_OPTIONS.preserveDrawingBuffer=false
     * @property {number} DEFAULT_RENDER_OPTIONS.resolution=1
     * @property {number} DEFAULT_RENDER_OPTIONS.backgroundColor=0x000000
     * @property {boolean} DEFAULT_RENDER_OPTIONS.clearBeforeRender=true
     * @property {boolean} DEFAULT_RENDER_OPTIONS.autoResize=false
     */
    DEFAULT_RENDER_OPTIONS: {
        view: null,
        resolution: 1,
        antialias: false,
        forceFXAA: false,
        autoResize: false,
        transparent: false,
        backgroundColor: 0x000000,
        clearBeforeRender: true,
        preserveDrawingBuffer: false
    },

    /**
     * Constants that identify shapes, mainly to prevent `instanceof` calls.
     *
     * @static
     * @constant
     * @property {object} SHAPES
     * @property {object} SHAPES.POLY=0
     * @property {object} SHAPES.RECT=1
     * @property {object} SHAPES.CIRC=2
     * @property {object} SHAPES.ELIP=3
     * @property {object} SHAPES.RREC=4
     */
    SHAPES: {
        POLY: 0,
        RECT: 1,
        CIRC: 2,
        ELIP: 3,
        RREC: 4
    },

    SPRITE_BATCH_SIZE: 2000 //nice balance between mobile and desktop machines
};

},{"../../package.json":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/package.json"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/display/Container.js":[function(require,module,exports){
var math = require('../math'),
    DisplayObject = require('./DisplayObject'),
    RenderTexture = require('../textures/RenderTexture'),
    _tempMatrix = new math.Matrix();

/**
 * A Container represents a collection of display objects.
 * It is the base class of all display objects that act as a container for other objects.
 *
 *```js
 * var container = new PIXI.Container();
 * container.addChild(sprite);
 * ```
 * @class
 * @extends DisplayObject
 * @memberof PIXI
 */
function Container()
{
    DisplayObject.call(this);

    /**
     * The array of children of this container.
     *
     * @member {DisplayObject[]}
     * @readonly
     */
    this.children = [];
}

// constructor
Container.prototype = Object.create(DisplayObject.prototype);
Container.prototype.constructor = Container;
module.exports = Container;

Object.defineProperties(Container.prototype, {
    /**
     * The width of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof Container#
     */
    width: {
        get: function ()
        {
            return this.scale.x * this.getLocalBounds().width;
        },
        set: function (value)
        {

            var width = this.getLocalBounds().width;

            if (width !== 0)
            {
                this.scale.x = value / width;
            }
            else
            {
                this.scale.x = 1;
            }


            this._width = value;
        }
    },

    /**
     * The height of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof Container#
     */
    height: {
        get: function ()
        {
            return  this.scale.y * this.getLocalBounds().height;
        },
        set: function (value)
        {

            var height = this.getLocalBounds().height;

            if (height !== 0)
            {
                this.scale.y = value / height ;
            }
            else
            {
                this.scale.y = 1;
            }

            this._height = value;
        }
    }
});

/**
 * Adds a child to the container.
 *
 * @param child {DisplayObject} The DisplayObject to add to the container
 * @return {DisplayObject} The child that was added.
 */
Container.prototype.addChild = function (child)
{
    return this.addChildAt(child, this.children.length);
};

/**
 * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
 *
 * @param child {DisplayObject} The child to add
 * @param index {Number} The index to place the child in
 * @return {DisplayObject} The child that was added.
 */
Container.prototype.addChildAt = function (child, index)
{
    // prevent adding self as child
    if (child === this)
    {
        return child;
    }

    if (index >= 0 && index <= this.children.length)
    {
        if (child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;

        this.children.splice(index, 0, child);
        return child;
    }
    else
    {
        throw new Error(child + 'addChildAt: The index '+ index +' supplied is out of bounds ' + this.children.length);
    }
};

/**
 * Swaps the position of 2 Display Objects within this container.
 *
 * @param child {DisplayObject}
 * @param child2 {DisplayObject}
 */
Container.prototype.swapChildren = function (child, child2)
{
    if (child === child2)
    {
        return;
    }

    var index1 = this.getChildIndex(child);
    var index2 = this.getChildIndex(child2);

    if (index1 < 0 || index2 < 0)
    {
        throw new Error('swapChildren: Both the supplied DisplayObjects must be children of the caller.');
    }

    this.children[index1] = child2;
    this.children[index2] = child;
};

/**
 * Returns the index position of a child DisplayObject instance
 *
 * @param child {DisplayObject} The DisplayObject instance to identify
 * @return {Number} The index position of the child display object to identify
 */
Container.prototype.getChildIndex = function (child)
{
    var index = this.children.indexOf(child);

    if (index === -1)
    {
        throw new Error('The supplied DisplayObject must be a child of the caller');
    }

    return index;
};

/**
 * Changes the position of an existing child in the display object container
 *
 * @param child {DisplayObject} The child DisplayObject instance for which you want to change the index number
 * @param index {Number} The resulting index number for the child display object
 */
Container.prototype.setChildIndex = function (child, index)
{
    if (index < 0 || index >= this.children.length)
    {
        throw new Error('The supplied index is out of bounds');
    }

    var currentIndex = this.getChildIndex(child);

    this.children.splice(currentIndex, 1); //remove from old position
    this.children.splice(index, 0, child); //add at new position
};

/**
 * Returns the child at the specified index
 *
 * @param index {Number} The index to get the child at
 * @return {DisplayObject} The child at the given index, if any.
 */
Container.prototype.getChildAt = function (index)
{
    if (index < 0 || index >= this.children.length)
    {
        throw new Error('getChildAt: Supplied index ' + index + ' does not exist in the child list, or the supplied DisplayObject is not a child of the caller');
    }

    return this.children[index];
};

/**
 * Removes a child from the container.
 *
 * @param child {DisplayObject} The DisplayObject to remove
 * @return {DisplayObject} The child that was removed.
 */
Container.prototype.removeChild = function (child)
{
    var index = this.children.indexOf(child);

    if (index === -1)
    {
        return;
    }

    return this.removeChildAt(index);
};

/**
 * Removes a child from the specified index position.
 *
 * @param index {Number} The index to get the child from
 * @return {DisplayObject} The child that was removed.
 */
Container.prototype.removeChildAt = function (index)
{
    var child = this.getChildAt(index);

    child.parent = null;
    this.children.splice(index, 1);

    return child;
};

/**
 * Removes all children from this container that are within the begin and end indexes.
 *
 * @param beginIndex {Number} The beginning position. Default value is 0.
 * @param endIndex {Number} The ending position. Default value is size of the container.
 */
Container.prototype.removeChildren = function (beginIndex, endIndex)
{
    var begin = beginIndex || 0;
    var end = typeof endIndex === 'number' ? endIndex : this.children.length;
    var range = end - begin;

    if (range > 0 && range <= end)
    {
        var removed = this.children.splice(begin, range);

        for (var i = 0; i < removed.length; ++i)
        {
            removed[i].parent = null;
        }

        return removed;
    }
    else if (range === 0 && this.children.length === 0)
    {
        return [];
    }
    else
    {
        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
    }
};

/**
 * Useful function that returns a texture of the display object that can then be used to create sprites
 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
 *
 * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used to generate the texture.
 * @param resolution {Number} The resolution of the texture being generated
 * @param scaleMode {Number} See {@link SCALE_MODES} for possible values
 * @return {Texture} a texture of the display object
 */
Container.prototype.generateTexture = function (renderer, resolution, scaleMode)
{
    var bounds = this.getLocalBounds();

    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, renderer, scaleMode, resolution);

    _tempMatrix.tx = -bounds.x;
    _tempMatrix.ty = -bounds.y;

    renderTexture.render(this, _tempMatrix);

    return renderTexture;
};

/*
 * Updates the transform on all children of this container for rendering
 *
 * @private
 */
Container.prototype.updateTransform = function ()
{
    if (!this.visible)
    {
        return;
    }

    this.displayObjectUpdateTransform();

    for (var i = 0, j = this.children.length; i < j; ++i)
    {
        this.children[i].updateTransform();
    }
};

// performance increase to avoid using call.. (10x faster)
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;

/**
 * Retrieves the bounds of the Container as a rectangle. The bounds calculation takes all visible children into consideration.
 *
 * @return {Rectangle} The rectangular bounding area
 */
Container.prototype.getBounds = function ()
{
    if(!this._currentBounds)
    {

        if (this.children.length === 0)
        {
            return math.Rectangle.EMPTY;
        }

        // TODO the bounds have already been calculated this render session so return what we have

        var minX = Infinity;
        var minY = Infinity;

        var maxX = -Infinity;
        var maxY = -Infinity;

        var childBounds;
        var childMaxX;
        var childMaxY;

        var childVisible = false;

        for (var i = 0, j = this.children.length; i < j; ++i)
        {
            var child = this.children[i];

            if (!child.visible)
            {
                continue;
            }

            childVisible = true;

            childBounds = this.children[i].getBounds();

            minX = minX < childBounds.x ? minX : childBounds.x;
            minY = minY < childBounds.y ? minY : childBounds.y;

            childMaxX = childBounds.width + childBounds.x;
            childMaxY = childBounds.height + childBounds.y;

            maxX = maxX > childMaxX ? maxX : childMaxX;
            maxY = maxY > childMaxY ? maxY : childMaxY;
        }

        if (!childVisible)
        {
            return math.Rectangle.EMPTY;
        }

        var bounds = this._bounds;

        bounds.x = minX;
        bounds.y = minY;
        bounds.width = maxX - minX;
        bounds.height = maxY - minY;

        this._currentBounds = bounds;
    }

    return this._currentBounds;
};

Container.prototype.containerGetBounds = Container.prototype.getBounds;

/**
 * Retrieves the non-global local bounds of the Container as a rectangle.
 * The calculation takes all visible children into consideration.
 *
 * @return {Rectangle} The rectangular bounding area
 */
Container.prototype.getLocalBounds = function ()
{
    var matrixCache = this.worldTransform;

    this.worldTransform = math.Matrix.IDENTITY;

    for (var i = 0, j = this.children.length; i < j; ++i)
    {
        this.children[i].updateTransform();
    }

    this.worldTransform = matrixCache;

    this._currentBounds = null;

    return this.getBounds();
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {WebGLRenderer} The renderer
 */
Container.prototype.renderWebGL = function (renderer)
{

    // if the object is not visible or the alpha is 0 then no need to render this element
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)
    {
        return;
    }

    var i, j;

    // do a quick check to see if this element has a mask or a filter.
    if (this._mask || this._filters)
    {
        renderer.currentRenderer.flush();

        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (this._filters)
        {
            renderer.filterManager.pushFilter(this, this._filters);
        }

        if (this._mask)
        {
            renderer.maskManager.pushMask(this, this._mask);
        }

        renderer.currentRenderer.start();

        // add this object to the batch, only rendered if it has a texture.
        this._renderWebGL(renderer);

        // now loop through the children and make sure they get rendered
        for (i = 0, j = this.children.length; i < j; i++)
        {
            this.children[i].renderWebGL(renderer);
        }

        renderer.currentRenderer.flush();

        if (this._mask)
        {
            renderer.maskManager.popMask(this, this._mask);
        }

        if (this._filters)
        {
            renderer.filterManager.popFilter();

        }
        renderer.currentRenderer.start();
    }
    else
    {
        this._renderWebGL(renderer);

        // simple render children!
        for (i = 0, j = this.children.length; i < j; ++i)
        {
            this.children[i].renderWebGL(renderer);
        }
    }
};

/**
 * To be overridden by the subclass
 *
 * @param renderer {WebGLRenderer} The renderer
 * @private
 */
Container.prototype._renderWebGL = function (renderer) // jshint unused:false
{
    // this is where content itself gets rendered...
};

/**
 * To be overridden by the subclass
 *
 * @param renderer {CanvasRenderer} The renderer
 * @private
 */
Container.prototype._renderCanvas = function (renderer) // jshint unused:false
{
    // this is where content itself gets rendered...
};


/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {CanvasRenderer} The renderer
 */
Container.prototype.renderCanvas = function (renderer)
{
    // if not visible or the alpha is 0 then no need to render this
    if (!this.visible || this.alpha <= 0 || !this.renderable)
    {
        return;
    }

    if (this._mask)
    {
        renderer.maskManager.pushMask(this._mask, renderer);
    }

    this._renderCanvas(renderer);
    for (var i = 0, j = this.children.length; i < j; ++i)
    {
        this.children[i].renderCanvas(renderer);
    }

    if (this._mask)
    {
        renderer.maskManager.popMask(renderer);
    }
};

/**
 * Destroys the container
 * @param destroyChildren {boolean} if set to true, all the children will have their destroy method called as well
 */
Container.prototype.destroy = function (destroyChildren)
{
    DisplayObject.prototype.destroy.call(this);

    if(destroyChildren)
    {
        for (var i = 0, j = this.children.length; i < j; ++i)
        {
            this.children[i].destroy(destroyChildren);
        }
    }

    this.removeChildren();

    this.children = null;
};

},{"../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../textures/RenderTexture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/RenderTexture.js","./DisplayObject":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/display/DisplayObject.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/display/DisplayObject.js":[function(require,module,exports){
var math = require('../math'),
    RenderTexture = require('../textures/RenderTexture'),
    EventEmitter = require('eventemitter3').EventEmitter,
    CONST = require('../const'),
    _tempMatrix = new math.Matrix();

/**
 * The base class for all objects that are rendered on the screen.
 * This is an abstract class and should not be used on its own rather it should be extended.
 *
 * @class
 * @memberof PIXI
 */
function DisplayObject()
{
    EventEmitter.call(this);

    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     *
     * @member {Point}
     */
    this.position = new math.Point();

    /**
     * The scale factor of the object.
     *
     * @member {Point}
     */
    this.scale = new math.Point(1, 1);

    /**
     * The pivot point of the displayObject that it rotates around
     *
     * @member {Point}
     */
    this.pivot = new math.Point(0, 0);

    /**
     * The rotation of the object in radians.
     *
     * @member {number}
     */
    this.rotation = 0;

    /**
     * The opacity of the object.
     *
     * @member {number}
     */
    this.alpha = 1;

    /**
     * The visibility of the object. If false the object will not be drawn, and
     * the updateTransform function will not be called.
     *
     * @member {boolean}
     */
    this.visible = true;

    /**
     * Can this object be rendered, if false the object will not be drawn but the updateTransform
     * methods will still be called.
     *
     * @member {boolean}
     */
    this.renderable = true;

    /**
     * The display object container that contains this display object.
     *
     * @member {Container}
     * @readOnly
     */
    this.parent = null;

    /**
     * The multiplied alpha of the displayObject
     *
     * @member {number}
     * @readOnly
     */
    this.worldAlpha = 1;

    /**
     * Current transform of the object based on world (parent) factors
     *
     * @member {Matrix}
     * @readOnly
     */
    this.worldTransform = new math.Matrix();

    /**
     * The area the filter is applied to. This is used as more of an optimisation
     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
     *
     * @member {Rectangle}
     */
    this.filterArea = null;

    /**
     * cached sin rotation
     *
     * @member {number}
     * @private
     */
    this._sr = 0;

    /**
     * cached cos rotation
     *
     * @member {number}
     * @private
     */
    this._cr = 1;

    /**
     * The original, cached bounds of the object
     *
     * @member {Rectangle}
     * @private
     */
    this._bounds = new math.Rectangle(0, 0, 1, 1);

    /**
     * The most up-to-date bounds of the object
     *
     * @member {Rectangle}
     * @private
     */
    this._currentBounds = null;

    /**
     * The original, cached mask of the object
     *
     * @member {Rectangle}
     * @private
     */
    this._mask = null;

    //TODO rename to _isMask
   // this.isMask = false;

    /**
     * Cached internal flag.
     *
     * @member {boolean}
     * @private
     */
    this._cacheAsBitmap = false;
    this._cachedObject = null;
}

// constructor
DisplayObject.prototype = Object.create(EventEmitter.prototype);
DisplayObject.prototype.constructor = DisplayObject;
module.exports = DisplayObject;

Object.defineProperties(DisplayObject.prototype, {
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     * @memberof DisplayObject#
     */
    x: {
        get: function ()
        {
            return this.position.x;
        },
        set: function (value)
        {
            this.position.x = value;
        }
    },

    /**
     * The position of the displayObject on the y axis relative to the local coordinates of the parent.
     *
     * @member {number}
     * @memberof DisplayObject#
     */
    y: {
        get: function ()
        {
            return this.position.y;
        },
        set: function (value)
        {
            this.position.y = value;
        }
    },

    /**
     * Indicates if the sprite is globally visible.
     *
     * @member {boolean}
     * @memberof DisplayObject#
     * @readonly
     */
    worldVisible: {
        get: function ()
        {
            var item = this;

            do {
                if (!item.visible)
                {
                    return false;
                }

                item = item.parent;
            } while (item);

            return true;
        }
    },

    /**
     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.
     * In PIXI a regular mask must be a PIXI.Graphics object. This allows for much faster masking in canvas as it utilises shape clipping.
     * To remove a mask, set this property to null.
     *
     * @member {Graphics}
     * @memberof DisplayObject#
     */
    mask: {
        get: function ()
        {
            return this._mask;
        },
        set: function (value)
        {
            if (this._mask)
            {
                this._mask.renderable = true;
            }

            this._mask = value;

            if (this._mask)
            {
                this._mask.renderable = false;
            }
        }
    },

    /**
     * Sets the filters for the displayObject.
     * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
     * To remove filters simply set this property to 'null'
     *
     * @member {Filter[]}
     * @memberof DisplayObject#
     */
    filters: {
        get: function ()
        {
            return this._filters && this._filters.slice();
        },
        set: function (value)
        {
            this._filters = value && value.slice();
        }
    }

});

/*
 * Updates the object transform for rendering
 *
 * TODO - Optimization pass!
 *
 * @private
 */
DisplayObject.prototype.updateTransform = function ()
{

    // create some matrix refs for easy access
    var pt = this.parent.worldTransform;
    var wt = this.worldTransform;

    // temporary matrix variables
    var a, b, c, d, tx, ty;

    // so if rotation is between 0 then we can simplify the multiplication process...
    if (this.rotation % CONST.PI_2)
    {
        // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes
        if (this.rotation !== this.rotationCache)
        {
            this.rotationCache = this.rotation;
            this._sr = Math.sin(this.rotation);
            this._cr = Math.cos(this.rotation);
        }

        // get the matrix values of the displayobject based on its transform properties..
        a  =  this._cr * this.scale.x;
        b  =  this._sr * this.scale.x;
        c  = -this._sr * this.scale.y;
        d  =  this._cr * this.scale.y;
        tx =  this.position.x;
        ty =  this.position.y;

        // check for pivot.. not often used so geared towards that fact!
        if (this.pivot.x || this.pivot.y)
        {
            tx -= this.pivot.x * a + this.pivot.y * c;
            ty -= this.pivot.x * b + this.pivot.y * d;
        }

        // concat the parent matrix with the objects transform.
        wt.a  = a  * pt.a + b  * pt.c;
        wt.b  = a  * pt.b + b  * pt.d;
        wt.c  = c  * pt.a + d  * pt.c;
        wt.d  = c  * pt.b + d  * pt.d;
        wt.tx = tx * pt.a + ty * pt.c + pt.tx;
        wt.ty = tx * pt.b + ty * pt.d + pt.ty;
    }
    else
    {
        // lets do the fast version as we know there is no rotation..
        a  = this.scale.x;
        d  = this.scale.y;

        tx = this.position.x - this.pivot.x * a;
        ty = this.position.y - this.pivot.y * d;

        wt.a  = a  * pt.a;
        wt.b  = a  * pt.b;
        wt.c  = d  * pt.c;
        wt.d  = d  * pt.d;
        wt.tx = tx * pt.a + ty * pt.c + pt.tx;
        wt.ty = tx * pt.b + ty * pt.d + pt.ty;
    }

    // multiply the alphas..
    this.worldAlpha = this.alpha * this.parent.worldAlpha;

    // reset the bounds each time this is called!
    this._currentBounds = null;
};

// performance increase to avoid using call.. (10x faster)
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;

/**
 *
 *
 * Retrieves the bounds of the displayObject as a rectangle object
 *
 * @param matrix {Matrix}
 * @return {Rectangle} the rectangular bounding area
 */
DisplayObject.prototype.getBounds = function (matrix) // jshint unused:false
{
    return math.Rectangle.EMPTY;
};

/**
 * Retrieves the local bounds of the displayObject as a rectangle object
 *
 * @return {Rectangle} the rectangular bounding area
 */
DisplayObject.prototype.getLocalBounds = function ()
{
    return this.getBounds(math.Matrix.IDENTITY);
};

/**
 * Calculates the global position of the display object
 *
 * @param position {Point} The world origin to calculate from
 * @return {Point} A point object representing the position of this object
 */
DisplayObject.prototype.toGlobal = function (position)
{
    // don't need to update the lot
    this.displayObjectUpdateTransform();
    return this.worldTransform.apply(position);
};

/**
 * Calculates the local position of the display object relative to another point
 *
 * @param position {Point} The world origin to calculate from
 * @param [from] {DisplayObject} The DisplayObject to calculate the global position from
 * @return {Point} A point object representing the position of this object
 */
DisplayObject.prototype.toLocal = function (position, from)
{
    if (from)
    {
        position = from.toGlobal(position);
    }

    // don't need to update the lot
    this.displayObjectUpdateTransform();
    return this.worldTransform.applyInverse(position);
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {WebGLRenderer} The renderer
 * @private
 */
DisplayObject.prototype.renderWebGL = function (renderer) // jshint unused:false
{
    // OVERWRITE;
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {CanvasRenderer} The renderer
 * @private
 */
DisplayObject.prototype.renderCanvas = function (renderer) // jshint unused:false
{
    // OVERWRITE;
};
/**
 * Useful function that returns a texture of the display object that can then be used to create sprites
 * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.
 *
 * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used to generate the texture.
 * @param resolution {Number} The resolution of the texture being generated
 * @param scaleMode {Number} See {@link SCALE_MODES} for possible values
 * @return {Texture} a texture of the display object
 */
DisplayObject.prototype.generateTexture = function (renderer, resolution, scaleMode)
{
    var bounds = this.getLocalBounds();

    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, renderer, scaleMode, resolution);

    _tempMatrix.tx = -bounds.x;
    _tempMatrix.ty = -bounds.y;

    renderTexture.render(this, _tempMatrix);

    return renderTexture;
};

/**
 * Base destroy method for generic display objects
 *
 */
DisplayObject.prototype.destroy = function ()
{

    this.position = null;
    this.scale = null;
    this.pivot = null;

    this._bounds = null;
    this._currentBounds = null;
    this._mask = null;

    this.worldTransform = null;
    this.filterArea = null;

    this.listeners = null;
};

},{"../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../textures/RenderTexture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/RenderTexture.js","eventemitter3":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/eventemitter3/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/graphics/Graphics.js":[function(require,module,exports){
var Container = require('../display/Container'),
    Sprite = require('../sprites/Sprite'),
    Texture = require('../textures/Texture'),
    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),
    CanvasGraphics = require('../renderers/canvas/utils/CanvasGraphics'),
    GraphicsData = require('./GraphicsData'),
    math = require('../math'),
    CONST = require('../const'),
    tempPoint = new math.Point();

/**
 * The Graphics class contains methods used to draw primitive shapes such as lines, circles and
 * rectangles to the display, and to color and fill them.
 *
 * @class
 * @extends Container
 * @memberof PIXI
 */
function Graphics()
{
    Container.call(this);

    /**
     * The alpha value used when filling the Graphics object.
     *
     * @member {number}
     * @default 1
     */
    this.fillAlpha = 1;

    /**
     * The width (thickness) of any lines drawn.
     *
     * @member {number}
     * @default 0
     */
    this.lineWidth = 0;

    /**
     * The color of any lines drawn.
     *
     * @member {string}
     * @default 0
     */
    this.lineColor = 0;

    /**
     * Graphics data
     *
     * @member {GraphicsData[]}
     * @private
     */
    this.graphicsData = [];

    /**
     * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    this.tint = 0xFFFFFF;

    /**
     * The previous tint applied to the graphic shape. Used to compare to the current tint and check if theres change.
     *
     * @member {number}
     * @private
     * @default 0xFFFFFF
     */
    this._prevTint = 0xFFFFFF;

    /**
     * The blend mode to be applied to the graphic shape. Apply a value of blendModes.NORMAL to reset the blend mode.
     *
     * @member {number}
     * @default CONST.BLEND_MODES.NORMAL;
     */
    this.blendMode = CONST.BLEND_MODES.NORMAL;

    /**
     * Current path
     *
     * @member {GraphicsData}
     * @private
     */
    this.currentPath = null;

    /**
     * Array containing some WebGL-related properties used by the WebGL renderer.
     *
     * @member {object<number, object>}
     * @private
     */
    // TODO - _webgl should use a prototype object, not a random undocumented object...
    this._webGL = {};

    /**
     * Whether this shape is being used as a mask.
     *
     * @member {boolean}
     */
    this.isMask = false;

    /**
     * The bounds' padding used for bounds calculation.
     *
     * @member {number}
     */
    this.boundsPadding = 0;

    /**
     * A cache of the local bounds to prevent recalculation.
     *
     * @member {Rectangle}
     * @private
     */
    this._localBounds = new math.Rectangle(0,0,1,1);

    /**
     * Used to detect if the graphics object has changed. If this is set to true then the graphics
     * object will be recalculated.
     *
     * @member {boolean}
     * @private
     */
    this.dirty = true;

    /**
     * Used to detect if the WebGL graphics object has changed. If this is set to true then the
     * graphics object will be recalculated.
     *
     * @member {boolean}
     * @private
     */
    this.glDirty = false;

    /**
     * Used to detect if the cached sprite object needs to be updated.
     *
     * @member {boolean}
     * @private
     */
    this.cachedSpriteDirty = false;
}

// constructor
Graphics.prototype = Object.create(Container.prototype);
Graphics.prototype.constructor = Graphics;
module.exports = Graphics;

Object.defineProperties(Graphics.prototype, {
    /**
     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
     * This is useful if your graphics element does not change often, as it will speed up the rendering
     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
     * you are constantly redrawing the graphics element.
     *
     * @member {boolean}
     * @memberof Graphics#
     * @default false
     * @private
     */

});

/**
 * Creates a new Graphics object with the same values as this one.
 *
 * @return {Graphics}
 */
Graphics.prototype.clone = function ()
{
    var clone = new Graphics();

    clone.renderable    = this.renderable;
    clone.fillAlpha     = this.fillAlpha;
    clone.lineWidth     = this.lineWidth;
    clone.lineColor     = this.lineColor;
    clone.tint          = this.tint;
    clone.blendMode     = this.blendMode;
    clone.isMask        = this.isMask;
    clone.boundsPadding = this.boundsPadding;
    clone.dirty         = this.dirty;
    clone.glDirty       = this.glDirty;
    clone.cachedSpriteDirty = this.cachedSpriteDirty;

    // copy graphics data
    for (var i = 0; i < this.graphicsData.length; ++i)
    {
        clone.graphicsData.push(this.graphicsData.clone());
    }

    clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];

    clone.updateLocalBounds();

    return clone;
};

/**
 * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.
 *
 * @param lineWidth {number} width of the line to draw, will update the objects stored style
 * @param color {number} color of the line to draw, will update the objects stored style
 * @param alpha {number} alpha of the line to draw, will update the objects stored style
 * @return {Graphics}
 */
Graphics.prototype.lineStyle = function (lineWidth, color, alpha)
{
    this.lineWidth = lineWidth || 0;
    this.lineColor = color || 0;
    this.lineAlpha = (arguments.length < 3) ? 1 : alpha;

    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length)
        {
            // halfway through a line? start a new one!
            this.drawShape( new math.Polygon( this.currentPath.shape.points.slice(-2) ));
        }
        else
        {
            // otherwise its empty so lets just set the line properties
            this.currentPath.lineWidth = this.lineWidth;
            this.currentPath.lineColor = this.lineColor;
            this.currentPath.lineAlpha = this.lineAlpha;
        }
    }

    return this;
};

/**
 * Moves the current drawing position to x, y.
 *
 * @param x {number} the X coordinate to move to
 * @param y {number} the Y coordinate to move to
 * @return {Graphics}
  */
Graphics.prototype.moveTo = function (x, y)
{
    this.drawShape(new math.Polygon([x,y]));

    return this;
};

/**
 * Draws a line using the current line style from the current drawing position to (x, y);
 * The current drawing position is then set to (x, y).
 *
 * @param x {number} the X coordinate to draw to
 * @param y {number} the Y coordinate to draw to
 * @return {Graphics}
 */
Graphics.prototype.lineTo = function (x, y)
{
    this.currentPath.shape.points.push(x, y);
    this.dirty = true;

    return this;
};

/**
 * Calculate the points for a quadratic bezier curve and then draws it.
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * @param cpX {number} Control point x
 * @param cpY {number} Control point y
 * @param toX {number} Destination point x
 * @param toY {number} Destination point y
 * @return {Graphics}
 */
Graphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY)
{
    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length === 0)
        {
            this.currentPath.shape.points = [0, 0];
        }
    }
    else
    {
        this.moveTo(0,0);
    }

    var xa,
        ya,
        n = 20,
        points = this.currentPath.shape.points;

    if (points.length === 0)
    {
        this.moveTo(0, 0);
    }

    var fromX = points[points.length-2];
    var fromY = points[points.length-1];

    var j = 0;
    for (var i = 1; i <= n; ++i)
    {
        j = i / n;

        xa = fromX + ( (cpX - fromX) * j );
        ya = fromY + ( (cpY - fromY) * j );

        points.push( xa + ( ((cpX + ( (toX - cpX) * j )) - xa) * j ),
                     ya + ( ((cpY + ( (toY - cpY) * j )) - ya) * j ) );
    }

    this.dirty = true;

    return this;
};

/**
 * Calculate the points for a bezier curve and then draws it.
 *
 * @param cpX {number} Control point x
 * @param cpY {number} Control point y
 * @param cpX2 {number} Second Control point x
 * @param cpY2 {number} Second Control point y
 * @param toX {number} Destination point x
 * @param toY {number} Destination point y
 * @return {Graphics}
 */
Graphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY)
{
    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length === 0)
        {
            this.currentPath.shape.points = [0, 0];
        }
    }
    else
    {
        this.moveTo(0,0);
    }

    var n = 20,
        dt,
        dt2,
        dt3,
        t2,
        t3,
        points = this.currentPath.shape.points;

    var fromX = points[points.length-2];
    var fromY = points[points.length-1];

    var j = 0;

    for (var i = 1; i <= n; ++i)
    {
        j = i / n;

        dt = (1 - j);
        dt2 = dt * dt;
        dt3 = dt2 * dt;

        t2 = j * j;
        t3 = t2 * j;

        points.push( dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,
                     dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }

    this.dirty = true;

    return this;
};

/**
 * The arcTo() method creates an arc/curve between two tangents on the canvas.
 *
 * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
 *
 * @param x1 {number} The x-coordinate of the beginning of the arc
 * @param y1 {number} The y-coordinate of the beginning of the arc
 * @param x2 {number} The x-coordinate of the end of the arc
 * @param y2 {number} The y-coordinate of the end of the arc
 * @param radius {number} The radius of the arc
 * @return {Graphics}
 */
Graphics.prototype.arcTo = function (x1, y1, x2, y2, radius)
{
    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length === 0)
        {
            this.currentPath.shape.points.push(x1, y1);
        }
    }
    else
    {
        this.moveTo(x1, y1);
    }

    var points = this.currentPath.shape.points,
        fromX = points[points.length-2],
        fromY = points[points.length-1],
        a1 = fromY - y1,
        b1 = fromX - x1,
        a2 = y2   - y1,
        b2 = x2   - x1,
        mm = Math.abs(a1 * b2 - b1 * a2);

    if (mm < 1.0e-8 || radius === 0)
    {
        if (points[points.length-2] !== x1 || points[points.length-1] !== y1)
        {
            points.push(x1, y1);
        }
    }
    else
    {
        var dd = a1 * a1 + b1 * b1,
            cc = a2 * a2 + b2 * b2,
            tt = a1 * a2 + b1 * b2,
            k1 = radius * Math.sqrt(dd) / mm,
            k2 = radius * Math.sqrt(cc) / mm,
            j1 = k1 * tt / dd,
            j2 = k2 * tt / cc,
            cx = k1 * b2 + k2 * b1,
            cy = k1 * a2 + k2 * a1,
            px = b1 * (k2 + j1),
            py = a1 * (k2 + j1),
            qx = b2 * (k1 + j2),
            qy = a2 * (k1 + j2),
            startAngle = Math.atan2(py - cy, px - cx),
            endAngle   = Math.atan2(qy - cy, qx - cx);

        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
    }

    this.dirty = true;

    return this;
};

/**
 * The arc method creates an arc/curve (used to create circles, or parts of circles).
 *
 * @param cx {number} The x-coordinate of the center of the circle
 * @param cy {number} The y-coordinate of the center of the circle
 * @param radius {number} The radius of the circle
 * @param startAngle {number} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)
 * @param endAngle {number} The ending angle, in radians
 * @param anticlockwise {boolean} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.
 * @return {Graphics}
 */
Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise)
{
    var startX = cx + Math.cos(startAngle) * radius;
    var startY = cy + Math.sin(startAngle) * radius;
    var points;

    if( this.currentPath )
    {
        points = this.currentPath.shape.points;

        if(points.length === 0)
        {
            points.push(startX, startY);
        }
        else if( points[points.length-2] !== startX || points[points.length-1] !== startY)
        {
            points.push(startX, startY);
        }
    }
    else
    {
        this.moveTo(startX, startY);
        points = this.currentPath.shape.points;
    }

    if (startAngle === endAngle)
    {
        return this;
    }

    if( !anticlockwise && endAngle <= startAngle )
    {
        endAngle += Math.PI * 2;
    }
    else if( anticlockwise && startAngle <= endAngle )
    {
        startAngle += Math.PI * 2;
    }

    var sweep = anticlockwise ? (startAngle - endAngle) *-1 : (endAngle - startAngle);
    var segs =  Math.ceil( Math.abs(sweep)/ (Math.PI * 2) ) * 40;

    if( sweep === 0 )
    {
        return this;
    }

    var theta = sweep/(segs*2);
    var theta2 = theta*2;

    var cTheta = Math.cos(theta);
    var sTheta = Math.sin(theta);

    var segMinus = segs - 1;

    var remainder = ( segMinus % 1 ) / segMinus;

    for(var i=0; i<=segMinus; i++)
    {
        var real =  i + remainder * i;


        var angle = ((theta) + startAngle + (theta2 * real));

        var c = Math.cos(angle);
        var s = -Math.sin(angle);

        points.push(( (cTheta *  c) + (sTheta * s) ) * radius + cx,
                    ( (cTheta * -s) + (sTheta * c) ) * radius + cy);
    }

    this.dirty = true;

    return this;
};

/**
 * Specifies a simple one-color fill that subsequent calls to other Graphics methods
 * (such as lineTo() or drawCircle()) use when drawing.
 *
 * @param color {number} the color of the fill
 * @param alpha {number} the alpha of the fill
 * @return {Graphics}
 */
Graphics.prototype.beginFill = function (color, alpha)
{
    this.filling = true;
    this.fillColor = color || 0;
    this.fillAlpha = (alpha === undefined) ? 1 : alpha;

    if (this.currentPath)
    {
        if (this.currentPath.shape.points.length <= 2)
        {
            this.currentPath.fill = this.filling;
            this.currentPath.fillColor = this.fillColor;
            this.currentPath.fillAlpha = this.fillAlpha;
        }
    }
    return this;
};

/**
 * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
 *
 * @return {Graphics}
 */
Graphics.prototype.endFill = function ()
{
    this.filling = false;
    this.fillColor = null;
    this.fillAlpha = 1;

    return this;
};

/**
 *
 * @param x {number} The X coord of the top-left of the rectangle
 * @param y {number} The Y coord of the top-left of the rectangle
 * @param width {number} The width of the rectangle
 * @param height {number} The height of the rectangle
 * @return {Graphics}
 */
Graphics.prototype.drawRect = function ( x, y, width, height )
{
    this.drawShape(new math.Rectangle(x,y, width, height));

    return this;
};

/**
 *
 * @param x {number} The X coord of the top-left of the rectangle
 * @param y {number} The Y coord of the top-left of the rectangle
 * @param width {number} The width of the rectangle
 * @param height {number} The height of the rectangle
 * @param radius {number} Radius of the rectangle corners
 */
Graphics.prototype.drawRoundedRect = function ( x, y, width, height, radius )
{
    this.drawShape(new math.RoundedRectangle(x, y, width, height, radius));

    return this;
};

/**
 * Draws a circle.
 *
 * @param x {number} The X coordinate of the center of the circle
 * @param y {number} The Y coordinate of the center of the circle
 * @param radius {number} The radius of the circle
 * @return {Graphics}
 */
Graphics.prototype.drawCircle = function (x, y, radius)
{
    this.drawShape(new math.Circle(x,y, radius));

    return this;
};

/**
 * Draws an ellipse.
 *
 * @param x {number} The X coordinate of the center of the ellipse
 * @param y {number} The Y coordinate of the center of the ellipse
 * @param width {number} The half width of the ellipse
 * @param height {number} The half height of the ellipse
 * @return {Graphics}
 */
Graphics.prototype.drawEllipse = function (x, y, width, height)
{
    this.drawShape(new math.Ellipse(x, y, width, height));

    return this;
};

/**
 * Draws a polygon using the given path.
 *
 * @param path {Array} The path data used to construct the polygon.
 * @return {Graphics}
 */
Graphics.prototype.drawPolygon = function (path)
{
    // prevents an argument assignment deopt
    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
    var points = path;

    if (!Array.isArray(points))
    {
        // prevents an argument leak deopt
        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        points = new Array(arguments.length);

        for (var i = 0; i < points.length; ++i) {
            points[i] = arguments[i];
        }
    }

    this.drawShape(new math.Polygon(points));

    return this;
};

/**
 * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
 *
 * @return {Graphics}
 */
Graphics.prototype.clear = function ()
{
    this.lineWidth = 0;
    this.filling = false;

    this.dirty = true;
    this.clearDirty = true;
    this.graphicsData = [];

    return this;
};

/**
 * Useful function that returns a texture of the graphics object that can then be used to create sprites
 * This can be quite useful if your geometry is complicated and needs to be reused multiple times.
 *
 * @param resolution {number} The resolution of the texture being generated
 * @param scaleMode {number} Should be one of the scaleMode consts
 * @return {Texture} a texture of the graphics object
 */
Graphics.prototype.generateTexture = function (renderer, resolution, scaleMode)
{

    resolution = resolution || 1;

    var bounds = this.getLocalBounds();

    var canvasBuffer = new CanvasBuffer(bounds.width * resolution, bounds.height * resolution);

    var texture = Texture.fromCanvas(canvasBuffer.canvas, scaleMode);
    texture.baseTexture.resolution = resolution;

    canvasBuffer.context.scale(resolution, resolution);

    canvasBuffer.context.translate(-bounds.x,-bounds.y);

    CanvasGraphics.renderGraphics(this, canvasBuffer.context);

    return texture;
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {WebGLRenderer}
 * @private
 */
Graphics.prototype._renderWebGL = function (renderer)
{
    // if the sprite is not visible or the alpha is 0 then no need to render this element

    // this code may still be needed so leaving for now..
    //
    /*
    if (this._cacheAsBitmap)
    {
        if (this.dirty || this.cachedSpriteDirty)
        {
            this._generateCachedSprite();

            // we will also need to update the texture on the gpu too!
            this.updateCachedSpriteTexture();

            this.cachedSpriteDirty = false;
            this.dirty = false;
        }

        this._cachedSprite.worldAlpha = this.worldAlpha;

        Sprite.prototype.renderWebGL.call(this._cachedSprite, renderer);

        return;
    }

    */

    if (this.glDirty)
    {
        this.dirty = true;
        this.glDirty = false;
    }

    renderer.setObjectRenderer(renderer.plugins.graphics);
    renderer.plugins.graphics.render(this);

};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {CanvasRenderer}
 * @private
 */
Graphics.prototype._renderCanvas = function (renderer)
{
    if (this.isMask === true)
    {
        return;
    }

    // if the tint has changed, set the graphics object to dirty.
    if (this._prevTint !== this.tint) {
        this.dirty = true;
        this._prevTint = this.tint;
    }

    if (this._cacheAsBitmap)
    {
        if (this.dirty || this.cachedSpriteDirty)
        {
            this._generateCachedSprite();

            // we will also need to update the texture
            this.updateCachedSpriteTexture();

            this.cachedSpriteDirty = false;
            this.dirty = false;
        }

        this._cachedSprite.alpha = this.alpha;

        Sprite.prototype._renderCanvas.call(this._cachedSprite, renderer);

        return;
    }
    else
    {
        var context = renderer.context;
        var transform = this.worldTransform;

        if (this.blendMode !== renderer.currentBlendMode)
        {
            renderer.currentBlendMode = this.blendMode;
            context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];
        }

        var resolution = renderer.resolution;
        context.setTransform(
            transform.a * resolution,
            transform.b * resolution,
            transform.c * resolution,
            transform.d * resolution,
            transform.tx * resolution,
            transform.ty * resolution
        );

        CanvasGraphics.renderGraphics(this, context);
    }
};

/**
 * Retrieves the bounds of the graphic shape as a rectangle object
 *
 * @return {Rectangle} the rectangular bounding area
 */
Graphics.prototype.getBounds = function (matrix)
{
    if(!this._currentBounds)
    {

        // return an empty object if the item is a mask!
        if (!this.renderable)
        {
            return math.Rectangle.EMPTY;
        }

        if (this.dirty)
        {
            this.updateLocalBounds();

            this.glDirty = true;
            this.cachedSpriteDirty = true;
            this.dirty = false;
        }

        var bounds = this._localBounds;

        var w0 = bounds.x;
        var w1 = bounds.width + bounds.x;

        var h0 = bounds.y;
        var h1 = bounds.height + bounds.y;

        var worldTransform = matrix || this.worldTransform;

        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;

        var x1 = a * w1 + c * h1 + tx;
        var y1 = d * h1 + b * w1 + ty;

        var x2 = a * w0 + c * h1 + tx;
        var y2 = d * h1 + b * w0 + ty;

        var x3 = a * w0 + c * h0 + tx;
        var y3 = d * h0 + b * w0 + ty;

        var x4 =  a * w1 + c * h0 + tx;
        var y4 =  d * h0 + b * w1 + ty;

        var maxX = x1;
        var maxY = y1;

        var minX = x1;
        var minY = y1;

        minX = x2 < minX ? x2 : minX;
        minX = x3 < minX ? x3 : minX;
        minX = x4 < minX ? x4 : minX;

        minY = y2 < minY ? y2 : minY;
        minY = y3 < minY ? y3 : minY;
        minY = y4 < minY ? y4 : minY;

        maxX = x2 > maxX ? x2 : maxX;
        maxX = x3 > maxX ? x3 : maxX;
        maxX = x4 > maxX ? x4 : maxX;

        maxY = y2 > maxY ? y2 : maxY;
        maxY = y3 > maxY ? y3 : maxY;
        maxY = y4 > maxY ? y4 : maxY;

        this._bounds.x = minX;
        this._bounds.width = maxX - minX;

        this._bounds.y = minY;
        this._bounds.height = maxY - minY;

        this._currentBounds = this._bounds;
    }

    return this._currentBounds;
};

/**
* Tests if a point is inside this graphics object
*
* @param point {Point} the point to test
* @return {boolean} the result of the test
*/
Graphics.prototype.containsPoint = function( point )
{
    this.worldTransform.applyInverse(point,  tempPoint);

    var graphicsData = this.graphicsData;

    for (var i = 0; i < graphicsData.length; i++)
    {
        var data = graphicsData[i];

        if (!data.fill)
        {
            continue;
        }

        // only deal with fills..
        if (data.shape)
        {
            if ( data.shape.contains( tempPoint.x, tempPoint.y ) )
            {
                return true;
            }
        }
    }

    return false;
};

/**
 * Update the bounds of the object
 *
 */
Graphics.prototype.updateLocalBounds = function ()
{
    var minX = Infinity;
    var maxX = -Infinity;

    var minY = Infinity;
    var maxY = -Infinity;

    if (this.graphicsData.length)
    {
        var shape, points, x, y, w, h;

        for (var i = 0; i < this.graphicsData.length; i++)
        {
            var data = this.graphicsData[i];
            var type = data.type;
            var lineWidth = data.lineWidth;
            shape = data.shape;

            if (type === CONST.SHAPES.RECT || type === CONST.SHAPES.RREC)
            {
                x = shape.x - lineWidth/2;
                y = shape.y - lineWidth/2;
                w = shape.width + lineWidth;
                h = shape.height + lineWidth;

                minX = x < minX ? x : minX;
                maxX = x + w > maxX ? x + w : maxX;

                minY = y < minY ? y : minY;
                maxY = y + h > maxY ? y + h : maxY;
            }
            else if (type === CONST.SHAPES.CIRC)
            {
                x = shape.x;
                y = shape.y;
                w = shape.radius + lineWidth/2;
                h = shape.radius + lineWidth/2;

                minX = x - w < minX ? x - w : minX;
                maxX = x + w > maxX ? x + w : maxX;

                minY = y - h < minY ? y - h : minY;
                maxY = y + h > maxY ? y + h : maxY;
            }
            else if (type === CONST.SHAPES.ELIP)
            {
                x = shape.x;
                y = shape.y;
                w = shape.width + lineWidth/2;
                h = shape.height + lineWidth/2;

                minX = x - w < minX ? x - w : minX;
                maxX = x + w > maxX ? x + w : maxX;

                minY = y - h < minY ? y - h : minY;
                maxY = y + h > maxY ? y + h : maxY;
            }
            else
            {
                // POLY
                points = shape.points;

                for (var j = 0; j < points.length; j += 2)
                {
                    x = points[j];
                    y = points[j+1];

                    minX = x-lineWidth < minX ? x-lineWidth : minX;
                    maxX = x+lineWidth > maxX ? x+lineWidth : maxX;

                    minY = y-lineWidth < minY ? y-lineWidth : minY;
                    maxY = y+lineWidth > maxY ? y+lineWidth : maxY;
                }
            }
        }
    }
    else
    {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
    }

    var padding = this.boundsPadding;

    this._localBounds.x = minX - padding;
    this._localBounds.width = (maxX - minX) + padding * 2;

    this._localBounds.y = minY - padding;
    this._localBounds.height = (maxY - minY) + padding * 2;
};

/**
 * Generates the cached sprite when the sprite has cacheAsBitmap = true
 *
 * @private
 */
/*
Graphics.prototype._generateCachedSprite = function ()
{
    var bounds = this.getLocalBounds();

    if (!this._cachedSprite)
    {
        var canvasBuffer = new CanvasBuffer(bounds.width, bounds.height);
        var texture = Texture.fromCanvas(canvasBuffer.canvas);

        this._cachedSprite = new Sprite(texture);
        this._cachedSprite.buffer = canvasBuffer;

        this._cachedSprite.worldTransform = this.worldTransform;
    }
    else
    {
        this._cachedSprite.buffer.resize(bounds.width, bounds.height);
    }

    // leverage the anchor to account for the offset of the element
    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

    // this._cachedSprite.buffer.context.save();
    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);

    // make sure we set the alpha of the graphics to 1 for the render..
    this.worldAlpha = 1;

    // now render the graphic..
    CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);

    this._cachedSprite.alpha = this.alpha;
};
*/
/**
 * Updates texture size based on canvas size
 *
 * @private
 */
/*
Graphics.prototype.updateCachedSpriteTexture = function ()
{
    var cachedSprite = this._cachedSprite;
    var texture = cachedSprite.texture;
    var canvas = cachedSprite.buffer.canvas;

    texture.baseTexture.width = canvas.width;
    texture.baseTexture.height = canvas.height;
    texture.crop.width = texture.frame.width = canvas.width;
    texture.crop.height = texture.frame.height = canvas.height;

    cachedSprite._width = canvas.width;
    cachedSprite._height = canvas.height;

    // update the dirty base textures
    texture.baseTexture.dirty();
};*/

/**
 * Destroys a previous cached sprite.
 *
 */
/*
Graphics.prototype.destroyCachedSprite = function ()
{
    this._cachedSprite.texture.destroy(true);

    // let the gc collect the unused sprite
    // TODO could be object pooled!
    this._cachedSprite = null;
};*/

/**
 * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
 *
 * @param shape {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.
 * @return {GraphicsData} The generated GraphicsData object.
 */
Graphics.prototype.drawShape = function (shape)
{
    if (this.currentPath)
    {
        // check current path!
        if (this.currentPath.shape.points.length <= 2)
        {
            this.graphicsData.pop();
        }
    }

    this.currentPath = null;

    var data = new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);

    this.graphicsData.push(data);

    if (data.type === CONST.SHAPES.POLY)
    {
        data.shape.closed = this.filling;
        this.currentPath = data;
    }

    this.dirty = true;

    return data;
};

},{"../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../display/Container":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/display/Container.js","../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../renderers/canvas/utils/CanvasBuffer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasBuffer.js","../renderers/canvas/utils/CanvasGraphics":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasGraphics.js","../sprites/Sprite":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/sprites/Sprite.js","../textures/Texture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/Texture.js","./GraphicsData":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/graphics/GraphicsData.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/graphics/GraphicsData.js":[function(require,module,exports){
/**
 * A GraphicsData object.
 *
 * @class
 * @memberof PIXI
 * @param lineWidth {number} the width of the line to draw
 * @param lineColor {number} the color of the line to draw
 * @param lineAlpha {number} the alpha of the line to draw
 * @param fillColor {number} the color of the fill
 * @param fillAlpha {number} the alpha of the fill
 * @param fill      {boolean} whether or not the shape is filled with a colour
 * @param shape     {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.
 */
function GraphicsData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape)
{
    /*
     * @member {number} the width of the line to draw
     */
    this.lineWidth = lineWidth;

    /*
     * @member {number} the color of the line to draw
     */
    this.lineColor = lineColor;
    /*
     * @member {number} the alpha of the line to draw
     */
    this.lineAlpha = lineAlpha;
    /*
     * @member {number} cached tint of the line to draw
     */
    this._lineTint = lineColor;

    /*
     * @member {number} the color of the fill
     */
    this.fillColor = fillColor;

    /*
     * @member {number} the alpha of the fill
     */
    this.fillAlpha = fillAlpha;

    /*
     * @member {number} cached tint of the fill
     */
    this._fillTint = fillColor;

    /*
     * @member {boolean} whether or not the shape is filled with a colour
     */
    this.fill = fill;

    /*
     * @member {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.
     */
    this.shape = shape;

    /*
     * @member {number} The type of the shape, see the Const.Shapes file for all the existing types,
     */
    this.type = shape.type;
}

GraphicsData.prototype.constructor = GraphicsData;
module.exports = GraphicsData;

/**
 * Creates a new GraphicsData object with the same values as this one.
 *
 * @return {GraphicsData}
 */
GraphicsData.prototype.clone = function ()
{
    return new GraphicsData(
        this.lineWidth,
        this.lineColor,
        this.lineAlpha,
        this.fillColor,
        this.fillAlpha,
        this.fill,
        this.shape
    );
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/graphics/webgl/GraphicsRenderer.js":[function(require,module,exports){
var utils = require('../../utils'),
    math = require('../../math'),
    CONST = require('../../const'),
    ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),
    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),
    WebGLGraphicsData = require('./WebGLGraphicsData');

/**
 * Renders the graphics object.
 *
 * @class
 * @private
 * @memberof PIXI
 * @extends ObjectRenderer
 * @param renderer {WebGLRenderer} The renderer this object renderer works for.
 */
function GraphicsRenderer(renderer)
{
    ObjectRenderer.call(this, renderer);

    this.graphicsDataPool = [];

    this.primitiveShader = null;
    this.complexPrimitiveShader = null;
}

GraphicsRenderer.prototype = Object.create(ObjectRenderer.prototype);
GraphicsRenderer.prototype.constructor = GraphicsRenderer;
module.exports = GraphicsRenderer;

WebGLRenderer.registerPlugin('graphics', GraphicsRenderer);

/**
 * Called when there is a WebGL context change
 *
 * @private
 *
 */
GraphicsRenderer.prototype.onContextChange = function()
{

};

/**
 * Destroys this renderer.
 *
 */
GraphicsRenderer.prototype.destroy = function () {
    ObjectRenderer.prototype.destroy.call(this);

    this.graphicsDataPool = null;
};

/**
 * Renders a graphics object.
 *
 * @param graphics {Graphics} The graphics object to render.
 */
GraphicsRenderer.prototype.render = function(graphics)
{
    var renderer = this.renderer;
    var gl = renderer.gl;

    var shader = renderer.shaderManager.plugins.primitiveShader,
        webGLData;

    if (graphics.dirty)
    {
        this.updateGraphics(graphics, gl);
    }

    var webGL = graphics._webGL[gl.id];

    // This  could be speeded up for sure!

    renderer.blendModeManager.setBlendMode( graphics.blendMode );

//    var matrix =  graphics.worldTransform.clone();
//    var matrix =  renderer.currentRenderTarget.projectionMatrix.clone();
//    matrix.append(graphics.worldTransform);

    for (var i = 0; i < webGL.data.length; i++)
    {
        if (webGL.data[i].mode === 1)
        {
            webGLData = webGL.data[i];

            renderer.stencilManager.pushStencil(graphics, webGLData, renderer);

            // render quad..
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );

            renderer.stencilManager.popStencil(graphics, webGLData, renderer);
        }
        else
        {
            webGLData = webGL.data[i];


            shader = renderer.shaderManager.primitiveShader;

            renderer.shaderManager.setShader( shader );//activatePrimitiveShader();

            gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));

            gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, renderer.currentRenderTarget.projectionMatrix.toArray(true));

            gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));

            gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);


            gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

            gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
            gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false,4 * 6, 2 * 4);

            // set the index buffer!
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );
        }
    }
};

/**
 * Updates the graphics object
 *
 * @private
 * @param graphicsData {Graphics} The graphics object to update
 */
GraphicsRenderer.prototype.updateGraphics = function(graphics)
{
    var gl = this.renderer.gl;

     // get the contexts graphics object
    var webGL = graphics._webGL[gl.id];

    // if the graphics object does not exist in the webGL context time to create it!
    if (!webGL)
    {
        webGL = graphics._webGL[gl.id] = {lastIndex:0, data:[], gl:gl};
    }

    // flag the graphics as not dirty as we are about to update it...
    graphics.dirty = false;

    var i;

    // if the user cleared the graphics object we will need to clear every object
    if (graphics.clearDirty)
    {
        graphics.clearDirty = false;

        // lop through and return all the webGLDatas to the object pool so than can be reused later on
        for (i = 0; i < webGL.data.length; i++)
        {
            var graphicsData = webGL.data[i];
            graphicsData.reset();
            this.graphicsDataPool.push( graphicsData );
        }

        // clear the array and reset the index..
        webGL.data = [];
        webGL.lastIndex = 0;
    }

    var webGLData;

    // loop through the graphics datas and construct each one..
    // if the object is a complex fill then the new stencil buffer technique will be used
    // other wise graphics objects will be pushed into a batch..
    for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];

        if (data.type === CONST.SHAPES.POLY)
        {
            // need to add the points the the graphics object..
            data.points = data.shape.points.slice();
            if (data.shape.closed)
            {
                // close the poly if the value is true!
                if (data.points[0] !== data.points[data.points.length-2] || data.points[1] !== data.points[data.points.length-1])
                {
                    data.points.push(data.points[0], data.points[1]);
                }
            }

            // MAKE SURE WE HAVE THE CORRECT TYPE..
            if (data.fill)
            {
                if (data.points.length >= 6)
                {
                    if (data.points.length < 6 * 2)
                    {
                        webGLData = this.switchMode(webGL, 0);

                        var canDrawUsingSimple = this.buildPoly(data, webGLData);
                   //     console.log(canDrawUsingSimple);

                        if (!canDrawUsingSimple)
                        {
                        //    console.log("<>>>")
                            webGLData = this.switchMode(webGL, 1);
                            this.buildComplexPoly(data, webGLData);
                        }

                    }
                    else
                    {
                        webGLData = this.switchMode(webGL, 1);
                        this.buildComplexPoly(data, webGLData);
                    }
                }
            }

            if (data.lineWidth > 0)
            {
                webGLData = this.switchMode(webGL, 0);
                this.buildLine(data, webGLData);
            }
        }
        else
        {
            webGLData = this.switchMode(webGL, 0);

            if (data.type === CONST.SHAPES.RECT)
            {
                this.buildRectangle(data, webGLData);
            }
            else if (data.type === CONST.SHAPES.CIRC || data.type === CONST.SHAPES.ELIP)
            {
                this.buildCircle(data, webGLData);
            }
            else if (data.type === CONST.SHAPES.RREC)
            {
                this.buildRoundedRectangle(data, webGLData);
            }
        }

        webGL.lastIndex++;
    }

    // upload all the dirty data...
    for (i = 0; i < webGL.data.length; i++)
    {
        webGLData = webGL.data[i];

        if (webGLData.dirty)
        {
            webGLData.upload();
        }
    }
};

/**
 *
 *
 * @private
 * @param webGL {WebGLRenderingContext} the current WebGL drawing context
 * @param type {number} TODO @Alvin
 */
GraphicsRenderer.prototype.switchMode = function (webGL, type)
{
    var webGLData;

    if (!webGL.data.length)
    {
        webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(webGL.gl);
        webGLData.mode = type;
        webGL.data.push(webGLData);
    }
    else
    {
        webGLData = webGL.data[webGL.data.length-1];

        if ((webGLData.points.length > 320000) || webGLData.mode !== type || type === 1)
        {
            webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(webGL.gl);
            webGLData.mode = type;
            webGL.data.push(webGLData);
        }
    }

    webGLData.dirty = true;

    return webGLData;
};

/**
 * Builds a rectangle to draw
 *
 * @private
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildRectangle = function (graphicsData, webGLData)
{
    // --- //
    // need to convert points to a nice regular data
    //
    var rectData = graphicsData.shape;
    var x = rectData.x;
    var y = rectData.y;
    var width = rectData.width;
    var height = rectData.height;

    if (graphicsData.fill)
    {
        var color = utils.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vertPos = verts.length/6;

        // start
        verts.push(x, y);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y);
        verts.push(r, g, b, alpha);

        verts.push(x , y + height);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y + height);
        verts.push(r, g, b, alpha);

        // insert 2 dead triangles..
        indices.push(vertPos, vertPos, vertPos+1, vertPos+2, vertPos+3, vertPos+3);
    }

    if (graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = [x, y,
                  x + width, y,
                  x + width, y + height,
                  x, y + height,
                  x, y];


        this.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Builds a rounded rectangle to draw
 *
 * @private
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildRoundedRectangle = function (graphicsData, webGLData)
{
    var rrectData = graphicsData.shape;
    var x = rrectData.x;
    var y = rrectData.y;
    var width = rrectData.width;
    var height = rrectData.height;

    var radius = rrectData.radius;

    var recPoints = [];
    recPoints.push(x, y + radius);
    this.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height, recPoints);
    this.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius, recPoints);
    this.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y, recPoints);
    this.quadraticBezierCurve(x + radius, y, x, y, x, y + radius + 0.0000000001, recPoints);
    // this tiny number deals with the issue that occurs when points overlap and polyK fails to triangulate the item.
    // TODO - fix this properly, this is not very elegant.. but it works for now.

    if (graphicsData.fill)
    {
        var color = utils.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length/6;

        //TODO use this https://github.com/mapbox/earcut
        var triangles = utils.PolyK.Triangulate(recPoints);
        //

        var i = 0;
        for (i = 0; i < triangles.length; i+=3)
        {
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i+1] + vecPos);
            indices.push(triangles[i+2] + vecPos);
            indices.push(triangles[i+2] + vecPos);
        }

        for (i = 0; i < recPoints.length; i++)
        {
            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);
        }
    }

    if (graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = recPoints;

        this.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Calculate the points for a quadratic bezier curve. (helper function..)
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * @private
 * @param fromX {number} Origin point x
 * @param fromY {number} Origin point x
 * @param cpX {number} Control point x
 * @param cpY {number} Control point y
 * @param toX {number} Destination point x
 * @param toY {number} Destination point y
 * @param [out] {number[]} The output array to add points into. If not passed, a new array is created.
 * @return {number[]} an array of points
 */
GraphicsRenderer.prototype.quadraticBezierCurve = function (fromX, fromY, cpX, cpY, toX, toY, out)
{
    var xa,
        ya,
        xb,
        yb,
        x,
        y,
        n = 20,
        points = out || [];

    function getPt(n1 , n2, perc) {
        var diff = n2 - n1;

        return n1 + ( diff * perc );
    }

    var j = 0;
    for (var i = 0; i <= n; i++ ) {
        j = i / n;

        // The Green Line
        xa = getPt( fromX , cpX , j );
        ya = getPt( fromY , cpY , j );
        xb = getPt( cpX , toX , j );
        yb = getPt( cpY , toY , j );

        // The Black Dot
        x = getPt( xa , xb , j );
        y = getPt( ya , yb , j );

        points.push(x, y);
    }

    return points;
};

/**
 * Builds a circle to draw
 *
 * @private
 * @param graphicsData {Graphics} The graphics object to draw
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildCircle = function (graphicsData, webGLData)
{
    // need to convert points to a nice regular data
    var circleData = graphicsData.shape;
    var x = circleData.x;
    var y = circleData.y;
    var width;
    var height;

    // TODO - bit hacky??
    if (graphicsData.type === CONST.SHAPES.CIRC)
    {
        width = circleData.radius;
        height = circleData.radius;
    }
    else
    {
        width = circleData.width;
        height = circleData.height;
    }

    var totalSegs = 40;
    var seg = (Math.PI * 2) / totalSegs ;

    var i = 0;

    if (graphicsData.fill)
    {
        var color = utils.hex2rgb(graphicsData.fillColor);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length/6;

        indices.push(vecPos);

        for (i = 0; i < totalSegs + 1 ; i++)
        {
            verts.push(x,y, r, g, b, alpha);

            verts.push(x + Math.sin(seg * i) * width,
                       y + Math.cos(seg * i) * height,
                       r, g, b, alpha);

            indices.push(vecPos++, vecPos++);
        }

        indices.push(vecPos-1);
    }

    if (graphicsData.lineWidth)
    {
        var tempPoints = graphicsData.points;

        graphicsData.points = [];

        for (i = 0; i < totalSegs + 1; i++)
        {
            graphicsData.points.push(x + Math.sin(seg * i) * width,
                                     y + Math.cos(seg * i) * height);
        }

        this.buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
};

/**
 * Builds a line to draw
 *
 * @private
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildLine = function (graphicsData, webGLData)
{
    // TODO OPTIMISE!
    var i = 0;
    var points = graphicsData.points;

    if (points.length === 0)
    {
        return;
    }

    // if the line width is an odd number add 0.5 to align to a whole pixel
    if (graphicsData.lineWidth%2)
    {
        for (i = 0; i < points.length; i++)
        {
            points[i] += 0.5;
        }
    }

    // get first and last point.. figure out the middle!
    var firstPoint = new math.Point(points[0], points[1]);
    var lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);

    // if the first point is the last point - gonna have issues :)
    if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y)
    {
        // need to clone as we are going to slightly modify the shape..
        points = points.slice();

        points.pop();
        points.pop();

        lastPoint = new math.Point(points[points.length - 2], points[points.length - 1]);

        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;
        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;

        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
    }

    var verts = webGLData.points;
    var indices = webGLData.indices;
    var length = points.length / 2;
    var indexCount = points.length;
    var indexStart = verts.length/6;

    // DRAW the Line
    var width = graphicsData.lineWidth / 2;

    // sort color
    var color = utils.hex2rgb(graphicsData.lineColor);
    var alpha = graphicsData.lineAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
    var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
    var a1, b1, c1, a2, b2, c2;
    var denom, pdist, dist;

    p1x = points[0];
    p1y = points[1];

    p2x = points[2];
    p2y = points[3];

    perpx = -(p1y - p2y);
    perpy =  p1x - p2x;

    dist = Math.sqrt(perpx*perpx + perpy*perpy);

    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    // start
    verts.push(p1x - perpx , p1y - perpy,
                r, g, b, alpha);

    verts.push(p1x + perpx , p1y + perpy,
                r, g, b, alpha);

    for (i = 1; i < length-1; i++)
    {
        p1x = points[(i-1)*2];
        p1y = points[(i-1)*2 + 1];

        p2x = points[(i)*2];
        p2y = points[(i)*2 + 1];

        p3x = points[(i+1)*2];
        p3y = points[(i+1)*2 + 1];

        perpx = -(p1y - p2y);
        perpy = p1x - p2x;

        dist = Math.sqrt(perpx*perpx + perpy*perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        perp2x = -(p2y - p3y);
        perp2y = p2x - p3x;

        dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);
        perp2x /= dist;
        perp2y /= dist;
        perp2x *= width;
        perp2y *= width;

        a1 = (-perpy + p1y) - (-perpy + p2y);
        b1 = (-perpx + p2x) - (-perpx + p1x);
        c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
        a2 = (-perp2y + p3y) - (-perp2y + p2y);
        b2 = (-perp2x + p2x) - (-perp2x + p3x);
        c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);

        denom = a1*b2 - a2*b1;

        if (Math.abs(denom) < 0.1 )
        {

            denom+=10.1;
            verts.push(p2x - perpx , p2y - perpy,
                r, g, b, alpha);

            verts.push(p2x + perpx , p2y + perpy,
                r, g, b, alpha);

            continue;
        }

        px = (b1*c2 - b2*c1)/denom;
        py = (a2*c1 - a1*c2)/denom;


        pdist = (px -p2x) * (px -p2x) + (py -p2y) + (py -p2y);


        if (pdist > 140 * 140)
        {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;

            dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;

            verts.push(p2x - perp3x, p2y -perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x + perp3x, p2y +perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x - perp3x, p2y -perp3y);
            verts.push(r, g, b, alpha);

            indexCount++;
        }
        else
        {

            verts.push(px , py);
            verts.push(r, g, b, alpha);

            verts.push(p2x - (px-p2x), p2y - (py - p2y));
            verts.push(r, g, b, alpha);
        }
    }

    p1x = points[(length-2)*2];
    p1y = points[(length-2)*2 + 1];

    p2x = points[(length-1)*2];
    p2y = points[(length-1)*2 + 1];

    perpx = -(p1y - p2y);
    perpy = p1x - p2x;

    dist = Math.sqrt(perpx*perpx + perpy*perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    verts.push(p2x - perpx , p2y - perpy);
    verts.push(r, g, b, alpha);

    verts.push(p2x + perpx , p2y + perpy);
    verts.push(r, g, b, alpha);

    indices.push(indexStart);

    for (i = 0; i < indexCount; i++)
    {
        indices.push(indexStart++);
    }

    indices.push(indexStart-1);
};

/**
 * Builds a complex polygon to draw
 *
 * @private
 * @param graphicsData {Graphics} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildComplexPoly = function (graphicsData, webGLData)
{
    //TODO - no need to copy this as it gets turned into a FLoat32Array anyways..
    var points = graphicsData.points.slice();

    if (points.length < 6)
    {
        return;
    }

    // get first and last point.. figure out the middle!
    var indices = webGLData.indices;
    webGLData.points = points;
    webGLData.alpha = graphicsData.fillAlpha;
    webGLData.color = utils.hex2rgb(graphicsData.fillColor);

    // calclate the bounds..
    var minX = Infinity;
    var maxX = -Infinity;

    var minY = Infinity;
    var maxY = -Infinity;

    var x,y;

    // get size..
    for (var i = 0; i < points.length; i+=2)
    {
        x = points[i];
        y = points[i+1];

        minX = x < minX ? x : minX;
        maxX = x > maxX ? x : maxX;

        minY = y < minY ? y : minY;
        maxY = y > maxY ? y : maxY;
    }

    // add a quad to the end cos there is no point making another buffer!
    points.push(minX, minY,
                maxX, minY,
                maxX, maxY,
                minX, maxY);

    // push a quad onto the end..

    //TODO - this aint needed!
    var length = points.length / 2;
    for (i = 0; i < length; i++)
    {
        indices.push( i );
    }

};

/**
 * Builds a polygon to draw
 *
 * @private
 * @param graphicsData {WebGLGraphicsData} The graphics object containing all the necessary properties
 * @param webGLData {object} an object containing all the webGL-specific information to create this shape
 */
GraphicsRenderer.prototype.buildPoly = function (graphicsData, webGLData)
{
    var points = graphicsData.points;

    if (points.length < 6)
    {
        return;
    }

    // get first and last point.. figure out the middle!
    var verts = webGLData.points;
    var indices = webGLData.indices;

    var length = points.length / 2;

    // sort color
    var color = utils.hex2rgb(graphicsData.fillColor);
    var alpha = graphicsData.fillAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var triangles = utils.PolyK.Triangulate(points);

    if (!triangles) {
        return false;
    }

    var vertPos = verts.length / 6;

    var i = 0;

    for (i = 0; i < triangles.length; i+=3)
    {
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i+1] + vertPos);
        indices.push(triangles[i+2] +vertPos);
        indices.push(triangles[i+2] + vertPos);
    }

    for (i = 0; i < length; i++)
    {
        verts.push(points[i * 2], points[i * 2 + 1],
                   r, g, b, alpha);
    }

    return true;
};

},{"../../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../../renderers/webgl/WebGLRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/WebGLRenderer.js","../../renderers/webgl/utils/ObjectRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/ObjectRenderer.js","../../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js","./WebGLGraphicsData":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/graphics/webgl/WebGLGraphicsData.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/graphics/webgl/WebGLGraphicsData.js":[function(require,module,exports){
/**
 * An object containing WebGL specific properties to be used by the WebGL renderer
 *
 * @class
 * @memberof PIXI
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 * @private
 */
function WebGLGraphicsData(gl) {

    /**
     * The current WebGL drawing context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    //TODO does this need to be split before uploding??
    /**
     * An array of color components (r,g,b)
     * @member {Array}
     */
    this.color = [0,0,0]; // color split!

    /**
     * An array of points to draw
     * @member {Array}
     */
    this.points = [];

    /**
     * The indices of the vertices
     * @member {Array}
     */
    this.indices = [];
    /**
     * The main buffer
     * @member {WebGLBuffer}
     */
    this.buffer = gl.createBuffer();

    /**
     * The index buffer
     * @member {WebGLBuffer}
     */
    this.indexBuffer = gl.createBuffer();

    /**
     * todo @alvin
     * @member {number}
     */
    this.mode = 1;

    /**
     * The alpha of the graphics
     * @member {number}
     */
    this.alpha = 1;

    /**
     * Whether this graphics is dirty or not
     * @member {boolean}
     */
    this.dirty = true;
}

WebGLGraphicsData.prototype.constructor = WebGLGraphicsData;
module.exports = WebGLGraphicsData;

/**
 * Resets the vertices and the indices
 */
WebGLGraphicsData.prototype.reset = function () {
    this.points.length = 0;
    this.indices.length = 0;
};

/**
 * Binds the buffers and uploads the data
 */
WebGLGraphicsData.prototype.upload = function () {
    var gl = this.gl;

//    this.lastIndex = graphics.graphicsData.length;
    this.glPoints = new Float32Array(this.points);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW);

    this.glIndices = new Uint16Array(this.indices);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndices, gl.STATIC_DRAW);

    this.dirty = false;
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js":[function(require,module,exports){
/**
 * @file        Main export of the PIXI core library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI
 */
// export core and const. We assign core to const so that the non-reference types in const remain in-tact
var core = module.exports = Object.assign(require('./const'), require('./math'), {
    // utils
    utils: require('./utils'),
    math: require('./math'),

    // display
    DisplayObject:          require('./display/DisplayObject'),
    Container:              require('./display/Container'),

    // sprites
    Sprite:                 require('./sprites/Sprite'),
    ParticleContainer:      require('./particles/ParticleContainer'),
    SpriteRenderer:         require('./sprites/webgl/SpriteRenderer'),
    ParticleRenderer:       require('./particles/webgl/ParticleRenderer'),

    // text
    Text:                   require('./text/Text'),

    // primitives
    Graphics:               require('./graphics/Graphics'),
    GraphicsData:           require('./graphics/GraphicsData'),
    GraphicsRenderer:       require('./graphics/webgl/GraphicsRenderer'),

    // textures
    Texture:                require('./textures/Texture'),
    BaseTexture:            require('./textures/BaseTexture'),
    RenderTexture:          require('./textures/RenderTexture'),
    VideoBaseTexture:       require('./textures/VideoBaseTexture'),
    TextureUvs:             require('./textures/TextureUvs'),

    // renderers - canvas
    CanvasRenderer:         require('./renderers/canvas/CanvasRenderer'),
    CanvasGraphics:         require('./renderers/canvas/utils/CanvasGraphics'),
    CanvasBuffer:           require('./renderers/canvas/utils/CanvasBuffer'),

    // renderers - webgl
    WebGLRenderer:          require('./renderers/webgl/WebGLRenderer'),
    ShaderManager:          require('./renderers/webgl/managers/ShaderManager'),
    Shader:                 require('./renderers/webgl/shaders/Shader'),

    // filters - webgl
    AbstractFilter:         require('./renderers/webgl/filters/AbstractFilter'),

    /**
     * This helper function will automatically detect which renderer you should be using.
     * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by
     * the browser then this function will return a canvas renderer
     *
     * @memberof PIXI
     * @param width=800 {number} the width of the renderers view
     * @param height=600 {number} the height of the renderers view
     * @param [options] {object} The optional renderer parameters
     * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
     * @param [options.transparent=false] {boolean} If the render view is transparent, default false
     * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
     * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if you
     *      need to call toDataUrl on the webgl context
     * @param [options.resolution=1] {number} the resolution of the renderer, retina would be 2
     * @param [noWebGL=false] {boolean} prevents selection of WebGL renderer, even if such is present
     *
     * @return {WebGLRenderer|CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer
     */
    autoDetectRenderer: function (width, height, options, noWebGL)
    {
        width = width || 800;
        height = height || 600;

        if (!noWebGL && core.utils.isWebGLSupported())
        {
            return new core.WebGLRenderer(width, height, options);
        }

        return new core.CanvasRenderer(width, height, options);
    }
});

},{"./const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","./display/Container":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/display/Container.js","./display/DisplayObject":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/display/DisplayObject.js","./graphics/Graphics":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/graphics/Graphics.js","./graphics/GraphicsData":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/graphics/GraphicsData.js","./graphics/webgl/GraphicsRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/graphics/webgl/GraphicsRenderer.js","./math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","./particles/ParticleContainer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/particles/ParticleContainer.js","./particles/webgl/ParticleRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/particles/webgl/ParticleRenderer.js","./renderers/canvas/CanvasRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/CanvasRenderer.js","./renderers/canvas/utils/CanvasBuffer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasBuffer.js","./renderers/canvas/utils/CanvasGraphics":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasGraphics.js","./renderers/webgl/WebGLRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/WebGLRenderer.js","./renderers/webgl/filters/AbstractFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/filters/AbstractFilter.js","./renderers/webgl/managers/ShaderManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/ShaderManager.js","./renderers/webgl/shaders/Shader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/Shader.js","./sprites/Sprite":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/sprites/Sprite.js","./sprites/webgl/SpriteRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/sprites/webgl/SpriteRenderer.js","./text/Text":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/text/Text.js","./textures/BaseTexture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/BaseTexture.js","./textures/RenderTexture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/RenderTexture.js","./textures/Texture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/Texture.js","./textures/TextureUvs":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/TextureUvs.js","./textures/VideoBaseTexture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/VideoBaseTexture.js","./utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/Matrix.js":[function(require,module,exports){
var Point = require('./Point');

/**
 * The pixi Matrix class as an object, which makes it a lot faster,
 * here is a representation of it :
 * | a | b | tx|
 * | c | d | ty|
 * | 0 | 0 | 1 |
 *
 * @class
 * @memberof PIXI
 */
function Matrix()
{
    /**
     * @member {number}
     * @default 1
     */
    this.a = 1;

    /**
     * @member {number}
     * @default 0
     */
    this.b = 0;

    /**
     * @member {number}
     * @default 0
     */
    this.c = 0;

    /**
     * @member {number}
     * @default 1
     */
    this.d = 1;

    /**
     * @member {number}
     * @default 0
     */
    this.tx = 0;

    /**
     * @member {number}
     * @default 0
     */
    this.ty = 0;
}

Matrix.prototype.constructor = Matrix;
module.exports = Matrix;

/**
 * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
 *
 * a = array[0]
 * b = array[1]
 * c = array[3]
 * d = array[4]
 * tx = array[2]
 * ty = array[5]
 *
 * @param array {number[]} The array that the matrix will be populated from.
 */
Matrix.prototype.fromArray = function (array)
{
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
};

/**
 * Creates an array from the current Matrix object.
 *
 * @param transpose {boolean} Whether we need to transpose the matrix or not
 * @return {number[]} the newly created array which contains the matrix
 */
Matrix.prototype.toArray = function (transpose)
{
    if (!this.array)
    {
        this.array = new Float32Array(9);
    }

    var array = this.array;

    if (transpose)
    {
        array[0] = this.a;
        array[1] = this.b;
        array[2] = 0;
        array[3] = this.c;
        array[4] = this.d;
        array[5] = 0;
        array[6] = this.tx;
        array[7] = this.ty;
        array[8] = 1;
    }
    else
    {
        array[0] = this.a;
        array[1] = this.c;
        array[2] = this.tx;
        array[3] = this.b;
        array[4] = this.d;
        array[5] = this.ty;
        array[6] = 0;
        array[7] = 0;
        array[8] = 1;
    }

    return array;
};

/**
 * Get a new position with the current transformation applied.
 * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
 *
 * @param pos {Point} The origin
 * @param [newPos] {Point} The point that the new position is assigned to (allowed to be same as input)
 * @return {Point} The new point, transformed through this matrix
 */
Matrix.prototype.apply = function (pos, newPos)
{
    newPos = newPos || new Point();

    var x = pos.x;
    var y = pos.y;

    newPos.x = this.a * x + this.c * y + this.tx;
    newPos.y = this.b * x + this.d * y + this.ty;

    return newPos;
};

/**
 * Get a new position with the inverse of the current transformation applied.
 * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
 *
 * @param pos {Point} The origin
 * @param [newPos] {Point} The point that the new position is assigned to (allowed to be same as input)
 * @return {Point} The new point, inverse-transformed through this matrix
 */
Matrix.prototype.applyInverse = function (pos, newPos)
{
    newPos = newPos || new Point();

    var id = 1 / (this.a * this.d + this.c * -this.b);

    var x = pos.x;
    var y = pos.y;

    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;

    return newPos;
};

/**
 * Translates the matrix on the x and y.
 *
 * @param {number} x
 * @param {number} y
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.translate = function (x, y)
{
    this.tx += x;
    this.ty += y;

    return this;
};

/**
 * Applies a scale transformation to the matrix.
 *
 * @param {number} x The amount to scale horizontally
 * @param {number} y The amount to scale vertically
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.scale = function (x, y)
{
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;

    return this;
};


/**
 * Applies a rotation transformation to the matrix.
 *
 * @param {number} angle - The angle in radians.
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.rotate = function (angle)
{
    var cos = Math.cos( angle );
    var sin = Math.sin( angle );

    var a1 = this.a;
    var c1 = this.c;
    var tx1 = this.tx;

    this.a = a1 * cos-this.b * sin;
    this.b = a1 * sin+this.b * cos;
    this.c = c1 * cos-this.d * sin;
    this.d = c1 * sin+this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;

    return this;
};

/**
 * Appends the given Matrix to this Matrix.
 *
 * @param {Matrix} matrix
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.append = function (matrix)
{
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;

    this.a  = matrix.a * a1 + matrix.b * c1;
    this.b  = matrix.a * b1 + matrix.b * d1;
    this.c  = matrix.c * a1 + matrix.d * c1;
    this.d  = matrix.c * b1 + matrix.d * d1;

    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;

    return this;
};

/**
 * Prepends the given Matrix to this Matrix.
 *
 * @param {Matrix} matrix
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.prepend = function(matrix)
{
    var tx1 = this.tx;

    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)
    {
        var a1 = this.a;
        var c1 = this.c;
        this.a  = a1*matrix.a+this.b*matrix.c;
        this.b  = a1*matrix.b+this.b*matrix.d;
        this.c  = c1*matrix.a+this.d*matrix.c;
        this.d  = c1*matrix.b+this.d*matrix.d;
    }

    this.tx = tx1*matrix.a+this.ty*matrix.c+matrix.tx;
    this.ty = tx1*matrix.b+this.ty*matrix.d+matrix.ty;

    return this;
};

/**
 * Inverts this matrix
 *
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.invert = function()
{
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;
    var tx1 = this.tx;
    var n = a1*d1-b1*c1;

    this.a = d1/n;
    this.b = -b1/n;
    this.c = -c1/n;
    this.d = a1/n;
    this.tx = (c1*this.ty-d1*tx1)/n;
    this.ty = -(a1*this.ty-b1*tx1)/n;

    return this;
};


/**
 * Resets this Matix to an identity (default) matrix.
 *
 * @return {Matrix} This matrix. Good for chaining method calls.
 */
Matrix.prototype.identity = function ()
{
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;

    return this;
};

/**
 * Creates a new Matrix object with the same values as this one.
 *
 * @return {Matrix} A copy of this matrix. Good for chaining method calls.
 */
Matrix.prototype.clone = function ()
{
    var matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;

    return matrix;
};

/**
 * Changes the values of the given matrix to be the same as the ones in this matrix
 *
 * @return {Matrix} The matrix given in parameter with its values updated.
 */
Matrix.prototype.copy = function (matrix)
{
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;

    return matrix;
};

/**
 * A default (identity) matrix
 */
Matrix.IDENTITY = new Matrix();
/**
 * A temp matrix
 */
Matrix.TEMP_MATRIX = new Matrix();

},{"./Point":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/Point.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/Point.js":[function(require,module,exports){
/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * @class
 * @memberof PIXI
 * @param [x=0] {number} position of the point on the x axis
 * @param [y=0] {number} position of the point on the y axis
 */
function Point(x, y)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;
}

Point.prototype.constructor = Point;
module.exports = Point;

/**
 * Creates a clone of this point
 *
 * @return {Point} a copy of the point
 */
Point.prototype.clone = function ()
{
    return new Point(this.x, this.y);
};

/**
 * Copies x and y from the given point
 *
 * @param p {Point}
 */
Point.prototype.copy = function (p) {
    this.set(p.x, p.y);
};

/**
 * Returns true if the given point is equal to this point
 *
 * @param p {Point}
 * @returns {boolean}
 */
Point.prototype.equals = function (p) {
    return (p.x === this.x) && (p.y === this.y);
};

/**
 * Sets the point to a new x and y position.
 * If y is omitted, both x and y will be set to x.
 *
 * @param [x=0] {number} position of the point on the x axis
 * @param [y=0] {number} position of the point on the y axis
 */
Point.prototype.set = function (x, y)
{
    this.x = x || 0;
    this.y = y || ( (y !== 0) ? this.x : 0 ) ;
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js":[function(require,module,exports){
module.exports = {
    Point:      require('./Point'),
    Matrix:     require('./Matrix'),

    Circle:     require('./shapes/Circle'),
    Ellipse:    require('./shapes/Ellipse'),
    Polygon:    require('./shapes/Polygon'),
    Rectangle:  require('./shapes/Rectangle'),
    RoundedRectangle: require('./shapes/RoundedRectangle')
};

},{"./Matrix":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/Matrix.js","./Point":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/Point.js","./shapes/Circle":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/shapes/Circle.js","./shapes/Ellipse":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/shapes/Ellipse.js","./shapes/Polygon":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/shapes/Polygon.js","./shapes/Rectangle":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/shapes/Rectangle.js","./shapes/RoundedRectangle":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/shapes/RoundedRectangle.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/shapes/Circle.js":[function(require,module,exports){
var Rectangle = require('./Rectangle'),
    CONST = require('../../const');

/**
 * The Circle object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 * @param x {number} The X coordinate of the center of this circle
 * @param y {number} The Y coordinate of the center of this circle
 * @param radius {number} The radius of the circle
 */
function Circle(x, y, radius)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.radius = radius || 0;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.CIRC;
}

Circle.prototype.constructor = Circle;
module.exports = Circle;

/**
 * Creates a clone of this Circle instance
 *
 * @return {Circle} a copy of the Circle
 */
Circle.prototype.clone = function ()
{
    return new Circle(this.x, this.y, this.radius);
};

/**
 * Checks whether the x and y coordinates given are contained within this circle
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Circle
 */
Circle.prototype.contains = function (x, y)
{
    if (this.radius <= 0)
    {
        return false;
    }

    var dx = (this.x - x),
        dy = (this.y - y),
        r2 = this.radius * this.radius;

    dx *= dx;
    dy *= dy;

    return (dx + dy <= r2);
};

/**
* Returns the framing rectangle of the circle as a Rectangle object
*
* @return {Rectangle} the framing rectangle
*/
Circle.prototype.getBounds = function ()
{
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
};

},{"../../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","./Rectangle":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/shapes/Rectangle.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/shapes/Ellipse.js":[function(require,module,exports){
var Rectangle = require('./Rectangle'),
    CONST = require('../../const');

/**
 * The Ellipse object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 * @param x {number} The X coordinate of the center of the ellipse
 * @param y {number} The Y coordinate of the center of the ellipse
 * @param width {number} The half width of this ellipse
 * @param height {number} The half height of this ellipse
 */
function Ellipse(x, y, width, height)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height || 0;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.ELIP;
}

Ellipse.prototype.constructor = Ellipse;
module.exports = Ellipse;

/**
 * Creates a clone of this Ellipse instance
 *
 * @return {Ellipse} a copy of the ellipse
 */
Ellipse.prototype.clone = function ()
{
    return new Ellipse(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates given are contained within this ellipse
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coords are within this ellipse
 */
Ellipse.prototype.contains = function (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }

    //normalize the coords to an ellipse with center 0,0
    var normx = ((x - this.x) / this.width),
        normy = ((y - this.y) / this.height);

    normx *= normx;
    normy *= normy;

    return (normx + normy <= 1);
};

/**
 * Returns the framing rectangle of the ellipse as a Rectangle object
 *
 * @return {Rectangle} the framing rectangle
 */
Ellipse.prototype.getBounds = function ()
{
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
};

},{"../../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","./Rectangle":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/shapes/Rectangle.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/shapes/Polygon.js":[function(require,module,exports){
var Point = require('../Point'),
    CONST = require('../../const');

/**
 * @class
 * @memberof PIXI
 * @param points {Point[]|number[]|...Point|...number} This can be an array of Points that form the polygon,
 *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be
 *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the
 *      arguments passed can be flat x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are
 *      Numbers.
 */
function Polygon(points_)
{
    // prevents an argument assignment deopt
    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
    var points = points_;

    //if points isn't an array, use arguments as the array
    if (!Array.isArray(points))
    {
        // prevents an argument leak deopt
        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        points = new Array(arguments.length);

        for (var a = 0; a < points.length; ++a) {
            points[a] = arguments[a];
        }
    }

    // if this is an array of points, convert it to a flat array of numbers
    if (points[0] instanceof Point)
    {
        var p = [];
        for (var i = 0, il = points.length; i < il; i++)
        {
            p.push(points[i].x, points[i].y);
        }

        points = p;
    }

    this.closed = true;

    /**
     * An array of the points of this polygon
     *
     * @member {number[]}
     */
    this.points = points;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.POLY;
}

Polygon.prototype.constructor = Polygon;
module.exports = Polygon;

/**
 * Creates a clone of this polygon
 *
 * @return {Polygon} a copy of the polygon
 */
Polygon.prototype.clone = function ()
{
    return new Polygon(this.points.slice());
};

/**
 * Checks whether the x and y coordinates passed to this function are contained within this polygon
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this polygon
 */
Polygon.prototype.contains = function (x, y)
{
    var inside = false;

    // use some raycasting to test hits
    // https://github.com/substack/point-in-polygon/blob/master/index.js
    var length = this.points.length / 2;

    for (var i = 0, j = length - 1; i < length; j = i++)
    {
        var xi = this.points[i * 2], yi = this.points[i * 2 + 1],
            xj = this.points[j * 2], yj = this.points[j * 2 + 1],
            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

        if (intersect)
        {
            inside = !inside;
        }
    }

    return inside;
};

},{"../../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../Point":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/Point.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/shapes/Rectangle.js":[function(require,module,exports){
var CONST = require('../../const');

/**
 * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.
 *
 * @class
 * @memberof PIXI
 * @param x {number} The X coordinate of the upper-left corner of the rectangle
 * @param y {number} The Y coordinate of the upper-left corner of the rectangle
 * @param width {number} The overall width of this rectangle
 * @param height {number} The overall height of this rectangle
 */
function Rectangle(x, y, width, height)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height || 0;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.RECT;
}

Rectangle.prototype.constructor = Rectangle;
module.exports = Rectangle;

/**
 * A constant empty rectangle.
 *
 * @static
 * @constant
 */
Rectangle.EMPTY = new Rectangle(0, 0, 0, 0);


/**
 * Creates a clone of this Rectangle
 *
 * @return {Rectangle} a copy of the rectangle
 */
Rectangle.prototype.clone = function ()
{
    return new Rectangle(this.x, this.y, this.width, this.height);
};

/**
 * Checks whether the x and y coordinates given are contained within this Rectangle
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Rectangle
 */
Rectangle.prototype.contains = function (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }

    if (x >= this.x && x < this.x + this.width)
    {
        if (y >= this.y && y < this.y + this.height)
        {
            return true;
        }
    }

    return false;
};

},{"../../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/shapes/RoundedRectangle.js":[function(require,module,exports){
var CONST = require('../../const');

/**
 * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its top-left corner point (x, y) and by its width and its height and its radius.
 *
 * @class
 * @memberof PIXI
 * @param x {number} The X coordinate of the upper-left corner of the rounded rectangle
 * @param y {number} The Y coordinate of the upper-left corner of the rounded rectangle
 * @param width {number} The overall width of this rounded rectangle
 * @param height {number} The overall height of this rounded rectangle
 * @param radius {number} Controls the radius of the rounded corners
 */
function RoundedRectangle(x, y, width, height, radius)
{
    /**
     * @member {number}
     * @default 0
     */
    this.x = x || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width || 0;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height || 0;

    /**
     * @member {number}
     * @default 20
     */
    this.radius = radius || 20;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     */
    this.type = CONST.SHAPES.RREC;
}

RoundedRectangle.prototype.constructor = RoundedRectangle;
module.exports = RoundedRectangle;

/**
 * Creates a clone of this Rounded Rectangle
 *
 * @return {RoundedRectangle} a copy of the rounded rectangle
 */
RoundedRectangle.prototype.clone = function ()
{
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
};

/**
 * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
 *
 * @param x {number} The X coordinate of the point to test
 * @param y {number} The Y coordinate of the point to test
 * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
 */
RoundedRectangle.prototype.contains = function (x, y)
{
    if (this.width <= 0 || this.height <= 0)
    {
        return false;
    }

    if (x >= this.x && x <= this.x + this.width)
    {
        if (y >= this.y && y <= this.y + this.height)
        {
            return true;
        }
    }

    return false;
};

},{"../../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/particles/ParticleContainer.js":[function(require,module,exports){
var Container = require('../display/Container');

/**
 * The ParticleContainer class is a really fast version of the Container built solely for speed,
 * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that advanced
 * functionality will not work. ParticleContainer implements only the basic object transform (position, scale, rotation).
 * Any other functionality like tinting, masking, etc will not work on sprites in this batch.
 *
 * It's extremely easy to use :
 *
 * ```js
 * var container = new ParticleContainer();
 *
 * for (var i = 0; i < 100; ++i)
 * {
 *     var sprite = new PIXI.Sprite.fromImage("myImage.png");
 *     container.addChild(sprite);
 * }
 * ```
 *
 * And here you have a hundred sprites that will be renderer at the speed of light.
 *
 * @class
 * @extends Container
 * @memberof PIXI
 *
 * @param [size=15000] {number} The number of images in the SpriteBatch before it flushes.
 * @param [properties] {object} The properties of children that should be uploaded to the gpu and applied.
 * @param [properties.scale=false] {boolean} When true, scale be uploaded and applied.
 * @param [properties.position=true] {boolean} When true, position be uploaded and applied.
 * @param [properties.rotation=false] {boolean} When true, rotation be uploaded and applied.
 * @param [properties.uvs=false] {boolean} When true, uvs be uploaded and applied.
 * @param [properties.alpha=false] {boolean} When true, alpha be uploaded and applied.
 */
function ParticleContainer(size, properties)
{
    Container.call(this);

    /**
     * Set properties to be dynamic (true) / static (false)
     *
     * @member {array}
     * @private
     */
    this._properties = [false, true, false, false, false];

    /**
     * @member {number}
     * @private
     */
    this._size = size || 15000;

    /**
     * @member {WebGLBuffer}
     * @private
     */
    this._buffers = null;

    /**
     * @member {boolean}
     * @private
     */
    this._updateStatic = false;

    /**
     * @member {boolean}
     *
     */
    this.interactiveChildren = false;

    this.setProperties(properties);
}

ParticleContainer.prototype = Object.create(Container.prototype);
ParticleContainer.prototype.constructor = ParticleContainer;
module.exports = ParticleContainer;

/**
 * Sets the private properties array to dynamic / static based on the passed properties object
 *
 * @param properties {object} The properties to be uploaded
 */
ParticleContainer.prototype.setProperties = function(properties)
{
    if ( properties ) {
        this._properties[0] = 'scale' in properties ? !!properties.scale : this._properties[0];
        this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];
        this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];
        this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];
        this._properties[4] = 'alpha' in properties ? !!properties.alpha : this._properties[4];
    }
};

/**
 * Updates the object transform for rendering
 *
 * @private
 */
ParticleContainer.prototype.updateTransform = function ()
{
    // TODO don't need to!
    this.displayObjectUpdateTransform();
    //  PIXI.Container.prototype.updateTransform.call( this );
};

/**
 * Renders the container using the WebGL renderer
 *
 * @param renderer {WebGLRenderer} The webgl renderer
 * @private
 */
ParticleContainer.prototype.renderWebGL = function (renderer)
{
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)
    {
        return;
    }

    renderer.setObjectRenderer( renderer.plugins.particle );
    renderer.plugins.particle.render( this );
};

/**
 * Adds a child to this particle container at a specified index. If the index is out of bounds an error will be thrown
 *
 * @param child {DisplayObject} The child to add
 * @param index {Number} The index to place the child in
 * @return {DisplayObject} The child that was added.
 */
ParticleContainer.prototype.addChildAt = function (child, index)
{
    // prevent adding self as child
    if (child === this)
    {
        return child;
    }

    if (index >= 0 && index <= this.children.length)
    {
        if (child.parent)
        {
            child.parent.removeChild(child);
        }

        child.parent = this;

        this.children.splice(index, 0, child);

        this._updateStatic = true;

        return child;
    }
    else
    {
        throw new Error(child + 'addChildAt: The index '+ index +' supplied is out of bounds ' + this.children.length);
    }
};

/**
 * Removes a child from the specified index position.
 *
 * @param index {Number} The index to get the child from
 * @return {DisplayObject} The child that was removed.
 */
ParticleContainer.prototype.removeChildAt = function (index)
{
    var child = this.getChildAt(index);

    child.parent = null;
    this.children.splice(index, 1);
    this._updateStatic = true;

    return child;
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {CanvasRenderer} The canvas renderer
 * @private
 */
ParticleContainer.prototype.renderCanvas = function (renderer)
{
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)
    {
        return;
    }

    var context = renderer.context;
    var transform = this.worldTransform;
    var isRotated = true;

    context.globalAlpha = this.worldAlpha;

    this.displayObjectUpdateTransform();

    for (var i = 0; i < this.children.length; ++i)
    {
        var child = this.children[i];

        if (!child.visible)
        {
            continue;
        }

        var frame = child.texture.frame;

        context.globalAlpha = this.worldAlpha * child.alpha;

        if (child.rotation % (Math.PI * 2) === 0)
        {
            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call
            if (isRotated)
            {
                context.setTransform(
                    transform.a,
                    transform.b,
                    transform.c,
                    transform.d,
                    transform.tx,
                    transform.ty
                );

                isRotated = false;
            }

            context.drawImage(
                child.texture.baseTexture.source,
                frame.x,
                frame.y,
                frame.width,
                frame.height,
                ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x  + 0.5) | 0,
                ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y  + 0.5) | 0,
                frame.width * child.scale.x,
                frame.height * child.scale.y
            );
        }
        else
        {
            if (!isRotated)
            {
                isRotated = true;
            }

            child.displayObjectUpdateTransform();

            var childTransform = child.worldTransform;

            if (renderer.roundPixels)
            {
                context.setTransform(
                    childTransform.a,
                    childTransform.b,
                    childTransform.c,
                    childTransform.d,
                    childTransform.tx | 0,
                    childTransform.ty | 0
                );
            }
            else
            {
                context.setTransform(
                    childTransform.a,
                    childTransform.b,
                    childTransform.c,
                    childTransform.d,
                    childTransform.tx,
                    childTransform.ty
                );
            }

            context.drawImage(
                child.texture.baseTexture.source,
                frame.x,
                frame.y,
                frame.width,
                frame.height,
                ((child.anchor.x) * (-frame.width) + 0.5) | 0,
                ((child.anchor.y) * (-frame.height) + 0.5) | 0,
                frame.width,
                frame.height
            );
        }
    }
};

},{"../display/Container":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/display/Container.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/particles/webgl/ParticleBuffer.js":[function(require,module,exports){

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's ParticleBuffer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleBuffer.java
 */

/**
 *
 * @class
 * @private
 * @memberof PIXI
 * @param renderer {WebGLRenderer} The renderer this sprite batch works for.
 */
function ParticleBuffer(gl, properties, size)
{
    /**
     * the current WebGL drawing context
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     *
     *
     * @member {number}
     */
    this.vertSize = 2;

    /**
     *
     *
     * @member {number}
     */
    this.vertByteSize = this.vertSize * 4;

    /**
     * The number of images in the SpriteBatch before it flushes.
     *
     * @member {number}
     */
    this.size = size;

    /**
     * 
     *
     * @member {Array}
     */
    this.dynamicProperties = [];

    /**
     * 
     *
     * @member {Array}
     */
    this.staticProperties = [];

    for (var i = 0; i < properties.length; i++)
    {
        var property = properties[i];

        if(property.dynamic)
        {
            this.dynamicProperties.push(property);
        }
        else
        {
            this.staticProperties.push(property);
        }
    }

    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;

    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;

    this.initBuffers();

}

ParticleBuffer.prototype.constructor = ParticleBuffer;
module.exports = ParticleBuffer;

/**
 * Sets up the renderer context and necessary buffers.
 *
 * @private
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 */
ParticleBuffer.prototype.initBuffers = function ()
{
    var gl = this.gl;
    var i;
    var property;

    var dynamicOffset = 0;
    this.dynamicStride = 0;

    for (i = 0; i < this.dynamicProperties.length; i++)
    {
        property = this.dynamicProperties[i];

        property.offset = dynamicOffset;
        dynamicOffset += property.size;
        this.dynamicStride += property.size;
    }

    this.dynamicData = new Float32Array( this.size * this.dynamicStride * 4);
    this.dynamicBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.dynamicData, gl.DYNAMIC_DRAW);


    // static //
    var staticOffset = 0;
    this.staticStride = 0;

    for (i = 0; i < this.staticProperties.length; i++)
    {
        property = this.staticProperties[i];

        property.offset = staticOffset;
        staticOffset += property.size;
        this.staticStride += property.size;
    }

    this.staticData = new Float32Array( this.size * this.staticStride * 4);
    this.staticBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.staticData, gl.DYNAMIC_DRAW);

};

ParticleBuffer.prototype.uploadDynamic = function(children, startIndex, amount)
{
    var gl = this.gl;

    for (var i = 0; i < this.dynamicProperties.length; i++)
    {
        var property = this.dynamicProperties[i];
        property.uploadFunction(children, startIndex, amount, this.dynamicData, this.dynamicStride, property.offset);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.dynamicData);
};

ParticleBuffer.prototype.uploadStatic = function(children, startIndex, amount)
{
    var gl = this.gl;

    for (var i = 0; i < this.staticProperties.length; i++)
    {
        var property = this.staticProperties[i];
        property.uploadFunction(children, startIndex, amount, this.staticData, this.staticStride, property.offset);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.staticData);
};

/**
 * Starts a new sprite batch.
 *
 */
ParticleBuffer.prototype.bind = function ()
{
    var gl = this.gl;
    var i, property;

    gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);

    for (i = 0; i < this.dynamicProperties.length; i++)
    {
        property = this.dynamicProperties[i];
        gl.vertexAttribPointer(property.attribute, property.size, gl.FLOAT, false, this.dynamicStride * 4, property.offset * 4);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.staticBuffer);

    for (i = 0; i < this.staticProperties.length; i++)
    {
        property = this.staticProperties[i];
        gl.vertexAttribPointer(property.attribute, property.size, gl.FLOAT, false, this.staticStride * 4, property.offset * 4);
    }
};

/**
 * Destroys the SpriteBatch.
 *
 */
ParticleBuffer.prototype.destroy = function ()
{
    //TODO implement this :) to busy making the fun bits..
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/particles/webgl/ParticleRenderer.js":[function(require,module,exports){
var ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),
    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),
    ParticleShader = require('./ParticleShader'),
    ParticleBuffer = require('./ParticleBuffer'),
    math            = require('../../math');

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's ParticleRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java
 */

/**
 *
 * @class
 * @private
 * @memberof PIXI
 * @param renderer {WebGLRenderer} The renderer this sprite batch works for.
 */
function ParticleRenderer(renderer)
{
    ObjectRenderer.call(this, renderer);


    /**
     * The number of images in the Particle before it flushes.
     *
     * @member {number}
     */
    this.size = 15000;//CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop

    var numIndices = this.size * 6;


    /**
     * Holds the indices
     *
     * @member {Uint16Array}
     */
    this.indices = new Uint16Array(numIndices);

    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    /**
     * The default shader that is used if a sprite doesn't have a more specific one.
     *
     * @member {Shader}
     */
    this.shader = null;

    this.tempMatrix = new math.Matrix();




}

ParticleRenderer.prototype = Object.create(ObjectRenderer.prototype);
ParticleRenderer.prototype.constructor = ParticleRenderer;
module.exports = ParticleRenderer;

WebGLRenderer.registerPlugin('particle', ParticleRenderer);

/**
 * When there is a WebGL context change
 *
 * @private
 *
 */
ParticleRenderer.prototype.onContextChange = function ()
{
    var gl = this.renderer.gl;

    // setup default shader
    this.shader = new ParticleShader(this.renderer.shaderManager);

    this.indexBuffer = gl.createBuffer();

    // 65535 is max index, so 65535 / 6 = 10922.

    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);


    this.properties = [
    //verticesData
    {
        attribute:this.shader.attributes.aVertexPosition,
        dynamic:false,
        size:2,
        uploadFunction:this.uploadVertices,
        offset:0
    },
    // positionData
    {
        attribute:this.shader.attributes.aPositionCoord,
        dynamic:true,
        size:2,
        uploadFunction:this.uploadPosition,
        offset:0
    },
    // rotationData
    {
        attribute:this.shader.attributes.aRotation,
        dynamic:false,
        size:1,
        uploadFunction:this.uploadRotation,
        offset:0
    },
    //u vsData
    {
        attribute:this.shader.attributes.aTextureCoord,
        dynamic:false,
        size:2,
        uploadFunction:this.uploadUvs,
        offset:0
    },
    // alphaData
    {
        attribute:this.shader.attributes.aColor,
        dynamic:false,
        size:1,
        uploadFunction:this.uploadAlpha,
        offset:0
    }];

};

/**
 * Starts a new sprite batch.
 *
 */
ParticleRenderer.prototype.start = function ()
{
    var gl = this.renderer.gl;

    // bind the main texture
    gl.activeTexture(gl.TEXTURE0);

    // bind the buffers

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    var shader = this.shader;

    this.renderer.shaderManager.setShader(shader);
};


/**
 * Renders the sprite object.
 *
 * @param container {Container|Sprite} the sprite to render using this ParticleRenderer
 */
ParticleRenderer.prototype.render = function ( container )
{
    var children = container.children,
        totalChildren = children.length,
        maxSize = container._size;

    if(totalChildren === 0)
    {
        return;
    }
    else if(totalChildren > maxSize)
    {
        totalChildren = maxSize;
    }

    if(!container._buffers)
    {
        container._buffers = this.generateBuffers( container );
    }



    // if the uvs have not updated then no point rendering just yet!
    //this.renderer.blendModeManager.setBlendMode(sprite.blendMode);
    var gl = this.renderer.gl;

    var m =  container.worldTransform.copy( this.tempMatrix );
    m.prepend( this.renderer.currentRenderTarget.projectionMatrix );
    gl.uniformMatrix3fv(this.shader.uniforms.projectionMatrix._location, false, m.toArray(true));

    // if this variable is true then we will upload the static contents as well as the dynamic contens
    var uploadStatic = container._updateStatic;

    // make sure the texture is bound..
    var baseTexture = children[0]._texture.baseTexture;

    if (!baseTexture._glTextures[gl.id])
    {
        this.renderer.updateTexture(baseTexture);
        if(!this.properties[0].dynamic || !this.properties[3].dynamic)
        {
            uploadStatic = true;
        }
    }
    else
    {
        gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);
    }

    // now lets upload and render the buffers..
    var j = 0;
    for (var i = 0; i < totalChildren; i+=this.size)
    {
         var amount = ( totalChildren - i);
        if(amount > this.size)
        {
            amount = this.size;
        }

        var buffer = container._buffers[j++];

        // we always upload the dynamic
        buffer.uploadDynamic(children, i, amount);

        // we only upload the static content when we have to!
        if(uploadStatic)
        {
            buffer.uploadStatic(children, i, amount);
        }

        // bind the buffer
        buffer.bind( this.shader );

         // now draw those suckas!
        gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
        this.renderer.drawCount++;
    }

    container._updateStatic = false;
};

/**
 * Creates one particle buffer for each child in the container we want to render and updates internal properties
 *
 * @param container {Container|Sprite} the sprite to render using this ParticleRenderer
 */
ParticleRenderer.prototype.generateBuffers = function ( container )
{
    var gl = this.renderer.gl,
        buffers = [],
        size = container._size,
        i;

    // update the properties to match the state of the container..
    for (i = 0; i < container._properties.length; i++)
    {
        this.properties[i].dynamic = container._properties[i];
    }

    for (i = 0; i < size; i += this.size)
    {
        buffers.push( new ParticleBuffer(gl,  this.properties, this.size, this.shader) );
    }

    return buffers;
};


/**
 *
 * @param children {Array} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their vertices uploaded
 * @param array {Array}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadVertices = function (children, startIndex, amount, array, stride, offset)
{
    var sprite,
        texture,
        trim,
        sx,
        sy,
        w0, w1, h0, h1;

    for (var i = 0; i < amount; i++) {

        sprite = children[startIndex + i];
        texture = sprite._texture;
        sx = sprite.scale.x;
        sy = sprite.scale.y;

        if (texture.trim)
        {
            // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..
            trim = texture.trim;

            w1 = trim.x - sprite.anchor.x * trim.width;
            w0 = w1 + texture.crop.width;

            h1 = trim.y - sprite.anchor.y * trim.height;
            h0 = h1 + texture.crop.height;
        }
        else
        {
            w0 = (texture._frame.width ) * (1-sprite.anchor.x);
            w1 = (texture._frame.width ) * -sprite.anchor.x;

            h0 = texture._frame.height * (1-sprite.anchor.y);
            h1 = texture._frame.height * -sprite.anchor.y;
        }

        array[offset] = w1 * sx;
        array[offset + 1] = h1 * sy;

        array[offset + stride] = w0 * sx;
        array[offset + stride + 1] = h1 * sy;

        array[offset + stride * 2] = w0 * sx;
        array[offset + stride * 2 + 1] = h0 * sy;

        array[offset + stride * 3] = w1 * sx;
        array[offset + stride * 3 + 1] = h0 * sy;

        offset += stride * 4;
    }

};

/**
 *
 * @param children {Array} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their positions uploaded
 * @param array {Array}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadPosition = function (children,startIndex, amount, array, stride, offset)
{
    for (var i = 0; i < amount; i++)
    {
        var spritePosition = children[startIndex + i].position;

        array[offset] = spritePosition.x;
        array[offset + 1] = spritePosition.y;

        array[offset + stride] = spritePosition.x;
        array[offset + stride + 1] = spritePosition.y;

        array[offset + stride * 2] = spritePosition.x;
        array[offset + stride * 2 + 1] = spritePosition.y;

        array[offset + stride * 3] = spritePosition.x;
        array[offset + stride * 3 + 1] = spritePosition.y;

        offset += stride * 4;
    }

};

/**
 *
 * @param children {Array} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their rotation uploaded
 * @param array {Array}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadRotation = function (children,startIndex, amount, array, stride, offset)
{
    for (var i = 0; i < amount; i++)
    {
        var spriteRotation = children[startIndex + i].rotation;


        array[offset] = spriteRotation;
        array[offset + stride] = spriteRotation;
        array[offset + stride * 2] = spriteRotation;
        array[offset + stride * 3] = spriteRotation;

        offset += stride * 4;
    }
};

/**
 *
 * @param children {Array} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their Uvs uploaded
 * @param array {Array}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadUvs = function (children,startIndex, amount, array, stride, offset)
{
    for (var i = 0; i < amount; i++)
    {
        var textureUvs = children[startIndex + i]._texture._uvs;

        if (textureUvs)
        {
            array[offset] = textureUvs.x0;
            array[offset + 1] = textureUvs.y0;

            array[offset + stride] = textureUvs.x1;
            array[offset + stride + 1] = textureUvs.y1;

            array[offset + stride * 2] = textureUvs.x2;
            array[offset + stride * 2 + 1] = textureUvs.y2;

            array[offset + stride * 3] = textureUvs.x3;
            array[offset + stride * 3 + 1] = textureUvs.y3;

            offset += stride * 4;
        }
        else
        {
            //TODO you know this can be easier!
            array[offset] = 0;
            array[offset + 1] = 0;

            array[offset + stride] = 0;
            array[offset + stride + 1] = 0;

            array[offset + stride * 2] = 0;
            array[offset + stride * 2 + 1] = 0;

            array[offset + stride * 3] = 0;
            array[offset + stride * 3 + 1] = 0;

            offset += stride * 4;
        }
    }
};

/**
 *
 * @param children {Array} the array of display objects to render
 * @param startIndex {number} the index to start from in the children array
 * @param amount {number} the amount of children that will have their alpha uploaded
 * @param array {Array}
 * @param stride {number}
 * @param offset {number}
 */
ParticleRenderer.prototype.uploadAlpha = function (children,startIndex, amount, array, stride, offset)
{
     for (var i = 0; i < amount; i++)
     {
        var spriteAlpha = children[startIndex + i].alpha;

        array[offset] = spriteAlpha;
        array[offset + stride] = spriteAlpha;
        array[offset + stride * 2] = spriteAlpha;
        array[offset + stride * 3] = spriteAlpha;

        offset += stride * 4;
    }
};


/**
 * Destroys the Particle.
 *
 */
ParticleRenderer.prototype.destroy = function ()
{

    this.shader.destroy();

    //TODO implement this!
};

},{"../../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../../renderers/webgl/WebGLRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/WebGLRenderer.js","../../renderers/webgl/utils/ObjectRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/ObjectRenderer.js","./ParticleBuffer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/particles/webgl/ParticleBuffer.js","./ParticleShader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/particles/webgl/ParticleShader.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/particles/webgl/ParticleShader.js":[function(require,module,exports){
var TextureShader = require('../../renderers/webgl/shaders/TextureShader');

/**
 * @class
 * @extends TextureShader
 * @memberof PIXI
 * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.
 */
function ParticleShader(shaderManager)
{
    TextureShader.call(this,
        shaderManager,
        // vertex shader
        [
            'attribute vec2 aVertexPosition;',
            'attribute vec2 aTextureCoord;',
            'attribute float aColor;',

            'attribute vec2 aPositionCoord;',
            'attribute vec2 aScale;',
            'attribute float aRotation;',

            'uniform mat3 projectionMatrix;',

            'varying vec2 vTextureCoord;',
            'varying float vColor;',

            'void main(void){',
            '   vec2 v = aVertexPosition;',

            '   v.x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);',
            '   v.y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);',
            '   v = v + aPositionCoord;',

            '   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);',

            '   vTextureCoord = aTextureCoord;',
            '   vColor = aColor;',
            '}'
        ].join('\n'),
        // hello
         [
            'precision lowp float;',

            'varying vec2 vTextureCoord;',
            'varying float vColor;',

            'uniform sampler2D uSampler;',

            'void main(void){',
            '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',
            '}'
        ].join('\n'),
        // custom uniforms
        null,
        // custom attributes
        {
            aPositionCoord: 0,
           // aScale:         0,
            aRotation:      0
        }
    );

    // TEMP HACK

}

ParticleShader.prototype = Object.create(TextureShader.prototype);
ParticleShader.prototype.constructor = ParticleShader;

module.exports = ParticleShader;

},{"../../renderers/webgl/shaders/TextureShader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/TextureShader.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/SystemRenderer.js":[function(require,module,exports){
var utils = require('../utils'),
    math = require('../math'),
    CONST = require('../const'),
    EventEmitter = require('eventemitter3').EventEmitter;

/**
 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @param system {string} The name of the system this renderer is for.
 * @param [width=800] {number} the width of the canvas view
 * @param [height=600] {number} the height of the canvas view
 * @param [options] {object} The optional renderer parameters
 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
 *      not before the new render pass.
 */
function SystemRenderer(system, width, height, options)
{
    EventEmitter.call(this);

    utils.sayHello(system);

    // prepare options
    if (options)
    {
        for (var i in CONST.DEFAULT_RENDER_OPTIONS)
        {
            if (typeof options[i] === 'undefined')
            {
                options[i] = CONST.DEFAULT_RENDER_OPTIONS[i];
            }
        }
    }
    else
    {
        options = CONST.DEFAULT_RENDER_OPTIONS;
    }

    /**
     * The type of the renderer.
     *
     * @member {RENDERER_TYPE}
     * @default CONT.RENDERER_TYPE.UNKNOWN
     */
    this.type = CONST.RENDERER_TYPE.UNKNOWN;

    /**
     * The width of the canvas view
     *
     * @member {number}
     * @default 800
     */
    this.width = width || 800;

    /**
     * The height of the canvas view
     *
     * @member {number}
     * @default 600
     */
    this.height = height || 600;

    /**
     * The canvas element that everything is drawn to
     *
     * @member {HTMLCanvasElement}
     */
    this.view = options.view || document.createElement('canvas');

    /**
     * The resolution of the renderer
     *
     * @member {number}
     * @default 1
     */
    this.resolution = options.resolution;

    /**
     * Whether the render view is transparent
     *
     * @member {boolean}
     */
    this.transparent = options.transparent;

    /**
     * Whether the render view should be resized automatically
     *
     * @member {boolean}
     */
    this.autoResize = options.autoResize || false;

    /**
     * Tracks the blend modes useful for this renderer.
     *
     * @member {object<string, mixed>}
     */
    this.blendModes = null;

    /**
     * The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.
     *
     * @member {boolean}
     */
    this.preserveDrawingBuffer = options.preserveDrawingBuffer;

    /**
     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
     * If the scene is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.
     * If the scene is transparent Pixi will use clearRect to clear the canvas every frame.
     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.
     *
     * @member {boolean}
     * @default
     */
    this.clearBeforeRender = options.clearBeforeRender;

    /**
     * The background color as a number.
     *
     * @member {number}
     * @private
     */
    this._backgroundColor = 0x000000;

    /**
     * The background color as an [R, G, B] array.
     *
     * @member {number[]}
     * @private
     */
    this._backgroundColorRgb = [0, 0, 0];

    /**
     * The background color as a string.
     *
     * @member {string}
     * @private
     */
    this._backgroundColorString = '#000000';

    this.backgroundColor = options.backgroundColor || this._backgroundColor; // run bg color setter

    /**
     * This temporary display object used as the parent of the currently being rendered item
     * @member {DisplayObject}
     * @private
     */
    this._tempDisplayObjectParent = {worldTransform:new math.Matrix(), worldAlpha:1, children:[]};

    //
    this._lastObjectRendered = this._tempDisplayObjectParent;
}

// constructor
SystemRenderer.prototype = Object.create(EventEmitter.prototype);
SystemRenderer.prototype.constructor = SystemRenderer;
module.exports = SystemRenderer;

Object.defineProperties(SystemRenderer.prototype, {
    /**
     * The background color to fill if not transparent
     *
     * @member {number}
     * @memberof SystemRenderer#
     */
    backgroundColor:
    {
        get: function ()
        {
            return this._backgroundColor;
        },
        set: function (val)
        {
            this._backgroundColor = val;
            this._backgroundColorString = utils.hex2string(val);
            utils.hex2rgb(val, this._backgroundColorRgb);
        }
    }
});

/**
 * Resizes the canvas view to the specified width and height
 *
 * @param width {number} the new width of the canvas view
 * @param height {number} the new height of the canvas view
 */
SystemRenderer.prototype.resize = function (width, height) {
    this.width = width * this.resolution;
    this.height = height * this.resolution;

    this.view.width = this.width;
    this.view.height = this.height;

    if (this.autoResize)
    {
        this.view.style.width = this.width / this.resolution + 'px';
        this.view.style.height = this.height / this.resolution + 'px';
    }
};

/**
 * Removes everything from the renderer and optionally removes the Canvas DOM element.
 *
 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
 */
SystemRenderer.prototype.destroy = function (removeView) {
    if (removeView && this.view.parent)
    {
        this.view.parent.removeChild(this.view);
    }

    this.type = CONST.RENDERER_TYPE.UNKNOWN;

    this.width = 0;
    this.height = 0;

    this.view = null;

    this.resolution = 0;

    this.transparent = false;

    this.autoResize = false;

    this.blendModes = null;

    this.preserveDrawingBuffer = false;
    this.clearBeforeRender = false;

    this._backgroundColor = 0;
    this._backgroundColorRgb = null;
    this._backgroundColorString = null;
};

},{"../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js","eventemitter3":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/eventemitter3/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/CanvasRenderer.js":[function(require,module,exports){
var SystemRenderer = require('../SystemRenderer'),
    CanvasMaskManager = require('./utils/CanvasMaskManager'),
    utils = require('../../utils'),
    math = require('../../math'),
    CONST = require('../../const');

/**
 * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.
 * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @extends SystemRenderer
 * @param [width=800] {number} the width of the canvas view
 * @param [height=600] {number} the height of the canvas view
 * @param [options] {object} The optional renderer parameters
 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
 * @param [options.antialias=false] {boolean} sets antialias (only applicable in chrome at the moment)
 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
 *      not before the new render pass.
 */
function CanvasRenderer(width, height, options)
{
    SystemRenderer.call(this, 'Canvas', width, height, options);

    this.type = CONST.RENDERER_TYPE.CANVAS;

    /**
     * The canvas 2d context that everything is drawn with.
     *
     * @member {CanvasRenderingContext2D}
     */
    this.context = this.view.getContext('2d', { alpha: this.transparent });

    /**
     * Boolean flag controlling canvas refresh.
     *
     * @member {boolean}
     */
    this.refresh = true;

    /**
     * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.
     *
     * @member {CanvasMaskManager}
     */
    this.maskManager = new CanvasMaskManager();

    /**
     * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Handy for crisp pixel art and speed on legacy devices.
     *
     * @member {boolean}
     */
    this.roundPixels = false;

    /**
     * Tracks the active scale mode for this renderer.
     *
     * @member {SCALE_MODE}
     */
    this.currentScaleMode = CONST.SCALE_MODES.DEFAULT;

    /**
     * Tracks the active blend mode for this renderer.
     *
     * @member {SCALE_MODE}
     */
    this.currentBlendMode = CONST.BLEND_MODES.NORMAL;

    /**
     * The canvas property used to set the canvas smoothing property.
     *
     * @member {string}
     */
    this.smoothProperty = 'imageSmoothingEnabled';

    if (!this.context.imageSmoothingEnabled)
    {
        if (this.context.webkitImageSmoothingEnabled)
        {
            this.smoothProperty = 'webkitImageSmoothingEnabled';
        }
        else if (this.context.mozImageSmoothingEnabled)
        {
            this.smoothProperty = 'mozImageSmoothingEnabled';
        }
        else if (this.context.oImageSmoothingEnabled)
        {
            this.smoothProperty = 'oImageSmoothingEnabled';
        }
        else if (this.context.msImageSmoothingEnabled)
        {
            this.smoothProperty = 'msImageSmoothingEnabled';
        }
    }

    this.initPlugins();

    this._mapBlendModes();

    /**
     * This temporary display object used as the parent of the currently being rendered item
     *
     * @member {DisplayObject}
     * @private
     */
    this._tempDisplayObjectParent = {
        worldTransform: new math.Matrix(),
        worldAlpha: 1
    };


    this.resize(width, height);
}

// constructor
CanvasRenderer.prototype = Object.create(SystemRenderer.prototype);
CanvasRenderer.prototype.constructor = CanvasRenderer;
module.exports = CanvasRenderer;
utils.pluginTarget.mixin(CanvasRenderer);

/**
 * Renders the object to this canvas view
 *
 * @param object {DisplayObject} the object to be rendered
 */
CanvasRenderer.prototype.render = function (object)
{
    var cacheParent = object.parent;

    this._lastObjectRendered = object;

    object.parent = this._tempDisplayObjectParent;

    // update the scene graph
    object.updateTransform();

    object.parent = cacheParent;

    this.context.setTransform(1, 0, 0, 1, 0, 0);

    this.context.globalAlpha = 1;

    this.currentBlendMode = CONST.BLEND_MODES.NORMAL;
    this.context.globalCompositeOperation = this.blendModes[CONST.BLEND_MODES.NORMAL];

    if (navigator.isCocoonJS && this.view.screencanvas)
    {
        this.context.fillStyle = 'black';
        this.context.clear();
    }

    if (this.clearBeforeRender)
    {
        if (this.transparent)
        {
            this.context.clearRect(0, 0, this.width, this.height);
        }
        else
        {
            this.context.fillStyle = this._backgroundColorString;
            this.context.fillRect(0, 0, this.width , this.height);
        }
    }

    this.renderDisplayObject(object, this.context);
};

/**
 * Removes everything from the renderer and optionally removes the Canvas DOM element.
 *
 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
 */
CanvasRenderer.prototype.destroy = function (removeView)
{
    this.destroyPlugins();

    // call the base destroy
    SystemRenderer.prototype.destroy.call(this, removeView);

    this.context = null;

    this.refresh = true;

    this.maskManager.destroy();
    this.maskManager = null;

    this.roundPixels = false;

    this.currentScaleMode = 0;
    this.currentBlendMode = 0;

    this.smoothProperty = null;
};

/**
 * Renders a display object
 *
 * @param displayObject {DisplayObject} The displayObject to render
 * @private
 */
CanvasRenderer.prototype.renderDisplayObject = function (displayObject, context)
{
    var tempContext = this.context;

    this.context = context;
    displayObject.renderCanvas(this);
    this.context = tempContext;
};

/**
 * Maps Pixi blend modes to canvas blend modes.
 *
 * @private
 */
CanvasRenderer.prototype._mapBlendModes = function ()
{
    if (!this.blendModes)
    {
        this.blendModes = {};

        if (utils.canUseNewCanvasBlendModes())
        {
            this.blendModes[CONST.BLEND_MODES.NORMAL]        = 'source-over';
            this.blendModes[CONST.BLEND_MODES.ADD]           = 'lighter'; //IS THIS OK???
            this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = 'multiply';
            this.blendModes[CONST.BLEND_MODES.SCREEN]        = 'screen';
            this.blendModes[CONST.BLEND_MODES.OVERLAY]       = 'overlay';
            this.blendModes[CONST.BLEND_MODES.DARKEN]        = 'darken';
            this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = 'lighten';
            this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = 'color-dodge';
            this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = 'color-burn';
            this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = 'hard-light';
            this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = 'soft-light';
            this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = 'difference';
            this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = 'exclusion';
            this.blendModes[CONST.BLEND_MODES.HUE]           = 'hue';
            this.blendModes[CONST.BLEND_MODES.SATURATION]    = 'saturation';
            this.blendModes[CONST.BLEND_MODES.COLOR]         = 'color';
            this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = 'luminosity';
        }
        else
        {
            // this means that the browser does not support the cool new blend modes in canvas 'cough' ie 'cough'
            this.blendModes[CONST.BLEND_MODES.NORMAL]        = 'source-over';
            this.blendModes[CONST.BLEND_MODES.ADD]           = 'lighter'; //IS THIS OK???
            this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = 'source-over';
            this.blendModes[CONST.BLEND_MODES.SCREEN]        = 'source-over';
            this.blendModes[CONST.BLEND_MODES.OVERLAY]       = 'source-over';
            this.blendModes[CONST.BLEND_MODES.DARKEN]        = 'source-over';
            this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = 'source-over';
            this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = 'source-over';
            this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = 'source-over';
            this.blendModes[CONST.BLEND_MODES.HUE]           = 'source-over';
            this.blendModes[CONST.BLEND_MODES.SATURATION]    = 'source-over';
            this.blendModes[CONST.BLEND_MODES.COLOR]         = 'source-over';
            this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = 'source-over';
        }
    }
};

},{"../../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js","../SystemRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/SystemRenderer.js","./utils/CanvasMaskManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasMaskManager.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasBuffer.js":[function(require,module,exports){
/**
 * Creates a Canvas element of the given size.
 *
 * @class
 * @memberof PIXI
 * @param width {number} the width for the newly created canvas
 * @param height {number} the height for the newly created canvas
 */
function CanvasBuffer(width, height)
{
    /**
     * The Canvas object that belongs to this CanvasBuffer.
     *
     * @member {HTMLCanvasElement}
     */
    this.canvas = document.createElement('canvas');

    /**
     * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
     *
     * @member {CanvasRenderingContext2D}
     */
    this.context = this.canvas.getContext('2d');

    this.canvas.width = width;
    this.canvas.height = height;
}

CanvasBuffer.prototype.constructor = CanvasBuffer;
module.exports = CanvasBuffer;

Object.defineProperties(CanvasBuffer.prototype, {
    /**
     * The width of the canvas buffer in pixels.
     *
     * @member {number}
     * @memberof CanvasBuffer#
     */
    width: {
        get: function ()
        {
            return this.canvas.width;
        },
        set: function (val)
        {
            this.canvas.width = val;
        }
    },
    /**
     * The height of the canvas buffer in pixels.
     *
     * @member {number}
     * @memberof CanvasBuffer#
     */
    height: {
        get: function ()
        {
            return this.canvas.height;
        },
        set: function (val)
        {
            this.canvas.height = val;
        }
    }
});

/**
 * Clears the canvas that was created by the CanvasBuffer class.
 *
 * @private
 */
CanvasBuffer.prototype.clear = function ()
{
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.clearRect(0,0, this.canvas.width, this.canvas.height);
};

/**
 * Resizes the canvas to the specified width and height.
 *
 * @param width {number} the new width of the canvas
 * @param height {number} the new height of the canvas
 */
CanvasBuffer.prototype.resize = function (width, height)
{
    this.canvas.width = width;
    this.canvas.height = height;
};

/**
 * Destroys this canvas.
 *
 */
CanvasBuffer.prototype.destroy = function ()
{
    this.context = null;
    this.canvas = null;
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasGraphics.js":[function(require,module,exports){
var CONST = require('../../../const');

/**
 * A set of functions used by the canvas renderer to draw the primitive graphics data.
 * @static
 * @memberof PIXI
 */
var CanvasGraphics = module.exports = {};

/*
 * Renders a Graphics object to a canvas.
 *
 * @param graphics {Graphics} the actual graphics object to render
 * @param context {CanvasRenderingContext2D} the 2d drawing method of the canvas
 */
CanvasGraphics.renderGraphics = function (graphics, context)
{
    var worldAlpha = graphics.worldAlpha;

    if (graphics.dirty)
    {
        this.updateGraphicsTint(graphics);
        graphics.dirty = false;
    }

    for (var i = 0; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];
        var shape = data.shape;

        var fillColor = data._fillTint;
        var lineColor = data._lineTint;

        context.lineWidth = data.lineWidth;

        if (data.type === CONST.SHAPES.POLY)
        {
            context.beginPath();

            var points = shape.points;

            context.moveTo(points[0], points[1]);

            for (var j=1; j < points.length/2; j++)
            {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            if (shape.closed)
            {
                context.lineTo(points[0], points[1]);
            }

            // if the first and last point are the same close the path - much neater :)
            if (points[0] === points[points.length-2] && points[1] === points[points.length-1])
            {
                context.closePath();
            }

            if (data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.stroke();
            }
        }
        else if (data.type === CONST.SHAPES.RECT)
        {

            if (data.fillColor || data.fillColor === 0)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fillRect(shape.x, shape.y, shape.width, shape.height);

            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.strokeRect(shape.x, shape.y, shape.width, shape.height);
            }
        }
        else if (data.type === CONST.SHAPES.CIRC)
        {
            // TODO - need to be Undefined!
            context.beginPath();
            context.arc(shape.x, shape.y, shape.radius,0,2*Math.PI);
            context.closePath();

            if (data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.stroke();
            }
        }
        else if (data.type === CONST.SHAPES.ELIP)
        {
            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

            var w = shape.width * 2;
            var h = shape.height * 2;

            var x = shape.x - w/2;
            var y = shape.y - h/2;

            context.beginPath();

            var kappa = 0.5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

            context.closePath();

            if (data.fill)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fill();
            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.stroke();
            }
        }
        else if (data.type === CONST.SHAPES.RREC)
        {
            var rx = shape.x;
            var ry = shape.y;
            var width = shape.width;
            var height = shape.height;
            var radius = shape.radius;

            var maxRadius = Math.min(width, height) / 2 | 0;
            radius = radius > maxRadius ? maxRadius : radius;

            context.beginPath();
            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();

            if (data.fillColor || data.fillColor === 0)
            {
                context.globalAlpha = data.fillAlpha * worldAlpha;
                context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6);
                context.fill();

            }
            if (data.lineWidth)
            {
                context.globalAlpha = data.lineAlpha * worldAlpha;
                context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6);
                context.stroke();
            }
        }
    }
};

/*
 * Renders a graphics mask
 *
 * @private
 * @param graphics {Graphics} the graphics which will be used as a mask
 * @param context {CanvasRenderingContext2D} the context 2d method of the canvas
 */
CanvasGraphics.renderGraphicsMask = function (graphics, context)
{
    var len = graphics.graphicsData.length;

    if (len === 0)
    {
        return;
    }

    context.beginPath();

    for (var i = 0; i < len; i++)
    {
        var data = graphics.graphicsData[i];
        var shape = data.shape;

        if (data.type === CONST.SHAPES.POLY)
        {

            var points = shape.points;

            context.moveTo(points[0], points[1]);

            for (var j=1; j < points.length/2; j++)
            {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            // if the first and last point are the same close the path - much neater :)
            if (points[0] === points[points.length-2] && points[1] === points[points.length-1])
            {
                context.closePath();
            }

        }
        else if (data.type === CONST.SHAPES.RECT)
        {
            context.rect(shape.x, shape.y, shape.width, shape.height);
            context.closePath();
        }
        else if (data.type === CONST.SHAPES.CIRC)
        {
            // TODO - need to be Undefined!
            context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
            context.closePath();
        }
        else if (data.type === CONST.SHAPES.ELIP)
        {

            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas

            var w = shape.width * 2;
            var h = shape.height * 2;

            var x = shape.x - w/2;
            var y = shape.y - h/2;

            var kappa = 0.5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

            context.moveTo(x, ym);
            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            context.closePath();
        }
        else if (data.type === CONST.SHAPES.RREC)
        {

            var rx = shape.x;
            var ry = shape.y;
            var width = shape.width;
            var height = shape.height;
            var radius = shape.radius;

            var maxRadius = Math.min(width, height) / 2 | 0;
            radius = radius > maxRadius ? maxRadius : radius;

            context.moveTo(rx, ry + radius);
            context.lineTo(rx, ry + height - radius);
            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
            context.lineTo(rx + width - radius, ry + height);
            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
            context.lineTo(rx + width, ry + radius);
            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
            context.lineTo(rx + radius, ry);
            context.quadraticCurveTo(rx, ry, rx, ry + radius);
            context.closePath();
        }
    }
};

/*
 * Updates the tint of a graphics object
 *
 * @private
 * @param graphics {Graphics} the graphics that will have its tint updated
 * 
 */
CanvasGraphics.updateGraphicsTint = function (graphics)
{
    if (graphics.tint === 0xFFFFFF)
    {
        return;
    }

    var tintR = (graphics.tint >> 16 & 0xFF) / 255;
    var tintG = (graphics.tint >> 8 & 0xFF) / 255;
    var tintB = (graphics.tint & 0xFF)/ 255;

    for (var i = 0; i < graphics.graphicsData.length; i++)
    {
        var data = graphics.graphicsData[i];

        var fillColor = data.fillColor | 0;
        var lineColor = data.lineColor | 0;

        /*
        var colorR = (fillColor >> 16 & 0xFF) / 255;
        var colorG = (fillColor >> 8 & 0xFF) / 255;
        var colorB = (fillColor & 0xFF) / 255;

        colorR *= tintR;
        colorG *= tintG;
        colorB *= tintB;

        fillColor = ((colorR*255 << 16) + (colorG*255 << 8) + colorB*255);

        colorR = (lineColor >> 16 & 0xFF) / 255;
        colorG = (lineColor >> 8 & 0xFF) / 255;
        colorB = (lineColor & 0xFF) / 255;

        colorR *= tintR;
        colorG *= tintG;
        colorB *= tintB;

        lineColor = ((colorR*255 << 16) + (colorG*255 << 8) + colorB*255);
        */

        // super inline cos im an optimization NAZI :)
        data._fillTint = (((fillColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (fillColor & 0xFF) / 255 * tintB*255);
        data._lineTint = (((lineColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (lineColor & 0xFF) / 255 * tintB*255);

    }
};


},{"../../../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasMaskManager.js":[function(require,module,exports){
var CanvasGraphics = require('./CanvasGraphics');

/**
 * A set of functions used to handle masking.
 *
 * @class
 * @memberof PIXI
 */
function CanvasMaskManager()
{}

CanvasMaskManager.prototype.constructor = CanvasMaskManager;
module.exports = CanvasMaskManager;

/**
 * This method adds it to the current stack of masks.
 *
 * @param maskData {object} the maskData that will be pushed
 * @param renderer {WebGLRenderer|CanvasRenderer} The renderer context to use.
 */
CanvasMaskManager.prototype.pushMask = function (maskData, renderer)
{

    renderer.context.save();

    var cacheAlpha = maskData.alpha;
    var transform = maskData.worldTransform;
    var resolution = renderer.resolution;

    renderer.context.setTransform(
        transform.a * resolution,
        transform.b * resolution,
        transform.c * resolution,
        transform.d * resolution,
        transform.tx * resolution,
        transform.ty * resolution
    );

    //TODO suport sprite alpha masks??
    //lots of effort required. If demand is great enough..
    if(!maskData.texture)
    {
        CanvasGraphics.renderGraphicsMask(maskData, renderer.context);
        renderer.context.clip();
    }

    maskData.worldAlpha = cacheAlpha;
};

/**
 * Restores the current drawing context to the state it was before the mask was applied.
 *
 * @param renderer {WebGLRenderer|CanvasRenderer} The renderer context to use.
 */
CanvasMaskManager.prototype.popMask = function (renderer)
{
    renderer.context.restore();
};

},{"./CanvasGraphics":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasGraphics.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasTinter.js":[function(require,module,exports){
var utils = require('../../../utils');

/**
 * Utility methods for Sprite/Texture tinting.
 * @static
 * @memberof PIXI
 */
var CanvasTinter = module.exports = {};

/**
 * Basically this method just needs a sprite and a color and tints the sprite with the given color.
 *
 * @param sprite {Sprite} the sprite to tint
 * @param color {number} the color to use to tint the sprite with
 * @return {HTMLCanvasElement} The tinted canvas
 */
CanvasTinter.getTintedTexture = function (sprite, color)
{
    var texture = sprite.texture;

    color = CanvasTinter.roundColor(color);

    var stringColor = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);

    texture.tintCache = texture.tintCache || {};

    if (texture.tintCache[stringColor])
    {
        return texture.tintCache[stringColor];
    }

     // clone texture..
    var canvas = CanvasTinter.canvas || document.createElement('canvas');

    //CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);
    CanvasTinter.tintMethod(texture, color, canvas);

    if (CanvasTinter.convertTintToImage)
    {
        // is this better?
        var tintImage = new Image();
        tintImage.src = canvas.toDataURL();

        texture.tintCache[stringColor] = tintImage;
    }
    else
    {
        texture.tintCache[stringColor] = canvas;
        // if we are not converting the texture to an image then we need to lose the reference to the canvas
        CanvasTinter.canvas = null;
    }

    return canvas;
};

/**
 * Tint a texture using the 'multiply' operation.
 *
 * @param texture {Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
CanvasTinter.tintWithMultiply = function (texture, color, canvas)
{
    var context = canvas.getContext( '2d' );

    var crop = texture.crop;

    canvas.width = crop.width;
    canvas.height = crop.height;

    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);

    context.fillRect(0, 0, crop.width, crop.height);

    context.globalCompositeOperation = 'multiply';

    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );

    context.globalCompositeOperation = 'destination-atop';

    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );
};

/**
 * Tint a texture using the 'overlay' operation.
 *
 * @param texture {Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
CanvasTinter.tintWithOverlay = function (texture, color, canvas)
{
    var context = canvas.getContext( '2d' );

    var crop = texture.crop;

    canvas.width = crop.width;
    canvas.height = crop.height;

    context.globalCompositeOperation = 'copy';
    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);
    context.fillRect(0, 0, crop.width, crop.height);

    context.globalCompositeOperation = 'destination-atop';
    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );

    // context.globalCompositeOperation = 'copy';
};

/**
 * Tint a texture pixel per pixel.
 *
 * @param texture {Texture} the texture to tint
 * @param color {number} the color to use to tint the sprite with
 * @param canvas {HTMLCanvasElement} the current canvas
 */
CanvasTinter.tintWithPerPixel = function (texture, color, canvas)
{
    var context = canvas.getContext( '2d' );

    var crop = texture.crop;

    canvas.width = crop.width;
    canvas.height = crop.height;

    context.globalCompositeOperation = 'copy';
    context.drawImage(
        texture.baseTexture.source,
        crop.x,
        crop.y,
        crop.width,
        crop.height,
        0,
        0,
        crop.width,
        crop.height
    );

    var rgbValues = utils.hex2rgb(color);
    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];

    var pixelData = context.getImageData(0, 0, crop.width, crop.height);

    var pixels = pixelData.data;

    for (var i = 0; i < pixels.length; i += 4)
    {
        pixels[i+0] *= r;
        pixels[i+1] *= g;
        pixels[i+2] *= b;
    }

    context.putImageData(pixelData, 0, 0);
};

/**
 * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.
 *
 * @param color {number} the color to round, should be a hex color
 */
CanvasTinter.roundColor = function (color)
{
    var step = CanvasTinter.cacheStepsPerColorChannel;

    var rgbValues = utils.hex2rgb(color);

    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);
    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);
    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);

    return utils.rgb2hex(rgbValues);
};

/**
 * Number of steps which will be used as a cap when rounding colors.
 *
 * @member
 */
CanvasTinter.cacheStepsPerColorChannel = 8;

/**
 * Tint cache boolean flag.
 *
 * @member
 */
CanvasTinter.convertTintToImage = false;

/**
 * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
 *
 * @member
 */
CanvasTinter.canUseMultiply = utils.canUseNewCanvasBlendModes();

/**
 * The tinting method that will be used.
 *
 */
CanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply :  CanvasTinter.tintWithPerPixel;

},{"../../../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/WebGLRenderer.js":[function(require,module,exports){
var SystemRenderer = require('../SystemRenderer'),
    ShaderManager = require('./managers/ShaderManager'),
    MaskManager = require('./managers/MaskManager'),
    StencilManager = require('./managers/StencilManager'),
    FilterManager = require('./managers/FilterManager'),
    BlendModeManager = require('./managers/BlendModeManager'),
    RenderTarget = require('./utils/RenderTarget'),
    ObjectRenderer = require('./utils/ObjectRenderer'),
    FXAAFilter = require('./filters/FXAAFilter'),
    utils = require('../../utils'),
    CONST = require('../../const');

/**
 * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer
 * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.
 * So no need for Sprite Batches or Sprite Clouds.
 * Don't forget to add the view to your DOM or you will not see anything :)
 *
 * @class
 * @memberof PIXI
 * @extends SystemRenderer
 * @param [width=0] {number} the width of the canvas view
 * @param [height=0] {number} the height of the canvas view
 * @param [options] {object} The optional renderer parameters
 * @param [options.view] {HTMLCanvasElement} the canvas to use as a view, optional
 * @param [options.transparent=false] {boolean} If the render view is transparent, default false
 * @param [options.autoResize=false] {boolean} If the render view is automatically resized, default false
 * @param [options.antialias=false] {boolean} sets antialias. If not available natively then FXAA antialiasing is used
 * @param [options.forceFXAA=false] {boolean} forces FXAA antialiasing to be used over native. FXAA is faster, but may not always lok as great
 * @param [options.resolution=1] {number} the resolution of the renderer retina would be 2
 * @param [options.clearBeforeRender=true] {boolean} This sets if the CanvasRenderer will clear the canvas or
 *      not before the new render pass.
 * @param [options.preserveDrawingBuffer=false] {boolean} enables drawing buffer preservation, enable this if
 *      you need to call toDataUrl on the webgl context.
 */
function WebGLRenderer(width, height, options)
{
    options = options || {};

    SystemRenderer.call(this, 'WebGL', width, height, options);

    /**
     * The type of this renderer as a standardised const
     *
     * @member {number}
     *
     */
    this.type = CONST.RENDERER_TYPE.WEBGL;

    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);

    this.view.addEventListener('webglcontextlost', this.handleContextLost, false);
    this.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);

    //TODO possibility to force FXAA as it may offer better performance?
    /**
     * Does it use FXAA ?
     *
     * @member {boolean}
     * @private
     */
    this._useFXAA = !!options.forceFXAA && options.antialias;

    /**
     * The fxaa filter
     *
     * @member {FXAAFilter}
     * @private
     */
    this._FXAAFilter = null;

    /**
     * The options passed in to create a new webgl context.
     *
     * @member {object}
     * @private
     */
    this._contextOptions = {
        alpha: this.transparent,
        antialias: options.antialias,
        premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer
    };

    /**
     * Counter for the number of draws made each frame
     *
     * @member {number}
     */
    this.drawCount = 0;

    /**
     * Deals with managing the shader programs and their attribs.
     *
     * @member {ShaderManager}
     */
    this.shaderManager = new ShaderManager(this);

    /**
     * Manages the masks using the stencil buffer.
     *
     * @member {MaskManager}
     */
    this.maskManager = new MaskManager(this);

    /**
     * Manages the stencil buffer.
     *
     * @member {StencilManager}
     */
    this.stencilManager = new StencilManager(this);

    /**
     * Manages the filters.
     *
     * @member {FilterManager}
     */
    this.filterManager = new FilterManager(this);


    /**
     * Manages the blendModes
     * @member {BlendModeManager}
     */
    this.blendModeManager = new BlendModeManager(this);

    /**
     * Holds the current render target
     * @member {Object}
     */
    this.currentRenderTarget = null;

    /**
     * object renderer @alvin
     * @member {ObjectRenderer}
     */
    this.currentRenderer = new ObjectRenderer(this);

    this.initPlugins();

     // initialize the context so it is ready for the managers.
    this._initContext();

    // map some webGL blend modes..
    this._mapBlendModes();

    /**
     * An array of render targets
     * @member {Array}
     * @private
     */
    this._renderTargetStack = [];
}

// constructor
WebGLRenderer.prototype = Object.create(SystemRenderer.prototype);
WebGLRenderer.prototype.constructor = WebGLRenderer;
module.exports = WebGLRenderer;
utils.pluginTarget.mixin(WebGLRenderer);

WebGLRenderer.glContextId = 0;

/**
 * Creates the WebGL context
 * @private
 */
WebGLRenderer.prototype._initContext = function ()
{
    var gl = this.view.getContext('webgl', this._contextOptions) || this.view.getContext('experimental-webgl', this._contextOptions);
    this.gl = gl;

    if (!gl)
    {
        // fail, not able to get a context
        throw new Error('This browser does not support webGL. Try using the canvas renderer');
    }

    this.glContextId = WebGLRenderer.glContextId++;
    gl.id = this.glContextId;
    gl.renderer = this;

    // set up the default pixi settings..
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);
    gl.enable(gl.BLEND);

    this.renderTarget = new RenderTarget(this.gl, this.width, this.height, null, this.resolution, true);

    this.setRenderTarget(this.renderTarget);

    this.emit('context', gl);

    // setup the width/height properties and gl viewport
    this.resize(this.width, this.height);

    if(!this._useFXAA)
    {
        this._useFXAA = ( this._contextOptions.antialias && ! gl.getContextAttributes().antialias );
    }


    if(this._useFXAA)
    {
        window.console.warn('FXAA antialiasing being used instead of native antialiasing');
        this._FXAAFilter = [new FXAAFilter()];
    }
};

/**
 * Renders the object to its webGL view
 *
 * @param object {DisplayObject} the object to be rendered
 */
WebGLRenderer.prototype.render = function (object)
{
    // no point rendering if our context has been blown up!
    if (this.gl.isContextLost())
    {
        return;
    }

    this._lastObjectRendered = object;

    if(this._useFXAA)
    {
        this._FXAAFilter[0].uniforms.resolution.value.x = this.width;
        this._FXAAFilter[0].uniforms.resolution.value.y = this.height;
        object.filterArea = this.renderTarget.size;
        object.filters = this._FXAAFilter;
    }

    var cacheParent = object.parent;
    object.parent = this._tempDisplayObjectParent;

    // update the scene graph
    object.updateTransform();

    object.parent = cacheParent;

    var gl = this.gl;

    // make sure we are bound to the main frame buffer
    this.setRenderTarget(this.renderTarget);

    if (this.clearBeforeRender)
    {
        if (this.transparent)
        {
            gl.clearColor(0, 0, 0, 0);
        }
        else
        {
            gl.clearColor(this._backgroundColorRgb[0], this._backgroundColorRgb[1], this._backgroundColorRgb[2], 1);
        }

        gl.clear(gl.COLOR_BUFFER_BIT);
    }

    this.renderDisplayObject(object, this.renderTarget);//this.projection);
};

/**
 * Renders a Display Object.
 *
 * @param displayObject {DisplayObject} The DisplayObject to render
 * @param renderTarget {RenderTarget} The render target to use to render this display object
 *
 */
WebGLRenderer.prototype.renderDisplayObject = function (displayObject, renderTarget, clear)//projection, buffer)
{
    // TODO is this needed...
    //this.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);
    this.setRenderTarget(renderTarget);

    if(clear)
    {
        renderTarget.clear();
    }

    // start the filter manager
    this.filterManager.setFilterStack( renderTarget.filterStack );

    // render the scene!
    displayObject.renderWebGL(this);

    // finish the current renderer..
    this.currentRenderer.flush();
};

/**
 * Changes the current renderer to the one given in parameter
 *
 * @param objectRenderer {Object} TODO @alvin
 *
 */
WebGLRenderer.prototype.setObjectRenderer = function (objectRenderer)
{
    if (this.currentRenderer === objectRenderer)
    {
        return;
    }

    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
};

/**
 * Changes the current render target to the one given in parameter
 *
 * @param renderTarget {RenderTarget} the new render target
 *
 */
WebGLRenderer.prototype.setRenderTarget = function (renderTarget)
{
    if( this.currentRenderTarget === renderTarget)
    {
        return;
    }
    // TODO - maybe down the line this should be a push pos thing? Leaving for now though.
    this.currentRenderTarget = renderTarget;
    this.currentRenderTarget.activate();
    this.stencilManager.setMaskStack( renderTarget.stencilMaskStack );
};


/**
 * Resizes the webGL view to the specified width and height.
 *
 * @param width {number} the new width of the webGL view
 * @param height {number} the new height of the webGL view
 */
WebGLRenderer.prototype.resize = function (width, height)
{
    SystemRenderer.prototype.resize.call(this, width, height);

   // console.log(width)
    this.filterManager.resize(width, height);
    this.renderTarget.resize(width, height);
    if(this.currentRenderTarget === this.renderTarget)
    {
        this.renderTarget.activate();
    }
};

/**
 * Updates and/or Creates a WebGL texture for the renderer's context.
 *
 * @param texture {BaseTexture|Texture} the texture to update
 */
WebGLRenderer.prototype.updateTexture = function (texture)
{
    texture = texture.baseTexture || texture;

    if (!texture.hasLoaded)
    {
        return;
    }

    var gl = this.gl;

    if (!texture._glTextures[gl.id])
    {
        texture._glTextures[gl.id] = gl.createTexture();
        texture.on('update', this.updateTexture, this);
        texture.on('dispose', this.destroyTexture, this);
    }


    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);

    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);


    if (texture.mipmap && texture.isPowerOfTwo)
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        gl.generateMipmap(gl.TEXTURE_2D);
    }
    else
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }

    if (!texture.isPowerOfTwo)
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    else
    {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    }

    return  texture._glTextures[gl.id];
};

/**
 * Deletes the texture from WebGL
 *
 * @param texture {BaseTexture|Texture} the texture to destroy
 */
WebGLRenderer.prototype.destroyTexture = function (texture)
{
    texture = texture.baseTexture || texture;

    if (!texture.hasLoaded)
    {
        return;
    }

    if (texture._glTextures[this.gl.id])
    {
        this.gl.deleteTexture(texture._glTextures[this.gl.id]);
    }
};

/**
 * Handles a lost webgl context
 *
 * @param event {Event}
 * @private
 */
WebGLRenderer.prototype.handleContextLost = function (event)
{
    event.preventDefault();
};

/**
 * Handles a restored webgl context
 *
 * @param event {Event}
 * @private
 */
WebGLRenderer.prototype.handleContextRestored = function ()
{
    this._initContext();

    // empty all the old gl textures as they are useless now
    for (var key in utils.BaseTextureCache)
    {
        utils.BaseTextureCache[key]._glTextures.length = 0;
    }
};

/**
 * Removes everything from the renderer (event listeners, spritebatch, etc...)
 *
 * @param [removeView=false] {boolean} Removes the Canvas element from the DOM.
 */
WebGLRenderer.prototype.destroy = function (removeView)
{
    this.destroyPlugins();

    // remove listeners
    this.view.removeEventListener('webglcontextlost', this.handleContextLost);
    this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);

    // call base destroy
    SystemRenderer.prototype.destroy.call(this, removeView);

    this.uuid = 0;

    // destroy the managers
    this.shaderManager.destroy();
    this.maskManager.destroy();
    this.stencilManager.destroy();
    this.filterManager.destroy();

    this.shaderManager = null;
    this.maskManager = null;
    this.filterManager = null;
    this.blendModeManager = null;

    this.handleContextLost = null;
    this.handleContextRestored = null;

    this._contextOptions = null;

    this.drawCount = 0;

    this.gl = null;
};

/**
 * Maps Pixi blend modes to WebGL blend modes.
 *
 * @private
 */
WebGLRenderer.prototype._mapBlendModes = function ()
{
    var gl = this.gl;

    if (!this.blendModes)
    {
        this.blendModes = {};

        this.blendModes[CONST.BLEND_MODES.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.ADD]           = [gl.SRC_ALPHA, gl.DST_ALPHA];
        this.blendModes[CONST.BLEND_MODES.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.SCREEN]        = [gl.SRC_ALPHA, gl.ONE];
        this.blendModes[CONST.BLEND_MODES.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
        this.blendModes[CONST.BLEND_MODES.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];
    }
};

},{"../../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js","../SystemRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/SystemRenderer.js","./filters/FXAAFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/filters/FXAAFilter.js","./managers/BlendModeManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/BlendModeManager.js","./managers/FilterManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/FilterManager.js","./managers/MaskManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/MaskManager.js","./managers/ShaderManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/ShaderManager.js","./managers/StencilManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/StencilManager.js","./utils/ObjectRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/ObjectRenderer.js","./utils/RenderTarget":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/RenderTarget.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/filters/AbstractFilter.js":[function(require,module,exports){
var DefaultShader = require('../shaders/TextureShader');

/**
 * This is the base class for creating a PIXI filter. Currently only WebGL supports filters.
 * If you want to make a custom filter this should be your base class.
 *
 * @class
 * @memberof PIXI
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param uniforms {object} An object containing the uniforms for this filter.
 */
function AbstractFilter(vertexSrc, fragmentSrc, uniforms)
{

    /**
     * An array of shaders
     * @member {Shader[]}
     * @private
     */
    this.shaders = [];

    /**
     * The extra padding that the filter might need
     * @member {number}
     */
    this.padding = 0;

    /**
     * The uniforms as an object
     * @member {object}
     * @private
     */
    this.uniforms = uniforms || {};


    /**
     * The code of the vertex shader
     * @member {string[]}
     * @private
     */
    this.vertexSrc = vertexSrc || DefaultShader.defaultVertexSrc;

    /**
     * The code of the frament shader
     * @member {string[]}
     * @private
     */
    this.fragmentSrc = fragmentSrc || DefaultShader.defaultFragmentSrc;

    //TODO a reminder - would be cool to have lower res filters as this would give better performance.

    //typeof fragmentSrc === 'string' ? fragmentSrc.split('') : (fragmentSrc || []);

}

AbstractFilter.prototype.constructor = AbstractFilter;
module.exports = AbstractFilter;

/*
 * Grabs a shader from the current renderer
 * @param renderer {WebGLRenderer} The renderer to retrieve the shader from
 *
 */
AbstractFilter.prototype.getShader = function (renderer)
{
    var gl = renderer.gl;

    var shader = this.shaders[gl.id];

    if (!shader)
    {
        shader = new DefaultShader(renderer.shaderManager,
            this.vertexSrc,
            this.fragmentSrc,
            this.uniforms,
            this.attributes
        );

        this.shaders[gl.id] = shader;
    }

    return shader;
};

/*
 * Applies the filter
 * @param renderer {WebGLRenderer} The renderer to retrieve the filter from
 * @param input {RenderTarget}
 * @param output {RenderTarget}
 * @param clear {boolean} Whether or not we want to clear the outputTarget
 */
AbstractFilter.prototype.applyFilter = function (renderer, input, output, clear)
{
    var shader = this.getShader(renderer);

    renderer.filterManager.applyFilter(shader, input, output, clear);
};

/**
 * Syncs a uniform between the class object and the shaders.
 *
 */
AbstractFilter.prototype.syncUniform = function (uniform)
{
    for (var i = 0, j = this.shaders.length; i < j; ++i)
    {
        this.shaders[i].syncUniform(uniform);
    }
};

/*
AbstractFilter.prototype.apply = function (frameBuffer)
{
    // TODO :)
};
*/

},{"../shaders/TextureShader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/TextureShader.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/filters/FXAAFilter.js":[function(require,module,exports){
var AbstractFilter = require('./AbstractFilter');
// @see https://github.com/substack/brfs/issues/25


/**
 *
 * Basic FXAA implementation based on the code on geeks3d.com with the
 * modification that the texture2DLod stuff was removed since it's
 * unsupported by WebGL.
 *
 * --
 * From:
 * https://github.com/mitsuhiko/webgl-meincraft
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI
 *
 */
function FXAAFilter()
{
    AbstractFilter.call(this,
        // vertex shader
        "\nprecision mediump float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform vec2 resolution;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvarying vec2 vResolution;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n            out vec2 v_rgbNW, out vec2 v_rgbNE,\n            out vec2 v_rgbSW, out vec2 v_rgbSE,\n            out vec2 v_rgbM) {\n    vec2 inverseVP = 1.0 / resolution.xy;\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n   vResolution = resolution;\n\n   //compute the texture coords and send them to varyings\n   texcoords(aTextureCoord * resolution, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n",
        // fragment shader
        "precision lowp float;\n\n\n/**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it's\nunsupported by WebGL.\n\n--\n\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\n\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE,\n            vec2 v_rgbSW, vec2 v_rgbSE,\n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vResolution;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nuniform sampler2D uSampler;\n\n\nvoid main(void){\n\n    gl_FragColor = fxaa(uSampler, vTextureCoord * vResolution, vResolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n}\n",
        // uniforms
        {
            resolution: { type: 'v2', value: { x: 1, y: 1 } }
        }
    );

}

FXAAFilter.prototype = Object.create(AbstractFilter.prototype);
FXAAFilter.prototype.constructor = FXAAFilter;
module.exports = FXAAFilter;

FXAAFilter.prototype.applyFilter = function (renderer, input, output)
{
    var filterManager = renderer.filterManager;

    var shader = this.getShader( renderer );
     // draw the filter...
    filterManager.applyFilter(shader, input, output);
};

},{"./AbstractFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/filters/AbstractFilter.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/filters/SpriteMaskFilter.js":[function(require,module,exports){
var AbstractFilter = require('./AbstractFilter'),
    math =  require('../../../math');

// @see https://github.com/substack/brfs/issues/25


/**
 * The SpriteMaskFilter class
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI
 * @param sprite {Sprite} the target sprite
 */
function SpriteMaskFilter(sprite)
{
    var maskMatrix = new math.Matrix();

    AbstractFilter.call(this,
        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
        "precision lowp float;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n    // check clip! this will stop the mask bleeding out from the edges\n    vec2 text = abs( vMaskCoord - 0.5 );\n    text = step(0.5, text);\n    float clip = 1.0 - max(text.y, text.x);\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    original *= (masky.r * masky.a * alpha * clip);\n    gl_FragColor = original;\n}\n",
        {
            mask:           { type: 'sampler2D', value: sprite._texture },
            alpha:          { type: 'f', value: 1},
            otherMatrix:    { type: 'mat3', value: maskMatrix.toArray(true) }
        }
    );

    this.maskSprite = sprite;
    this.maskMatrix = maskMatrix;
}

SpriteMaskFilter.prototype = Object.create(AbstractFilter.prototype);
SpriteMaskFilter.prototype.constructor = SpriteMaskFilter;
module.exports = SpriteMaskFilter;

/**
 * Applies the filter ? @alvin
 *
 * @param renderer {WebGLRenderer} A reference to the WebGL renderer
 * @param input {RenderTarget}
 * @param output {RenderTarget}
 */
SpriteMaskFilter.prototype.applyFilter = function (renderer, input, output)
{
    var filterManager = renderer.filterManager;

    this.uniforms.mask.value = this.maskSprite._texture;

    filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);

    this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);
    this.uniforms.alpha.value = this.maskSprite.worldAlpha;

    var shader = this.getShader(renderer);
     // draw the filter...
    filterManager.applyFilter(shader, input, output);
};


Object.defineProperties(SpriteMaskFilter.prototype, {
    /**
     * The texture used for the displacement map. Must be power of 2 sized texture.
     *
     * @member {Texture}
     * @memberof SpriteMaskFilter#
     */
    map: {
        get: function ()
        {
            return this.uniforms.mask.value;
        },
        set: function (value)
        {
            this.uniforms.mask.value = value;
        }
    },

    /**
     * The offset used to move the displacement map.
     *
     * @member {Point}
     * @memberof SpriteMaskFilter#
     */
    offset: {
        get: function()
        {
            return this.uniforms.offset.value;
        },
        set: function(value)
        {
            this.uniforms.offset.value = value;
        }
    }
});

},{"../../../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","./AbstractFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/filters/AbstractFilter.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/BlendModeManager.js":[function(require,module,exports){
var WebGLManager = require('./WebGLManager');

/**
 * @class
 * @memberof PIXI
 * @extends WebGlManager
 * @param renderer {WebGLRenderer} The renderer this manager works for.
 */
function BlendModeManager(renderer)
{
    WebGLManager.call(this, renderer);

    /**
     * @member {number}
     */
    this.currentBlendMode = 99999;
}

BlendModeManager.prototype = Object.create(WebGLManager.prototype);
BlendModeManager.prototype.constructor = BlendModeManager;
module.exports = BlendModeManager;

/**
 * Sets-up the given blendMode from WebGL's point of view.
 *
 * @param blendMode {number} the blendMode, should be a Pixi const, such as BlendModes.ADD
 */
BlendModeManager.prototype.setBlendMode = function (blendMode)
{
    if (this.currentBlendMode === blendMode)
    {
        return false;
    }

    this.currentBlendMode = blendMode;

    var mode = this.renderer.blendModes[this.currentBlendMode];
    this.renderer.gl.blendFunc(mode[0], mode[1]);

    return true;
};

},{"./WebGLManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/WebGLManager.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/FilterManager.js":[function(require,module,exports){
var WebGLManager = require('./WebGLManager'),
    RenderTarget = require('../utils/RenderTarget'),
    CONST = require('../../../const'),
    Quad = require('../utils/Quad'),
    math =  require('../../../math');

/**
 * @class
 * @memberof PIXI
 * @extends WebGLManager
 * @param renderer {WebGLRenderer} The renderer this manager works for.
 */
function FilterManager(renderer)
{
    WebGLManager.call(this, renderer);

    /**
     * @member {any[]}
     */
    this.filterStack = [];

    this.filterStack.push({
        renderTarget:renderer.currentRenderTarget,
        filter:[],
        bounds:null
    });

    /**
     * @member {any[]}
     */
    this.texturePool = [];

    // listen for context and update necessary buffers
    //TODO make this dynamic!
    //TODO test this out by forces power of two?
    this.textureSize = new math.Rectangle( 0, 0, renderer.width, renderer.height );

    this.currentFrame = null;
}

FilterManager.prototype = Object.create(WebGLManager.prototype);
FilterManager.prototype.constructor = FilterManager;
module.exports = FilterManager;


/**
 * Called when there is a WebGL context change.
 *
 */
FilterManager.prototype.onContextChange = function ()
{
    this.texturePool.length = 0;

    var gl = this.renderer.gl;
    this.quad = new Quad(gl);
};

/**
 * @param renderer {WebGLRenderer}
 * @param buffer {ArrayBuffer}
 */
FilterManager.prototype.setFilterStack = function ( filterStack )
{
    this.filterStack = filterStack;
};

/**
 * Applies the filter and adds it to the current filter stack.
 *
 * @param filterBlock {object} the filter that will be pushed to the current filter stack
 */
FilterManager.prototype.pushFilter = function (target, filters)
{
    // get the bounds of the object..
    var bounds = target.filterArea || target.getBounds();
    //bounds = bounds.clone();

    // round off the rectangle to get a nice smoooooooth filter :)
    bounds.x = bounds.x | 0;
    bounds.y = bounds.y | 0;
    bounds.width = bounds.width | 0;
    bounds.height = bounds.height | 0;


    // padding!
    var padding = filters[0].padding | 0;
    bounds.x -= padding;
    bounds.y -= padding;
    bounds.width += padding * 2;
    bounds.height += padding * 2;


    if(this.renderer.currentRenderTarget.transform)
    {
        //TODO this will break if the renderTexture transform is anything other than a translation.
        //Will need to take the full matrix transform into acount..
        var transform = this.renderer.currentRenderTarget.transform;

        bounds.x += transform.tx;
        bounds.y += transform.ty;

        this.capFilterArea( bounds );

        bounds.x -= transform.tx;
        bounds.y -= transform.ty;
    }
    else
    {
         this.capFilterArea( bounds );
    }

    if(bounds.width > 0 && bounds.height > 0)
    {
        this.currentFrame = bounds;

        var texture = this.getRenderTarget();

        this.renderer.setRenderTarget(texture);

        // clear the texture..
        texture.clear();

        // TODO get rid of object creation!
        this.filterStack.push({
            renderTarget: texture,
            filter: filters
        });

    }
    else
    {
        // push somthing on to the stack that is empty
        this.filterStack.push({
            renderTarget: null,
            filter: filters
        });
    }
};


/**
 * Removes the last filter from the filter stack and returns it.
 *
 */
FilterManager.prototype.popFilter = function ()
{
    var filterData = this.filterStack.pop();
    var previousFilterData = this.filterStack[this.filterStack.length-1];

    var input = filterData.renderTarget;

    // if the renderTarget is null then we don't apply the filter as its offscreen
    if(!filterData.renderTarget)
    {
        return;
    }

    var output = previousFilterData.renderTarget;

    // use program
    var gl = this.renderer.gl;


    this.currentFrame = input.frame;

    this.quad.map(this.textureSize, input.frame);


    // TODO.. this probably only needs to be done once!
    gl.bindBuffer(gl.ARRAY_BUFFER, this.quad.vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.quad.indexBuffer);

    var filters = filterData.filter;

    // assuming all filters follow the correct format??
    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);

    // restore the normal blendmode!
    this.renderer.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);

    if (filters.length === 1)
    {
        // TODO (cengler) - There has to be a better way then setting this each time?
        if (filters[0].uniforms.dimensions)
        {
            filters[0].uniforms.dimensions.value[0] = this.renderer.width;
            filters[0].uniforms.dimensions.value[1] = this.renderer.height;
            filters[0].uniforms.dimensions.value[2] = this.quad.vertices[0];
            filters[0].uniforms.dimensions.value[3] = this.quad.vertices[5];
        }

        filters[0].applyFilter( this.renderer, input, output );
        this.returnRenderTarget( input );

    }
    else
    {
        var flipTexture = input;
        var flopTexture = this.getRenderTarget(true);

        for (var i = 0; i < filters.length-1; i++)
        {
            var filter = filters[i];

            // TODO (cengler) - There has to be a better way then setting this each time?
            if (filter.uniforms.dimensions)
            {
                filter.uniforms.dimensions.value[0] = this.renderer.width;
                filter.uniforms.dimensions.value[1] = this.renderer.height;
                filter.uniforms.dimensions.value[2] = this.quad.vertices[0];
                filter.uniforms.dimensions.value[3] = this.quad.vertices[5];
            }

            filter.applyFilter( this.renderer, flipTexture, flopTexture );

            var temp = flipTexture;
            flipTexture = flopTexture;
            flopTexture = temp;
        }

        filters[filters.length-1].applyFilter( this.renderer, flipTexture, output );

        this.returnRenderTarget( flipTexture );
        this.returnRenderTarget( flopTexture );
    }

    return filterData.filter;
};

/**
 * Grabs an render target from the internal pool
 *
 * @param clear {boolean} Whether or not we need to clear the RenderTarget
 * @return {RenderTarget}
 */
FilterManager.prototype.getRenderTarget = function ( clear )
{
    var renderTarget = this.texturePool.pop() || new RenderTarget(this.renderer.gl, this.textureSize.width, this.textureSize.height, CONST.SCALE_MODES.LINEAR, this.renderer.resolution * CONST.FILTER_RESOLUTION);
    renderTarget.frame = this.currentFrame;

    if (clear)
    {
        renderTarget.clear(true);
    }

    return renderTarget;
};

/*
 * Returns a RenderTarget to the internal pool
 * @param renderTarget {RenderTarget} The RenderTarget we want to return to the pool
 */
FilterManager.prototype.returnRenderTarget = function (renderTarget)
{
    this.texturePool.push( renderTarget );
};

/*
 * Applies the filter
 * @param shader {Shader} The shader to upload
 * @param inputTarget {RenderTarget}
 * @param outputTarget {RenderTarget}
 * @param clear {boolean} Whether or not we want to clear the outputTarget
 */
FilterManager.prototype.applyFilter = function (shader, inputTarget, outputTarget, clear)
{
    var gl = this.renderer.gl;

    this.renderer.setRenderTarget(outputTarget);

    if (clear)
    {
        outputTarget.clear();
    }

    // set the shader
    this.renderer.shaderManager.setShader(shader);

    // TODO (cengler) - Can this be cached and not `toArray`ed each frame?
    shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);

    //TODO can this be optimised?
    shader.syncUniforms();
/*
    gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);
    gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
    gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);
*/

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);

    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
};

/*
 * Calculates the mapped matrix
 * @param filterArea {Rectangle} The filter area
 * @param sprite {Sprite} the target sprite
 * @param outputMatrix {Matrix} @alvin
 */
// TODO playing around here.. this is temporary - (will end up in the shader)
FilterManager.prototype.calculateMappedMatrix = function (filterArea, sprite, outputMatrix)
{
    var worldTransform = sprite.worldTransform.copy(math.Matrix.TEMP_MATRIX),
    texture = sprite._texture.baseTexture;

    var mappedMatrix = outputMatrix.identity();

    // scale..
    var ratio = this.textureSize.height / this.textureSize.width;

    mappedMatrix.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height );

    mappedMatrix.scale(1 , ratio);

    var translateScaleX = (this.textureSize.width / texture.width);
    var translateScaleY = (this.textureSize.height / texture.height);

    worldTransform.tx /= texture.width * translateScaleX;
    worldTransform.ty /= texture.width * translateScaleX;

    worldTransform.invert();

    mappedMatrix.prepend(worldTransform);

    // apply inverse scale..
    mappedMatrix.scale(1 , 1/ratio);

    mappedMatrix.scale( translateScaleX , translateScaleY );

    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);

    return mappedMatrix;

    // Keeping the orginal as a reminder to me on how this works!
    //
    // var m = new math.Matrix();

    // // scale..
    // var ratio = this.textureSize.height / this.textureSize.width;

    // m.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height);


    // m.scale(1 , ratio);


    // var transform = wt.clone();

    // var translateScaleX = (this.textureSize.width / 620);
    // var translateScaleY = (this.textureSize.height / 380);

    // transform.tx /= 620 * translateScaleX;
    // transform.ty /= 620 * translateScaleX;

    // transform.invert();

    // transform.append(m);

    // // apply inverse scale..
    // transform.scale(1 , 1/ratio);

    // transform.scale( translateScaleX , translateScaleY );

    // return transform;
};

/*
 * Constrains the filter area to the texture size
 * @param filterArea {Rectangle} The filter area we want to cap
 */
FilterManager.prototype.capFilterArea = function (filterArea)
{
    if (filterArea.x < 0)
    {
        filterArea.width += filterArea.x;
        filterArea.x = 0;
    }

    if (filterArea.y < 0)
    {
        filterArea.height += filterArea.y;
        filterArea.y = 0;
    }

    if ( filterArea.x + filterArea.width > this.textureSize.width )
    {
        filterArea.width = this.textureSize.width - filterArea.x;
    }

    if ( filterArea.y + filterArea.height > this.textureSize.height )
    {
        filterArea.height = this.textureSize.height - filterArea.y;
    }
};

/*
 * Resizes all the render targets in the pool
 * @param width {number} the new width
 * @param height {number} the new height
 */
FilterManager.prototype.resize = function ( width, height )
{
    this.textureSize.width = width;
    this.textureSize.height = height;

    for (var i = 0; i < this.texturePool.length; i++)
    {
        this.texturePool[i].resize( width, height );
    }
};

/**
 * Destroys the filter and removes it from the filter stack.
 *
 */
FilterManager.prototype.destroy = function ()
{
    this.filterStack = null;
    this.offsetY = 0;

    // destroy textures
    for (var i = 0; i < this.texturePool.length; i++)
    {
        this.texturePool[i].destroy();
    }

    this.texturePool = null;
};

},{"../../../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../../../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../utils/Quad":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/Quad.js","../utils/RenderTarget":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/RenderTarget.js","./WebGLManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/WebGLManager.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/MaskManager.js":[function(require,module,exports){
var WebGLManager = require('./WebGLManager'),
    AlphaMaskFilter = require('../filters/SpriteMaskFilter');

/**
 * @class
 * @memberof PIXI
 * @param renderer {WebGLRenderer} The renderer this manager works for.
 */
function MaskManager(renderer)
{
    WebGLManager.call(this, renderer);

    this.stencilStack = [];
    this.reverse = true;
    this.count = 0;

    this.alphaMaskPool = [];
}

MaskManager.prototype = Object.create(WebGLManager.prototype);
MaskManager.prototype.constructor = MaskManager;
module.exports = MaskManager;

/**
 * Applies the Mask and adds it to the current filter stack.
 *
 * @param graphics {Graphics}
 * @param webGLData {any[]}
 */
MaskManager.prototype.pushMask = function (target, maskData)
{
    if (maskData.texture)
    {
        this.pushSpriteMask(target, maskData);
    }
    else
    {
        this.pushStencilMask(target, maskData);
    }

};

/**
 * Removes the last mask from the mask stack and doesn't return it.
 *
 * @param target {RenderTarget}
 * @param maskData {any[]}
 */
MaskManager.prototype.popMask = function (target, maskData)
{
    if (maskData.texture)
    {
        this.popSpriteMask(target, maskData);
    }
    else
    {
        this.popStencilMask(target, maskData);
    }
};

/**
 * Applies the Mask and adds it to the current filter stack.
 *
 * @param target {RenderTarget}
 * @param maskData {any[]}
 */
MaskManager.prototype.pushSpriteMask = function (target, maskData)
{
    var alphaMaskFilter = this.alphaMaskPool.pop();

    if (!alphaMaskFilter)
    {
        alphaMaskFilter = [new AlphaMaskFilter(maskData)];
    }

    alphaMaskFilter[0].maskSprite = maskData;
    this.renderer.filterManager.pushFilter(target, alphaMaskFilter);
};

/**
 * Removes the last filter from the filter stack and doesn't return it.
 *
 */
MaskManager.prototype.popSpriteMask = function ()
{
    var filters = this.renderer.filterManager.popFilter();

    this.alphaMaskPool.push(filters);
};


/**
 * Applies the Mask and adds it to the current filter stack.
 *
 * @param target {RenderTarget}
 * @param maskData {any[]}
 */
MaskManager.prototype.pushStencilMask = function (target, maskData)
{
    this.renderer.stencilManager.pushMask(maskData);
};

/**
 * Removes the last filter from the filter stack and doesn't return it.
 * @param target {RenderTarget}
 * @param maskData {any[]}
 */
MaskManager.prototype.popStencilMask = function (target, maskData)
{
    this.renderer.stencilManager.popMask(maskData);
};


},{"../filters/SpriteMaskFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/filters/SpriteMaskFilter.js","./WebGLManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/WebGLManager.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/ShaderManager.js":[function(require,module,exports){
var WebGLManager = require('./WebGLManager'),
    TextureShader = require('../shaders/TextureShader'),
    ComplexPrimitiveShader = require('../shaders/ComplexPrimitiveShader'),
    PrimitiveShader = require('../shaders/PrimitiveShader'),
    utils = require('../../../utils');

/**
 * @class
 * @memberof PIXI
 * @extends WebGLManager
 * @param renderer {WebGLRenderer} The renderer this manager works for.
 */
function ShaderManager(renderer)
{
    WebGLManager.call(this, renderer);

    /**
     * @member {number}
     */
    this.maxAttibs = 10;

    /**
     * @member {any[]}
     */
    this.attribState = [];

    /**
     * @member {any[]}
     */
    this.tempAttribState = [];

    for (var i = 0; i < this.maxAttibs; i++)
    {
        this.attribState[i] = false;
    }

    /**
     * @member {any[]}
     */
    this.stack = [];

    /**
     * @member {number}
     * @private
     */
    this._currentId = -1;

    /**
     * @member {Shader}
     * @private
     */
    this.currentShader = null;

//    this.initPlugins();
}

ShaderManager.prototype = Object.create(WebGLManager.prototype);
ShaderManager.prototype.constructor = ShaderManager;
utils.pluginTarget.mixin(ShaderManager);

module.exports = ShaderManager;

/**
 * Called when there is a WebGL context change.
 *
 */
ShaderManager.prototype.onContextChange = function ()
{
    this.initPlugins();

    // TODO - Why are these not plugins? We can't decouple primitives unless they are....
    this.defaultShader = new TextureShader(this);
    this.primitiveShader = new PrimitiveShader(this);
    this.complexPrimitiveShader = new ComplexPrimitiveShader(this);
};

/**
 * Takes the attributes given in parameters and uploads them.
 *
 * @param attribs {Array} attribs
 */
ShaderManager.prototype.setAttribs = function (attribs)
{
    // reset temp state
    var i;

    for (i = 0; i < this.tempAttribState.length; i++)
    {
        this.tempAttribState[i] = false;
    }

    // set the new attribs
    for (var a in attribs)
    {
        this.tempAttribState[attribs[a]] = true;
    }

    var gl = this.renderer.gl;

    for (i = 0; i < this.attribState.length; i++)
    {
        if (this.attribState[i] !== this.tempAttribState[i])
        {
            this.attribState[i] = this.tempAttribState[i];

            if (this.attribState[i])
            {
                gl.enableVertexAttribArray(i);
            }
            else
            {
                gl.disableVertexAttribArray(i);
            }
        }
    }
};

/**
 * Sets the current shader.
 *
 * @param shader {Shader} the shader to upload
 */
ShaderManager.prototype.setShader = function (shader)
{
    if (this._currentId === shader.uuid)
    {
        return false;
    }

    this._currentId = shader.uuid;

    this.currentShader = shader;

    this.renderer.gl.useProgram(shader.program);
    this.setAttribs(shader.attributes);

    return true;
};

/**
 * Destroys this object.
 *
 */
ShaderManager.prototype.destroy = function ()
{
    WebGLManager.prototype.destroy.call(this);

    this.destroyPlugins();

    this.attribState = null;

    this.tempAttribState = null;
};

},{"../../../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js","../shaders/ComplexPrimitiveShader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/ComplexPrimitiveShader.js","../shaders/PrimitiveShader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/PrimitiveShader.js","../shaders/TextureShader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/TextureShader.js","./WebGLManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/WebGLManager.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/StencilManager.js":[function(require,module,exports){
var WebGLManager = require('./WebGLManager'),
    utils = require('../../../utils');

/**
 * @class
 * @memberof PIXI
 * @param renderer {WebGLRenderer} The renderer this manager works for.
 */
function WebGLMaskManager(renderer)
{
    WebGLManager.call(this, renderer);
    this.stencilMaskStack = null;
}

WebGLMaskManager.prototype = Object.create(WebGLManager.prototype);
WebGLMaskManager.prototype.constructor = WebGLMaskManager;
module.exports = WebGLMaskManager;

/**
 * Changes the mask stack that is used by this manager
 * @param stencilMaskStack {StencilMaskStack} The mask stack 
 *
 */
WebGLMaskManager.prototype.setMaskStack = function ( stencilMaskStack )
{
    this.stencilMaskStack = stencilMaskStack;

    var gl = this.renderer.gl;

    if (stencilMaskStack.stencilStack.length === 0)
    {
        gl.disable(gl.STENCIL_TEST);
    }
    else
    {
        gl.enable(gl.STENCIL_TEST);
    }
};

/**
 * Applies the Mask and adds it to the current filter stack. @alvin
 * 
 * @param graphics {Graphics}
 * @param webGLData {any[]}
 */
WebGLMaskManager.prototype.pushStencil = function (graphics, webGLData)
{
    this.renderer.currentRenderTarget.attachStencilBuffer();

    var gl = this.renderer.gl,
        sms = this.stencilMaskStack;

    this.bindGraphics(graphics, webGLData, this.renderer);

    if (sms.stencilStack.length === 0)
    {
        gl.enable(gl.STENCIL_TEST);
        gl.clear(gl.STENCIL_BUFFER_BIT);
        sms.reverse = true;
        sms.count = 0;
    }

    sms.stencilStack.push(webGLData);

    var level = sms.count;

    gl.colorMask(false, false, false, false);

    gl.stencilFunc(gl.ALWAYS,0,0xFF);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);

    // draw the triangle strip!

    if (webGLData.mode === 1)
    {
        gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );

        if (sms.reverse)
        {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
        }

        // draw a quad to increment..
        gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );

        if (sms.reverse)
        {
            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
        }

        sms.reverse = !sms.reverse;
    }
    else
    {
        if (!sms.reverse)
        {
            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level, 0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
        }

        gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );

        if (!sms.reverse)
        {
            gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF);
        }
        else
        {
            gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
        }
    }

    gl.colorMask(true, true, true, true);
    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);

    sms.count++;
};

/**
 * TODO this does not belong here!
 *
 * @param graphics {Graphics}
 * @param webGLData {Array}
 */
WebGLMaskManager.prototype.bindGraphics = function (graphics, webGLData)
{
    //if (this._currentGraphics === graphics)return;
    this._currentGraphics = graphics;

    var gl = this.renderer.gl;

     // bind the graphics object..
    var shader;// = this.renderer.shaderManager.plugins.primitiveShader;

    if (webGLData.mode === 1)
    {
        shader = this.renderer.shaderManager.complexPrimitiveShader;

        this.renderer.shaderManager.setShader(shader);

        gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));

        gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));

        gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));

        gl.uniform3fv(shader.uniforms.color._location, webGLData.color);

        gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);

        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);


        // now do the rest..
        // set the index buffer!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
    }
    else
    {
        //this.renderer.shaderManager.activatePrimitiveShader();
        shader = this.renderer.shaderManager.primitiveShader;

        this.renderer.shaderManager.setShader( shader );

        gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, graphics.worldTransform.toArray(true));

        gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));

        gl.uniform3fv(shader.uniforms.tint._location, utils.hex2rgb(graphics.tint));

        gl.uniform1f(shader.uniforms.alpha._location, graphics.worldAlpha);

        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);

        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);
        gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false,4 * 6, 2 * 4);

        // set the index buffer!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);
    }
};

/**
 * TODO @alvin
 * @param graphics {Graphics}
 * @param webGLData {Array}
 */
WebGLMaskManager.prototype.popStencil = function (graphics, webGLData)
{
    var gl = this.renderer.gl,
        sms = this.stencilMaskStack;

    sms.stencilStack.pop();

    sms.count--;

    if (sms.stencilStack.length === 0)
    {
        // the stack is empty!
        gl.disable(gl.STENCIL_TEST);

    }
    else
    {

        var level = sms.count;

        this.bindGraphics(graphics, webGLData, this.renderer);

        gl.colorMask(false, false, false, false);

        if (webGLData.mode === 1)
        {
            sms.reverse = !sms.reverse;

            if (sms.reverse)
            {
                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
            }

            // draw a quad to increment..
            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 );

            gl.stencilFunc(gl.ALWAYS,0,0xFF);
            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);

            // draw the triangle strip!
            gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 );

            if (!sms.reverse)
            {
                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level, 0xFF);
            }

        }
        else
        {
          //  console.log("<<>>")
            if (!sms.reverse)
            {
                gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level+1, 0xFF);
                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);
            }

            gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 );

            if (!sms.reverse)
            {
                gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF);
            }
            else
            {
                gl.stencilFunc(gl.EQUAL,level, 0xFF);
            }
        }

        gl.colorMask(true, true, true, true);
        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);


    }
};

/**
 * Destroys the mask stack.
 *
 */
WebGLMaskManager.prototype.destroy = function ()
{
    WebGLManager.prototype.destroy.call(this);

    this.stencilMaskStack.stencilStack = null;
};

/**
 * Applies the Mask and adds it to the current filter stack.
 *
 * @param maskData {any[]} The mask data structure to use
 */
WebGLMaskManager.prototype.pushMask = function (maskData)
{


    this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

    if (maskData.dirty)
    {
        this.renderer.plugins.graphics.updateGraphics(maskData, this.renderer.gl);
    }

    if (!maskData._webGL[this.renderer.gl.id].data.length)
    {
        return;
    }

    this.pushStencil(maskData, maskData._webGL[this.renderer.gl.id].data[0], this.renderer);
};

/**
 * Removes the last filter from the filter stack and doesn't return it.
 *
 * @param maskData {any[]}
 */
WebGLMaskManager.prototype.popMask = function (maskData)
{
    this.renderer.setObjectRenderer(this.renderer.plugins.graphics);

    this.popStencil(maskData, maskData._webGL[this.renderer.gl.id].data[0], this.renderer);
};


},{"../../../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js","./WebGLManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/WebGLManager.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/WebGLManager.js":[function(require,module,exports){
/**
 * @class
 * @memberof PIXI
 * @param renderer {WebGLRenderer} The renderer this manager works for.
 */
function WebGLManager(renderer)
{
    /**
     * The renderer this manager works for.
     *
     * @member {WebGLRenderer}
     */
    this.renderer = renderer;

    this.renderer.on('context', this.onContextChange, this);
}

WebGLManager.prototype.constructor = WebGLManager;
module.exports = WebGLManager;

/**
 * Generic method called when there is a WebGL context change.
 *
 */
WebGLManager.prototype.onContextChange = function ()
{
	// do some codes init!
};

/**
 * Generic destroy methods to be overridden by the subclass
 *
 */
WebGLManager.prototype.destroy = function ()
{
    this.renderer.off('context', this.onContextChange);

    this.renderer = null;
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/ComplexPrimitiveShader.js":[function(require,module,exports){
var Shader = require('./Shader');

/**
 * @class
 * @memberof PIXI
 * @extends Shader
 * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.
 */
function ComplexPrimitiveShader(shaderManager)
{
    Shader.call(this,
        shaderManager,
        // vertex shader
        [
            'attribute vec2 aVertexPosition;',

            'uniform mat3 translationMatrix;',
            'uniform mat3 projectionMatrix;',

            'uniform vec3 tint;',
            'uniform float alpha;',
            'uniform vec3 color;',

            'varying vec4 vColor;',

            'void main(void){',
            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
            '   vColor = vec4(color * alpha * tint, alpha);',//" * vec4(tint * alpha, alpha);',
            '}'
        ].join('\n'),
        // fragment shader
        [
            'precision mediump float;',

            'varying vec4 vColor;',

            'void main(void){',
            '   gl_FragColor = vColor;',
            '}'
        ].join('\n'),
        // custom uniforms
        {
            tint:   { type: '3f', value: [0, 0, 0] },
            alpha:  { type: '1f', value: 0 },
            color:  { type: '3f', value: [0,0,0] },
            translationMatrix: { type: 'mat3', value: new Float32Array(9) },
            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }
        },
        // attributes
        {
            aVertexPosition:0
        }
    );
}

ComplexPrimitiveShader.prototype = Object.create(Shader.prototype);
ComplexPrimitiveShader.prototype.constructor = ComplexPrimitiveShader;
module.exports = ComplexPrimitiveShader;

},{"./Shader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/Shader.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/PrimitiveShader.js":[function(require,module,exports){
var Shader = require('./Shader');

/**
 * @class
 * @memberof PIXI
 * @extends Shader
 * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.
 */
function PrimitiveShader(shaderManager)
{
    Shader.call(this,
        shaderManager,
        // vertex shader
        [
            'attribute vec2 aVertexPosition;',
            'attribute vec4 aColor;',

            'uniform mat3 translationMatrix;',
            'uniform mat3 projectionMatrix;',

            'uniform float alpha;',
            'uniform float flipY;',
            'uniform vec3 tint;',

            'varying vec4 vColor;',

            'void main(void){',
            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
            '   vColor = aColor * vec4(tint * alpha, alpha);',
            '}'
        ].join('\n'),
        // fragment shader
        [
            'precision mediump float;',

            'varying vec4 vColor;',

            'void main(void){',
            '   gl_FragColor = vColor;',
            '}'
        ].join('\n'),
        // custom uniforms
        {
            tint:   { type: '3f', value: [0, 0, 0] },
            alpha:  { type: '1f', value: 0 },
            translationMatrix: { type: 'mat3', value: new Float32Array(9) },
            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }
        },
        // custom attributes
        {
            aVertexPosition:0,
            aColor:0
        }
    );
}

PrimitiveShader.prototype = Object.create(Shader.prototype);
PrimitiveShader.prototype.constructor = PrimitiveShader;
module.exports = PrimitiveShader;

},{"./Shader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/Shader.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/Shader.js":[function(require,module,exports){
/*global console */
var utils = require('../../../utils');

/**
 * @class
 * @memberof PIXI
 * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.
 * @param [vertexSrc] {string} The source of the vertex shader.
 * @param [fragmentSrc] {string} The source of the fragment shader.
 * @param [uniforms] {object} Uniforms for this shader.
 * @param [attributes] {object} Attributes for this shader.
 */
function Shader(shaderManager, vertexSrc, fragmentSrc, uniforms, attributes)
{
    if (!vertexSrc || !fragmentSrc)
    {
         throw new Error('Pixi.js Error. Shader requires vertexSrc and fragmentSrc');
    }

    /**
     * A unique id
     * @member {number}
     * @readonly
     */
    this.uuid = utils.uuid();

    /**
     * The current WebGL drawing context
     * @member {WebGLRenderingContext}
     * @readonly
     */
    this.gl = shaderManager.renderer.gl;

    //TODO maybe we should pass renderer rather than shader manger?? food for thought..
    this.shaderManager = shaderManager;

    /**
     * The WebGL program.
     *
     * @member {WebGLProgram}
     * @readonly
     */
    this.program = null;

    /**
     * The uniforms as an object
     * @member {object}
     * @private
     */
    this.uniforms = uniforms || {};

    /**
     * The attributes as an object
     * @member {object}
     * @private
     */
    this.attributes = attributes || {};

    /**
     * Internal texture counter
     * @member {number}
     * @private
     */
    this.textureCount = 1;

    /**
     * The vertex shader as an array of strings
     *
     * @member {string}
     */
    this.vertexSrc = vertexSrc;

    /**
     * The fragment shader as an array of strings
     *
     * @member {string}
     */
    this.fragmentSrc = fragmentSrc;

    this.init();
}

Shader.prototype.constructor = Shader;
module.exports = Shader;

/*
 * Creates the shader and uses it
 *
 */
Shader.prototype.init = function ()
{
    this.compile();

    this.gl.useProgram(this.program);

    this.cacheUniformLocations(Object.keys(this.uniforms));
    this.cacheAttributeLocations(Object.keys(this.attributes));
};

/*
 * Caches the locations of the uniform for reuse
 * @param keys {string} the uniforms to cache
 */
Shader.prototype.cacheUniformLocations = function (keys)
{
    for (var i = 0; i < keys.length; ++i)
    {
        this.uniforms[keys[i]]._location = this.gl.getUniformLocation(this.program, keys[i]);
    }
};

/*
 * Caches the locations of the attribute for reuse
 * @param keys {string} the attributes to cache
 */
Shader.prototype.cacheAttributeLocations = function (keys)
{
    for (var i = 0; i < keys.length; ++i)
    {
        this.attributes[keys[i]] = this.gl.getAttribLocation(this.program, keys[i]);
    }

    // TODO: Check if this is needed anymore...

    // Begin worst hack eva //

    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?
    // maybe its something to do with the current state of the gl context.
    // I'm convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel
    // If theres any webGL people that know why could happen please help :)
    // if (this.attributes.aColor === -1){
    //     this.attributes.aColor = 2;
    // }

    // End worst hack eva //
};

/*
 * Attaches the shaders and creates the program
 * @return {WebGLProgram}
 */
Shader.prototype.compile = function ()
{
    var gl = this.gl;

    var glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexSrc);
    var glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentSrc);

    var program = gl.createProgram();

    gl.attachShader(program, glVertShader);
    gl.attachShader(program, glFragShader);
    gl.linkProgram(program);

    // if linking fails, then log and cleanup
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Pixi.js Error: Could not initialize shader.');
        console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
        console.error('gl.getError()', gl.getError());

        // if there is a program info log, log it
        if (gl.getProgramInfoLog(program) !== '')
        {
            console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
        }

        gl.deleteProgram(program);
        program = null;
    }

    // clean up some shaders
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);

    return (this.program = program);
};

/*
Shader.prototype.buildSync = function ()
{
   // var str = ""

   // str =  "Shader.prototype.syncUniforms = function()";
   // str += "{\n";

    for (var key in this.uniforms)
    {
        var uniform = this.uniforms[key];

        Object.defineProperty(this, key, {

            get: function ()
            {
                return uniform.value
            },
            set: function (value)
            {
                this.setUniform(uniform, value);
            }
        });

        console.log( makePropSetter( key, " bloop", uniform.type )  )
  //      Object.def
        //    location = uniform._location,
          //  value = uniform.value,
            //i, il;

    //    str += "gl.uniform1i(this.uniforms."+ key +"._location, this.uniforms." + key + ".value );\n"

    }

}*/

/**
* Adds a new uniform
*
* @param uniform {Object} the new uniform to attach
*/
Shader.prototype.syncUniform = function (uniform)
{
    var location = uniform._location,
        value = uniform.value,
        gl = this.gl,
        i, il;

    switch (uniform.type)
    {
        // single int value
        case 'i':
        case '1i':
            gl.uniform1i(location, value);
            break;

        // single float value
        case 'f':
        case '1f':
            gl.uniform1f(location, value);
            break;

        // Float32Array(2) or JS Arrray
        case '2f':
            gl.uniform2f(location, value[0], value[1]);
            break;

        // Float32Array(3) or JS Arrray
        case '3f':
            gl.uniform3f(location, value[0], value[1], value[2]);
            break;

        // Float32Array(4) or JS Arrray
        case '4f':
            gl.uniform4f(location, value[0], value[1], value[2], value[3]);
            break;

        // a 2D Point object
        case 'v2':
            gl.uniform2f(location, value.x, value.y);
            break;

        // a 3D Point object
        case 'v3':
            gl.uniform3f(location, value.x, value.y, value.z);
            break;

        // a 4D Point object
        case 'v4':
            gl.uniform4f(location, value.x, value.y, value.z, value.w);
            break;

        // Int32Array or JS Array
        case '1iv':
            gl.uniform1iv(location, value);
            break;

        // Int32Array or JS Array
        case '2iv':
            gl.uniform2iv(location, value);
            break;

        // Int32Array or JS Array
        case '3iv':
            gl.uniform3iv(location, value);
            break;

        // Int32Array or JS Array
        case '4iv':
            gl.uniform4iv(location, value);
            break;

        // Float32Array or JS Array
        case '1fv':
            gl.uniform1fv(location, value);
            break;

        // Float32Array or JS Array
        case '2fv':
            gl.uniform2fv(location, value);
            break;

        // Float32Array or JS Array
        case '3fv':
            gl.uniform3fv(location, value);
            break;

        // Float32Array or JS Array
        case '4fv':
            gl.uniform4fv(location, value);
            break;

        // Float32Array or JS Array
        case 'm2':
        case 'mat2':
        case 'Matrix2fv':
            gl.uniformMatrix2fv(location, uniform.transpose, value);
            break;

        // Float32Array or JS Array
        case 'm3':
        case 'mat3':
        case 'Matrix3fv':

            gl.uniformMatrix3fv(location, uniform.transpose, value);
            break;

        // Float32Array or JS Array
        case 'm4':
        case 'mat4':
        case 'Matrix4fv':
            gl.uniformMatrix4fv(location, uniform.transpose, value);
            break;

        // a Color Value
        case 'c':
            if (typeof value === 'number')
            {
                value = utils.hex2rgb(value);
            }

            gl.uniform3f(location, value[0], value[1], value[2]);
            break;

        // flat array of integers (JS or typed array)
        case 'iv1':
            gl.uniform1iv(location, value);
            break;

        // flat array of integers with 3 x N size (JS or typed array)
        case 'iv':
            gl.uniform3iv(location, value);
            break;

        // flat array of floats (JS or typed array)
        case 'fv1':
            gl.uniform1fv(location, value);
            break;

        // flat array of floats with 3 x N size (JS or typed array)
        case 'fv':
            gl.uniform3fv(location, value);
            break;

        // array of 2D Point objects
        case 'v2v':
            if (!uniform._array)
            {
                uniform._array = new Float32Array(2 * value.length);
            }

            for (i = 0, il = value.length; i < il; ++i)
            {
                uniform._array[i * 2]       = value[i].x;
                uniform._array[i * 2 + 1]   = value[i].y;
            }

            gl.uniform2fv(location, uniform._array);
            break;

        // array of 3D Point objects
        case 'v3v':
            if (!uniform._array)
            {
                uniform._array = new Float32Array(3 * value.length);
            }

            for (i = 0, il = value.length; i < il; ++i)
            {
                uniform._array[i * 3]       = value[i].x;
                uniform._array[i * 3 + 1]   = value[i].y;
                uniform._array[i * 3 + 2]   = value[i].z;

            }

            gl.uniform3fv(location, uniform._array);
            break;

        // array of 4D Point objects
        case 'v4v':
            if (!uniform._array)
            {
                uniform._array = new Float32Array(4 * value.length);
            }

            for (i = 0, il = value.length; i < il; ++i)
            {
                uniform._array[i * 4]       = value[i].x;
                uniform._array[i * 4 + 1]   = value[i].y;
                uniform._array[i * 4 + 2]   = value[i].z;
                uniform._array[i * 4 + 3]   = value[i].w;

            }

            gl.uniform4fv(location, uniform._array);
            break;

        // PIXI.Texture
        case 't':
        case 'sampler2D':

            if (!uniform.value || !uniform.value.baseTexture.hasLoaded)
            {
                break;
            }

            // activate this texture
            gl.activeTexture(gl['TEXTURE' + this.textureCount]);

            var texture = uniform.value.baseTexture._glTextures[gl.id];

            if (!texture)
            {
                this.initSampler2D(uniform);
            }

            // bind the texture
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // set uniform to texture index
            gl.uniform1i(uniform._location, this.textureCount);

            // increment next texture id
            this.textureCount++;

            break;

        default:
            console.warn('Pixi.js Shader Warning: Unknown uniform type: ' + uniform.type);
    }
};

/*
 * Updates the shader uniform values.
 */
Shader.prototype.syncUniforms = function ()
{
    this.textureCount = 1;

    for (var key in this.uniforms)
    {
        this.syncUniform(this.uniforms[key]);
    }
};


/**
 * Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)
 *
 */
Shader.prototype.initSampler2D = function (uniform)
{
    var gl = this.gl;

    var texture = uniform.value.baseTexture;

    if(!texture.hasLoaded)
    {
        return;
    }



    if (uniform.textureData)
    {

        //TODO move this...
        var data = uniform.textureData;

        texture._glTextures[gl.id] = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);

        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);
        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);
        // GLTextureLinear = mag/min linear, wrap clamp
        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat
        // GLTextureNearest = mag/min nearest, wrap clamp
        // AudioTexture = whatever + luminance + width 512, height 2, border 0
        // KeyTexture = whatever + luminance + width 256, height 2, border 0

        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST
        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT

        gl.texImage2D(gl.TEXTURE_2D, 0, data.luminance ? gl.LUMINANCE : gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, data.magFilter ? data.magFilter : gl.LINEAR );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE );

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, data.wrapS ? data.wrapS : gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, data.wrapT ? data.wrapT : gl.CLAMP_TO_EDGE);
    }
    else
    {
        this.shaderManager.renderer.updateTexture(texture);
    }
};

/**
 * Destroys the shader.
 *
 */
Shader.prototype.destroy = function ()
{
    this.gl.deleteProgram(this.program);

    this.gl = null;
    this.uniforms = null;
    this.attributes = null;

    this.vertexSrc = null;
    this.fragmentSrc = null;
};

Shader.prototype._glCompile = function (type, src)
{
    var shader = this.gl.createShader(type);

    this.gl.shaderSource(shader, src);
    this.gl.compileShader(shader);

    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS))
    {
        console.log(this.gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
};

},{"../../../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/TextureShader.js":[function(require,module,exports){
var Shader = require('./Shader');

/**
 * @class
 * @memberof PIXI
 * @extends Shader
 * @param shaderManager {ShaderManager} The webgl shader manager this shader works for.
 * @param [vertexSrc] {string} The source of the vertex shader.
 * @param [fragmentSrc] {string} The source of the fragment shader.
 * @param [customUniforms] {object} Custom uniforms to use to augment the built-in ones.
 * @param [fragmentSrc] {string} The source of the fragment shader.
 */
function TextureShader(shaderManager, vertexSrc, fragmentSrc, customUniforms, customAttributes)
{
    var uniforms = {

        uSampler:           { type: 'sampler2D', value: 0 },
        projectionMatrix:   { type: 'mat3', value: new Float32Array(1, 0, 0,
                                                                    0, 1, 0,
                                                                    0, 0, 1) }
    };

    if (customUniforms)
    {
        for (var u in customUniforms)
        {
            uniforms[u] = customUniforms[u];
        }
    }


    var attributes = {
        aVertexPosition:    0,
        aTextureCoord:      0,
        aColor:             0
    };

    if (customAttributes)
    {
        for (var a in customAttributes)
        {
            attributes[a] = customAttributes[a];
        }
    }

    /**
     * The vertex shader.
     * @member {Array}
     */
    vertexSrc = vertexSrc || TextureShader.defaultVertexSrc;

    /**
     * The fragment shader.
     * @member {Array}
     */
    fragmentSrc = fragmentSrc || TextureShader.defaultFragmentSrc;

    Shader.call(this, shaderManager, vertexSrc, fragmentSrc, uniforms, attributes);
}

// constructor
TextureShader.prototype = Object.create(Shader.prototype);
TextureShader.prototype.constructor = TextureShader;
module.exports = TextureShader;

TextureShader.defaultVertexSrc = [
    'precision lowp float;',
    'attribute vec2 aVertexPosition;',
    'attribute vec2 aTextureCoord;',
    'attribute vec4 aColor;',

    'uniform mat3 projectionMatrix;',

    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',

    'void main(void){',
    '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
    '   vTextureCoord = aTextureCoord;',
    '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',
    '}'
].join('\n');

TextureShader.defaultFragmentSrc = [
    'precision lowp float;',

    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',

    'uniform sampler2D uSampler;',

    'void main(void){',
    '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',
    '}'
].join('\n');

},{"./Shader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/shaders/Shader.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/ObjectRenderer.js":[function(require,module,exports){
var WebGLManager = require('../managers/WebGLManager');

/**
 * Base for a common object renderer that can be used as a system renderer plugin.
 *
 * @class
 * @extends WebGLManager
 * @memberof PIXI
 * @param renderer {WebGLRenderer} The renderer this object renderer works for.
 */
function ObjectRenderer(renderer)
{
    WebGLManager.call(this, renderer);
}


ObjectRenderer.prototype = Object.create(WebGLManager.prototype);
ObjectRenderer.prototype.constructor = ObjectRenderer;
module.exports = ObjectRenderer;

/**
 * Starts the renderer and sets the shader
 *
 */
ObjectRenderer.prototype.start = function ()
{
    // set the shader..
};

/**
 * Stops the renderer
 *
 */
ObjectRenderer.prototype.stop = function ()
{
    this.flush();
};

/**
 * flushes
 *
 */
ObjectRenderer.prototype.flush = function ()
{
    // flush!
};

/**
 * Renders an object
 *
 */
ObjectRenderer.prototype.render = function (object) // jshint unused:false
{
    // render the object
};

},{"../managers/WebGLManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/WebGLManager.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/Quad.js":[function(require,module,exports){
/**
 * Helper class to create a quad
 * @class
 * @memberof PIXI
 * @param gl {WebGLRenderingContext} The gl context for this quad to use.
 */
function Quad(gl)
{
    /*
     * the current WebGL drawing context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

//    this.textures = new TextureUvs();

    /**
     * An array of vertices
     *
     * @member {Float32Array}
     */
    this.vertices = new Float32Array([
        0,0,
        200,0,
        200,200,
        0,200
    ]);

    /**
     * The Uvs of the quad
     *
     * @member {Float32Array}
     */
    this.uvs = new Float32Array([
        0,0,
        1,0,
        1,1,
        0,1
    ]);

//    var white = (0xFFFFFF >> 16) + (0xFFFFFF & 0xff00) + ((0xFFFFFF & 0xff) << 16) + (1 * 255 << 24);
    //TODO convert this to a 32 unsigned int array
    /**
     * The color components of the triangles
     *
     * @member {Float32Array}
     */
    this.colors = new Float32Array([
        1,1,1,1,
        1,1,1,1,
        1,1,1,1,
        1,1,1,1
    ]);

    /*
     * @member {Uint16Array} An array containing the indices of the vertices
     */
    this.indices = new Uint16Array([
        0, 1, 2, 0, 3, 2
    ]);

    /*
     * @member {WebGLBuffer} The vertex buffer
     */
    this.vertexBuffer = gl.createBuffer();

    /*
     * @member {WebGLBuffer} The index buffer
     */
    this.indexBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, (8 + 8 + 16) * 4, gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    this.upload();
}

Quad.prototype.constructor = Quad;

/**
 * Maps two Rectangle to the quad
 * @param rect {Rectangle} the first rectangle
 * @param rect2 {Rectangle} the second rectangle
 */
Quad.prototype.map = function(rect, rect2)
{
    var x = 0; //rect2.x / rect.width;
    var y = 0; //rect2.y / rect.height;

    this.uvs[0] = x;
    this.uvs[1] = y;

    this.uvs[2] = x + rect2.width / rect.width;
    this.uvs[3] = y;

    this.uvs[4] = x + rect2.width / rect.width;
    this.uvs[5] = y + rect2.height / rect.height;

    this.uvs[6] = x;
    this.uvs[7] = y + rect2.height / rect.height;

    /// -----
    x = rect2.x;
    y = rect2.y;

    this.vertices[0] = x;
    this.vertices[1] = y;

    this.vertices[2] = x + rect2.width;
    this.vertices[3] = y;

    this.vertices[4] = x + rect2.width;
    this.vertices[5] = y + rect2.height;

    this.vertices[6] = x;
    this.vertices[7] = y + rect2.height;

    this.upload();
};

/**
 * Binds the buffer and uploads the data
 */
Quad.prototype.upload = function()
{
    var gl = this.gl;

    // TODO could probably be pushed into one upload!
    gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);

    gl.bufferSubData(gl.ARRAY_BUFFER, 8 * 4, this.uvs);

    gl.bufferSubData(gl.ARRAY_BUFFER, (8 + 8) * 4, this.colors);
};

module.exports = Quad;



},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/RenderTarget.js":[function(require,module,exports){
var math = require('../../../math'),
    utils = require('../../../utils'),
    CONST = require('../../../const'),
    //StencilManager = require('../managers/StencilManager'),
    StencilMaskStack = require('./StencilMaskStack');

/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 */

/**
 * @class
 * @memberof PIXI
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 * @param width {number} the horizontal range of the filter
 * @param height {number} the vertical range of the filter
 * @param scaleMode {number} See {{#crossLink "PIXI/scaleModes:property"}}PIXI.scaleModes{{/crossLink}} for possible values
 * @param resolution {number} the current resolution
 * @param root {boolean} Whether this object is the root element or not
 */
var RenderTarget = function(gl, width, height, scaleMode, resolution, root)
{
    //TODO Resolution could go here ( eg low res blurs )

    /**
     * The current WebGL drawing context
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    // next time to create a frame buffer and texture

    /**
     * A frame buffer
     * @member {WebGLFrameBuffer}
     */
    this.frameBuffer = null;

    /**
     * @member {Texture}
     */
    this.texture = null;

    /**
     * The size of the object as a rectangle
     * @member {Rectangle}
     */
    this.size = new math.Rectangle(0, 0, 1, 1);

    /**
     * The current resolution
     * @member {number}
     */
    this.resolution = resolution || CONST.RESOLUTION;

    /**
     * The projection matrix
     * @member {Matrix}
     */
    this.projectionMatrix = new math.Matrix();

    /**
     * The object's transform
     * @member {Matrix}
     */
    this.transform = null;

    /**
     *
     * @member {Rectangle}
     */
    this.frame = null;

    /**
     * The stencil buffer stores masking data for the render target
     * @member {WebGLRenderBuffer}
     */
    this.stencilBuffer = null;

    /**
     * The data structure for the stencil masks
     * @member {StencilMaskStack}
     */
    this.stencilMaskStack = new StencilMaskStack();

    /**
     * Stores filter data for the render target
     * @member {Array}
     */
    this.filterStack = [
        {
            renderTarget:this,
            filter:[],
            bounds:this.size
        }
    ];


    /**
     * The scale mode
     * @member {number}
     * @default CONST.SCALE_MODES.DEFAULT
     */
    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;

    /**
     * Whether this object is the root element or not
     * @member {boolean}
     */
    this.root = root;

    if (!this.root)
    {
       // this.flipY = true;
        this.frameBuffer = gl.createFramebuffer();

        /*
            A frame buffer needs a target to render to..
            create a texture and bind it attach it to the framebuffer..
         */

        this.texture = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D,  this.texture);

        // set the scale properties of the texture..
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === CONST.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);

        // check to see if the texture is a power of two!
        var isPowerOfTwo = utils.isPowerOfTwo(width, height);

        //TODO for 99% of use cases if a texture is power of two we should tile the texture...
         if (!isPowerOfTwo)
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
        else
        {

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    }


    this.resize(width, height);
};

RenderTarget.prototype.constructor = RenderTarget;
module.exports = RenderTarget;

/**
* Clears the filter texture.
*
*/
RenderTarget.prototype.clear = function(bind)
{
    var gl = this.gl;
    if(bind)
    {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
    }

    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/**
* Binds the stencil buffer.
*
*/
RenderTarget.prototype.attachStencilBuffer = function()
{

    if ( this.stencilBuffer )
    {
        return;
    }

    /*
        The stencil buffer is used for masking in pixi
        lets create one and then add attach it to the framebuffer..
     */
    if (!this.root)
    {
        var gl = this.gl;

        this.stencilBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencilBuffer);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencilBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  this.size.width * this.resolution  , this.size.height * this.resolution );
    }
};

/**
* Binds the buffers and initialises the viewport.
*
*/
RenderTarget.prototype.activate = function()
{
    //TOOD refactor usage of frame..
    var gl = this.gl;

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);

    var projectionFrame = this.frame || this.size;

    // TODO add a dirty flag to this of a setter for the frame?
    this.calculateProjection( projectionFrame );

    if(this.transform)
    {
        this.projectionMatrix.append(this.transform);
    }

    gl.viewport(0,0, projectionFrame.width * this.resolution, projectionFrame.height * this.resolution);
};

/**
* Updates the projection matrix based on a projection frame (which is a rectangle)
*
*/
RenderTarget.prototype.calculateProjection = function( projectionFrame )
{
    var pm = this.projectionMatrix;

    pm.identity();

    if (!this.root)
    {
        pm.a = 1 / projectionFrame.width*2;
        pm.d = 1 / projectionFrame.height*2;

        pm.tx = -1 - projectionFrame.x * pm.a;
        pm.ty = -1 - projectionFrame.y * pm.d;
    }
    else
    {
        pm.a = 1 / projectionFrame.width*2;
        pm.d = -1 / projectionFrame.height*2;

        pm.tx = -1 - projectionFrame.x * pm.a;
        pm.ty = 1 - projectionFrame.y * pm.d;
    }
};


/**
 * Resizes the texture to the specified width and height
 *
 * @param width {Number} the new width of the texture
 * @param height {Number} the new height of the texture
 */
RenderTarget.prototype.resize = function(width, height)
{
    width = width | 0;
    height = height | 0;

    if (this.size.width === width && this.size.height === height) {
        return;
    }

    this.size.width = width;
    this.size.height = height;

    if (!this.root)
    {
        var gl = this.gl;

        gl.bindTexture(gl.TEXTURE_2D,  this.texture);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width * this.resolution, height * this.resolution , 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        if (this.stencilBuffer )
        {
            // update the stencil buffer width and height
            gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencilBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  width * this.resolution, height * this.resolution );
        }
    }

    var projectionFrame = this.frame || this.size;

    this.calculateProjection( projectionFrame );
};

/**
 * Destroys the render target.
 *
 */
RenderTarget.prototype.destroy = function()
{
    var gl = this.gl;
    gl.deleteFramebuffer( this.frameBuffer );
    gl.deleteTexture( this.texture );

    this.frameBuffer = null;
    this.texture = null;
};

},{"../../../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../../../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../../../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js","./StencilMaskStack":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/StencilMaskStack.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/StencilMaskStack.js":[function(require,module,exports){
/**
 * Generic Mask Stack data structure
 * @class
 * @memberof PIXI
 * @param renderer {WebGLRenderer} The renderer this manager works for.
 */
function StencilMaskStack()
{
	/**
     * The actual stack
     *
     * @member {Array}
     */
    this.stencilStack = [];

    /**
     * TODO @alvin
     *
     * @member {boolean}
     */
    this.reverse = true;

    /**
     * Internal count
     *
     * @member {number}
     */
    this.count = 0;
}

StencilMaskStack.prototype.constructor = StencilMaskStack;
module.exports = StencilMaskStack;

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/sprites/Sprite.js":[function(require,module,exports){
var math = require('../math'),
    Texture = require('../textures/Texture'),
    Container = require('../display/Container'),
    CanvasTinter = require('../renderers/canvas/utils/CanvasTinter'),
    utils = require('../utils'),
    CONST = require('../const'),
    tempPoint = new math.Point();

/**
 * The Sprite object is the base for all textured objects that are rendered to the screen
 *
 * A sprite can be created directly from an image like this:
 *
 * ```js
 * var sprite = new PIXI.Sprite.fromImage('assets/image.png');
 * ```
 *
 * @class
 * @extends Container
 * @memberof PIXI
 * @param texture {Texture} The texture for this sprite
 */
function Sprite(texture)
{
    Container.call(this);

    /**
     * The anchor sets the origin point of the texture.
     * The default is 0,0 this means the texture's origin is the top left
     * Setting the anchor to 0.5,0.5 means the texture's origin is centered
     * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner
     *
     * @member {Point}
     */
    this.anchor = new math.Point();

    /**
     * The texture that the sprite is using
     *
     * @member {Texture}
     * @private
     */
    this._texture = null;

    /**
     * The width of the sprite (this is initially set by the texture)
     *
     * @member {number}
     * @private
     */
    this._width = 0;

    /**
     * The height of the sprite (this is initially set by the texture)
     *
     * @member {number}
     * @private
     */
    this._height = 0;

    /**
     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default [0xFFFFFF]
     */
    this.tint = 0xFFFFFF;

    /**
     * The blend mode to be applied to the sprite. Apply a value of blendModes.NORMAL to reset the blend mode.
     *
     * @member {number}
     * @default CONST.BLEND_MODES.NORMAL;
     */
    this.blendMode = CONST.BLEND_MODES.NORMAL;

    /**
     * The shader that will be used to render the sprite. Set to null to remove a current shader.
     *
     * @member {AbstractFilter}
     */
    this.shader = null;

    /**
     * An internal cached value of the tint.
     *
     * @member {number}
     * @default [0xFFFFFF]
     */
    this.cachedTint = 0xFFFFFF;

    // call texture setter
    this.texture = texture || Texture.EMPTY;
}

// constructor
Sprite.prototype = Object.create(Container.prototype);
Sprite.prototype.constructor = Sprite;
module.exports = Sprite;

Object.defineProperties(Sprite.prototype, {
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member
     * @memberof Sprite#
     */
    width: {
        get: function ()
        {
            return this.scale.x * this.texture._frame.width;
        },
        set: function (value)
        {
            this.scale.x = value / this.texture._frame.width;
            this._width = value;
        }
    },

    /**
     * The height of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member
     * @memberof Sprite#
     */
    height: {
        get: function ()
        {
            return  this.scale.y * this.texture._frame.height;
        },
        set: function (value)
        {
            this.scale.y = value / this.texture._frame.height;
            this._height = value;
        }
    },

    /**
     * The height of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member
     * @memberof Sprite#
     */
    texture: {
        get: function ()
        {
            return  this._texture;
        },
        set: function (value)
        {
            if (this._texture === value)
            {
                return;
            }

            this._texture = value;
            this.cachedTint = 0xFFFFFF;

            if (value)
            {
                // wait for the texture to load
                if (value.baseTexture.hasLoaded)
                {
                    this._onTextureUpdate();
                }
                else
                {
                    value.once('update', this._onTextureUpdate, this);
                }
            }
        }
    }
});

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @private
 */
Sprite.prototype._onTextureUpdate = function ()
{
    // so if _width is 0 then width was not set..
    if (this._width)
    {
        this.scale.x = this._width / this.texture.frame.width;
    }

    if (this._height)
    {
        this.scale.y = this._height / this.texture.frame.height;
    }
};

/**
*
* Renders the object using the WebGL renderer
*
* @param renderer {WebGLRenderer}
* @private
*/
Sprite.prototype._renderWebGL = function (renderer)
{
    renderer.setObjectRenderer(renderer.plugins.sprite);
    renderer.plugins.sprite.render(this);
};

/**
 * Returns the bounds of the Sprite as a rectangle. The bounds calculation takes the worldTransform into account.
 *
 * @param matrix {Matrix} the transformation matrix of the sprite
 * @return {Rectangle} the framing rectangle
 */
Sprite.prototype.getBounds = function (matrix)
{
    if(!this._currentBounds)
    {

        var width = this._texture._frame.width;
        var height = this._texture._frame.height;

        var w0 = width * (1-this.anchor.x);
        var w1 = width * -this.anchor.x;

        var h0 = height * (1-this.anchor.y);
        var h1 = height * -this.anchor.y;

        var worldTransform = matrix || this.worldTransform ;

        var a = worldTransform.a;
        var b = worldTransform.b;
        var c = worldTransform.c;
        var d = worldTransform.d;
        var tx = worldTransform.tx;
        var ty = worldTransform.ty;

        var minX,
            maxX,
            minY,
            maxY;


        if (b === 0 && c === 0)
        {
            // scale may be negative!
            if (a < 0)
            {
                a *= -1;
            }

            if (d < 0)
            {
                d *= -1;
            }

            // this means there is no rotation going on right? RIGHT?
            // if thats the case then we can avoid checking the bound values! yay
            minX = a * w1 + tx;
            maxX = a * w0 + tx;
            minY = d * h1 + ty;
            maxY = d * h0 + ty;
        }
        else
        {
            var x1 = a * w1 + c * h1 + tx;
            var y1 = d * h1 + b * w1 + ty;

            var x2 = a * w0 + c * h1 + tx;
            var y2 = d * h1 + b * w0 + ty;

            var x3 = a * w0 + c * h0 + tx;
            var y3 = d * h0 + b * w0 + ty;

            var x4 =  a * w1 + c * h0 + tx;
            var y4 =  d * h0 + b * w1 + ty;

            minX = x1;
            minX = x2 < minX ? x2 : minX;
            minX = x3 < minX ? x3 : minX;
            minX = x4 < minX ? x4 : minX;

            minY = y1;
            minY = y2 < minY ? y2 : minY;
            minY = y3 < minY ? y3 : minY;
            minY = y4 < minY ? y4 : minY;

            maxX = x1;
            maxX = x2 > maxX ? x2 : maxX;
            maxX = x3 > maxX ? x3 : maxX;
            maxX = x4 > maxX ? x4 : maxX;

            maxY = y1;
            maxY = y2 > maxY ? y2 : maxY;
            maxY = y3 > maxY ? y3 : maxY;
            maxY = y4 > maxY ? y4 : maxY;
        }

        // check for children
        if(this.children.length)
        {
            var childBounds = this.containerGetBounds();

            w0 = childBounds.x;
            w1 = childBounds.x + childBounds.width;
            h0 = childBounds.y;
            h1 = childBounds.y + childBounds.height;

            minX = (minX < w0) ? minX : w0;
            minY = (minY < h0) ? minY : h0;

            maxX = (maxX > w1) ? maxX : w1;
            maxY = (maxY > h1) ? maxY : h1;
        }

        var bounds = this._bounds;

        bounds.x = minX;
        bounds.width = maxX - minX;

        bounds.y = minY;
        bounds.height = maxY - minY;

        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
        this._currentBounds = bounds;
    }

    return this._currentBounds;
};

Sprite.prototype.getLocalBounds = function ()
{
    this._bounds.x = -this._texture._frame.width * this.anchor.x;
    this._bounds.y = -this._texture._frame.height * this.anchor.y;
    this._bounds.width = this._texture._frame.width;
    this._bounds.height = this._texture._frame.height;
    return this._bounds;
};

/**
* Tests if a point is inside this sprite
*
* @param point {Point} the point to test
* @return {boolean} the result of the test
*/
Sprite.prototype.containsPoint = function( point )
{
    this.worldTransform.applyInverse(point,  tempPoint);

    var width = this._texture._frame.width;
    var height = this._texture._frame.height;
    var x1 = -width * this.anchor.x;
    var y1;

    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )
    {
        y1 = -height * this.anchor.y;

        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )
        {
            return true;
        }
    }

    return false;
};

/**
* Renders the object using the Canvas renderer
*
* @param renderer {CanvasRenderer} The renderer
* @private
*/
Sprite.prototype._renderCanvas = function (renderer)
{
    if (this.texture.crop.width <= 0 || this.texture.crop.height <= 0)
    {
        return;
    }

    if (this.blendMode !== renderer.currentBlendMode)
    {
        renderer.currentBlendMode = this.blendMode;
        renderer.context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];
    }

    //  Ignore null sources
    if (this.texture.valid)
    {
        var texture = this._texture,
            wt = this.worldTransform,
            dx,
            dy,
            width,
            height;

        var resolution = texture.baseTexture.resolution / renderer.resolution;

        renderer.context.globalAlpha = this.worldAlpha;

        // If smoothingEnabled is supported and we need to change the smoothing property for this texture
        if (renderer.smoothProperty && renderer.currentScaleMode !== texture.baseTexture.scaleMode)
        {
            renderer.currentScaleMode = texture.baseTexture.scaleMode;
            renderer.context[renderer.smoothProperty] = (renderer.currentScaleMode === CONST.SCALE_MODES.LINEAR);
        }

        // If the texture is trimmed we offset by the trim x/y, otherwise we use the frame dimensions

        if(texture.rotate)
        {

            // cheeky rotation!
            var a = wt.a;
            var b = wt.b;

            wt.a  = -wt.c;
            wt.b  = -wt.d;
            wt.c  =  a;
            wt.d  =  b;

            width = texture.crop.height;
            height = texture.crop.width;

            dx = (texture.trim) ? texture.trim.y - this.anchor.y * texture.trim.height : this.anchor.y * -texture._frame.height;
            dy = (texture.trim) ? texture.trim.x - this.anchor.x * texture.trim.width : this.anchor.x * -texture._frame.width;
        }
        else
        {
            width = texture.crop.width;
            height = texture.crop.height;

            dx = (texture.trim) ? texture.trim.x - this.anchor.x * texture.trim.width : this.anchor.x * -texture._frame.width;
            dy = (texture.trim) ? texture.trim.y - this.anchor.y * texture.trim.height : this.anchor.y * -texture._frame.height;
        }



        // Allow for pixel rounding
        if (renderer.roundPixels)
        {
            renderer.context.setTransform(
                wt.a,
                wt.b,
                wt.c,
                wt.d,
                (wt.tx * renderer.resolution) | 0,
                (wt.ty * renderer.resolution) | 0
            );

            dx = dx | 0;
            dy = dy | 0;
        }
        else
        {

            renderer.context.setTransform(
                wt.a,
                wt.b,
                wt.c,
                wt.d,
                wt.tx * renderer.resolution,
                wt.ty * renderer.resolution
            );


        }

        if (this.tint !== 0xFFFFFF)
        {
            if (this.cachedTint !== this.tint)
            {
                this.cachedTint = this.tint;

                // TODO clean up caching - how to clean up the caches?
                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);
            }

            renderer.context.drawImage(
                this.tintedTexture,
                0,
                0,
                width * resolution * renderer.resolution,
                height * resolution * renderer.resolution,
                dx / resolution,
                dy / resolution,
                width * renderer.resolution,
                height * renderer.resolution
            );
        }
        else
        {
            renderer.context.drawImage(
                texture.baseTexture.source,
                texture.crop.x * resolution,
                texture.crop.y * resolution,
                width * resolution * renderer.resolution,
                height * resolution * renderer.resolution,
                dx / resolution,
                dy / resolution,
                width * renderer.resolution,
                height * renderer.resolution
            );
        }
    }
};

/**
 * Destroys this sprite and optionally its texture
 *
 * @param destroyTexture {boolean} Should it destroy the current texture of the sprite as well
 * @param destroyBaseTexture {boolean} Should it destroy the base texture of the sprite as well
 */
Sprite.prototype.destroy = function (destroyTexture, destroyBaseTexture)
{
    Container.prototype.destroy.call(this);

    this.anchor = null;

    if (destroyTexture)
    {
        this._texture.destroy(destroyBaseTexture);
    }

    this._texture = null;
    this.shader = null;
};

// some helper functions..

/**
 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @static
 * @param frameId {String} The frame Id of the texture in the cache
 * @return {Sprite} A new Sprite using a texture from the texture cache matching the frameId
 * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter
 * @param [scaleMode=scaleModes.DEFAULT] {number} if you want to specify the scale mode, see {@link SCALE_MODES} for possible values
 */
Sprite.fromFrame = function (frameId)
{
    var texture = utils.TextureCache[frameId];

    if (!texture)
    {
        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ' + this);
    }

    return new Sprite(texture);
};

/**
 * Helper function that creates a sprite that will contain a texture based on an image url
 * If the image is not in the texture cache it will be loaded
 *
 * @static
 * @param imageId {String} The image url of the texture
 * @return {Sprite} A new Sprite using a texture from the texture cache matching the image id
 */
Sprite.fromImage = function (imageId, crossorigin, scaleMode)
{
    return new Sprite(Texture.fromImage(imageId, crossorigin, scaleMode));
};

},{"../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../display/Container":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/display/Container.js","../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../renderers/canvas/utils/CanvasTinter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasTinter.js","../textures/Texture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/Texture.js","../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/sprites/webgl/SpriteRenderer.js":[function(require,module,exports){
var ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),
    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),
    CONST = require('../../const');

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's SpriteRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteRenderer.java
 */

/**
 *
 * @class
 * @private
 * @memberof PIXI
 * @extends ObjectRenderer
 * @param renderer {WebGLRenderer} The renderer this sprite batch works for.
 */
function SpriteRenderer(renderer)
{
    ObjectRenderer.call(this, renderer);

    /**
     *
     *
     * @member {number}
     */
    this.vertSize = 5;

    /**
     *
     *
     * @member {number}
     */
    this.vertByteSize = this.vertSize * 4;

    /**
     * The number of images in the SpriteBatch before it flushes.
     *
     * @member {number}
     */
    this.size = CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop

    // the total number of bytes in our batch
    var numVerts = this.size * 4 * this.vertByteSize;
    // the total number of indices in our batch
    var numIndices = this.size * 6;

    /**
     * Holds the vertices
     *
     * @member {ArrayBuffer}
     */
    this.vertices = new ArrayBuffer(numVerts);

    /**
     * View on the vertices as a Float32Array
     *
     * @member {Float32Array}
     */
    this.positions = new Float32Array(this.vertices);

    /**
     * Holds the color components
     *
     * @member {Uint32Array}
     */
    this.colors = new Uint32Array(this.vertices);

    /**
     * Holds the indices
     *
     * @member {Uint16Array}
     */
    this.indices = new Uint16Array(numIndices);

    /**
     *
     *
     * @member {number}
     */
    this.lastIndexCount = 0;

    for (var i=0, j=0; i < numIndices; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }

    /**
     *
     *
     * @member {boolean}
     */
    this.drawing = false;

    /**
     *
     *
     * @member {number}
     */
    this.currentBatchSize = 0;

    /**
     *
     *
     * @member {BaseTexture}
     */
    this.currentBaseTexture = null;

    /**
     *
     *
     * @member {Array}
     */
    this.textures = [];

    /**
     *
     *
     * @member {Array}
     */
    this.blendModes = [];

    /**
     *
     *
     * @member {Array}
     */
    this.shaders = [];

    /**
     *
     *
     * @member {Array}
     */
    this.sprites = [];

    /**
     * The default shader that is used if a sprite doesn't have a more specific one.
     *
     * @member {Shader}
     */
    this.shader = null;

}

SpriteRenderer.prototype = Object.create(ObjectRenderer.prototype);
SpriteRenderer.prototype.constructor = SpriteRenderer;
module.exports = SpriteRenderer;

WebGLRenderer.registerPlugin('sprite', SpriteRenderer);

/**
 * Sets up the renderer context and necessary buffers.
 *
 * @private
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 */
SpriteRenderer.prototype.onContextChange = function ()
{
    var gl = this.renderer.gl;

    // setup default shader
    this.shader = this.renderer.shaderManager.defaultShader;

    // create a couple of buffers
    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer();

    // 65535 is max index, so 65535 / 6 = 10922.

    //upload the index data
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);

    this.currentBlendMode = 99999;
};

/**
 * Renders the sprite object.
 *
 * @param sprite {Sprite} the sprite to render when using this spritebatch
 */
SpriteRenderer.prototype.render = function (sprite)
{
    var texture = sprite._texture;

    //TODO set blend modes..
    // check texture..
    if (this.currentBatchSize >= this.size)
    {
        this.flush();
        this.currentBaseTexture = texture.baseTexture;
    }

    // get the uvs for the texture
    var uvs = texture._uvs;

    // if the uvs have not updated then no point rendering just yet!
    if (!uvs)
    {
        return;
    }

    // TODO trim??
    var aX = sprite.anchor.x;
    var aY = sprite.anchor.y;

    var w0, w1, h0, h1;

    if (texture.trim)
    {
        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..
        var trim = texture.trim;

        w1 = trim.x - aX * trim.width;
        w0 = w1 + texture.crop.width;

        h1 = trim.y - aY * trim.height;
        h0 = h1 + texture.crop.height;

    }
    else
    {
        w0 = (texture._frame.width ) * (1-aX);
        w1 = (texture._frame.width ) * -aX;

        h0 = texture._frame.height * (1-aY);
        h1 = texture._frame.height * -aY;
    }

    var index = this.currentBatchSize * this.vertByteSize;

    var worldTransform = sprite.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.b;
    var c = worldTransform.c;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var colors = this.colors;
    var positions = this.positions;

    if (this.renderer.roundPixels)
    {
        // xy
        positions[index] = a * w1 + c * h1 + tx | 0;
        positions[index+1] = d * h1 + b * w1 + ty | 0;

        // xy
        positions[index+5] = a * w0 + c * h1 + tx | 0;
        positions[index+6] = d * h1 + b * w0 + ty | 0;

         // xy
        positions[index+10] = a * w0 + c * h0 + tx | 0;
        positions[index+11] = d * h0 + b * w0 + ty | 0;

        // xy
        positions[index+15] = a * w1 + c * h0 + tx | 0;
        positions[index+16] = d * h0 + b * w1 + ty | 0;
    }
    else
    {
        // xy
        positions[index] = a * w1 + c * h1 + tx;
        positions[index+1] = d * h1 + b * w1 + ty;

        // xy
        positions[index+5] = a * w0 + c * h1 + tx;
        positions[index+6] = d * h1 + b * w0 + ty;

         // xy
        positions[index+10] = a * w0 + c * h0 + tx;
        positions[index+11] = d * h0 + b * w0 + ty;

        // xy
        positions[index+15] = a * w1 + c * h0 + tx;
        positions[index+16] = d * h0 + b * w1 + ty;
    }

    // uv
    positions[index+2] = uvs.x0;
    positions[index+3] = uvs.y0;

    // uv
    positions[index+7] = uvs.x1;
    positions[index+8] = uvs.y1;

     // uv
    positions[index+12] = uvs.x2;
    positions[index+13] = uvs.y2;

    // uv
    positions[index+17] = uvs.x3;
    positions[index+18] = uvs.y3;

    // color and alpha
    var tint = sprite.tint;
    colors[index+4] = colors[index+9] = colors[index+14] = colors[index+19] = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);

    // increment the batchsize
    this.sprites[this.currentBatchSize++] = sprite;
};

/**
 * Renders the content and empties the current batch.
 *
 */
SpriteRenderer.prototype.flush = function ()
{
    // If the batch is length 0 then return as there is nothing to draw
    if (this.currentBatchSize === 0)
    {
        return;
    }

    var gl = this.renderer.gl;
    var shader;

    // upload the verts to the buffer
    if (this.currentBatchSize > ( this.size * 0.5 ) )
    {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
    }
    else
    {
        var view = this.positions.subarray(0, this.currentBatchSize * this.vertByteSize);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);
    }

    var nextTexture, nextBlendMode, nextShader;
    var batchSize = 0;
    var start = 0;

    var currentBaseTexture = null;
    var currentBlendMode = this.renderer.blendModeManager.currentBlendMode;
    var currentShader = null;

    var blendSwap = false;
    var shaderSwap = false;
    var sprite;

    for (var i = 0, j = this.currentBatchSize; i < j; i++)
    {

        sprite = this.sprites[i];

        nextTexture = sprite._texture.baseTexture;
        nextBlendMode = sprite.blendMode;
        nextShader = sprite.shader || this.shader;

        blendSwap = currentBlendMode !== nextBlendMode;
        shaderSwap = currentShader !== nextShader; // should I use uuidS???

        if (currentBaseTexture !== nextTexture || blendSwap || shaderSwap)
        {
            this.renderBatch(currentBaseTexture, batchSize, start);

            start = i;
            batchSize = 0;
            currentBaseTexture = nextTexture;

            if (blendSwap)
            {
                currentBlendMode = nextBlendMode;
                this.renderer.blendModeManager.setBlendMode( currentBlendMode );
            }

            if (shaderSwap)
            {
                currentShader = nextShader;



                shader = currentShader.shaders ? currentShader.shaders[gl.id] : currentShader;

                if (!shader)
                {
                    shader = currentShader.getShader(this.renderer);

                }

                // set shader function???
                this.renderer.shaderManager.setShader(shader);

                //TODO - i KNOW this can be optimised! Once v3 is stable il look at this next...
                shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);
                //Make this a little more dynamic / intelligent!
                shader.syncUniforms();

                //TODO investigate some kind of texture state managment??
                // need to make sure this texture is the active one for all the batch swaps..
                gl.activeTexture(gl.TEXTURE0);

                // both thease only need to be set if they are changing..
                // set the projection
                //gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));


            }
        }

        batchSize++;
    }

    this.renderBatch(currentBaseTexture, batchSize, start);

    // then reset the batch!
    this.currentBatchSize = 0;
};

/**
 * Draws the currently batches sprites.
 *
 * @private
 * @param texture {Texture}
 * @param size {number}
 * @param startIndex {number}
 */
SpriteRenderer.prototype.renderBatch = function (texture, size, startIndex)
{
    if (size === 0)
    {
        return;
    }

    var gl = this.renderer.gl;

    if (!texture._glTextures[gl.id])
    {
        this.renderer.updateTexture(texture);
    }
    else
    {
        // bind the current texture
        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
    }

    // now draw those suckas!
    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);

    // increment the draw count
    this.renderer.drawCount++;
};

/**
 * Starts a new sprite batch.
 *
 */
SpriteRenderer.prototype.start = function ()
{
    var gl = this.renderer.gl;

    // bind the main texture


    // bind the buffers
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

    // this is the same for each shader?
    var stride =  this.vertByteSize;
    gl.vertexAttribPointer(this.shader.attributes.aVertexPosition, 2, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(this.shader.attributes.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);

    // color attributes will be interpreted as unsigned bytes and normalized
    gl.vertexAttribPointer(this.shader.attributes.aColor, 4, gl.UNSIGNED_BYTE, true, stride, 4 * 4);
};

/**
 * Destroys the SpriteBatch.
 *
 */
SpriteRenderer.prototype.destroy = function ()
{
    this.renderer.gl.deleteBuffer(this.vertexBuffer);
    this.renderer.gl.deleteBuffer(this.indexBuffer);

    this.shader.destroy();

    this.renderer = null;

    this.vertices = null;
    this.positions = null;
    this.colors = null;
    this.indices = null;

    this.vertexBuffer = null;
    this.indexBuffer = null;

    this.currentBaseTexture = null;

    this.drawing = false;

    this.textures = null;
    this.blendModes = null;
    this.shaders = null;
    this.sprites = null;
    this.shader = null;
};

},{"../../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../../renderers/webgl/WebGLRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/WebGLRenderer.js","../../renderers/webgl/utils/ObjectRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/ObjectRenderer.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/text/Text.js":[function(require,module,exports){
var Sprite = require('../sprites/Sprite'),
    Texture = require('../textures/Texture'),
    math = require('../math'),
    CONST = require('../const');

/**
 * A Text Object will create a line or multiple lines of text. To split a line you can use '\n' in your text string,
 * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.
 *
 * A Text can be created directly from a string and a style object
 *
 * ```js
 * var text = new PIXI.Text('This is a pixi text',{font : '24px Arial', fill : 0xff1010, align : 'center'});
 * ```
 *
 * @class
 * @extends Sprite
 * @memberof PIXI
 * @param text {string} The copy that you would like the text to display
 * @param [style] {object} The style parameters
 * @param [style.font] {string} default 'bold 20px Arial' The style and size of the font
 * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'
 * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
 * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'
 * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
 * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used
 * @param [style.wordWrapWidth=100] {number} The width at which text will wrap, it needs wordWrap to be set to true
 * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses
 * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text
 * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
 * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow
 * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow
 * @param [style.padding=0] {number} Occasionally some fonts are cropped. Adding some padding will prevent this from happening
 * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.
 * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve
 *      spiked text issues. Default is 'miter' (creates a sharp corner).
 * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce
 *      or increase the spikiness of rendered text.
 */
function Text(text, style, resolution)
{
    /**
     * The canvas element that everything is drawn to
     *
     * @member {HTMLCanvasElement}
     */
    this.canvas = document.createElement('canvas');

    /**
     * The canvas 2d context that everything is drawn with
     * @member {HTMLCanvasElement}
     */
    this.context = this.canvas.getContext('2d');

    /**
     * The resolution of the canvas.
     * @member {number}
     */
    this.resolution = resolution || CONST.RESOLUTION;

    /**
     * Private tracker for the current text.
     *
     * @member {string}
     * @private
     */
    this._text = null;

    /**
     * Private tracker for the current style.
     *
     * @member {object}
     * @private
     */
    this._style = null;

    var texture = Texture.fromCanvas(this.canvas);
    texture.trim = new math.Rectangle();
    Sprite.call(this, texture);


    this.text = text;
    this.style = style;
}

// constructor
Text.prototype = Object.create(Sprite.prototype);
Text.prototype.constructor = Text;
module.exports = Text;

Text.fontPropertiesCache = {};
Text.fontPropertiesCanvas = document.createElement('canvas');
Text.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');

Object.defineProperties(Text.prototype, {
    /**
     * The width of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof Text#
     */
    width: {
        get: function ()
        {
            if (this.dirty)
            {
                this.updateText();
            }

            return this.scale.x * this._texture._frame.width;
        },
        set: function (value)
        {
            this.scale.x = value / this._texture._frame.width;
            this._width = value;
        }
    },

    /**
     * The height of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof Text#
     */
    height: {
        get: function ()
        {
            if (this.dirty)
            {
                this.updateText();
            }

            return  this.scale.y * this._texture._frame.height;
        },
        set: function (value)
        {
            this.scale.y = value / this._texture._frame.height;
            this._height = value;
        }
    },

    /**
     * Set the style of the text
     *
     * @param [style] {object} The style parameters
     * @param [style.font='bold 20pt Arial'] {string} The style and size of the font
     * @param [style.fill='black'] {object} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'
     * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
     * @param [style.stroke='black'] {string} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'
     * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)
     * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used
     * @param [style.wordWrapWidth=100] {number} The width at which text will wrap
     * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses
     * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text
     * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'
     * @param [style.dropShadowAngle=Math.PI/6] {number} Set a angle of the drop shadow
     * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow
     * @param [style.padding=0] {number} Occasionally some fonts are cropped. Adding some padding will prevent this from happening
     * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.
     * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve
     *      spiked text issues. Default is 'miter' (creates a sharp corner).
     * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce
     *      or increase the spikiness of rendered text.
     * @memberof Text#
     */
    style: {
        get: function ()
        {
            return this._style;
        },
        set: function (style)
        {
            style = style || {};
            style.font = style.font || 'bold 20pt Arial';
            style.fill = style.fill || 'black';
            style.align = style.align || 'left';
            style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136
            style.strokeThickness = style.strokeThickness || 0;
            style.wordWrap = style.wordWrap || false;
            style.wordWrapWidth = style.wordWrapWidth || 100;

            style.dropShadow = style.dropShadow || false;
            style.dropShadowColor = style.dropShadowColor || '#000000';
            style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;
            style.dropShadowDistance = style.dropShadowDistance || 5;

            style.padding = style.padding || 0;

            style.textBaseline = style.textBaseline || 'alphabetic';

            style.lineJoin = style.lineJoin || 'miter';
            style.miterLimit = style.miterLimit || 10;

            this._style = style;
            this.dirty = true;
        }
    },

    /**
     * Set the copy for the text object. To split a line you can use '\n'.
     *
     * @param text {string} The copy that you would like the text to display
     * @memberof Text#
     */
    text: {
        get: function()
        {
            return this._text;
        },
        set: function (text){
            text = text.toString() || ' ';
            if (this._text === text)
            {
                return;
            }
            this._text = text;
            this.dirty = true;
        }
    }
});

/**
 * Renders text and updates it when needed
 *
 * @private
 */
Text.prototype.updateText = function ()
{
    var style = this._style;
    this.context.font = style.font;

    // word wrap
    // preserve original text
    var outputText = style.wordWrap ? this.wordWrap(this._text) : this._text;

    // split text into lines
    var lines = outputText.split(/(?:\r\n|\r|\n)/);

    // calculate text width
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    var fontProperties = this.determineFontProperties(style.font);
    for (var i = 0; i < lines.length; i++)
    {
        var lineWidth = this.context.measureText(lines[i]).width;
        lineWidths[i] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }

    var width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow)
    {
        width += style.dropShadowDistance;
    }

    this.canvas.width = ( width + this.context.lineWidth ) * this.resolution;

    // calculate text height
    var lineHeight = this.style.lineHeight || fontProperties.fontSize + style.strokeThickness;

    var height = lineHeight * lines.length;
    if (style.dropShadow)
    {
        height += style.dropShadowDistance;
    }

    this.canvas.height = ( height + this._style.padding * 2 ) * this.resolution;

    this.context.scale( this.resolution, this.resolution);

    if (navigator.isCocoonJS)
    {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

    }

    //this.context.fillStyle="#FF0000";
    //this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);

    this.context.font = style.font;
    this.context.strokeStyle = style.stroke;
    this.context.lineWidth = style.strokeThickness;
    this.context.textBaseline = style.textBaseline;
    this.context.lineJoin = style.lineJoin;
    this.context.miterLimit = style.miterLimit;

    var linePositionX;
    var linePositionY;

    if (style.dropShadow)
    {
        this.context.fillStyle = style.dropShadowColor;

        var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
        var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;

        for (i = 0; i < lines.length; i++)
        {
            linePositionX = style.strokeThickness / 2;
            linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;

            if (style.align === 'right')
            {
                linePositionX += maxLineWidth - lineWidths[i];
            }
            else if (style.align === 'center')
            {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }

            if (style.fill)
            {
                this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset + this._style.padding);
            }
        }
    }

    //set canvas text styles
    this.context.fillStyle = style.fill;

    //draw lines line by line
    for (i = 0; i < lines.length; i++)
    {
        linePositionX = style.strokeThickness / 2;
        linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;

        if (style.align === 'right')
        {
            linePositionX += maxLineWidth - lineWidths[i];
        }
        else if (style.align === 'center')
        {
            linePositionX += (maxLineWidth - lineWidths[i]) / 2;
        }

        if (style.stroke && style.strokeThickness)
        {
            this.context.strokeText(lines[i], linePositionX, linePositionY + this._style.padding);
        }

        if (style.fill)
        {
            this.context.fillText(lines[i], linePositionX, linePositionY + this._style.padding);
        }
    }

    this.updateTexture();
};

/**
 * Updates texture size based on canvas size
 *
 * @private
 */
Text.prototype.updateTexture = function ()
{
    var texture = this._texture;

    texture.baseTexture.hasLoaded = true;
    texture.baseTexture.resolution = this.resolution;

    texture.baseTexture.width = this.canvas.width / this.resolution;
    texture.baseTexture.height = this.canvas.height / this.resolution;
    texture.crop.width = texture._frame.width = this.canvas.width / this.resolution;
    texture.crop.height = texture._frame.height = this.canvas.height / this.resolution;

    texture.trim.x = 0;
    texture.trim.y = -this._style.padding;

    texture.trim.width = texture._frame.width;
    texture.trim.height = texture._frame.height - this._style.padding*2;

    this._width = this.canvas.width / this.resolution;
    this._height = this.canvas.height / this.resolution;

    texture.update();

    this.dirty = false;
};

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {WebGLRenderer}
 */
Text.prototype.renderWebGL = function (renderer)
{
    if (this.dirty)
    {
        //this.resolution = 1//renderer.resolution;

        this.updateText();
    }

    Sprite.prototype.renderWebGL.call(this, renderer);
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {CanvasRenderer}
 * @private
 */
Text.prototype._renderCanvas = function (renderer)
{
    if (this.dirty)
    {
     //   this.resolution = 1//renderer.resolution;

        this.updateText();
    }

    Sprite.prototype._renderCanvas.call(this, renderer);
};

/**
 * Calculates the ascent, descent and fontSize of a given fontStyle
 *
 * @param fontStyle {object}
 * @private
 */
Text.prototype.determineFontProperties = function (fontStyle)
{
    var properties = Text.fontPropertiesCache[fontStyle];

    if (!properties)
    {
        properties = {};

        var canvas = Text.fontPropertiesCanvas;
        var context = Text.fontPropertiesContext;

        context.font = fontStyle;

        var width = Math.ceil(context.measureText('|MÉq').width);
        var baseline = Math.ceil(context.measureText('M').width);
        var height = 2 * baseline;

        baseline = baseline * 1.4 | 0;

        canvas.width = width;
        canvas.height = height;

        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);

        context.font = fontStyle;

        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText('|MÉq', 0, baseline);

        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;

        var i, j;

        var idx = 0;
        var stop = false;

        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; i++)
        {
            for (j = 0; j < line; j += 4)
            {
                if (imagedata[idx + j] !== 255)
                {
                    stop = true;
                    break;
                }
            }
            if (!stop)
            {
                idx += line;
            }
            else
            {
                break;
            }
        }

        properties.ascent = baseline - i;

        idx = pixels - line;
        stop = false;

        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; i--)
        {
            for (j = 0; j < line; j += 4)
            {
                if (imagedata[idx + j] !== 255)
                {
                    stop = true;
                    break;
                }
            }
            if (!stop)
            {
                idx -= line;
            }
            else
            {
                break;
            }
        }

        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;

        Text.fontPropertiesCache[fontStyle] = properties;
    }

    return properties;
};

/**
 * Applies newlines to a string to have it optimally fit into the horizontal
 * bounds set by the Text object's wordWrapWidth property.
 *
 * @param text {string}
 * @private
 */
Text.prototype.wordWrap = function (text)
{
    // Greedy wrapping algorithm that will wrap words as the line grows longer
    // than its horizontal bounds.
    var result = '';
    var lines = text.split('\n');
    var wordWrapWidth = this._style.wordWrapWidth;
    for (var i = 0; i < lines.length; i++)
    {
        var spaceLeft = wordWrapWidth;
        var words = lines[i].split(' ');
        for (var j = 0; j < words.length; j++)
        {
            var wordWidth = this.context.measureText(words[j]).width;
            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;
            if (j === 0 || wordWidthWithSpace > spaceLeft)
            {
                // Skip printing the newline if it's the first word of the line that is
                // greater than the word wrap width.
                if (j > 0)
                {
                    result += '\n';
                }
                result += words[j];
                spaceLeft = wordWrapWidth - wordWidth;
            }
            else
            {
                spaceLeft -= wordWidthWithSpace;
                result += ' ' + words[j];
            }
        }

        if (i < lines.length-1)
        {
            result += '\n';
        }
    }
    return result;
};

/**
 * Returns the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
 *
 * @param matrix {Matrix} the transformation matrix of the Text
 * @return {Rectangle} the framing rectangle
 */
Text.prototype.getBounds = function (matrix)
{
    if (this.dirty)
    {
        this.updateText();
    }

    return Sprite.prototype.getBounds.call(this, matrix);
};

/**
 * Destroys this text object.
 *
 * @param destroyBaseTexture {boolean} whether to destroy the base texture as well
 */
Text.prototype.destroy = function (destroyBaseTexture)
{
    // make sure to reset the the context and canvas.. dont want this hanging around in memory!
    this.context = null;
    this.canvas = null;

    this._texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);
};

},{"../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../sprites/Sprite":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/sprites/Sprite.js","../textures/Texture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/Texture.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/BaseTexture.js":[function(require,module,exports){
var utils = require('../utils'),
    CONST = require('../const'),
    EventEmitter = require('eventemitter3').EventEmitter;

/**
 * A texture stores the information that represents an image. All textures have a base texture.
 *
 * @class
 * @memberof PIXI
 * @param source {Image|Canvas} the source object of the texture.
 * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values
 * @param resolution {number} the resolution of the texture for devices with different pixel ratios
 */
function BaseTexture(source, scaleMode, resolution)
{
    EventEmitter.call(this);

    this.uuid = utils.uuid();

    /**
     * The Resolution of the texture.
     *
     * @member {number}
     */
    this.resolution = resolution || 1;

    /**
     * The width of the base texture set when the image has loaded
     *
     * @member {number}
     * @readOnly
     */
    this.width = 100;

    /**
     * The height of the base texture set when the image has loaded
     *
     * @member {number}
     * @readOnly
     */
    this.height = 100;

    // TODO docs
    // used to store the actual dimensions of the source
    /**
     * Used to store the actual width of the source of this texture
     *
     * @member {number}
     * @readOnly
     */
    this.realWidth = 100;
    /**
     * Used to store the actual height of the source of this texture
     *
     * @member {number}
     * @readOnly
     */
    this.realHeight = 100;

    /**
     * The scale mode to apply when scaling this texture
     *
     * @member {{number}}
     * @default scaleModes.LINEAR
     */
    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;

    /**
     * Set to true once the base texture has successfully loaded.
     *
     * This is never true if the underlying source fails to load or has no texture data.
     *
     * @member {boolean}
     * @readOnly
     */
    this.hasLoaded = false;

    /**
     * Set to true if the source is currently loading.
     *
     * If an Image source is loading the 'loaded' or 'error' event will be
     * dispatched when the operation ends. An underyling source that is
     * immediately-available bypasses loading entirely.
     *
     * @member {boolean}
     * @readonly
     */
    this.isLoading = false;

    /**
     * The image source that is used to create the texture.
     *
     * TODO: Make this a setter that calls loadSource();
     *
     * @member {Image|Canvas}
     * @readonly
     */
    this.source = null; // set in loadSource, if at all

    /**
     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
     *
     * @member {boolean}
     * @default true
     */
    this.premultipliedAlpha = true;

    /**
     * @member {string}
     */
    this.imageUrl = null;

    /**
     * Wether or not the texture is a power of two, try to use power of two textures as much as you can
     * @member {boolean}
     * @private
     */
    this.isPowerOfTwo = false;

    // used for webGL

    /**
     *
     * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used
     * Also the texture must be a power of two size to work
     *
     * @member {boolean}
     */
    this.mipmap = false;

    /**
     * A map of renderer IDs to webgl textures
     *
     * @member {object<number, WebGLTexture>}
     * @private
     */
    this._glTextures = [];

    // if no source passed don't try to load
    if (source)
    {
        this.loadSource(source);
    }

    /**
     * Fired when a not-immediately-available source finishes loading.
     *
     * @event loaded
     * @memberof BaseTexture#
     * @protected
     */

    /**
     * Fired when a not-immediately-available source fails to load.
     *
     * @event error
     * @memberof BaseTexture#
     * @protected
     */
}

BaseTexture.prototype = Object.create(EventEmitter.prototype);
BaseTexture.prototype.constructor = BaseTexture;
module.exports = BaseTexture;

/**
 * Updates the texture on all the webgl renderers.
 *
 * @fires update
 */
BaseTexture.prototype.update = function ()
{
    this.emit('update', this);
};

/**
 * Load a source.
 *
 * If the source is not-immediately-available, such as an image that needs to be
 * downloaded, then the 'loaded' or 'error' event will be dispatched in the future
 * and `hasLoaded` will remain false after this call.
 *
 * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:
 *
 *     if (texture.hasLoaded)
 {
 *        // texture ready for use
 *     } else if (texture.isLoading)
 {
 *        // listen to 'loaded' and/or 'error' events on texture
 *     } else {
 *        // not loading, not going to load UNLESS the source is reloaded
 *        // (it may still make sense to listen to the events)
 *     }
 *
 * @protected
 * @param source {Image|Canvas} the source object of the texture.
 */
BaseTexture.prototype.loadSource = function (source)
{
    var wasLoading = this.isLoading;
    this.hasLoaded = false;
    this.isLoading = false;

    if (wasLoading && this.source)
    {
        this.source.onload = null;
        this.source.onerror = null;
    }

    this.source = source;

    // Apply source if loaded. Otherwise setup appropriate loading monitors.
    if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height)
    {
        this._sourceLoaded();
    }
    else if (!source.getContext)
    {

        // Image fail / not ready
        this.isLoading = true;

        var scope = this;

        source.onload = function ()
        {
            source.onload = null;
            source.onerror = null;

            if (!scope.isLoading)
            {
                return;
            }

            scope.isLoading = false;
            scope._sourceLoaded();

            scope.emit('loaded', scope);
        };

        source.onerror = function ()
        {
            source.onload = null;
            source.onerror = null;

            if (!scope.isLoading)
            {
                return;
            }

            scope.isLoading = false;
            scope.emit('error', scope);
        };

        // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element
        //   "The value of `complete` can thus change while a script is executing."
        // So complete needs to be re-checked after the callbacks have been added..
        // NOTE: complete will be true if the image has no src so best to check if the src is set.
        if (source.complete && source.src)
        {
            this.isLoading = false;

            // ..and if we're complete now, no need for callbacks
            source.onload = null;
            source.onerror = null;

            if (source.width && source.height)
            {
                this._sourceLoaded();

                // If any previous subscribers possible
                if (wasLoading)
                {
                    this.emit('loaded', this);
                }
            }
            else
            {
                // If any previous subscribers possible
                if (wasLoading)
                {
                    this.emit('error', this);
                }
            }
        }
    }
};

/**
 * Used internally to update the width, height, and some other tracking vars once
 * a source has successfully loaded.
 *
 * @private
 */
BaseTexture.prototype._sourceLoaded = function ()
{
    this.hasLoaded = true;

    this.realWidth = this.source.naturalWidth || this.source.width;
    this.realHeight = this.source.naturalHeight || this.source.height;

    this.width = this.realWidth / this.resolution;
    this.height = this.realHeight / this.resolution;


    this.isPowerOfTwo = utils.isPowerOfTwo(this.width, this.height);

    this.update();
};

/**
 * Destroys this base texture
 *
 */
BaseTexture.prototype.destroy = function ()
{
    if (this.imageUrl)
    {
        delete utils.BaseTextureCache[this.imageUrl];
        delete utils.TextureCache[this.imageUrl];

        this.imageUrl = null;

        if (!navigator.isCocoonJS)
        {
            this.source.src = '';
        }
    }
    else if (this.source && this.source._pixiId)
    {
        delete utils.BaseTextureCache[this.source._pixiId];
    }

    this.source = null;

    this.dispose();
};

/**
 * Frees the texture from WebGL memory without destroying this texture object.
 * This means you can still use the texture later which will upload it to GPU
 * memory again.
 *
 */
BaseTexture.prototype.dispose = function ()
{
    this.emit('dispose', this);
};

/**
 * Changes the source image of the texture.
 * The original source must be an Image element.
 *
 * @param newSrc {string} the path of the image
 */
BaseTexture.prototype.updateSourceImage = function (newSrc)
{
    this.source.src = newSrc;

    this.loadSource(this.source);
};

/**
 * Helper function that creates a base texture from the given image url.
 * If the image is not in the base texture cache it will be created and loaded.
 *
 * @static
 * @param imageUrl {string} The image url of the texture
 * @param [crossorigin=(auto)] {boolean} Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
 * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values
 * @return BaseTexture
 */
BaseTexture.fromImage = function (imageUrl, crossorigin, scaleMode)
{
    var baseTexture = utils.BaseTextureCache[imageUrl];

    if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0)
    {
        crossorigin = true;
    }

    if (!baseTexture)
    {
        // new Image() breaks tex loading in some versions of Chrome.
        // See https://code.google.com/p/chromium/issues/detail?id=238071
        var image = new Image();//document.createElement('img');
        if (crossorigin)
        {
            image.crossOrigin = '';
        }

        baseTexture = new BaseTexture(image, scaleMode);
        baseTexture.imageUrl = imageUrl;

        image.src = imageUrl;

        utils.BaseTextureCache[imageUrl] = baseTexture;

        // if there is an @2x at the end of the url we are going to assume its a highres image
        baseTexture.resolution = utils.getResolutionOfUrl(imageUrl);
    }

    return baseTexture;
};

/**
 * Helper function that creates a base texture from the given canvas element.
 *
 * @static
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {number} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
 * @return BaseTexture
 */
BaseTexture.fromCanvas = function (canvas, scaleMode)
{
    if (!canvas._pixiId)
    {
        canvas._pixiId = 'canvas_' + utils.uuid();
    }

    var baseTexture = utils.BaseTextureCache[canvas._pixiId];

    if (!baseTexture)
    {
        baseTexture = new BaseTexture(canvas, scaleMode);
        utils.BaseTextureCache[canvas._pixiId] = baseTexture;
    }

    return baseTexture;
};

},{"../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js","eventemitter3":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/eventemitter3/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/RenderTexture.js":[function(require,module,exports){
var BaseTexture = require('./BaseTexture'),
    Texture = require('./Texture'),
    RenderTarget = require('../renderers/webgl/utils/RenderTarget'),
    FilterManager = require('../renderers/webgl/managers/FilterManager'),
    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),
    math = require('../math'),
    CONST = require('../const'),
    tempMatrix = new math.Matrix();

/**
 * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.
 *
 * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
 * otherwise black rectangles will be drawn instead.
 *
 * A RenderTexture takes a snapshot of any Display Object given to its render method. The position
 * and rotation of the given Display Objects is ignored. For example:
 *
 * ```js
 * var renderTexture = new PIXI.RenderTexture(800, 600);
 * var sprite = PIXI.Sprite.fromImage("spinObj_01.png");
 *
 * sprite.position.x = 800/2;
 * sprite.position.y = 600/2;
 * sprite.anchor.x = 0.5;
 * sprite.anchor.y = 0.5;
 *
 * renderTexture.render(sprite);
 * ```
 *
 * The Sprite in this case will be rendered to a position of 0,0. To render this sprite at its actual
 * position a Container should be used:
 *
 * ```js
 * var doc = new Container();
 *
 * doc.addChild(sprite);
 *
 * renderTexture.render(doc);  // Renders to center of renderTexture
 * ```
 *
 * @class
 * @extends Texture
 * @memberof PIXI
 * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used for this RenderTexture
 * @param [width=100] {number} The width of the render texture
 * @param [height=100] {number} The height of the render texture
 * @param [scaleMode] {number} See {@link SCALE_MODES} for possible values
 * @param [resolution=1] {number} The resolution of the texture being generated
 */
function RenderTexture(renderer, width, height, scaleMode, resolution)
{
    if (!renderer)
    {
        throw new Error('Unable to create RenderTexture, you must pass a renderer into the constructor.');
    }

    width = width || 100;
    height = height || 100;
    resolution = resolution || CONST.RESOLUTION;

    /**
     * The base texture object that this texture uses
     *
     * @member {BaseTexture}
     */
    var baseTexture = new BaseTexture();
    baseTexture.width = width;
    baseTexture.height = height;
    baseTexture.resolution = resolution;
    baseTexture.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;
    baseTexture.hasLoaded = true;


    Texture.call(this,
        baseTexture,
        new math.Rectangle(0, 0, width, height)
    );


    /**
     * The with of the render texture
     *
     * @member {number}
     */
    this.width = width;

    /**
     * The height of the render texture
     *
     * @member {number}
     */
    this.height = height;

    /**
     * The Resolution of the texture.
     *
     * @member {number}
     */
    this.resolution = resolution;

    /**
     * The framing rectangle of the render texture
     *
     * @member {Rectangle}
     */
    //this._frame = new math.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);

    /**
     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
     *
     * @member {Rectangle}
     */
    //this.crop = new math.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);

    /**
     * Draw/render the given DisplayObject onto the texture.
     *
     * The displayObject and descendents are transformed during this operation.
     * If `updateTransform` is true then the transformations will be restored before the
     * method returns. Otherwise it is up to the calling code to correctly use or reset
     * the transformed display objects.
     *
     * The display object is always rendered with a worldAlpha value of 1.
     *
     * @method
     * @param displayObject {DisplayObject} The display object to render this texture on
     * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.
     * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn
     * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children
     *  transformations will be restored. Not restoring this information will be a little faster.
     */
    this.render = null;

    /**
     * The renderer this RenderTexture uses. A RenderTexture can only belong to one renderer at the moment if its webGL.
     *
     * @member {CanvasRenderer|WebGLRenderer}
     */
    this.renderer = renderer;

    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        var gl = this.renderer.gl;

        this.textureBuffer = new RenderTarget(gl, this.width, this.height, null, this.resolution);//, this.baseTexture.scaleMode);
        this.baseTexture._glTextures[gl.id] =  this.textureBuffer.texture;

        //TODO refactor filter manager.. as really its no longer a manager if we use it here..
        this.filterManager = new FilterManager(this.renderer);
        this.filterManager.onContextChange();
        this.filterManager.resize(width, height);
        this.render = this.renderWebGL;

        // the creation of a filter manager unbinds the buffers..
        this.renderer.currentRenderer.start();
        this.renderer.currentRenderTarget.activate();
    }
    else
    {

        this.render = this.renderCanvas;
        this.textureBuffer = new CanvasBuffer(this.width* this.resolution, this.height* this.resolution);
        this.baseTexture.source = this.textureBuffer.canvas;
    }

    /**
     * @member {boolean}
     */
    this.valid = true;

    this._updateUvs();
}

RenderTexture.prototype = Object.create(Texture.prototype);
RenderTexture.prototype.constructor = RenderTexture;
module.exports = RenderTexture;

/**
 * Resizes the RenderTexture.
 *
 * @param width {number} The width to resize to.
 * @param height {number} The height to resize to.
 * @param updateBase {boolean} Should the baseTexture.width and height values be resized as well?
 */
RenderTexture.prototype.resize = function (width, height, updateBase)
{
    if (width === this.width && height === this.height)
    {
        return;
    }

    this.valid = (width > 0 && height > 0);

    this.width = this._frame.width = this.crop.width = width;
    this.height =  this._frame.height = this.crop.height = height;

    if (updateBase)
    {
        this.baseTexture.width = this.width;
        this.baseTexture.height = this.height;
    }

    if (!this.valid)
    {
        return;
    }

    this.textureBuffer.resize(this.width * this.resolution, this.height * this.resolution);

    if(this.filterManager)
    {
        this.filterManager.resize(this.width, this.height);
    }
};

/**
 * Clears the RenderTexture.
 *
 */
RenderTexture.prototype.clear = function ()
{
    if (!this.valid)
    {
        return;
    }

    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
    }

    this.textureBuffer.clear();
};

/**
 * Internal method assigned to the `render` property if using a CanvasRenderer.
 *
 * @private
 * @param displayObject {DisplayObject} The display object to render this texture on
 * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.
 * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn
 * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children
 *  transformations will be restored. Not restoring this information will be a little faster.
 */
RenderTexture.prototype.renderWebGL = function (displayObject, matrix, clear, updateTransform)
{
    if (!this.valid)
    {
        return;
    }


    updateTransform = (updateTransform !== undefined) ? updateTransform : true;//!updateTransform;

    this.textureBuffer.transform = matrix;


    // setWorld Alpha to ensure that the object is renderer at full opacity
    displayObject.worldAlpha = displayObject.alpha;

    if (updateTransform)
    {

        // reset the matrix of the displatyObject..
        displayObject.worldTransform.identity();

        displayObject.currentBounds = null;

        // Time to update all the children of the displayObject with the new matrix..
        var children = displayObject.children;
        var i, j;

        for (i = 0, j = children.length; i < j; ++i)
        {
            children[i].updateTransform();
        }
    }

    //TODO rename textureBuffer to renderTarget..
    var temp =  this.renderer.filterManager;

    this.renderer.filterManager = this.filterManager;
    this.renderer.renderDisplayObject(displayObject, this.textureBuffer, clear);

    this.renderer.filterManager = temp;
};


/**
 * Internal method assigned to the `render` property if using a CanvasRenderer.
 *
 * @private
 * @param displayObject {DisplayObject} The display object to render this texture on
 * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.
 * @param [clear] {boolean} If true the texture will be cleared before the displayObject is drawn
 */
RenderTexture.prototype.renderCanvas = function (displayObject, matrix, clear, updateTransform)
{
    if (!this.valid)
    {
        return;
    }

    updateTransform = !!updateTransform;
    var cachedWt = displayObject.worldTransform;

    var wt = tempMatrix;

    wt.identity();

    if (matrix)
    {
        wt.append(matrix);
    }

    displayObject.worldTransform = wt;

    // setWorld Alpha to ensure that the object is renderer at full opacity
    displayObject.worldAlpha = 1;

    // Time to update all the children of the displayObject with the new matrix..
    var children = displayObject.children;
    var i, j;

    for (i = 0, j = children.length; i < j; ++i)
    {
        children[i].updateTransform();
    }

    if (clear)
    {
        this.textureBuffer.clear();
    }

    displayObject.worldTransform = cachedWt;

//    this.textureBuffer.
    var context = this.textureBuffer.context;

    var realResolution = this.renderer.resolution;

    this.renderer.resolution = this.resolution;

    this.renderer.renderDisplayObject(displayObject, context);

    this.renderer.resolution = realResolution;
 //   context.setTransform(1, 0, 0, 1, 0, 0);
   // context.fillStyle ="#FF0000"
//    context.fillRect(0, 0, 800, 600);

};

/**
 * Destroys this texture
 *
 * @param destroyBase {boolean} Whether to destroy the base texture as well
 */
RenderTexture.prototype.destroy = function ()
{
    Texture.prototype.destroy.call(this, true);

    this.textureBuffer.destroy();

    // destroy the filtermanager..
    if(this.filterManager)
    {
        this.filterManager.destroy();
    }

    this.renderer = null;
};

/**
 * Will return a HTML Image of the texture
 *
 * @return {Image}
 */
RenderTexture.prototype.getImage = function ()
{
    var image = new Image();
    image.src = this.getBase64();
    return image;
};

/**
 * Will return a a base64 encoded string of this texture. It works by calling RenderTexture.getCanvas and then running toDataURL on that.
 *
 * @return {string} A base64 encoded string of the texture.
 */
RenderTexture.prototype.getBase64 = function ()
{
    return this.getCanvas().toDataURL();
};

/**
 * Creates a Canvas element, renders this RenderTexture to it and then returns it.
 *
 * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
 */
RenderTexture.prototype.getCanvas = function ()
{
    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)
    {
        var gl = this.renderer.gl;
        var width = this.textureBuffer.size.width;
        var height = this.textureBuffer.size.height;

        var webGLPixels = new Uint8Array(4 * width * height);

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        var tempCanvas = new CanvasBuffer(width, height);
        var canvasData = tempCanvas.context.getImageData(0, 0, width, height);
        canvasData.data.set(webGLPixels);

        tempCanvas.context.putImageData(canvasData, 0, 0);

        return tempCanvas.canvas;
    }
    else
    {
        return this.textureBuffer.canvas;
    }
};

},{"../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../renderers/canvas/utils/CanvasBuffer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasBuffer.js","../renderers/webgl/managers/FilterManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/managers/FilterManager.js","../renderers/webgl/utils/RenderTarget":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/RenderTarget.js","./BaseTexture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/BaseTexture.js","./Texture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/Texture.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/Texture.js":[function(require,module,exports){
var BaseTexture = require('./BaseTexture'),
    VideoBaseTexture = require('./VideoBaseTexture'),
    TextureUvs = require('./TextureUvs'),
    EventEmitter = require('eventemitter3').EventEmitter,
    math = require('../math'),
    utils = require('../utils');

/**
 * A texture stores the information that represents an image or part of an image. It cannot be added
 * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided then the whole image is used.
 *
 * You can directly create a texture from an image and then reuse it multiple times like this :
 *
 * ```js
 * var texture = PIXI.Texture.fromImage('assets/image.png');
 * var sprite1 = new PIXI.Sprite(texture);
 * var sprite2 = new PIXI.Sprite(texture);
 * ```
 *
 * @class
 * @memberof PIXI
 * @param baseTexture {BaseTexture} The base texture source to create the texture from
 * @param [frame] {Rectangle} The rectangle frame of the texture to show
 * @param [crop] {Rectangle} The area of original texture
 * @param [trim] {Rectangle} Trimmed texture rectangle
 * @param [rotate] {boolean} indicates whether the texture should be rotated by 90 degrees ( used by texture packer )
 */
function Texture(baseTexture, frame, crop, trim, rotate)
{
    EventEmitter.call(this);

    /**
     * Does this Texture have any frame data assigned to it?
     *
     * @member {boolean}
     */
    this.noFrame = false;

    if (!frame)
    {
        this.noFrame = true;
        frame = new math.Rectangle(0, 0, 1, 1);
    }

    if (baseTexture instanceof Texture)
    {
        baseTexture = baseTexture.baseTexture;
    }

  //  console.log(frame);

    /**
     * The base texture that this texture uses.
     *
     * @member {BaseTexture}
     */
    this.baseTexture = baseTexture;

    /**
     * The frame specifies the region of the base texture that this texture uses
     *
     * @member {Rectangle}
     * @private
     */
    this._frame = frame;

    /**
     * The texture trim data.
     *
     * @member {Rectangle}
     */
    this.trim = trim;

    /**
     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
     *
     * @member {boolean}
     */
    this.valid = false;

    /**
     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
     *
     * @member {boolean}
     */
    this.requiresUpdate = false;

    /**
     * The WebGL UV data cache.
     *
     * @member {TextureUvs}
     * @private
     */
    this._uvs = null;

    /**
     * The width of the Texture in pixels.
     *
     * @member {number}
     */
    this.width = 0;

    /**
     * The height of the Texture in pixels.
     *
     * @member {number}
     */
    this.height = 0;

    /**
     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
     *
     * @member {Rectangle}
     */
    this.crop = crop || frame;//new math.Rectangle(0, 0, 1, 1);

    /**
     * Indicates whether the texture should be rotated by 90 degrees
     *
     * @private
     * @member {boolean}
     */
    this.rotate = !!rotate;

    if (baseTexture.hasLoaded)
    {
        if (this.noFrame)
        {
            frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
        }
        this.frame = frame;
    }
    else
    {
        baseTexture.once('loaded', this.onBaseTextureLoaded, this);
    }
}

Texture.prototype = Object.create(EventEmitter.prototype);
Texture.prototype.constructor = Texture;
module.exports = Texture;

Object.defineProperties(Texture.prototype, {
    frame: {
        get: function ()
        {
            return this._frame;
        },
        set: function (frame)
        {
            this._frame = frame;

            this.noFrame = false;

            this.width = frame.width;
            this.height = frame.height;



            if (!this.trim && !this.rotate && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))
            {
                throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);
            }

            //this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;
            this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;

            if (this.trim)
            {

                this.width = this.trim.width;
                this.height = this.trim.height;
                this._frame.width = this.trim.width;
                this._frame.height = this.trim.height;
            }
            else
            {
                this.crop = frame;
            }

             if (this.valid)
            {
                this._updateUvs();
            }
        }
    }
});

/**
 * Updates this texture on the gpu.
 *
 */
Texture.prototype.update = function ()
{
    this.baseTexture.update();


};

/**
 * Called when the base texture is loaded
 *
 * @private
 */
Texture.prototype.onBaseTextureLoaded = function (baseTexture)
{
    // TODO this code looks confusing.. boo to abusing getters and setterss!
    if (this.noFrame)
    {
        this.frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
    }
    else
    {
        this.frame = this._frame;
    }

    this.emit( 'update', this );
};

/**
 * Destroys this texture
 *
 * @param destroyBase {boolean} Whether to destroy the base texture as well
 */
Texture.prototype.destroy = function (destroyBase)
{
    if (destroyBase)
    {
        this.baseTexture.destroy();
    }

    this.valid = false;
};

Texture.prototype.clone = function ()
{
    return new Texture(this.baseTexture, this.frame, this.crop, this.trim, this.rotate);
};

/**
 * Updates the internal WebGL UV cache.
 *
 * @private
 */
Texture.prototype._updateUvs = function ()
{
    if (!this._uvs)
    {
        this._uvs = new TextureUvs();
    }

    this._uvs.set(this.crop, this.baseTexture, this.rotate);
};

/**
 * Helper function that creates a Texture object from the given image url.
 * If the image is not in the texture cache it will be  created and loaded.
 *
 * @static
 * @param imageUrl {string} The image url of the texture
 * @param crossorigin {boolean} Whether requests should be treated as crossorigin
 * @param scaleMode {number} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
 * @return {Texture} The newly created texture
 */
Texture.fromImage = function (imageUrl, crossorigin, scaleMode)
{
    var texture = utils.TextureCache[imageUrl];

    if (!texture)
    {
        texture = new Texture(BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));
        utils.TextureCache[imageUrl] = texture;
    }

    return texture;
};

/**
 * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @static
 * @param frameId {String} The frame Id of the texture in the cache
 * @return {Texture} The newly created texture
 */
Texture.fromFrame = function (frameId)
{
    var texture = utils.TextureCache[frameId];

    if (!texture)
    {
        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
    }

    return texture;
};

/**
 * Helper function that creates a new Texture based on the given canvas element.
 *
 * @static
 * @param canvas {Canvas} The canvas element source of the texture
 * @param scaleMode {number} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
 * @return {Texture}
 */
Texture.fromCanvas = function (canvas, scaleMode)
{
    return new Texture(BaseTexture.fromCanvas(canvas, scaleMode));
};

/**
 * Helper function that creates a new Texture based on the given video element.
 *
 * @static
 * @param video {HTMLVideoElement}
 * @param scaleMode {number} See {{#crossLink "PIXI/scaleModes:property"}}scaleModes{{/crossLink}} for possible values
 * @return {Texture} A Texture
 */
Texture.fromVideo = function (video, scaleMode)
{
    if (typeof video === 'string')
    {
        return Texture.fromVideoUrl(video, scaleMode);
    }
    else
    {
        return new Texture(VideoBaseTexture.fromVideo(video, scaleMode));
    }
};

/**
 * Helper function that creates a new Texture based on the video url.
 *
 * @static
 * @param videoUrl {string}
 * @param scaleMode {number} See {{@link SCALE_MODES}} for possible values
 * @return {Texture} A Texture
 */
Texture.fromVideoUrl = function (videoUrl, scaleMode)
{
    return new Texture(VideoBaseTexture.fromUrl(videoUrl, scaleMode));
};

/**
 * Adds a texture to the global utils.TextureCache. This cache is shared across the whole PIXI object.
 *
 * @static
 * @param texture {Texture} The Texture to add to the cache.
 * @param id {string} The id that the texture will be stored against.
 */
Texture.addTextureToCache = function (texture, id)
{
    utils.TextureCache[id] = texture;
};

/**
 * Remove a texture from the global utils.TextureCache.
 *
 * @static
 * @param id {string} The id of the texture to be removed
 * @return {Texture} The texture that was removed
 */
Texture.removeTextureFromCache = function (id)
{
    var texture = utils.TextureCache[id];

    delete utils.TextureCache[id];
    delete utils.BaseTextureCache[id];

    return texture;
};

Texture.emptyTexture = new Texture(new BaseTexture());

},{"../math":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/math/index.js","../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js","./BaseTexture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/BaseTexture.js","./TextureUvs":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/TextureUvs.js","./VideoBaseTexture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/VideoBaseTexture.js","eventemitter3":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/eventemitter3/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/TextureUvs.js":[function(require,module,exports){

/**
 * A standard object to store the Uvs of a texture
 *
 * @class
 * @private
 */
function TextureUvs()
{
    this.x0 = 0;
    this.y0 = 0;

    this.x1 = 0;
    this.y1 = 0;

    this.x2 = 0;
    this.y2 = 0;

    this.x3 = 0;
    this.y3 = 0;
}

module.exports = TextureUvs;

/**
 * Sets the texture Uvs based on the given frame information
 * @param frame {Rectangle}
 * @param baseFrame {Rectangle}
 * @param rotate {boolean} Whether or not the frame is rotated
 * @private
 */
TextureUvs.prototype.set = function (frame, baseFrame, rotate)
{
    var tw = baseFrame.width;
    var th = baseFrame.height;

    if(rotate)
    {
        this.x0 = (frame.x + frame.height) / tw;
        this.y0 = frame.y / th;

        this.x1 = (frame.x + frame.height) / tw;
        this.y1 = (frame.y + frame.width) / th;

        this.x2 = frame.x / tw;
        this.y2 = (frame.y + frame.width) / th;

        this.x3 = frame.x / tw;
        this.y3 = frame.y / th;
    }
    else
    {

        this.x0 = frame.x / tw;
        this.y0 = frame.y / th;

        this.x1 = (frame.x + frame.width) / tw;
        this.y1 = frame.y / th;

        this.x2 = (frame.x + frame.width) / tw;
        this.y2 = (frame.y + frame.height) / th;

        this.x3 = frame.x / tw;
        this.y3 = (frame.y + frame.height) / th;
    }
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/VideoBaseTexture.js":[function(require,module,exports){
var BaseTexture = require('./BaseTexture'),
    utils = require('../utils');

/**
 * A texture of a [playing] Video.
 *
 * Video base textures mimic Pixi BaseTexture.from.... method in their creation process.
 *
 * This can be used in several ways, such as:
 *
 * ```js
 * var texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
 *
 * var texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
 *
 * var texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
 *
 * var texture = PIXI.VideoBaseTexture.fromUrls([
 *     { src: '/video.webm', mime: 'video/webm' },
 *     { src: '/video.mp4', mime: 'video/mp4' }
 * ]);
 * ```
 *
 * See the ["deus" demo](http://www.goodboydigital.com/pixijs/examples/deus/).
 *
 * @class
 * @extends BaseTexture
 * @memberof PIXI
 * @param source {HTMLVideoElement}
 * @param [scaleMode] {number} See {@link SCALE_MODES} for possible values
 */
function VideoBaseTexture(source, scaleMode)
{
    if (!source)
    {
        throw new Error('No video source element specified.');
    }

    // hook in here to check if video is already available.
    // BaseTexture looks for a source.complete boolean, plus width & height.

    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height)
    {
        source.complete = true;
    }

    BaseTexture.call(this, source, scaleMode);

    /**
     * Should the base texture automatically update itself, set to true by default
     *
     * @member {boolean}
     * @default true
     */
    this.autoUpdate = false;

    this._onUpdate = this._onUpdate.bind(this);
    this._onCanPlay = this._onCanPlay.bind(this);

    if (!source.complete)
    {
        source.addEventListener('canplay', this._onCanPlay);
        source.addEventListener('canplaythrough', this._onCanPlay);

        // started playing..
        source.addEventListener('play', this._onPlayStart.bind(this));
        source.addEventListener('pause', this._onPlayStop.bind(this));
    }

    this.__loaded = false;
}

VideoBaseTexture.prototype = Object.create(BaseTexture.prototype);
VideoBaseTexture.prototype.constructor = VideoBaseTexture;
module.exports = VideoBaseTexture;

/**
 * The internal update loop of the video base texture, only runs when autoUpdate is set to true
 * @private
 */
VideoBaseTexture.prototype._onUpdate = function ()
{
    if (this.autoUpdate)
    {
        window.requestAnimationFrame(this._onUpdate);
        this.update();
    }
};

/**
 * Runs the update loop when the video is ready to play
 * @private
 */
VideoBaseTexture.prototype._onPlayStart = function ()
{
    if (!this.autoUpdate)
    {
        window.requestAnimationFrame(this._onUpdate);
        this.autoUpdate = true;
    }
};

/**
 * Fired when a pause event is triggered, stops the update loop
 * @private
 */
VideoBaseTexture.prototype._onPlayStop = function ()
{
    this.autoUpdate = false;
};

/**
 * Fired when the video is loaded and ready to play
 * @private
 */
VideoBaseTexture.prototype._onCanPlay = function ()
{
    this.hasLoaded = true;

    if (this.source)
    {
        this.source.removeEventListener('canplay', this._onCanPlay);
        this.source.removeEventListener('canplaythrough', this._onCanPlay);

        this.width = this.source.videoWidth;
        this.height = this.source.videoHeight;

        this.source.play();

        // prevent multiple loaded dispatches..
        if (!this.__loaded)
        {
            this.__loaded = true;
            this.emit('loaded', this);
        }
    }
};

/**
 * Destroys this texture
 *
 */
VideoBaseTexture.prototype.destroy = function ()
{
    if (this.source && this.source._pixiId)
    {
        utils.BaseTextureCache[ this.source._pixiId ] = null;
        delete utils.BaseTextureCache[ this.source._pixiId ];

        this.source._pixiId = null;
        delete this.source._pixiId;
    }

    BaseTexture.prototype.destroy.call(this);
};

/**
 * Mimic Pixi BaseTexture.from.... method.
 *
 * @static
 * @param video {HTMLVideoElement}
 * @param scaleMode {number} See {@link SCALE_MODES} for possible values
 * @return {VideoBaseTexture}
 */
VideoBaseTexture.fromVideo = function (video, scaleMode)
{
    if (!video._pixiId)
    {
        video._pixiId = 'video_' + utils.uuid();
    }

    var baseTexture = utils.BaseTextureCache[video._pixiId];

    if (!baseTexture)
    {
        baseTexture = new VideoBaseTexture(video, scaleMode);
        utils.BaseTextureCache[ video._pixiId ] = baseTexture;
    }

    return baseTexture;
};

/**
 * Helper function that creates a new BaseTexture based on the given video element.
 * This BaseTexture can then be used to create a texture
 *
 * @static
 * @param videoSrc {string|object|string[]|object[]} The URL(s) for the video.
 * @param [videoSrc.src] {string} One of the source urls for the video
 * @param [videoSrc.mime] {string} The mimetype of the video (e.g. 'video/mp4'). If not specified
 *  the url's extension will be used as the second part of the mime type.
 * @param scaleMode {number} See {@link SCALE_MODES} for possible values
 * @return {VideoBaseTexture}
 */
VideoBaseTexture.fromUrl = function (videoSrc, scaleMode)
{
    var video = document.createElement('video');

    // array of objects or strings
    if (Array.isArray(videoSrc))
    {
        for (var i = 0; i < videoSrc.length; ++i)
        {
            video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));
        }
    }
    // single object or string
    else
    {
        video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));
    }

    video.load();
    video.play();

    return VideoBaseTexture.fromVideo(video, scaleMode);
};

VideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;

function createSource(path, type)
{
    if (!type)
    {
        type = 'video/' + path.substr(path.lastIndexOf('.') + 1);
    }

    var source = document.createElement('source');

    source.src = path;
    source.type = type;

    return source;
}

},{"../utils":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js","./BaseTexture":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/textures/BaseTexture.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/PolyK.js":[function(require,module,exports){
//TODO: Have Graphics use https://github.com/mattdesl/shape2d
// and https://github.com/mattdesl/shape2d-triangulate instead of custom code.

/*
    PolyK library
    url: http://polyk.ivank.net
    Released under MIT licence.

    Copyright (c) 2012 Ivan Kuckir

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

    This is an amazing lib!

    Slightly modified by Mat Groves (matgroves.com);
*/

/**
 * Based on the Polyk library http://polyk.ivank.net released under MIT licence.
 * This is an amazing lib!
 * Slightly modified by Mat Groves (matgroves.com);
 *
 * @memberof PIXI.utils
 */
var PolyK = module.exports = {};

/**
 * Triangulates shapes for webGL graphic fills.
 *
 */
PolyK.Triangulate = function (p)
{
    var sign = true;

    var n = p.length >> 1;
    if (n < 3) return [];

    var tgs = [];
    var avl = [];
    for (var i = 0; i < n; i++) avl.push(i);

    i = 0;
    var al = n;
    while (al > 3)
    {
        var i0 = avl[(i+0)%al];
        var i1 = avl[(i+1)%al];
        var i2 = avl[(i+2)%al];

        var ax = p[2*i0],  ay = p[2*i0+1];
        var bx = p[2*i1],  by = p[2*i1+1];
        var cx = p[2*i2],  cy = p[2*i2+1];

        var earFound = false;
        if (PolyK._convex(ax, ay, bx, by, cx, cy, sign))
        {
            earFound = true;
            for (var j = 0; j < al; j++)
            {
                var vi = avl[j];
                if (vi === i0 || vi === i1 || vi === i2) continue;

                if (PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy))
                {
                    earFound = false;
                    break;
                }
            }
        }

        if (earFound)
        {
            tgs.push(i0, i1, i2);
            avl.splice((i+1)%al, 1);
            al--;
            i = 0;
        }
        else if (i++ > 3*al)
        {
            // need to flip flip reverse it!
            // reset!
            if (sign)
            {
                tgs = [];
                avl = [];
                for (i = 0; i < n; i++) avl.push(i);

                i = 0;
                al = n;

                sign = false;
            }
            else
            {
             //   window.console.log("PIXI Warning: shape too complex to fill");
                return null;
            }
        }
    }

    tgs.push(avl[0], avl[1], avl[2]);
    return tgs;
};

/**
 * Checks whether a point is within a triangle
 *
 * @param px {number} x coordinate of the point to test
 * @param py {number} y coordinate of the point to test
 * @param ax {number} x coordinate of the a point of the triangle
 * @param ay {number} y coordinate of the a point of the triangle
 * @param bx {number} x coordinate of the b point of the triangle
 * @param by {number} y coordinate of the b point of the triangle
 * @param cx {number} x coordinate of the c point of the triangle
 * @param cy {number} y coordinate of the c point of the triangle
 * @private
 * @return {boolean}
 */
PolyK._PointInTriangle = function (px, py, ax, ay, bx, by, cx, cy)
{
    var v0x = cx-ax;
    var v0y = cy-ay;
    var v1x = bx-ax;
    var v1y = by-ay;
    var v2x = px-ax;
    var v2y = py-ay;

    var dot00 = v0x*v0x+v0y*v0y;
    var dot01 = v0x*v1x+v0y*v1y;
    var dot02 = v0x*v2x+v0y*v2y;
    var dot11 = v1x*v1x+v1y*v1y;
    var dot12 = v1x*v2x+v1y*v2y;

    var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    // Check if point is in triangle
    return (u >= 0) && (v >= 0) && (u + v < 1);
};

/**
 * Checks whether a shape is convex
 *
 * @private
 * @return {boolean}
 */
PolyK._convex = function (ax, ay, bx, by, cx, cy, sign)
{
    return ((ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0) === sign;
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/index.js":[function(require,module,exports){
var CONST = require('../const');

/**
 * @namespace PIXI.utils
 */
var utils = module.exports = {
    _uid: 0,
    _saidHello: false,

    pluginTarget:   require('./pluginTarget'),
    PolyK:          require('./PolyK'),


    /**
     * Gets the next uuid
     *
     * @return {number} The next uuid to use.
     */
    uuid: function ()
    {
        return ++utils._uid;
    },

    /**
     * Converts a hex color number to an [R, G, B] array
     *
     * @param hex {number}
     * @return {number[]} An array representing the [R, G, B] of the color.
     */
    hex2rgb: function (hex, out)
    {
        out = out || [];

        out[0] = (hex >> 16 & 0xFF) / 255;
        out[1] = (hex >> 8 & 0xFF) / 255;
        out[2] = (hex & 0xFF) / 255;

        return out;
    },

    /**
     * Converts a hex color number to a string.
     *
     * @param hex {number}
     * @return {string} The string color.
     */
    hex2string: function (hex)
    {
        hex = hex.toString(16);
        hex = '000000'.substr(0, 6 - hex.length) + hex;

        return '#' + hex;
    },

    /**
     * Converts a color as an [R, G, B] array to a hex number
     *
     * @param rgb {number[]}
     * @return {number} The color number
     */
    rgb2hex: function (rgb)
    {
        return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);
    },

    /**
     * Checks whether the Canvas BlendModes are supported by the current browser
     *
     * @return {boolean} whether they are supported
     */
    canUseNewCanvasBlendModes: function ()
    {
        if (typeof document === 'undefined')
        {
            return false;
        }

        var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';
        var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';

        var magenta = new Image();
        magenta.src = pngHead + 'AP804Oa6' + pngEnd;

        var yellow = new Image();
        yellow.src = pngHead + '/wCKxvRF' + pngEnd;

        var canvas = document.createElement('canvas');
        canvas.width = 6;
        canvas.height = 1;

        var context = canvas.getContext('2d');
        context.globalCompositeOperation = 'multiply';
        context.drawImage(magenta, 0, 0);
        context.drawImage(yellow, 2, 0);

        var data = context.getImageData(2,0,1,1).data;

        return (data[0] === 255 && data[1] === 0 && data[2] === 0);
    },

    /**
     * Given a number, this function returns the closest number that is a power of two
     * this function is taken from Starling Framework as its pretty neat ;)
     *
     * @param number {number}
     * @return {number} the closest number that is a power of two
     */
    getNextPowerOfTwo: function (number)
    {
        // see: http://en.wikipedia.org/wiki/Power_of_two#Fast_algorithm_to_check_if_a_positive_number_is_a_power_of_two
        if (number > 0 && (number & (number - 1)) === 0)
        {
            return number;
        }
        else
        {
            var result = 1;

            while (result < number)
            {
                result <<= 1;
            }

            return result;
        }
    },

    /**
     * checks if the given width and height make a power of two rectangle
     *
     * @param width {number}
     * @param height {number}
     * @return {boolean}
     */
    isPowerOfTwo: function (width, height)
    {
        return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);
    },

    /**
     * get the resolution of an asset by looking for the prefix
     * used by spritesheets and image urls
     *
     * @param url {string} the image path
     * @return {boolean}
     */
    getResolutionOfUrl: function (url)
    {
        var resolution = CONST.RETINA_PREFIX.exec(url);

        if (resolution)
        {
           return parseFloat(resolution[1]);
        }

        return 1;
    },

    /**
     * Logs out the version and renderer information for this running instance of PIXI.
     * If you don't want to see this message you can set `PIXI.utils._saidHello = true;`
     * so the library thinks it already said it. Keep in mind that doing that will forever
     * makes you a jerk face.
     *
     * @param {string} type - The string renderer type to log.
     * @constant
     * @static
     */
    sayHello: function (type)
    {
        if (utils._saidHello)
        {
            return;
        }

        if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1)
        {
            var args = [
                '\n %c %c %c Pixi.js ' + CONST.VERSION + ' - ✰ ' + type + ' ✰  %c ' + ' %c ' + ' http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n',
                'background: #ff66a5; padding:5px 0;',
                'background: #ff66a5; padding:5px 0;',
                'color: #ff66a5; background: #030307; padding:5px 0;',
                'background: #ff66a5; padding:5px 0;',
                'background: #ffc3dc; padding:5px 0;',
                'background: #ff66a5; padding:5px 0;',
                'color: #ff2424; background: #fff; padding:5px 0;',
                'color: #ff2424; background: #fff; padding:5px 0;',
                'color: #ff2424; background: #fff; padding:5px 0;',
            ];

            window.console.log.apply(console, args); //jshint ignore:line
        }
        else if (window.console)
        {
            window.console.log('Pixi.js ' + CONST.VERSION + ' - ' + type + ' - http://www.pixijs.com/'); //jshint ignore:line
        }

        utils._saidHello = true;
    },

    /**
     * Helper for checking for webgl support
     *
     * @return {boolean}
     */
    isWebGLSupported: function ()
    {
        var contextOptions = { stencil: true };
        try
        {
            if (!window.WebGLRenderingContext)
            {
                return false;
            }

            var canvas = document.createElement('canvas'),
                gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);

            return !!(gl && gl.getContextAttributes().stencil);
        }
        catch (e)
        {
            return false;
        }
    },

    TextureCache: {},
    BaseTextureCache: {}
};

},{"../const":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/const.js","./PolyK":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/PolyK.js","./pluginTarget":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/pluginTarget.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/utils/pluginTarget.js":[function(require,module,exports){
/**
 * Mixins functionality to make an object have "plugins".
 *
 * @mixin
 * @memberof PIXI.utils
 * @param obj {object} The object to mix into.
 * @example
 *      function MyObject() {}
 *
 *      pluginTarget.mixin(MyObject);
 */
function pluginTarget(obj)
{
    obj.__plugins = {};

    /**
     * Adds a plugin to an object
     *
     * @param pluginName {string} The events that should be listed.
     * @param ctor {Object} ?? @alvin
     */
    obj.registerPlugin = function (pluginName, ctor)
    {
        obj.__plugins[pluginName] = ctor;
    };

    /**
     * Instantiates all the plugins of this object
     *
     */
    obj.prototype.initPlugins = function ()
    {
        this.plugins = this.plugins || {};

        for (var o in obj.__plugins)
        {
            this.plugins[o] = new (obj.__plugins[o])(this);
        }
    };

    /**
     * Removes all the plugins of this object
     *
     */
    obj.prototype.destroyPlugins = function ()
    {
        for (var o in this.plugins)
        {
            this.plugins[o].destroy();
            this.plugins[o] = null;
        }

        this.plugins = null;
    };
}


module.exports = {
    /**
     * Mixes in the properties of the pluginTarget into another object
     *
     * @param object {object} The obj to mix into
     */
    mixin: function mixin(obj)
    {
        pluginTarget(obj);
    }
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/deprecation.js":[function(require,module,exports){
/*global console */
var core   = require('./core'),
    mesh   = require('./mesh'),
    extras = require('./extras');

/**
 * @class
 * @name PIXI.SpriteBatch
 * @see {@link PIXI.ParticleContainer}
 * @throws {ReferenceError} SpriteBatch does not exist any more, please use the new ParticleContainer instead.
 */
core.SpriteBatch = function ()
{
    throw new ReferenceError('SpriteBatch does not exist any more, please use the new ParticleContainer instead.');
};

/**
 * @class
 * @name PIXI.AssetLoader
 * @see {@link PIXI.loaders.Loader}
 * @throws {ReferenceError} The loader system was overhauled in pixi v3, please see the new PIXI.Loader class.
 */
core.AssetLoader = function () {
    throw new ReferenceError('The loader system was overhauled in pixi v3, please see the new PIXI.Loader class.');
};

Object.defineProperties(core, {

    /**
     * @class
     * @name PIXI.Stage
     * @see {@link PIXI.Container}
     * @deprecated since version 3.0
     */
    Stage: {
        get: function ()
        {
            console.warn('You do not need to use a PIXI Stage any more, you can simply render any container.');
            return core.Container;
        }
    },

    /**
     * @class
     * @name PIXI.DisplayObjectContainer
     * @see {@link PIXI.Container}
     * @deprecated since version 3.0
     */
    DisplayObjectContainer: {
        get: function ()
        {
            console.warn('DisplayObjectContainer has been shortened to Container, please use Container from now on.');
            return core.Container;
        }
    },

    /**
     * @class
     * @name PIXI.Strip
     * @see {@link PIXI.mesh.Mesh}
     * @deprecated since version 3.0
     */
    Strip: {
        get: function ()
        {
            console.warn('The Strip class has been renamed to Mesh, please use Mesh from now on.');
            return mesh.Mesh;
        }
    }

});

/**
 * @method
 * @name PIXI.Sprite#setTexture
 * @see {@link PIXI.Sprite#texture}
 * @deprecated since version 3.0
 */
core.Sprite.prototype.setTexture = function (texture)
{
    this.texture = texture;
    console.warn('setTexture is now deprecated, please use the texture property, e.g : sprite.texture = texture;');
};

/**
 * @method
 * @name PIXI.extras.BitmapText#setText
 * @see {@link PIXI.BitmapText#text}
 * @deprecated since version 3.0
 */
extras.BitmapText.prototype.setText = function (text)
{
    this.text = text;
    console.warn('setText is now deprecated, please use the text property, e.g : myBitmapText.text = \'my text\';');
};

/**
 * @method
 * @name PIXI.Text#setText
 * @see {@link PIXI.Text#text}
 * @deprecated since version 3.0
 */
core.Text.prototype.setText = function (text)
{
    this.text = text;
    console.warn('setText is now deprecated, please use the text property, e.g : myText.text = \'my text\';');
};

},{"./core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js","./extras":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/index.js","./mesh":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/mesh/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/BitmapText.js":[function(require,module,exports){
var core = require('../core');

/**
 * A BitmapText object will create a line or multiple lines of text using bitmap font. To
 * split a line you can use '\n', '\r' or '\r\n' in your string. You can generate the fnt files using:
 *
 * A BitmapText can only be created when the font is loaded
 *
 * ```js
 * // in this case the font is in a file called 'desyrel.fnt'
 * var bitmapText = new PIXI.BitmapText("text using a fancy font!", {font: "35px Desyrel", align: "right"});
 * ```
 *
 *
 * http://www.angelcode.com/products/bmfont/ for windows or
 * http://www.bmglyph.com/ for mac.
 *
 * @class
 * @extends Container
 * @memberof PIXI.extras
 * @param text {string} The copy that you would like the text to display
 * @param style {object} The style parameters
 * @param style.font {string|object} The font descriptor for the object, can be passed as a string of form
 *      "24px FontName" or "FontName" or as an object with explicit name/size properties.
 * @param [style.font.name] {string} The bitmap font id
 * @param [style.font.size] {number} The size of the font in pixels, e.g. 24
 * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect
 *      single line text
 * @param [style.tint=0xFFFFFF] {number} The tint color
 */
function BitmapText(text, style)
{
    core.Container.call(this);

    /**
     * The width of the overall text, different from fontSize,
     * which is defined in the style object
     *
     * @member {number}
     * @readOnly
     */
    this.textWidth = 0;

    /**
     * The height of the overall text, different from fontSize,
     * which is defined in the style object
     *
     * @member {number}
     * @readOnly
     */
    this.textHeight = 0;

    /**
     * Private tracker for the letter sprite pool.
     *
     * @member {Sprite[]}
     * @private
     */
    this._glyphs = [];

    /**
     * Private tracker for the current style.
     *
     * @member {object}
     * @private
     */
    this._font = {
        tint: style.tint !== undefined ? style.tint : 0xFFFFFF,
        align: style.align || 'left',
        name: null,
        size: 0
    };

    /**
     * Private tracker for the current font.
     *
     * @member {object}
     * @private
     */
    this.font = style.font; // run font setter

    /**
     * Private tracker for the current text.
     *
     * @member {string}
     * @private
     */
    this._text = text;

    /**
     * The max width of this bitmap text in pixels. If the text provided is longer than the value provided, line breaks will be automatically inserted in the last whitespace.
     * Disable by setting value to 0
     *
     * @member {number}
     */
    this.maxWidth = 0;

    /**
     * The dirty state of this object.
     *
     * @member {boolean}
     */
    this.dirty = false;

    this.updateText();
}

// constructor
BitmapText.prototype = Object.create(core.Container.prototype);
BitmapText.prototype.constructor = BitmapText;
module.exports = BitmapText;

Object.defineProperties(BitmapText.prototype, {
    /**
     * The tint of the BitmapText object
     *
     * @member {number}
     * @memberof BitmapText#
     */
    tint: {
        get: function ()
        {
            return this._font.tint;
        },
        set: function (value)
        {
            this._font.tint = (typeof value === 'number' && value >= 0) ? value : 0xFFFFFF;

            this.dirty = true;
        }
    },

    /**
     * The alignment of the BitmapText object
     *
     * @member {string}
     * @default 'left'
     * @memberof BitmapText#
     */
    align: {
        get: function ()
        {
            return this._font.align;
        },
        set: function (value)
        {
            this._font.align = value;

            this.dirty = true;
        }
    },

    /**
     * The font descriptor of the BitmapText object
     *
     * @member {Font}
     * @memberof BitmapText#
     */
    font: {
        get: function ()
        {
            return this._font;
        },
        set: function (value)
        {
            if (typeof value === 'string') {
                value = value.split(' ');

                this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');
                this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;
            }
            else {
                this._font.name = value.name;
                this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);
            }

            this.dirty = true;
        }
    },

    /**
     * The text of the BitmapText object
     *
     * @member {string}
     * @memberof BitmapText#
     */
    text: {
        get: function ()
        {
            return this._text;
        },
        set: function (value)
        {
            this._text = value;

            this.dirty = true;
        }
    }
});

/**
 * Renders text and updates it when needed
 *
 * @private
 */
BitmapText.prototype.updateText = function ()
{
    var data = BitmapText.fonts[this._font.name];
    var pos = new core.math.Point();
    var prevCharCode = null;
    var chars = [];
    var lastLineWidth = 0;
    var maxLineWidth = 0;
    var lineWidths = [];
    var line = 0;
    var scale = this._font.size / data.size;
    var lastSpace = -1;

    for (var i = 0; i < this.text.length; i++)
    {
        var charCode = this.text.charCodeAt(i);
        lastSpace = /(\s)/.test(this.text.charAt(i)) ? i : lastSpace;

        if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i)))
        {
            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            line++;

            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
        }

        if (lastSpace !== -1 && this.maxWidth > 0 && pos.x * scale > this.maxWidth)
        {
            chars.splice(lastSpace, i - lastSpace);
            i = lastSpace;
            lastSpace = -1;

            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            line++;

            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
        }

        var charData = data.chars[charCode];

        if (!charData)
        {
            continue;
        }

        if (prevCharCode && charData.kerning[prevCharCode])
        {
            pos.x += charData.kerning[prevCharCode];
        }

        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new core.math.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});
        lastLineWidth = pos.x + (charData.texture.width + charData.xOffset);
        pos.x += charData.xAdvance;

        prevCharCode = charCode;
    }

    lineWidths.push(lastLineWidth);
    maxLineWidth = Math.max(maxLineWidth, lastLineWidth);

    var lineAlignOffsets = [];

    for (i = 0; i <= line; i++)
    {
        var alignOffset = 0;

        if (this._font.align === 'right')
        {
            alignOffset = maxLineWidth - lineWidths[i];
        }
        else if (this._font.align === 'center')
        {
            alignOffset = (maxLineWidth - lineWidths[i]) / 2;
        }

        lineAlignOffsets.push(alignOffset);
    }

    var lenChars = chars.length;
    var tint = this.tint;

    for (i = 0; i < lenChars; i++)
    {
        var c = this._glyphs[i]; // get the next glyph sprite

        if (c)
        {
            c.texture = chars[i].texture;
        }
        else
        {
            c = new core.Sprite(chars[i].texture);
            this._glyphs.push(c);
        }

        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;
        c.position.y = chars[i].position.y * scale;
        c.scale.x = c.scale.y = scale;
        c.tint = tint;

        if (!c.parent)
        {
            this.addChild(c);
        }
    }

    // remove unnecessary children.
    for (i = lenChars; i < this._glyphs.length; ++i)
    {
        this.removeChild(this._glyphs[i]);
    }

    this.textWidth = maxLineWidth * scale;
    this.textHeight = (pos.y + data.lineHeight) * scale;
};

/**
 * Updates the transform of this object
 *
 * @private
 */
BitmapText.prototype.updateTransform = function ()
{
    if (this.dirty)
    {
        this.updateText();
        this.dirty = false;
    }

    this.containerUpdateTransform();
};

BitmapText.fonts = {};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/MovieClip.js":[function(require,module,exports){
var core    = require('../core'),
    Ticker  = require('./Ticker');

/**
 * A MovieClip is a simple way to display an animation depicted by a list of textures.
 *
 * ```js
 * var alienImages = ["image_sequence_01.png","image_sequence_02.png","image_sequence_03.png","image_sequence_04.png"];
 * var textureArray = [];
 *
 * for (var i=0; i < 4; i++)
 * {
 *      var texture = PIXI.Texture.fromImage(alienImages[i]);
 *      textureArray.push(texture);
 * };
 *
 * var mc = new PIXI.MovieClip(textureArray);
 * ```
 *
 * @class
 * @extends Sprite
 * @memberof PIXI.extras
 * @param textures {Texture[]} an array of {Texture} objects that make up the animation
 */
function MovieClip(textures)
{
    core.Sprite.call(this, textures[0]);

    /**
     * The array of textures that make up the animation
     *
     * @member {Texture[]}
     */
    this._textures = textures;

    /**
     * The speed that the MovieClip will play at. Higher is faster, lower is slower
     *
     * @member {number}
     * @default 1
     */
    this.animationSpeed = 1;

    /**
     * Whether or not the movie clip repeats after playing.
     *
     * @member {boolean}
     * @default true
     */
    this.loop = true;

    /**
     * Function to call when a MovieClip finishes playing
     *
     * @method
     * @memberof MovieClip#
     */
    this.onComplete = null;

    /**
     * The MovieClips current frame index (this may not have to be a whole number)
     *
     * @member {number}
     * @default 0
     * @readonly
     */
    this.currentFrame = 0;

    /**
     * Indicates if the MovieClip is currently playing
     *
     * @member {boolean}
     * @readonly
     */
    this.playing = false;
}

// constructor
MovieClip.prototype = Object.create(core.Sprite.prototype);
MovieClip.prototype.constructor = MovieClip;
module.exports = MovieClip;

Object.defineProperties(MovieClip.prototype, {
    /**
     * totalFrames is the total number of frames in the MovieClip. This is the same as number of textures
     * assigned to the MovieClip.
     *
     * @member
     * @memberof MovieClip#
     * @default 0
     * @readonly
     */
    totalFrames: {
        get: function()
        {
            return this._textures.length;
        }
    },

    /**
     * The array of textures used for this MovieClip
     *
     * @member
     * @memberof MovieClip#
     *
     */
    textures: {
        get: function ()
        {
            return this._textures;
        },
        set: function (value)
        {
            this._textures = value;

            this.texture = this._textures[Math.floor(this.currentFrame) % this._textures.length];
        }
    }

});

/**
 * Stops the MovieClip
 *
 */
MovieClip.prototype.stop = function ()
{
    if(!this.playing)
    {
        return;
    }

    this.playing = false;
    Ticker.off('tick', this.update);
};

/**
 * Plays the MovieClip
 *
 */
MovieClip.prototype.play = function ()
{
    if(this.playing)
    {
        return;
    }

    this.playing = true;
    Ticker.on('tick', this.update, this);
};

/**
 * Stops the MovieClip and goes to a specific frame
 *
 * @param frameNumber {number} frame index to stop at
 */
MovieClip.prototype.gotoAndStop = function (frameNumber)
{
    this.stop();

    this.currentFrame = frameNumber;

    var round = Math.floor(this.currentFrame);
    this.texture = this._textures[round % this._textures.length];
};

/**
 * Goes to a specific frame and begins playing the MovieClip
 *
 * @param frameNumber {number} frame index to start at
 */
MovieClip.prototype.gotoAndPlay = function (frameNumber)
{
    this.currentFrame = frameNumber;
    this.play();
};

/*
 * Updates the object transform for rendering
 * @private
 */
MovieClip.prototype.update = function (deltaTime)
{

    this.currentFrame += this.animationSpeed * deltaTime;

    var floor = Math.floor(this.currentFrame);

    if (floor < 0)
    {
        if (this.loop)
        {
            this.currentFrame += this._textures.length;
            this.texture = this._textures[this.currentFrame];
        }
        else
        {
            this.gotoAndStop(0);

            if (this.onComplete)
            {
                this.onComplete();
            }
        }
    }
    else if (this.loop || floor < this._textures.length)
    {
        this.texture = this._textures[floor % this._textures.length];
    }
    else if (floor >= this._textures.length)
    {
        this.gotoAndStop(this.textures.length - 1);

        if (this.onComplete)
        {
            this.onComplete();
        }
    }
};

/*
 * Stops the MovieClip and destroys it
 *
 */
MovieClip.prototype.destroy = function ( )
{
    this.stop();
    core.Sprite.prototype.destroy.call(this);
};

/**
 * A short hand way of creating a movieclip from an array of frame ids
 *
 * @static
 * @param frames {string[]} the array of frames ids the movieclip will use as its texture frames
 */
MovieClip.fromFrames = function (frames)
{
    var textures = [];

    for (var i = 0; i < frames.length; ++i)
    {
        textures.push(new core.Texture.fromFrame(frames[i]));
    }

    return new MovieClip(textures);
};

/**
 * A short hand way of creating a movieclip from an array of image ids
 *
 * @static
 * @param images {string[]} the array of image urls the movieclip will use as its texture frames
 */
MovieClip.fromImages = function (images)
{
    var textures = [];

    for (var i = 0; i < images.length; ++i)
    {
        textures.push(new core.Texture.fromImage(images[i]));
    }

    return new MovieClip(textures);
};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js","./Ticker":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/Ticker.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/Ticker.js":[function(require,module,exports){
var EventEmitter = require('eventemitter3').EventEmitter;

/**
 * A Ticker class that runs an update loop that other objects listen to
 *
 * @class
 * @memberof PIXI.extras
 */
var Ticker = function()
{
    EventEmitter.call(this);

    this.updateBind = this.update.bind(this);

    /**
     * Whether or not this ticker runs
     *
     * @member {boolean}
     */
    this.active = false;

    /**
     * The deltaTime
     *
     * @member {number}
     */
    this.deltaTime = 1;

    /**
     * The time between two frames
     *
     * @member {number}
     */
    this.timeElapsed = 0;

    /**
     * The time at the last frame
     *
     * @member {number}
     */
    this.lastTime = 0;

    /**
     * The speed
     *
     * @member {number}
     */
    this.speed = 1;

    // auto start ticking!
    this.start();
};

Ticker.prototype = Object.create(EventEmitter.prototype);
Ticker.prototype.constructor = Ticker;

/**
 * Starts the ticker, automatically called by the constructor
 *
 */
Ticker.prototype.start = function()
{
    if(this.active)
    {
        return;
    }

    this.active = true;
    requestAnimationFrame(this.updateBind);
};

/**
 * Stops the ticker
 *
 */
Ticker.prototype.stop = function()
{
    if(!this.active)
    {
        return;
    }

    this.active = false;
};

/**
 * The update loop, fires the 'tick' event
 *
 */
Ticker.prototype.update = function()
{
    if(this.active)
    {
        requestAnimationFrame(this.updateBind);

        var currentTime = new Date().getTime();
        var timeElapsed = currentTime - this.lastTime;

        // cap the time!
        if(timeElapsed > 100)
        {
            timeElapsed = 100;
        }

        this.deltaTime = (timeElapsed * 0.06);

        this.deltaTime *= this.speed;

        this.emit('tick', this.deltaTime);

        this.lastTime = currentTime;
    }

};

module.exports = new Ticker();

},{"eventemitter3":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/eventemitter3/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/TilingSprite.js":[function(require,module,exports){
var core = require('../core'),
    // a sprite use dfor rendering textures..
    tempSprite = new core.Sprite(),
    tempPoint = new core.Point(),
    tempMatrix = new core.Matrix();

/**
 * A tiling sprite is a fast way of rendering a tiling image
 *
 * @class
 * @extends Sprite
 * @memberof PIXI.extras
 * @param texture {Texture} the texture of the tiling sprite
 * @param width {number}  the width of the tiling sprite
 * @param height {number} the height of the tiling sprite
 */
function TilingSprite(texture, width, height)
{
    core.Sprite.call(this, texture);

    /**
     * The scaling of the image that is being tiled
     *
     * @member {Point}
     */
    this.tileScale = new core.math.Point(1,1);


    /**
     * The offset position of the image that is being tiled
     *
     * @member {Point}
     */
    this.tilePosition = new core.math.Point(0,0);

    ///// private

    /**
     * The with of the tiling sprite
     *
     * @member {number}
     * @private
     */
    this._width = width || 100;

    /**
     * The height of the tiling sprite
     *
     * @member {number}
     * @private
     */
    this._height = height || 100;

     /**
     * A point that represents the scale of the texture object
     *
     * @member {Point}
     * @private
     */
    this._tileScaleOffset = new core.math.Point(1,1);


    /**
     *
     *
     * @member {boolean}
     * @private
     */
    this._tilingTexture = null;

    /**
     *
     *
     * @member {boolean}
     * @private
     */
    this._refreshTexture = false;

    /**
     * An internal WebGL UV cache.
     *
     * @member {TextureUvs}
     * @private
     */
    this._uvs = new core.TextureUvs();
}

TilingSprite.prototype = Object.create(core.Sprite.prototype);
TilingSprite.prototype.constructor = TilingSprite;
module.exports = TilingSprite;


Object.defineProperties(TilingSprite.prototype, {
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof TilingSprite#
     */
    width: {
        get: function ()
        {
            return this._width;
        },
        set: function (value)
        {
            this._width = value;
        }
    },

    /**
     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     * @memberof TilingSprite#
     */
    height: {
        get: function ()
        {
            return this._height;
        },
        set: function (value)
        {
            this._height = value;
        }
    }
});

TilingSprite.prototype._onTextureUpdate = function ()
{
    return;
};


/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {WebGLRenderer}
 * @private
 */
TilingSprite.prototype._renderWebGL = function (renderer)
{
    if (!this._tilingTexture || this._refreshTexture)
    {
        this.generateTilingTexture(renderer, this.texture, true);
    }

    // tweak our texture temporarily..
    var texture = this._tilingTexture;

    if(!texture)
    {
        return;
    }


    var uvs = this._uvs;

    this.tilePosition.x %= texture.baseTexture.width / this._tileScaleOffset.x;
    this.tilePosition.y %= texture.baseTexture.height / this._tileScaleOffset.y;

    var offsetX =  this.tilePosition.x/(texture.baseTexture.width / this._tileScaleOffset.x);
    var offsetY =  this.tilePosition.y/(texture.baseTexture.height / this._tileScaleOffset.y);

    var scaleX =  (this._width / texture.baseTexture.width) * this._tileScaleOffset.x;
    var scaleY =  (this._height / texture.baseTexture.height) * this._tileScaleOffset.y;

    scaleX /= this.tileScale.x;
    scaleY /= this.tileScale.y;

    uvs.x0 = 0 - offsetX;
    uvs.y0 = 0 - offsetY;

    uvs.x1 = (1 * scaleX) - offsetX;
    uvs.y1 = 0 - offsetY;

    uvs.x2 = (1 * scaleX) - offsetX;
    uvs.y2 = (1 * scaleY) - offsetY;

    uvs.x3 = 0 - offsetX;
    uvs.y3 = (1 * scaleY) - offsetY;

    var tempUvs = texture._uvs;
    var tempWidth = texture._frame.width;
    var tempHeight = texture._frame.height;

    texture._uvs = uvs;
    texture._frame.width = this.width;
    texture._frame.height = this.height;

    renderer.setObjectRenderer(renderer.plugins.sprite);
    renderer.plugins.sprite.render(this);

    texture._uvs = tempUvs;
    texture._frame.width = tempWidth;
    texture._frame.height = tempHeight;

};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {CanvasRenderer} a reference to the canvas renderer
 * @private
 */
TilingSprite.prototype._renderCanvas = function (renderer)
{
    var context = renderer.context;

    context.globalAlpha = this.worldAlpha;

    var transform = this.worldTransform;

    var resolution = renderer.resolution;

    context.setTransform(transform.a * resolution,
                         transform.b * resolution,
                         transform.c * resolution,
                         transform.d * resolution,
                         transform.tx * resolution,
                         transform.ty * resolution);

    if (!this.__tilePattern ||  this._refreshTexture)
    {
        this.generateTilingTexture(false);

        if (this._tilingTexture)
        {
            this.__tilePattern = context.createPattern(this._tilingTexture.baseTexture.source, 'repeat');
        }
        else
        {
            return;
        }
    }

    // check blend mode
    if (this.blendMode !== renderer.currentBlendMode)
    {
        renderer.currentBlendMode = this.blendMode;
        context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];
    }

    var tilePosition = this.tilePosition;
    var tileScale = this.tileScale;

    tilePosition.x %= this._tilingTexture.baseTexture.width;
    tilePosition.y %= this._tilingTexture.baseTexture.height;

    // offset - make sure to account for the anchor point..
    context.scale(tileScale.x,tileScale.y);
    context.translate(tilePosition.x + (this.anchor.x * -this._width), tilePosition.y + (this.anchor.y * -this._height));

    context.fillStyle = this.__tilePattern;

    context.fillRect(-tilePosition.x,
                    -tilePosition.y,
                    this._width / tileScale.x,
                    this._height / tileScale.y);

    context.translate(-tilePosition.x + (this.anchor.x * this._width), -tilePosition.y + (this.anchor.y * this._height));
    context.scale(1 / tileScale.x, 1 / tileScale.y);
};


/**
 * Returns the framing rectangle of the sprite as a Rectangle object
*
 * @return {Rectangle} the framing rectangle
 */
TilingSprite.prototype.getBounds = function ()
{
    var width = this._width;
    var height = this._height;

    var w0 = width * (1-this.anchor.x);
    var w1 = width * -this.anchor.x;

    var h0 = height * (1-this.anchor.y);
    var h1 = height * -this.anchor.y;

    var worldTransform = this.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.b;
    var c = worldTransform.c;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var x1 = a * w1 + c * h1 + tx;
    var y1 = d * h1 + b * w1 + ty;

    var x2 = a * w0 + c * h1 + tx;
    var y2 = d * h1 + b * w0 + ty;

    var x3 = a * w0 + c * h0 + tx;
    var y3 = d * h0 + b * w0 + ty;

    var x4 =  a * w1 + c * h0 + tx;
    var y4 =  d * h0 + b * w1 + ty;

    var minX,
        maxX,
        minY,
        maxY;

    minX = x1;
    minX = x2 < minX ? x2 : minX;
    minX = x3 < minX ? x3 : minX;
    minX = x4 < minX ? x4 : minX;

    minY = y1;
    minY = y2 < minY ? y2 : minY;
    minY = y3 < minY ? y3 : minY;
    minY = y4 < minY ? y4 : minY;

    maxX = x1;
    maxX = x2 > maxX ? x2 : maxX;
    maxX = x3 > maxX ? x3 : maxX;
    maxX = x4 > maxX ? x4 : maxX;

    maxY = y1;
    maxY = y2 > maxY ? y2 : maxY;
    maxY = y3 > maxY ? y3 : maxY;
    maxY = y4 > maxY ? y4 : maxY;

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    this._currentBounds = bounds;

    return bounds;
};

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @param event
 * @private
 */
TilingSprite.prototype.onTextureUpdate = function ()
{
   // overriding the sprite version of this!
};

/**
 * Creates the tiling texture
 * @param renderer {CanvasRenderer|WebGLRenderer} a reference to the current renderer
 * @param texture {Texture} The texture to use to generate the tiling texture
 * @param forcePowerOfTwo {boolean} Whether we want to force the texture to be a power of two
 */
TilingSprite.prototype.generateTilingTexture = function (renderer, texture, forcePowerOfTwo)
{
    if (!this.texture.baseTexture.hasLoaded)
    {
        return;
    }

    texture = this.originalTexture || this._texture;
    var frame = texture.frame;
    var targetWidth, targetHeight;

    //  Check that the frame is the same size as the base texture.
    var isFrame = frame.width !== texture.baseTexture.width || frame.height !== texture.baseTexture.height;

    if ((forcePowerOfTwo && !texture.baseTexture.isPowerOfTwo) || isFrame)
    {
        targetWidth = core.utils.getNextPowerOfTwo(frame.width);
        targetHeight = core.utils.getNextPowerOfTwo(frame.height);
        tempSprite.texture = texture;

        //TODO not create a new one each time you refresh
        var renderTexture = new core.RenderTexture(renderer, targetWidth, targetHeight, texture.baseTexture.scaleMode, texture.baseTexture.resolution);

        var cachedRenderTarget = renderer.currentRenderTarget;

        var m = tempMatrix;
        m.a =  (targetWidth + 1) / (frame.width);
        m.d =   (targetHeight + 1) / (frame.height);

        tempSprite.worldTransform.tx -= 0.5;
        tempSprite.worldTransform.ty -= 0.5;

        renderer.currentRenderer.flush();

        renderTexture.render( tempSprite, m, true, false );

        renderer.setRenderTarget(cachedRenderTarget);


        this._tileScaleOffset.x = targetWidth / frame.width;
        this._tileScaleOffset.y = targetHeight / frame.height;

        this._tilingTexture = renderTexture;
    }
    else
    {
        if (this._tilingTexture && this._tilingTexture.isTiling)
        {
            // destroy the tiling texture!
            // TODO could store this somewhere?
            this._tilingTexture.destroy(true);
        }

        this._tileScaleOffset.x = 1;
        this._tileScaleOffset.y = 1;
        this._tilingTexture = texture;

    }


    this._refreshTexture = false;

    this.originalTexture = this.texture;
    this._texture = this._tilingTexture;

};

/**
 * Checks if a point is inside this tiling sprite
 * @param point {Point} the point to check
 */
TilingSprite.prototype.containsPoint = function( point )
{
    this.worldTransform.applyInverse(point,  tempPoint);

    var width = this._width;
    var height = this._height;
    var x1 = -width * this.anchor.x;
    var y1;

    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )
    {
        y1 = -height * this.anchor.y;

        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )
        {
            return true;
        }
    }

    return false;
};

/**
 * Destroys this tiling sprite
 *
 */
TilingSprite.prototype.destroy = function () {
    core.Sprite.prototype.destroy.call(this);

    this.tileScale = null;
    this._tileScaleOffset = null;
    this.tilePosition = null;

    this._tilingTexture.destroy(true);
    this._tilingTexture = null;

    this._uvs = null;
};

/**
 * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId
 * The frame ids are created when a Texture packer file has been loaded
 *
 * @static
 * @param frameId {String} The frame Id of the texture in the cache
 * @return {TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId
 * @param width {number}  the width of the tiling sprite
 * @param height {number} the height of the tiling sprite
 */
TilingSprite.fromFrame = function (frameId,width,height)
{
    var texture = core.utils.TextureCache[frameId];

    if (!texture)
    {
        throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ' + this);
    }

    return new TilingSprite(texture,width,height);
};

/**
 * Helper function that creates a sprite that will contain a texture based on an image url
 * If the image is not in the texture cache it will be loaded
 *
 * @static
 * @param imageId {String} The image url of the texture
 * @param width {number}  the width of the tiling sprite
 * @param height {number} the height of the tiling sprite
 * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter
 * @param [scaleMode=scaleModes.DEFAULT] {number} if you want to specify the scale mode, see {@link SCALE_MODES} for possible values
 * @return {TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id
 */
TilingSprite.fromImage = function (imageId, width, height, crossorigin, scaleMode)
{
    return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode),width,height);
};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/cacheAsBitmap.js":[function(require,module,exports){
var core = require('../core'),
    DisplayObject = core.DisplayObject,
    _tempMatrix = new core.Matrix();

DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._originalRenderWebGL = null;
DisplayObject.prototype._originalRenderCanvas = null;

DisplayObject.prototype._originalUpdateTransform = null;
DisplayObject.prototype._originalHitTest = null;
DisplayObject.prototype._cachedSprite = null;

Object.defineProperties(DisplayObject.prototype, {

    /**
     * Set this to true if you want this display object to be cached as a bitmap.
     * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects.
     * To remove simply set this property to 'null'
     *
     * @member {boolean}
     * @memberof DisplayObject#
     */
    cacheAsBitmap: {
        get: function ()
        {
            return this._cacheAsBitmap;
        },
        set: function (value)
        {
            if(this._cacheAsBitmap === value)
            {
                return;
            }

            this._cacheAsBitmap = value;

            if(value)
            {
                this._originalRenderWebGL = this.renderWebGL;
                this._originalRenderCanvas = this.renderCanvas;

                this._originalUpdateTransform = this.updateTransform;
                this._originalGetBounds = this.getBounds;


                this._originalContainesPoint = this.containsPoint;

                this.renderWebGL = this._renderCachedWebGL;
                this.renderCanvas = this._renderCachedCanvas;



            }
            else
            {
                if(this._cachedSprite)
                {
                    this._destroyCachedDisplayObject();
                }

                this.renderWebGL = this._originalRenderWebGL;
                this.renderCanvas = this._originalRenderCanvas;
                this.getBounds = this._originalGetBounds;

                this.updateTransform = this._originalUpdateTransform;
                this.containsPoint = this._originalContainsPoint;
            }
        }
    }
});
/**
* Renders a cached version of the sprite with WebGL
*
* @param renderer {WebGLRenderer} the WebGL renderer
* @private
*/
DisplayObject.prototype._renderCachedWebGL = function(renderer)
{
    this._initCachedDisplayObject( renderer );

    this._cachedSprite.worldAlpha = this.worldAlpha;

    renderer.setObjectRenderer(renderer.plugins.sprite);
    renderer.plugins.sprite.render( this._cachedSprite );
};

/**
* Prepares the WebGL renderer to cache the sprite
*
* @param renderer {WebGLRenderer} the WebGL renderer
* @private
*/
DisplayObject.prototype._initCachedDisplayObject = function( renderer )
{
    if(this._cachedSprite)
    {
        return;
    }


    // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)
    renderer.currentRenderer.flush();
    //this.filters= [];
    // next we find the dimensions of the untransformed object
    // this function also calls updatetransform on all its children as part of the measuring. This means we don't need to update the transform again in this function
    // TODO pass an object to clone too? saves having to create a new one each time!
    var bounds = this.getLocalBounds().clone();

    // add some padding!
    if(this._filters)
    {
        var padding = this._filters[0].padding;
        bounds.x -= padding;
        bounds.y -= padding;

        bounds.width += padding * 2;
        bounds.height += padding * 2;
    }

    // for now we cache the current renderTarget that the webGL renderer is currently using.
    // this could be more elegent..
    var cachedRenderTarget = renderer.currentRenderTarget;
    // We also store the filter stack - I will definitely look to change how this works a little later down the line.
    var stack = renderer.filterManager.filterStack;

    // this renderTexture will be used to store the cached DisplayObject
    var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);

    // need to set //
    var m = _tempMatrix;

    m.tx = -bounds.x;
    m.ty = -bounds.y;



    // set all properties to there original so we can render to a texture
    this.renderWebGL = this._originalRenderWebGL;

    renderTexture.render(this, m, true);

    // now restore the state be setting the new properties
    renderer.setRenderTarget(cachedRenderTarget);
    renderer.filterManager.filterStack = stack;

    this.renderWebGL     = this._renderCachedWebGL;
    this.updateTransform = this.displayObjectUpdateTransform;
    this.getBounds       = this._getCachedBounds;


    // create our cached sprite
    this._cachedSprite = new core.Sprite(renderTexture);
    this._cachedSprite.worldTransform = this.worldTransform;
    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );

    // map the hit test..
    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);
};

/**
* Renders a cached version of the sprite with canvas
*
* @param renderer {CanvasRenderer} the Canvas renderer
* @private
*/
DisplayObject.prototype._renderCachedCanvas = function(renderer)
{
    this._initCachedDisplayObjectCanvas( renderer );

    this._cachedSprite.worldAlpha = this.worldAlpha;

    this._cachedSprite.renderCanvas(renderer);
};

//TODO this can be the same as the webGL verison.. will need to do a little tweaking first though..
/**
* Prepares the Canvas renderer to cache the sprite
*
* @param renderer {CanvasRenderer} the Canvas renderer
* @private
*/
DisplayObject.prototype._initCachedDisplayObjectCanvas = function( renderer )
{
    if(this._cachedSprite)
    {
        return;
    }

    //get bounds actually transforms the object for us already!
    var bounds = this.getLocalBounds();

    var cachedRenderTarget = renderer.context;

    var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);

    // need to set //
    var m = _tempMatrix;

    m.tx = -bounds.x;
    m.ty = -bounds.y;

    // set all properties to there original so we can render to a texture
    this.renderCanvas = this._originalRenderCanvas;

    renderTexture.render(this, m, true);

    // now restore the state be setting the new properties
    renderer.context = cachedRenderTarget;

    this.renderCanvas = this._renderCachedCanvas;
    this.updateTransform = this.displayObjectUpdateTransform;
    this.getBounds  = this._getCachedBounds;


    // create our cached sprite
    this._cachedSprite = new core.Sprite(renderTexture);
    this._cachedSprite.worldTransform = this.worldTransform;
    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );
    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );
    this.hitTest = this._cachedSprite.hitTest.bind(this._cachedSprite);
};

/**
* Calculates the bounds of the cached sprite
*
* @private
*/
DisplayObject.prototype._getCachedBounds = function()
{
    this._cachedSprite._currentBounds = null;

    return this._cachedSprite.getBounds();
};

/**
* Destroys the cached sprite.
*
* @private
*/
DisplayObject.prototype._destroyCachedDisplayObject = function()
{
    this._cachedSprite._texture.destroy();
    this._cachedSprite = null;
};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/getChildByName.js":[function(require,module,exports){
var core = require('../core');

/**
 * The instance name of the object.
 *
 * @member {string}
 */
core.DisplayObject.prototype.name = null;

/**
* Returns the display object in the container
*
* @param name {string} instance name
* @return {DisplayObject}
*/
core.Container.prototype.getChildByName = function (name)
{
    for (var i = 0; i < this.children.length; i++) 
    {
        if (this.children[i].name === name) 
        {
            return this.children[i];
        }
    }
    return null;
};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/getGlobalPosition.js":[function(require,module,exports){
var core = require('../core');

/**
* Returns the global position of the displayObject
*
* @param point {Point} the point to write the global value to. If null a new point will be returned
* @return {Point}
*/
core.DisplayObject.prototype.getGlobalPosition = function (point)
{
    point = point || new core.Point();

    if(this.parent)
    {
        this.displayObjectUpdateTransform();

        point.x = this.worldTransform.tx;
        point.y = this.worldTransform.ty;
    }
    else
    {
        point.x = this.position.x;
        point.y = this.position.y;
    }

    return point;
};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/index.js":[function(require,module,exports){
/**
 * @file        Main export of the PIXI extras library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}
 */

require('./cacheAsBitmap');
require('./getChildByName');
require('./getGlobalPosition');

/**
 * @namespace PIXI.extras
 */
module.exports = {
    Ticker:         require('./Ticker'),
    MovieClip:      require('./MovieClip'),
    TilingSprite:   require('./TilingSprite'),
    BitmapText:     require('./BitmapText'),
};

},{"./BitmapText":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/BitmapText.js","./MovieClip":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/MovieClip.js","./Ticker":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/Ticker.js","./TilingSprite":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/TilingSprite.js","./cacheAsBitmap":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/cacheAsBitmap.js","./getChildByName":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/getChildByName.js","./getGlobalPosition":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/getGlobalPosition.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/ascii/AsciiFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


// TODO (cengler) - The Y is flipped in this shader for some reason.

/**
 * @author Vico @vicocotea
 * original shader : https://www.shadertoy.com/view/lssGDj by @movAX13h
 */

/**
 * An ASCII filter.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function AsciiFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nuniform vec4 dimensions;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\n    if (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\n    {\n        if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy;\n\n    vec3 col = texture2D(uSampler, floor( uv / pixelSize ) * pixelSize / dimensions.xy).rgb;\n\n    float gray = (col.r + col.g + col.b) / 3.0;\n\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    vec2 p = mod( uv / ( pixelSize * 0.5 ), 2.0) - vec2(1.0);\n    col = col * character(n, p);\n\n    gl_FragColor = vec4(col, 1.0);\n}\n",
        // custom uniforms
        {
            dimensions: { type: '4fv', value: new Float32Array([0, 0, 0, 0]) },
            pixelSize:  { type: '1f', value: 8 }
        }
    );
}

AsciiFilter.prototype = Object.create(core.AbstractFilter.prototype);
AsciiFilter.prototype.constructor = AsciiFilter;
module.exports = AsciiFilter;

Object.defineProperties(AsciiFilter.prototype, {
    /**
     * The pixel size used by the filter.
     *
     * @member {number}
     * @memberof AsciiFilter#
     */
    size: {
        get: function ()
        {
            return this.uniforms.pixelSize.value;
        },
        set: function (value)
        {
            this.uniforms.pixelSize.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/bloom/BloomFilter.js":[function(require,module,exports){
var core = require('../../core'),
    BlurXFilter = require('../blur/BlurXFilter'),
    BlurYFilter = require('../blur/BlurYFilter');

/**
 * The BloomFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function BloomFilter()
{
    core.AbstractFilter.call(this);

    this.blurXFilter = new BlurXFilter();
    this.blurYFilter = new BlurYFilter();

    this.defaultFilter = new core.AbstractFilter();
}

BloomFilter.prototype = Object.create(core.AbstractFilter.prototype);
BloomFilter.prototype.constructor = BloomFilter;
module.exports = BloomFilter;

BloomFilter.prototype.applyFilter = function (renderer, input, output)
{
    var renderTarget = renderer.filterManager.getRenderTarget(true);

    //TODO - copyTexSubImage2D could be used here?
    this.defaultFilter.applyFilter(renderer, input, output);

    this.blurXFilter.applyFilter(renderer, input, renderTarget);

    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.SCREEN);

    this.blurYFilter.applyFilter(renderer, renderTarget, output);

    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.NORMAL);

    renderer.filterManager.returnRenderTarget(renderTarget);
};

Object.defineProperties(BloomFilter.prototype, {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @memberOf BloomFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = this.blurYFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @memberOf BloomFilter#
     * @default 2
     */
    blurX: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @memberOf BloomFilter#
     * @default 2
     */
    blurY: {
        get: function ()
        {
            return this.blurYFilter.blur;
        },
        set: function (value)
        {
            this.blurYFilter.blur = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js","../blur/BlurXFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/BlurXFilter.js","../blur/BlurYFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/BlurYFilter.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/BlurFilter.js":[function(require,module,exports){
var core = require('../../core'),
    BlurXFilter = require('./BlurXFilter'),
    BlurYFilter = require('./BlurYFilter');

/**
 * The BlurFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function BlurFilter()
{
    core.AbstractFilter.call(this);

    this.blurXFilter = new BlurXFilter();
    this.blurYFilter = new BlurYFilter();
}

BlurFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurFilter.prototype.constructor = BlurFilter;
module.exports = BlurFilter;

BlurFilter.prototype.applyFilter = function (renderer, input, output)
{
    var renderTarget = renderer.filterManager.getRenderTarget(true);

    this.blurXFilter.applyFilter(renderer, input, renderTarget);
    this.blurYFilter.applyFilter(renderer, renderTarget, output);

    renderer.filterManager.returnRenderTarget(renderTarget);


};

Object.defineProperties(BlurFilter.prototype, {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @memberOf BlurFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.padding = value * 0.5;
            this.blurXFilter.blur = this.blurYFilter.blur = value;
        }
    },

    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @memberof BlurYFilter#
     * @default 1
     */
    passes: {
        get: function ()
        {
            return  this.blurXFilter.passes;
        },
        set: function (value)
        {
            this.blurXFilter.passes = this.blurYFilter.passes = value;
        }
    },

    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @memberOf BlurFilter#
     * @default 2
     */
    blurX: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @memberOf BlurFilter#
     * @default 2
     */
    blurY: {
        get: function ()
        {
            return this.blurYFilter.blur;
        },
        set: function (value)
        {
            this.blurYFilter.blur = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js","./BlurXFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/BlurXFilter.js","./BlurYFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/BlurYFilter.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/BlurXFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The BlurXFilter applies a horizontal Gaussian blur to an object.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function BlurXFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(-0.012 * strength, 0.0);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(-0.008 * strength, 0.0);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(-0.004 * strength, 0.0);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2( 0.004 * strength, 0.0);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2( 0.008 * strength, 0.0);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2( 0.012 * strength, 0.0);\n\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
        // fragment shader
        "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n}\n",
        // set the uniforms
        {
            strength: { type: '1f', value: 1 }
        }
    );

    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @memberof BlurXFilter#
     * @default 1
     */
    this.passes = 1;

    this.strength = 4;
}

BlurXFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurXFilter.prototype.constructor = BlurXFilter;
module.exports = BlurXFilter;

BlurXFilter.prototype.applyFilter = function (renderer, input, output, clear)
{
    var shader = this.getShader(renderer);

    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.width / input.size.width);

    if(this.passes === 1)
    {
        renderer.filterManager.applyFilter(shader, input, output, clear);
    }
    else
    {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        var flip = input;
        var flop = renderTarget;

        for(var i = 0; i < this.passes-1; i++)
        {
            renderer.filterManager.applyFilter(shader, flip, flop, clear);

           var temp = flop;
           flop = flip;
           flip = temp;
        }

        renderer.filterManager.applyFilter(shader, flip, output, clear);

        renderer.filterManager.returnRenderTarget(renderTarget);
    }
};


Object.defineProperties(BlurXFilter.prototype, {
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @memberof BlurXFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return  this.strength;
        },
        set: function (value)
        {
            this.padding = value * 0.5;
            this.strength = value;
        }
    },
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/BlurYFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The BlurYFilter applies a horizontal Gaussian blur to an object.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function BlurYFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(0.0, -0.012 * strength);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(0.0, -0.008 * strength);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(0.0, -0.004 * strength);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2(0.0,  0.004 * strength);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2(0.0,  0.008 * strength);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2(0.0,  0.012 * strength);\n\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
        // fragment shader
        "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n}\n",
        // set the uniforms
        {
            strength: { type: '1f', value: 1 }
        }
    );

    this.passes = 1;
    this.strength = 4;
}

BlurYFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurYFilter.prototype.constructor = BlurYFilter;
module.exports = BlurYFilter;

BlurYFilter.prototype.applyFilter = function (renderer, input, output, clear)
{
    var shader = this.getShader(renderer);

    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.height / input.size.height);

    if(this.passes === 1)
    {
        renderer.filterManager.applyFilter(shader, input, output, clear);
    }
    else
    {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        var flip = input;
        var flop = renderTarget;

        for(var i = 0; i < this.passes-1; i++)
        {
            renderer.filterManager.applyFilter(shader, flip, flop, clear);

           var temp = flop;
           flop = flip;
           flip = temp;
        }

        renderer.filterManager.applyFilter(shader, flip, output, clear);

        renderer.filterManager.returnRenderTarget(renderTarget);
    }
};


Object.defineProperties(BlurYFilter.prototype, {
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @memberof BlurYFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return  this.strength;
        },
        set: function (value)
        {
            this.padding = value * 0.5;
            this.strength = value;
        }
    },
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/SmartBlurFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * A Smart Blur Filter.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function SmartBlurFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nconst vec2 delta = vec2(1.0/10.0, 0.0);\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta * percent);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n"
    );
}

SmartBlurFilter.prototype = Object.create(core.AbstractFilter.prototype);
SmartBlurFilter.prototype.constructor = SmartBlurFilter;
module.exports = SmartBlurFilter;

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/color/ColorMatrixFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The ColorMatrixFilter class lets you apply a 5x5 matrix transformation on the RGBA
 * color and alpha values of every pixel on your displayObject to produce a result
 * with a new set of RGBA color and alpha values. It's pretty powerful!
 *
 * ```js
 *  var colorMatrix = new PIXI.ColorMatrixFilter();
 *  container.filters = [colorMatrix];
 *  colorMatrix.contrast(2);
 * ```
 * @author Clément Chenebault <clement@goodboydigital.com>
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function ColorMatrixFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float m[24];\n\nuniform vec4 d;\n\nvoid main(void)\n{\n    \n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n\tgl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];\n\tgl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];\n\tgl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];\n\tgl_FragColor.a = c.a;\n}\n",
        // custom uniforms
        {
            m: { type: '1fv', value: [1, 0, 0, 0, 0,
                                    0, 1, 0, 0, 0,
                                    0, 0, 1, 0, 0,
                                    0, 0, 0, 1, 0,
                                    0, 0, 0, 0, 1] },
        }
    );
}

ColorMatrixFilter.prototype = Object.create(core.AbstractFilter.prototype);
ColorMatrixFilter.prototype.constructor = ColorMatrixFilter;
module.exports = ColorMatrixFilter;


/**
 * Transforms current matrix and set the new one
 *
 * @param matrix {array} (mat 5x5)
 * @param multiply {boolean} if true, current matrix and matrix are multiplied. If false, just set the current matrix with @param matrix
 */
ColorMatrixFilter.prototype._loadMatrix = function(matrix, multiply)
{
    multiply = !!multiply;

    var newMatrix = matrix;

    if(multiply)
    {
        this._multiply(newMatrix, this.uniforms.m.value, matrix);
        newMatrix = this._colorMatrix(newMatrix);
    }

    // set the new matrix
    this.uniforms.m.value = newMatrix;
};

/**
 * Multiplies two mat5's
 *
 * @param out {array} (mat 5x5) the receiving matrix
 * @param a {array} (mat 5x5) the first operand
 * @param b {array} (mat 5x5) the second operand
 * @returns out {array} (mat 5x5)
 */
ColorMatrixFilter.prototype._multiply = function (out, a, b) {

    // first line
    out[0] = a[0]*b[0] + a[1]*b[5] + a[2]*b[10] + a[3]*b[15] + a[4]*b[20];
    out[1] = a[0]*b[1] + a[1]*b[6] + a[2]*b[11] + a[3]*b[16] +a[4]*b[21];
    out[2] = a[0]*b[2] + a[1]*b[7] + a[2]*b[12] + a[3]*b[17] +a[4]*b[22];
    out[3] = a[0]*b[3] + a[1]*b[8] + a[2]*b[13] + a[3]*b[18] +a[4]*b[23];
    out[4] = a[0]*b[4] + a[1]*b[9] + a[2]*b[14] + a[3]*b[19]+a[4]*b[24];

    // second line
    out[5] = a[5]*b[0] + a[6]*b[5] + a[7]*b[10]+ a[8]*b[15]+a[9]*b[20];
    out[6] = a[5]*b[1] + a[6]*b[6] + a[7]*b[11]+ a[8]*b[16]+a[9]*b[21];
    out[7] = a[5]*b[2] + a[6]*b[7] + a[7]*b[12]+ a[8]*b[17]+a[9]*b[22];
    out[8] = a[5]*b[3] + a[6]*b[8] + a[7]*b[13]+ a[8]*b[18]+a[9]*b[23];
    out[9] = a[5]*b[4] + a[6]*b[9] + a[7]*b[14]+ a[8]*b[19]+a[9]*b[24];

    // third line
    out[10] = a[10]*b[0] + a[11]*b[5] + a[12]*b[10]+ a[13]*b[15]+a[14]*b[20];
    out[11] = a[10]*b[1] + a[11]*b[6] + a[12]*b[11]+ a[13]*b[16]+a[14]*b[21];
    out[12] = a[10]*b[2] + a[11]*b[7] + a[12]*b[12]+ a[13]*b[17]+a[14]*b[22];
    out[13] = a[10]*b[3] + a[11]*b[8] + a[12]*b[13]+ a[13]*b[18]+a[14]*b[23];
    out[14] = a[10]*b[4] + a[11]*b[9] + a[12]*b[14]+ a[13]*b[19]+a[14]*b[24];

    // fourth line
    out[15] = a[15]*b[0] + a[16]*b[5] + a[17]*b[10]+ a[18]*b[15]+a[19]*b[20];
    out[16] = a[15]*b[1] + a[16]*b[6] + a[17]*b[11]+ a[18]*b[16]+a[19]*b[21];
    out[17] = a[15]*b[2] + a[16]*b[7] + a[17]*b[12]+ a[18]*b[17]+a[19]*b[22];
    out[18] = a[15]*b[3] + a[16]*b[8] + a[17]*b[13]+ a[18]*b[18]+a[19]*b[23];
    out[19] = a[15]*b[4] + a[16]*b[9] + a[17]*b[14]+ a[18]*b[19]+a[19]*b[24];

    // fifth line
    out[20] = a[20]*b[0] + a[21]*b[5] + a[22]*b[10]+ a[23]*b[15]+a[24]*b[20];
    out[21] = a[20]*b[1] + a[21]*b[6] + a[22]*b[11]+ a[23]*b[16]+a[24]*b[21];
    out[22] = a[20]*b[2] + a[21]*b[7] + a[22]*b[12]+ a[23]*b[17]+a[24]*b[22];
    out[23] = a[20]*b[3] + a[21]*b[8] + a[22]*b[13]+ a[23]*b[18]+a[24]*b[23];
    out[24] = a[20]*b[4] + a[21]*b[9] + a[22]*b[14]+ a[23]*b[19]+a[24]*b[24];

    return out;
};

/**
 * Create a Float32 Array and normalize the offset component to 0-1
 *
 * @param matrix {array} (mat 5x5)
 * @return m { array } (mat 5x5) with all values between 0-1
 */
ColorMatrixFilter.prototype._colorMatrix = function( matrix )
{
    // Create a Float32 Array and normalize the offset component to 0-1
    var m = new Float32Array(matrix);
    m[4] /= 255;
    m[9] /= 255;
    m[14] /= 255;
    m[19] /= 255;

    return m;
};

/**
 * Adjusts brightness
 *
 * Multiply the current matrix
 * @param b {number} value of the brigthness (0 is black)
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.brightness = function(b, multiply)
{
    var matrix = [
        b, 0, 0, 0, 0,
        0, b, 0, 0, 0,
        0, 0, b, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1
    ];


    this._loadMatrix(matrix, multiply);
};

/**
 * Set the matrices in grey scales
 *
 * Multiply the current matrix
 * @param scale {number} value of the grey (0 is black)
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.greyscale = function(scale, multiply)
{
    var matrix = [
        scale, scale, scale, 0, 0,
        scale, scale, scale, 0, 0,
        scale, scale, scale, 0, 0,
        0,0,0,1,0,
        0,0,0,0,1
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Set the black and white matrice
 * Multiply the current matrix
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.blackAndWhite = function(multiply)
{
    var matrix = [
        0.3, 0.6, 0.1, 0, 0,
        0.3, 0.6, 0.1, 0, 0,
        0.3, 0.6, 0.1, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Set the hue propertie of the color
 *
 * Multiply the current matrix
 * @param rotation {number} in degrees
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.hue = function(rotation, multiply)
{
    rotation = (rotation || 0)/180 * Math.PI;
    var cos = Math.cos(rotation),
        sin = Math.sin(rotation);

    // luminanceRed, luminanceGreen, luminanceBlue
    var lumR = 0.213, // or 0.3086
        lumG = 0.715, // or 0.6094
        lumB = 0.072; // or 0.0820

    var matrix = [
        lumR+cos*(1-lumR)+sin*(-lumR), lumG+cos*(-lumG)+sin*(-lumG), lumB+cos*(-lumB)+sin*(1-lumB), 0, 0,
        lumR+cos*(-lumR)+sin*(0.143), lumG+cos*(1-lumG)+sin*(0.140), lumB+cos*(-lumB)+sin*(-0.283), 0, 0,
        lumR+cos*(-lumR)+sin*(-(1-lumR)), lumG+cos*(-lumG)+sin*(lumG), lumB+cos*(1-lumB)+sin*(lumB), 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1
    ];

    this._loadMatrix(matrix, multiply);
};


/**
 * Set the contrast matrix, increase the separation between dark and bright
 * Increase contrast : shadows darker and highlights brighter
 * Decrease contrast : bring the shadows up and the highlights down
 *
 * @param amount {number} value of the contrast
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.contrast = function(amount, multiply)
{
    var v = (amount || 0) + 1;
    var o = -128 * (v-1);

    var matrix = [
        v, 0, 0, 0, o,
        0, v, 0, 0, o,
        0, 0, v, 0, o,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Set the saturation matrix, increase the separation between colors
 * Increase saturation : increase contrast, brightness, and sharpness
 * @param amount {number}
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.saturation = function(amount, multiply)
{
    var x = (amount || 0) * 2/3 + 1;
    var y = ((x-1) *-0.5);

    var matrix = [
        x, y, y, 0, 0,
        y, x, y, 0, 0,
        y, y, x, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Desaturate image (remove color)
 *
 * Call the saturate function
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.desaturate = function(multiply) // jshint unused:false
{
    this.saturation(-1);
};

/**
 * Negative image (inverse of classic rgb matrix)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.negative = function(multiply)
{
    var matrix = [
        0, 1, 1, 0, 0,
        1, 0, 1, 0, 0,
        1, 1, 0, 0, 0,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 1
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Sepia image
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.sepia = function(multiply)
{
  var matrix = [
      0.393, 0.7689999, 0.18899999, 0, 0,
      0.349, 0.6859999, 0.16799999, 0, 0,
      0.272, 0.5339999, 0.13099999, 0, 0,
      0, 0, 0, 1, 0,
      0, 0, 0, 0, 1];

  this._loadMatrix(matrix, multiply);
};

/**
 * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.technicolor = function(multiply)
{
  var matrix = [
      1.9125277891456083,-0.8545344976951645,-0.09155508482755585,0,11.793603434377337,
      -0.3087833385928097,1.7658908555458428,-0.10601743074722245,0,-70.35205161461398,
      -0.231103377548616,-0.7501899197440212,1.847597816108189,0,30.950940869491138,
      0, 0, 0, 1, 0,
      0, 0, 0, 0, 0];

  this._loadMatrix(matrix, multiply);
};

/**
 * Polaroid filter
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.polaroid = function(multiply)
{
  var matrix = [
      1.438,-0.062,-0.062,0,0,
      -0.122,1.378,-0.122,0,0,
      -0.016,-0.016,1.483,0,0,
      0,0,0,1,0,
      0,0,0,0,1];

  this._loadMatrix(matrix, multiply);
};

/**
 * Filter who transforms : Red -> Blue and Blue -> Red
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.toBGR = function(multiply)
{
    var matrix = [
        0,0,1,0,0,
        0,1,0,0,0,
        1,0,0,0,0,
        0,0,0,1,0,
        0,0,0,0,1
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.kodachrome = function(multiply)
{
    var matrix = [
        1.1285582396593525,-0.3967382283601348,-0.03992559172921793,0,63.72958762196502,
        -0.16404339962244616,1.0835251566291304,-0.05498805115633132,0,24.732407896706203,
        -0.16786010706155763,-0.5603416277695248,1.6014850761964943,0,35.62982807460946,
        0,0,0,1,0,
        0,0,0,0,1
    ];

    this._loadMatrix(matrix, multiply);
};

/**
 * Brown delicious browni filter (thanks Dominic Szablewski)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.browni = function(multiply)
{
    var matrix = [
        0.5997023498159715,0.34553243048391263,-0.2708298674538042,0,47.43192855600873,
        -0.037703249837783157,0.8609577587992641,0.15059552388459913,0,-36.96841498319127,
        0.24113635128153335,-0.07441037908422492,0.44972182064877153,0,-7.562075277591283,
        0,0,0,1,0,
        0,0,0,0,1
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * Vintage filter (thanks Dominic Szablewski)
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.vintage = function(multiply)
{
    var matrix = [
        0.6279345635605994,0.3202183420819367,-0.03965408211312453,0,9.651285835294123,
        0.02578397704808868,0.6441188644374771,0.03259127616149294,0,7.462829176470591,
        0.0466055556782719,-0.0851232987247891,0.5241648018700465,0,5.159190588235296,
        0,0,0,1,0,
        0,0,0,0,1,
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * We don't know exactly what it does, kind of gradient map, but funny to play with!
 *
 * @param desaturation {number}
 * @param toned {number}
 * @param lightColor {string} (example : "0xFFE580")
 * @param darkColor {string}  (example : "0xFFE580")
 *
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.colorTone = function(desaturation, toned, lightColor, darkColor, multiply)
{
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 0xFFE580;
    darkColor = darkColor || 0x338000;

    var lR = ((lightColor >> 16) & 0xFF) / 255;
    var lG = ((lightColor >> 8) & 0xFF) / 255;
    var lB = (lightColor & 0xFF) / 255;

    var dR = ((darkColor >> 16) & 0xFF) / 255;
    var dG = ((darkColor >> 8) & 0xFF) / 255;
    var dB = (darkColor & 0xFF) / 255;

    var matrix = [
        0.3, 0.59, 0.11, 0, 0,
        lR, lG, lB, desaturation, 0,
        dR, dG, dB, toned, 0,
        lR-dR, lG-dG, lB-dB, 0, 0,
        0, 0, 0, 0, 1
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * Night effect
 *
 * @param intensity {number}
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.night = function(intensity, multiply)
{
    intensity = intensity || 0.1;
    var matrix = [
        intensity * ( -2.0), -intensity,  0, 0, 0,
        -intensity, 0,  intensity, 0, 0,
        0, intensity, intensity * 2.0, 0, 0,
        0,0,0,1,0,
        0,0,0,0,1
    ];

    this._loadMatrix(matrix, multiply);
};


/*
 * Predator effect
 *
 * Erase the current matrix by setting a new indepent one
 *
 * @param amount {number} how much the predator feels his future victim
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.predator = function(amount, multiply)
{
    var matrix = [
        11.224130630493164*amount, -4.794486999511719*amount, -2.8746118545532227*amount, 0*amount, 0.40342438220977783*amount,
        -3.6330697536468506*amount, 9.193157196044922*amount, -2.951810836791992*amount, 0*amount, -1.316135048866272*amount,
        -3.2184197902679443*amount, -4.2375030517578125*amount, 7.476448059082031*amount, 0*amount, 0.8044459223747253*amount,
        0, 0, 0, 1, 0,
        0, 0, 0, 0, 0
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * LSD effect
 *
 * Multiply the current matrix
 *
 * @param amount {number} How crazy is your effect
 * @param multiply {boolean} refer to ._loadMatrix() method
 */
ColorMatrixFilter.prototype.lsd = function(multiply)
{
    var matrix = [
        2, -0.4, 0.5, 0, 0,
        -0.5, 2, -0.4, 0, 0,
        -0.4, -0.5, 3, 0, 0,
        0,0,0,1,0,
        0,0,0,0,1
    ];

    this._loadMatrix(matrix, multiply);
};

/*
 * Reset function
 *
 * Erase the current matrix by setting the default one
 *
 */
ColorMatrixFilter.prototype.reset = function()
{
  var matrix = [
    1,0,0,0,0,
    0,1,0,0,0,
    0,0,1,0,0,
    0,0,0,1,0,
    0,0,0,0,1
  ];

  this._loadMatrix(matrix, false);
};


Object.defineProperties(ColorMatrixFilter.prototype, {
    /**
     * Sets the matrix of the color matrix filter
     *
     * @member {number[]}
     * @memberof ColorMatrixFilter#
     * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
     */
    matrix: {
        get: function ()
        {
            return this.uniforms.m.value;
        },
        set: function (value)
        {
            this.uniforms.m.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/color/ColorStepFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This lowers the color depth of your image by the given amount, producing an image with a smaller palette.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function ColorStepFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float step;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    color = floor(color * step) / step;\n\n    gl_FragColor = color;\n}\n",
        // custom uniforms
        {
            step: { type: '1f', value: 5 }
        }
    );
}

ColorStepFilter.prototype = Object.create(core.AbstractFilter.prototype);
ColorStepFilter.prototype.constructor = ColorStepFilter;
module.exports = ColorStepFilter;

Object.defineProperties(ColorStepFilter.prototype, {
    /**
     * The number of steps to reduce the palette by.
     *
     * @member {number}
     * @memberof ColorStepFilter#
     */
    step: {
        get: function ()
        {
            return this.uniforms.step.value;
        },
        set: function (value)
        {
            this.uniforms.step.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/convolution/ConvolutionFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The ConvolutionFilter class applies a matrix convolution filter effect.
 * A convolution combines pixels in the input image with neighboring pixels to produce a new image.
 * A wide variety of image effects can be achieved through convolutions, including blurring, edge
 * detection, sharpening, embossing, and beveling. The matrix should be specified as a 9 point Array.
 * See http://docs.gimp.org/en/plug-in-convmatrix.html for more info.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 * @param matrix {number[]} An array of values used for matrix transformation. Specified as a 9 point Array.
 * @param width {number} Width of the object you are transforming
 * @param height {number} Height of the object you are transforming
 */
function ConvolutionFilter(matrix, width, height)
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n",
        // custom uniforms
        {
            matrix:     { type: '1fv', value: new Float32Array(matrix) },
            texelSize:  { type: '2v', value: { x: 1 / width, y: 1 / height } }
        }
    );
}

ConvolutionFilter.prototype = Object.create(core.AbstractFilter.prototype);
ConvolutionFilter.prototype.constructor = ConvolutionFilter;
module.exports = ConvolutionFilter;

Object.defineProperties(ConvolutionFilter.prototype, {
    /**
     * An array of values used for matrix transformation. Specified as a 9 point Array.
     *
     * @member {number[]}
     * @memberof ConvolutionFilter#
     */
    matrix: {
        get: function ()
        {
            return this.uniforms.matrix.value;
        },
        set: function (value)
        {
            this.uniforms.matrix.value = new Float32Array(value);
        }
    },

    /**
     * Width of the object you are transforming
     *
     * @member {number}
     * @memberof ConvolutionFilter#
     */
    width: {
        get: function ()
        {
            return 1/this.uniforms.texelSize.value.x;
        },
        set: function (value)
        {
            this.uniforms.texelSize.value.x = 1/value;
        }
    },

    /**
     * Height of the object you are transforming
     *
     * @member {number}
     * @memberof ConvolutionFilter#
     */
    height: {
        get: function ()
        {
            return 1/this.uniforms.texelSize.value.y;
        },
        set: function (value)
        {
            this.uniforms.texelSize.value.y = 1/value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/crosshatch/CrossHatchFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * A Cross Hatch effect filter.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function CrossHatchFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n"
    );
}

CrossHatchFilter.prototype = Object.create(core.AbstractFilter.prototype);
CrossHatchFilter.prototype.constructor = CrossHatchFilter;
module.exports = CrossHatchFilter;

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/displacement/DisplacementFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The DisplacementFilter class uses the pixel values from the specified texture (called the displacement map) to perform a displacement of an object.
 * You can use this filter to apply all manor of crazy warping effects
 * Currently the r property of the texture is used to offset the x and the g property of the texture is used to offset the y.
 *
 * @class
 * @extends AbstractFilter
 * @namespace PIXI
 * @param texture {Texture} The texture used for the displacement map * must be power of 2 texture at the moment
 */
function DisplacementFilter(sprite)
{
    var maskMatrix = new core.math.Matrix();
    sprite.renderable = false;

    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMapCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void)\n{\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n   vMapCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
        // fragment shader
        "precision lowp float;\n\nvarying vec2 vMapCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec2 scale;\n\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nvoid main(void)\n{\n   vec4 original =  texture2D(uSampler, vTextureCoord);\n   vec4 map =  texture2D(mapSampler, vMapCoord);\n\n   map -= 0.5;\n   map.xy *= scale;\n\n   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y));\n}\n",
        // uniforms
        {
            mapSampler:     { type: 'sampler2D', value: sprite.texture },
            otherMatrix:    { type: 'mat3', value: maskMatrix.toArray(true) },
            scale:          { type: 'v2', value: { x: 1, y: 1 } }
        }
    );

    this.maskSprite = sprite;
    this.maskMatrix = maskMatrix;


    this.scale = new core.math.Point(20,20);

}

DisplacementFilter.prototype = Object.create(core.AbstractFilter.prototype);
DisplacementFilter.prototype.constructor = DisplacementFilter;
module.exports = DisplacementFilter;

DisplacementFilter.prototype.applyFilter = function (renderer, input, output)
{
    var filterManager = renderer.filterManager;

    filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);

    this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);
    this.uniforms.scale.value.x = this.scale.x * (1/input.frame.width);
    this.uniforms.scale.value.y = this.scale.y * (1/input.frame.height);

    var shader = this.getShader(renderer);
     // draw the filter...
    filterManager.applyFilter(shader, input, output);
};


Object.defineProperties(DisplacementFilter.prototype, {
    /**
     * The texture used for the displacement map. Must be power of 2 sized texture.
     *
     * @member {Texture}
     * @memberof DisplacementFilter#
     */
    map: {
        get: function ()
        {
            return this.uniforms.mapSampler.value;
        },
        set: function (value)
        {
            this.uniforms.mapSampler.value = value;

        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/dot/DotScreenFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * @author Mat Groves http://matgroves.com/ @Doormat23
 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/fun/dotscreen.js
 */

/**
 * This filter applies a dotscreen effect making display objects appear to be made out of
 * black and white halftone dots like an old printer.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function DotScreenFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 dimensions;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * dimensions.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   float average = (color.r + color.g + color.b) / 3.0;\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n}\n",
        // custom uniforms
        {
            scale:      { type: '1f', value: 1 },
            angle:      { type: '1f', value: 5 },
            dimensions: { type: '4fv', value: [0, 0, 0, 0] }
        }
    );
}

DotScreenFilter.prototype = Object.create(core.AbstractFilter.prototype);
DotScreenFilter.prototype.constructor = DotScreenFilter;
module.exports = DotScreenFilter;

Object.defineProperties(DotScreenFilter.prototype, {
    /**
     * The scale of the effect.
     * @member {number}
     * @memberof DotScreenFilter#
     */
    scale: {
        get: function ()
        {
            return this.uniforms.scale.value;
        },
        set: function (value)
        {
            this.uniforms.scale.value = value;
        }
    },

    /**
     * The radius of the effect.
     * @member {number}
     * @memberof DotScreenFilter#
     */
    angle: {
        get: function ()
        {
            return this.uniforms.angle.value;
        },
        set: function (value)
        {
            this.uniforms.angle.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/dropshadow/BlurYTintFilter.js":[function(require,module,exports){
var core = require('../../core');

// @see https://github.com/substack/brfs/issues/25


/**
 * The BlurYTintFilter applies a vertical Gaussian blur to an object.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function BlurYTintFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform vec2 offset;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition+offset), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(0.0, -0.012 * strength);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(0.0, -0.008 * strength);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(0.0, -0.004 * strength);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2(0.0,  0.004 * strength);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2(0.0,  0.008 * strength);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2(0.0,  0.012 * strength);\n\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n",
        // fragment shader
        "precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform vec3 color;\nuniform float alpha;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    vec4 sum = vec4(0.0);\n\n    sum += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    sum += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    sum += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    sum += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    sum += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    sum += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    sum += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n\n    gl_FragColor = vec4( color.rgb * sum.a * alpha, sum.a * alpha );\n}\n",
        // set the uniforms
        {
            blur: { type: '1f', value: 1 / 512 },
            color: { type: 'c', value: [0,0,0]},
            alpha: { type: '1f', value: 0.7 },
            offset: { type: '2f', value:[5, 5]},
            strength: { type: '1f', value:1}
        }
    );

    this.passes = 1;
    this.strength = 4;
}

BlurYTintFilter.prototype = Object.create(core.AbstractFilter.prototype);
BlurYTintFilter.prototype.constructor = BlurYTintFilter;
module.exports = BlurYTintFilter;

BlurYTintFilter.prototype.applyFilter = function (renderer, input, output, clear)
{
    var shader = this.getShader(renderer);

    this.uniforms.strength.value = this.strength / 4 / this.passes * (input.frame.height / input.size.height);

    if(this.passes === 1)
    {
        renderer.filterManager.applyFilter(shader, input, output, clear);
    }
    else
    {
        var renderTarget = renderer.filterManager.getRenderTarget(true);
        var flip = input;
        var flop = renderTarget;

        for(var i = 0; i < this.passes-1; i++)
        {
            renderer.filterManager.applyFilter(shader, flip, flop, clear);

           var temp = flop;
           flop = flip;
           flip = temp;
        }

        renderer.filterManager.applyFilter(shader, flip, output, clear);

        renderer.filterManager.returnRenderTarget(renderTarget);
    }
};


Object.defineProperties(BlurYTintFilter.prototype, {
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @memberof BlurYFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return  this.strength;
        },
        set: function (value)
        {
            this.padding = value * 0.5;
            this.strength = value;
        }
    },
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/dropshadow/DropShadowFilter.js":[function(require,module,exports){
var core = require('../../core'),
    BlurXFilter = require('../blur/BlurXFilter'),
    BlurYTintFilter = require('./BlurYTintFilter');

/**
 * The DropShadowFilter applies a Gaussian blur to an object.
 * The strength of the blur can be set for x- and y-axis separately.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function DropShadowFilter()
{
    core.AbstractFilter.call(this);

    this.blurXFilter = new BlurXFilter();
    this.blurYTintFilter = new BlurYTintFilter();

    this.defaultFilter = new core.AbstractFilter();

    this.padding = 30;

    this._dirtyPosition = true;
    this._angle = 45 * Math.PI / 180;
    this._distance = 10;
    this.alpha = 0.75;
    this.hideObject = false;
    this.blendMode = core.BLEND_MODES.MULTIPLY;
}

DropShadowFilter.prototype = Object.create(core.AbstractFilter.prototype);
DropShadowFilter.prototype.constructor = DropShadowFilter;
module.exports = DropShadowFilter;

DropShadowFilter.prototype.applyFilter = function (renderer, input, output)
{
    var renderTarget = renderer.filterManager.getRenderTarget(true);

    //TODO - copyTexSubImage2D could be used here?
    if(this._dirtyPosition)
    {
        this._dirtyPosition = false;

        this.blurYTintFilter.uniforms.offset.value[0] = Math.sin(this._angle) * this._distance;
        this.blurYTintFilter.uniforms.offset.value[1] = Math.cos(this._angle) * this._distance;
    }

    this.blurXFilter.applyFilter(renderer, input, renderTarget);

    renderer.blendModeManager.setBlendMode(this.blendMode);

    this.blurYTintFilter.applyFilter(renderer, renderTarget, output);

    renderer.blendModeManager.setBlendMode(core.BLEND_MODES.NORMAL);

    if(!this.hideObject)
    {

        this.defaultFilter.applyFilter(renderer, input, output);
    }


    renderer.filterManager.returnRenderTarget(renderTarget);
};

Object.defineProperties(DropShadowFilter.prototype, {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @memberOf DropShadowFilter#
     * @default 2
     */
    blur: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = this.blurYTintFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @memberOf DropShadowFilter#
     * @default 2
     */
    blurX: {
        get: function ()
        {
            return this.blurXFilter.blur;
        },
        set: function (value)
        {
            this.blurXFilter.blur = value;
        }
    },

    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @memberOf DropShadowFilter#
     * @default 2
     */
    blurY: {
        get: function ()
        {
            return this.blurYTintFilter.blur;
        },
        set: function (value)
        {
            this.blurYTintFilter.blur = value;
        }
    },

    color: {
        get: function ()
        {
            return  core.utils.rgb2hex( this.blurYTintFilter.uniforms.color.value );
        },
        set: function (value)
        {
            this.blurYTintFilter.uniforms.color.value = core.utils.hex2rgb(value);
        }
    },

    alpha: {
        get: function ()
        {
            return  this.blurYTintFilter.uniforms.alpha.value;
        },
        set: function (value)
        {
            this.blurYTintFilter.uniforms.alpha.value = value;
        }
    },

    distance: {
        get: function ()
        {
            return  this._distance;
        },
        set: function (value)
        {
            this._dirtyPosition = true;
            this._distance = value;
        }
    },

    angle: {
        get: function ()
        {
            return  this._angle;
        },
        set: function (value)
        {
            this._dirtyPosition = true;
            this._angle = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js","../blur/BlurXFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/BlurXFilter.js","./BlurYTintFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/dropshadow/BlurYTintFilter.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/gray/GrayFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This greyscales the palette of your Display Objects.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function GrayFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform float gray;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n   gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.2126*gl_FragColor.r + 0.7152*gl_FragColor.g + 0.0722*gl_FragColor.b), gray);\n}\n",
        // set the uniforms
        {
            gray: { type: '1f', value: 1 }
        }
    );
}

GrayFilter.prototype = Object.create(core.AbstractFilter.prototype);
GrayFilter.prototype.constructor = GrayFilter;
module.exports = GrayFilter;

Object.defineProperties(GrayFilter.prototype, {
    /**
     * The strength of the gray. 1 will make the object black and white, 0 will make the object its normal color.
     *
     * @member {number}
     * @memberof GrayFilter#
     */
    gray: {
        get: function ()
        {
            return this.uniforms.gray.value;
        },
        set: function (value)
        {
            this.uniforms.gray.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/index.js":[function(require,module,exports){
/**
 * @file        Main export of the PIXI filters library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.filters
 */
module.exports = {
    // expose some internal filters...
    AbstractFilter:     require('../core/renderers/webgl/filters/AbstractFilter'),
    FXAAFilter:         require('../core/renderers/webgl/filters/FXAAFilter'),
    SpriteMaskFilter:   require('../core/renderers/webgl/filters/SpriteMaskFilter'),
    // add the rest!
    AsciiFilter:        require('./ascii/AsciiFilter'),
    BloomFilter:        require('./bloom/BloomFilter'),
    BlurFilter:         require('./blur/BlurFilter'),
    BlurXFilter:        require('./blur/BlurXFilter'),
    BlurYFilter:        require('./blur/BlurYFilter'),
    ColorMatrixFilter:  require('./color/ColorMatrixFilter'),
    ColorStepFilter:    require('./color/ColorStepFilter'),
    ConvolutionFilter:  require('./convolution/ConvolutionFilter'),
    CrossHatchFilter:   require('./crosshatch/CrossHatchFilter'),
    DisplacementFilter: require('./displacement/DisplacementFilter'),
    DotScreenFilter:    require('./dot/DotScreenFilter'),
    GrayFilter:         require('./gray/GrayFilter'),
    DropShadowFilter:   require('./dropshadow/DropShadowFilter'),
    InvertFilter:       require('./invert/InvertFilter'),
    NoiseFilter:        require('./noise/NoiseFilter'),
    NormalMapFilter:    require('./normal/NormalMapFilter'),
    PixelateFilter:     require('./pixelate/PixelateFilter'),
    RGBSplitFilter:     require('./rgb/RGBSplitFilter'),
    ShockwaveFilter:    require('./shockwave/ShockwaveFilter'),
    SepiaFilter:        require('./sepia/SepiaFilter'),
    SmartBlurFilter:    require('./blur/SmartBlurFilter'),
    TiltShiftFilter:    require('./tiltshift/TiltShiftFilter'),
    TiltShiftXFilter:   require('./tiltshift/TiltShiftXFilter'),
    TiltShiftYFilter:   require('./tiltshift/TiltShiftYFilter'),
    TwistFilter:        require('./twist/TwistFilter')
};

},{"../core/renderers/webgl/filters/AbstractFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/filters/AbstractFilter.js","../core/renderers/webgl/filters/FXAAFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/filters/FXAAFilter.js","../core/renderers/webgl/filters/SpriteMaskFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/filters/SpriteMaskFilter.js","./ascii/AsciiFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/ascii/AsciiFilter.js","./bloom/BloomFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/bloom/BloomFilter.js","./blur/BlurFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/BlurFilter.js","./blur/BlurXFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/BlurXFilter.js","./blur/BlurYFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/BlurYFilter.js","./blur/SmartBlurFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/blur/SmartBlurFilter.js","./color/ColorMatrixFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/color/ColorMatrixFilter.js","./color/ColorStepFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/color/ColorStepFilter.js","./convolution/ConvolutionFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/convolution/ConvolutionFilter.js","./crosshatch/CrossHatchFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/crosshatch/CrossHatchFilter.js","./displacement/DisplacementFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/displacement/DisplacementFilter.js","./dot/DotScreenFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/dot/DotScreenFilter.js","./dropshadow/DropShadowFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/dropshadow/DropShadowFilter.js","./gray/GrayFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/gray/GrayFilter.js","./invert/InvertFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/invert/InvertFilter.js","./noise/NoiseFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/noise/NoiseFilter.js","./normal/NormalMapFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/normal/NormalMapFilter.js","./pixelate/PixelateFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/pixelate/PixelateFilter.js","./rgb/RGBSplitFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/rgb/RGBSplitFilter.js","./sepia/SepiaFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/sepia/SepiaFilter.js","./shockwave/ShockwaveFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/shockwave/ShockwaveFilter.js","./tiltshift/TiltShiftFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/tiltshift/TiltShiftFilter.js","./tiltshift/TiltShiftXFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/tiltshift/TiltShiftXFilter.js","./tiltshift/TiltShiftYFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/tiltshift/TiltShiftYFilter.js","./twist/TwistFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/twist/TwistFilter.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/invert/InvertFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This inverts your Display Objects colors.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function InvertFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform float invert;\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    gl_FragColor.rgb = mix( (vec3(1)-gl_FragColor.rgb) * gl_FragColor.a, gl_FragColor.rgb, 1.0 - invert);\n}\n",
        // custom uniforms
        {
            invert: { type: '1f', value: 1 }
        }
    );
}

InvertFilter.prototype = Object.create(core.AbstractFilter.prototype);
InvertFilter.prototype.constructor = InvertFilter;
module.exports = InvertFilter;

Object.defineProperties(InvertFilter.prototype, {
    /**
     * The strength of the invert. `1` will fully invert the colors, and
     * `0` will make the object its normal color.
     *
     * @member {number}
     * @memberof InvertFilter#
     */
    invert: {
        get: function ()
        {
            return this.uniforms.invert.value;
        },
        set: function (value)
        {
            this.uniforms.invert.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/noise/NoiseFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * @author Vico @vicocotea
 * original filter: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js
 */

/**
 * A Noise effect filter.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function NoiseFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float noise;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    float diff = (rand(vTextureCoord) - 0.5) * noise;\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    gl_FragColor = color;\n}\n",
        // custom uniforms
        {
            noise: { type: '1f', value: 0.5 }
        }
    );
}

NoiseFilter.prototype = Object.create(core.AbstractFilter.prototype);
NoiseFilter.prototype.constructor = NoiseFilter;
module.exports = NoiseFilter;

Object.defineProperties(NoiseFilter.prototype, {
    /**
     * The amount of noise to apply.
     *
     * @member {number}
     * @memberof NoiseFilter#
     * @default 0.5
     */
    noise: {
        get: function ()
        {
            return this.uniforms.noise.value;
        },
        set: function (value)
        {
            this.uniforms.noise.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/normal/NormalMapFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The NormalMapFilter class uses the pixel values from the specified texture (called the normal map)
 * to project lighting onto an object.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 * @param texture {Texture} The texture used for the normal map, must be power of 2 texture at the moment
 */
function NormalMapFilter(texture)
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying float vColor;\n\nuniform sampler2D displacementMap;\nuniform sampler2D uSampler;\n\nuniform vec4 dimensions;\n\nconst vec2 Resolution = vec2(1.0,1.0);      //resolution of screen\nuniform vec3 LightPos;    //light position, normalized\nconst vec4 LightColor = vec4(1.0, 1.0, 1.0, 1.0);      //light RGBA -- alpha is intensity\nconst vec4 AmbientColor = vec4(1.0, 1.0, 1.0, 0.5);    //ambient RGBA -- alpha is intensity\nconst vec3 Falloff = vec3(0.0, 1.0, 0.2);         //attenuation coefficients\n\nuniform vec3 LightDir; // = vec3(1.0, 0.0, 1.0);\n\nuniform vec2 mapDimensions; // = vec2(256.0, 256.0);\n\n\nvoid main(void)\n{\n    vec2 mapCords = vTextureCoord.xy;\n\n    vec4 color = texture2D(uSampler, vTextureCoord.st);\n    vec3 nColor = texture2D(displacementMap, vTextureCoord.st).rgb;\n\n\n    mapCords *= vec2(dimensions.x/512.0, dimensions.y/512.0);\n\n    mapCords.y *= -1.0;\n    mapCords.y += 1.0;\n\n    // RGBA of our diffuse color\n    vec4 DiffuseColor = texture2D(uSampler, vTextureCoord);\n\n    // RGB of our normal map\n    vec3 NormalMap = texture2D(displacementMap, mapCords).rgb;\n\n    // The delta position of light\n    // vec3 LightDir = vec3(LightPos.xy - (gl_FragCoord.xy / Resolution.xy), LightPos.z);\n    vec3 LightDir = vec3(LightPos.xy - (mapCords.xy), LightPos.z);\n\n    // Correct for aspect ratio\n    // LightDir.x *= Resolution.x / Resolution.y;\n\n    // Determine distance (used for attenuation) BEFORE we normalize our LightDir\n    float D = length(LightDir);\n\n    // normalize our vectors\n    vec3 N = normalize(NormalMap * 2.0 - 1.0);\n    vec3 L = normalize(LightDir);\n\n    // Pre-multiply light color with intensity\n    // Then perform 'N dot L' to determine our diffuse term\n    vec3 Diffuse = (LightColor.rgb * LightColor.a) * max(dot(N, L), 0.0);\n\n    // pre-multiply ambient color with intensity\n    vec3 Ambient = AmbientColor.rgb * AmbientColor.a;\n\n    // calculate attenuation\n    float Attenuation = 1.0 / ( Falloff.x + (Falloff.y*D) + (Falloff.z*D*D) );\n\n    // the calculation which brings it all together\n    vec3 Intensity = Ambient + Diffuse * Attenuation;\n    vec3 FinalColor = DiffuseColor.rgb * Intensity;\n    gl_FragColor = vColor * vec4(FinalColor, DiffuseColor.a);\n\n    // gl_FragColor = vec4(1.0, 0.0, 0.0, Attenuation); // vColor * vec4(FinalColor, DiffuseColor.a);\n\n/*\n    // normalise color\n    vec3 normal = normalize(nColor * 2.0 - 1.0);\n\n    vec3 deltaPos = vec3( (light.xy - gl_FragCoord.xy) / resolution.xy, light.z );\n\n    float lambert = clamp(dot(normal, lightDir), 0.0, 1.0);\n\n    float d = sqrt(dot(deltaPos, deltaPos));\n    float att = 1.0 / ( attenuation.x + (attenuation.y*d) + (attenuation.z*d*d) );\n\n    vec3 result = (ambientColor * ambientIntensity) + (lightColor.rgb * lambert) * att;\n    result *= color.rgb;\n\n    gl_FragColor = vec4(result, 1.0);\n*/\n}\n",
        // custom uniforms
        {
            displacementMap:  { type: 'sampler2D', value: texture },
            scale:            { type: '2f', value: { x: 15, y: 15 } },
            offset:           { type: '2f', value: { x: 0,  y: 0 } },
            mapDimensions:    { type: '2f', value: { x: 1,  y: 1 } },
            dimensions:       { type: '4f', value: [0, 0, 0, 0] },
            // LightDir:         { type: 'f3', value: [0, 1, 0] },
            LightPos:         { type: '3f', value: [0, 1, 0] }
        }
    );

    texture.baseTexture._powerOf2 = true;

    if (texture.baseTexture.hasLoaded)
    {
        this.onTextureLoaded();
    }
    else
    {
        texture.baseTexture.once('loaded', this.onTextureLoaded, this);
    }
}

NormalMapFilter.prototype = Object.create(core.AbstractFilter.prototype);
NormalMapFilter.prototype.constructor = NormalMapFilter;
module.exports = NormalMapFilter;

/**
 * Sets the map dimensions uniforms when the texture becomes available.
 *
 * @private
 */
NormalMapFilter.prototype.onTextureLoaded = function ()
{
    this.uniforms.mapDimensions.value.x = this.uniforms.displacementMap.value.width;
    this.uniforms.mapDimensions.value.y = this.uniforms.displacementMap.value.height;
};

Object.defineProperties(NormalMapFilter.prototype, {
    /**
     * The texture used for the displacement map. Must be power of 2 texture.
     *
     * @member {Texture}
     * @memberof NormalMapFilter#
     */
    map: {
        get: function ()
        {
            return this.uniforms.displacementMap.value;
        },
        set: function (value)
        {
            this.uniforms.displacementMap.value = value;
        }
    },

    /**
     * The multiplier used to scale the displacement result from the map calculation.
     *
     * @member {Point}
     * @memberof NormalMapFilter#
     */
    scale: {
        get: function ()
        {
            return this.uniforms.scale.value;
        },
        set: function (value)
        {
            this.uniforms.scale.value = value;
        }
    },

    /**
     * The offset used to move the displacement map.
     *
     * @member {Point}
     * @memberof NormalMapFilter#
     */
    offset: {
        get: function ()
        {
            return this.uniforms.offset.value;
        },
        set: function (value)
        {
            this.uniforms.offset.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/pixelate/PixelateFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This filter applies a pixelate effect making display objects appear 'blocky'.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function PixelateFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 dimensions;\nuniform vec2 pixelSize;\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord;\n\n    vec2 size = dimensions.xy / pixelSize;\n\n    vec2 color = floor( ( vTextureCoord * size ) ) / size + pixelSize/dimensions.xy * 0.5;\n\n    gl_FragColor = texture2D(uSampler, color);\n}\n",
        // custom uniforms
        {
            dimensions: { type: '4fv',  value: new Float32Array([0, 0, 0, 0]) },
            pixelSize:  { type: 'v2',   value: { x: 10, y: 10 } }
        }
    );
}

PixelateFilter.prototype = Object.create(core.AbstractFilter.prototype);
PixelateFilter.prototype.constructor = PixelateFilter;
module.exports = PixelateFilter;

Object.defineProperties(PixelateFilter.prototype, {
    /**
     * This a point that describes the size of the blocks.
     * x is the width of the block and y is the height.
     *
     * @member {Point}
     * @memberof PixelateFilter#
     */
    size: {
        get: function ()
        {
            return this.uniforms.pixelSize.value;
        },
        set: function (value)
        {
            this.uniforms.pixelSize.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/rgb/RGBSplitFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * An RGB Split Filter.
 *
 * @class
 * @extends AbstractFilter
 * @namespace PIXI
 */
function RGBSplitFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 dimensions;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/dimensions.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/dimensions.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/dimensions.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n",
        // custom uniforms
        {
            red:        { type: 'v2', value: { x: 20, y: 20 } },
            green:      { type: 'v2', value: { x: -20, y: 20 } },
            blue:       { type: 'v2', value: { x: 20, y: -20 } },
            dimensions: { type: '4fv', value: [0, 0, 0, 0] }
        }
    );
}

RGBSplitFilter.prototype = Object.create(core.AbstractFilter.prototype);
RGBSplitFilter.prototype.constructor = RGBSplitFilter;
module.exports = RGBSplitFilter;

Object.defineProperties(RGBSplitFilter.prototype, {
    /**
     * Red channel offset.
     *
     * @member {Point}
     * @memberof RGBSplitFilter#
     */
    red: {
        get: function ()
        {
            return this.uniforms.red.value;
        },
        set: function (value)
        {
            this.uniforms.red.value = value;
        }
    },

    /**
     * Green channel offset.
     *
     * @member {Point}
     * @memberof RGBSplitFilter#
     */
    green: {
        get: function ()
        {
            return this.uniforms.green.value;
        },
        set: function (value)
        {
            this.uniforms.green.value = value;
        }
    },

    /**
     * Blue offset.
     *
     * @member {Point}
     * @memberof RGBSplitFilter#
     */
    blue: {
        get: function ()
        {
            return this.uniforms.blue.value;
        },
        set: function (value)
        {
            this.uniforms.blue.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/sepia/SepiaFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This applies a sepia effect to your Display Objects.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function SepiaFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float sepia;\n\nconst mat3 sepiaMatrix = mat3(0.3588, 0.7044, 0.1368, 0.2990, 0.5870, 0.1140, 0.2392, 0.4696, 0.0912);\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n   gl_FragColor.rgb = mix( gl_FragColor.rgb, gl_FragColor.rgb * sepiaMatrix, sepia);\n}\n",
        // custom uniforms
        {
            sepia: { type: '1f', value: 1 }
        }
    );
}

SepiaFilter.prototype = Object.create(core.AbstractFilter.prototype);
SepiaFilter.prototype.constructor = SepiaFilter;
module.exports = SepiaFilter;

Object.defineProperties(SepiaFilter.prototype, {
    /**
     * The strength of the sepia. `1` will apply the full sepia effect, and
     * `0` will make the object its normal color.
     *
     * @member {number}
     * @memberof SepiaFilter#
     */
    sepia: {
        get: function ()
        {
            return this.uniforms.sepia.value;
        },
        set: function (value)
        {
            this.uniforms.sepia.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/shockwave/ShockwaveFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * The ColorMatrixFilter class lets you apply a 4x4 matrix transformation on the RGBA
 * color and alpha values of every pixel on your displayObject to produce a result
 * with a new set of RGBA color and alpha values. It's pretty powerful!
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function ShockwaveFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nuniform vec2 center;\nuniform vec3 params; // 10.0, 0.8, 0.1\nuniform float time;\n\nvoid main()\n{\n    vec2 uv = vTextureCoord;\n    vec2 texCoord = uv;\n\n    float dist = distance(uv, center);\n\n    if ( (dist <= (time + params.z)) && (dist >= (time - params.z)) )\n    {\n        float diff = (dist - time);\n        float powDiff = 1.0 - pow(abs(diff*params.x), params.y);\n\n        float diffTime = diff  * powDiff;\n        vec2 diffUV = normalize(uv - center);\n        texCoord = uv + (diffUV * diffTime);\n    }\n\n    gl_FragColor = texture2D(uSampler, texCoord);\n}\n",
        // custom uniforms
        {
            center: { type: 'v2', value: { x: 0.5, y: 0.5 } },
            params: { type: 'v3', value: { x: 10, y: 0.8, z: 0.1 } },
            time: { type: '1f', value: 0 }
        }
    );
}

ShockwaveFilter.prototype = Object.create(core.AbstractFilter.prototype);
ShockwaveFilter.prototype.constructor = ShockwaveFilter;
module.exports = ShockwaveFilter;

Object.defineProperties(ShockwaveFilter.prototype, {
    /**
     * Sets the center of the shockwave in normalized screen coords. That is
     * (0,0) is the top-left and (1,1) is the bottom right.
     *
     * @member {object<string, number>}
     * @memberof ShockwaveFilter#
     */
    center: {
        get: function ()
        {
            return this.uniforms.center.value;
        },
        set: function (value)
        {
            this.uniforms.center.value = value;
        }
    },
    /**
     * Sets the params of the shockwave. These modify the look and behavior of
     * the shockwave as it ripples out.
     *
     * @member {object<string, number>}
     * @memberof ShockwaveFilter#
     */
    params: {
        get: function ()
        {
            return this.uniforms.params.value;
        },
        set: function (value)
        {
            this.uniforms.params.value = value;
        }
    },
    /**
     * Sets the elapsed time of the shockwave. This controls the speed at which
     * the shockwave ripples out.
     *
     * @member {number}
     * @memberof ShockwaveFilter#
     */
    time: {
        get: function ()
        {
            return this.uniforms.time.value;
        },
        set: function (value)
        {
            this.uniforms.time.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/tiltshift/TiltShiftAxisFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * @author Vico @vicocotea
 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
 */

/**
 * A TiltShiftAxisFilter.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function TiltShiftAxisFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n",
        // custom uniforms
        {
            blur:           { type: '1f', value: 100 },
            gradientBlur:   { type: '1f', value: 600 },
            start:          { type: 'v2', value: { x: 0,    y: window.innerHeight / 2 } },
            end:            { type: 'v2', value: { x: 600,  y: window.innerHeight / 2 } },
            delta:          { type: 'v2', value: { x: 30,   y: 30 } },
            texSize:        { type: 'v2', value: { x: window.innerWidth, y: window.innerHeight } }
        }
    );

    this.updateDelta();
}

TiltShiftAxisFilter.prototype = Object.create(core.AbstractFilter.prototype);
TiltShiftAxisFilter.prototype.constructor = TiltShiftAxisFilter;
module.exports = TiltShiftAxisFilter;

/**
 * Updates the filter delta values.
 * This is overridden in the X and Y filters, does nothing for this class.
 *
 */
TiltShiftAxisFilter.prototype.updateDelta = function ()
{
    this.uniforms.delta.value.x = 0;
    this.uniforms.delta.value.y = 0;
};

Object.defineProperties(TiltShiftAxisFilter.prototype, {
    /**
     * The strength of the blur.
     *
     * @member {number}
     * @memberof TiltShiftAxisFilter#
     */
    blur: {
        get: function ()
        {
            return this.uniforms.blur.value;
        },
        set: function (value)
        {
            this.uniforms.blur.value = value;
        }
    },

    /**
     * The strength of the gradient blur.
     *
     * @member {number}
     * @memberof TiltShiftAxisFilter#
     */
    gradientBlur: {
        get: function ()
        {
            return this.uniforms.gradientBlur.value;
        },
        set: function (value)
        {
            this.uniforms.gradientBlur.value = value;
        }
    },

    /**
     * The X value to start the effect at.
     *
     * @member {Point}
     * @memberof TiltShiftAxisFilter#
     */
    start: {
        get: function ()
        {
            return this.uniforms.start.value;
        },
        set: function (value)
        {
            this.uniforms.start.value = value;
            this.updateDelta();
        }
    },

    /**
     * The X value to end the effect at.
     *
     * @member {Point}
     * @memberof TiltShiftAxisFilter#
     */
    end: {
        get: function ()
        {
            return this.uniforms.end.value;
        },
        set: function (value)
        {
            this.uniforms.end.value = value;
            this.updateDelta();
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/tiltshift/TiltShiftFilter.js":[function(require,module,exports){
var core = require('../../core'),
    TiltShiftXFilter = require('./TiltShiftXFilter'),
    TiltShiftYFilter = require('./TiltShiftYFilter');

/**
 * @author Vico @vicocotea
 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
 */

/**
 * A TiltShift Filter. Manages the pass of both a TiltShiftXFilter and TiltShiftYFilter.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function TiltShiftFilter()
{
    core.AbstractFilter.call(this);

    this.tiltShiftXFilter = new TiltShiftXFilter();
    this.tiltShiftYFilter = new TiltShiftYFilter();
}

TiltShiftFilter.prototype = Object.create(core.AbstractFilter.prototype);
TiltShiftFilter.prototype.constructor = TiltShiftFilter;
module.exports = TiltShiftFilter;

TiltShiftFilter.prototype.applyFilter = function (renderer, input, output)
{
    var renderTarget = renderer.filterManager.getRenderTarget(true);

    this.tiltShiftXFilter.applyFilter(renderer, input, renderTarget);

    this.tiltShiftYFilter.applyFilter(renderer, renderTarget, output);

    renderer.filterManager.returnRenderTarget(renderTarget);
};

Object.defineProperties(TiltShiftFilter.prototype, {
    /**
     * The strength of the blur.
     *
     * @member {number}
     * @memberof TiltShiftFilter#
     */
    blur: {
        get: function ()
        {
            return this.tiltShiftXFilter.blur;
        },
        set: function (value)
        {
            this.tiltShiftXFilter.blur = this.tiltShiftYFilter.blur = value;
        }
    },

    /**
     * The strength of the gradient blur.
     *
     * @member {number}
     * @memberof TiltShiftFilter#
     */
    gradientBlur: {
        get: function ()
        {
            return this.tiltShiftXFilter.gradientBlur;
        },
        set: function (value)
        {
            this.tiltShiftXFilter.gradientBlur = this.tiltShiftYFilter.gradientBlur = value;
        }
    },

    /**
     * The Y value to start the effect at.
     *
     * @member {number}
     * @memberof TiltShiftFilter#
     */
    start: {
        get: function ()
        {
            return this.tiltShiftXFilter.start;
        },
        set: function (value)
        {
            this.tiltShiftXFilter.start = this.tiltShiftYFilter.start = value;
        }
    },

    /**
     * The Y value to end the effect at.
     *
     * @member {number}
     * @memberof TiltShiftFilter#
     */
    end: {
        get: function ()
        {
            return this.tiltShiftXFilter.end;
        },
        set: function (value)
        {
            this.tiltShiftXFilter.end = this.tiltShiftYFilter.end = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js","./TiltShiftXFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/tiltshift/TiltShiftXFilter.js","./TiltShiftYFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/tiltshift/TiltShiftYFilter.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/tiltshift/TiltShiftXFilter.js":[function(require,module,exports){
var TiltShiftAxisFilter = require('./TiltShiftAxisFilter');

/**
 * @author Vico @vicocotea
 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
 */

/**
 * A TiltShiftXFilter.
 *
 * @class
 * @extends TiltShiftAxisFilter
 * @memberof PIXI.filters
 */
function TiltShiftXFilter()
{
    TiltShiftAxisFilter.call(this);
}

TiltShiftXFilter.prototype = Object.create(TiltShiftAxisFilter.prototype);
TiltShiftXFilter.prototype.constructor = TiltShiftXFilter;
module.exports = TiltShiftXFilter;

/**
 * Updates the filter delta values.
 *
 */
TiltShiftXFilter.prototype.updateDelta = function ()
{
    var dx = this.uniforms.end.value.x - this.uniforms.start.value.x;
    var dy = this.uniforms.end.value.y - this.uniforms.start.value.y;
    var d = Math.sqrt(dx * dx + dy * dy);

    this.uniforms.delta.value.x = dx / d;
    this.uniforms.delta.value.y = dy / d;
};

},{"./TiltShiftAxisFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/tiltshift/TiltShiftAxisFilter.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/tiltshift/TiltShiftYFilter.js":[function(require,module,exports){
var TiltShiftAxisFilter = require('./TiltShiftAxisFilter');

/**
 * @author Vico @vicocotea
 * original filter https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js by Evan Wallace : http://madebyevan.com/
 */

/**
 * A TiltShiftYFilter.
 *
 * @class
 * @extends TiltShiftAxisFilter
 * @memberof PIXI.filters
 */
function TiltShiftYFilter()
{
    TiltShiftAxisFilter.call(this);
}

TiltShiftYFilter.prototype = Object.create(TiltShiftAxisFilter.prototype);
TiltShiftYFilter.prototype.constructor = TiltShiftYFilter;
module.exports = TiltShiftYFilter;

/**
 * Updates the filter delta values.
 *
 */
TiltShiftYFilter.prototype.updateDelta = function ()
{
    var dx = this.uniforms.end.value.x - this.uniforms.start.value.x;
    var dy = this.uniforms.end.value.y - this.uniforms.start.value.y;
    var d = Math.sqrt(dx * dx + dy * dy);

    this.uniforms.delta.value.x = -dy / d;
    this.uniforms.delta.value.y = dx / d;
};

},{"./TiltShiftAxisFilter":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/tiltshift/TiltShiftAxisFilter.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/twist/TwistFilter.js":[function(require,module,exports){
var core = require('../../core');
// @see https://github.com/substack/brfs/issues/25


/**
 * This filter applies a twist effect making display objects appear twisted in the given direction.
 *
 * @class
 * @extends AbstractFilter
 * @memberof PIXI.filters
 */
function TwistFilter()
{
    core.AbstractFilter.call(this,
        // vertex shader
        null,
        // fragment shader
        "precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\n\nvoid main(void)\n{\n   vec2 coord = vTextureCoord - offset;\n   float dist = length(coord);\n\n   if (dist < radius)\n   {\n       float ratio = (radius - dist) / radius;\n       float angleMod = ratio * ratio * angle;\n       float s = sin(angleMod);\n       float c = cos(angleMod);\n       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n   }\n\n   gl_FragColor = texture2D(uSampler, coord+offset);\n}\n",
        // custom uniforms
        {
            radius:     { type: '1f', value: 0.5 },
            angle:      { type: '1f', value: 5 },
            offset:     { type: 'v2', value: { x: 0.5, y: 0.5 } }
        }
    );
}

TwistFilter.prototype = Object.create(core.AbstractFilter.prototype);
TwistFilter.prototype.constructor = TwistFilter;
module.exports = TwistFilter;

Object.defineProperties(TwistFilter.prototype, {
    /**
     * This point describes the the offset of the twist.
     *
     * @member {Point}
     * @memberof TwistFilter#
     */
    offset: {
        get: function ()
        {
            return this.uniforms.offset.value;
        },
        set: function (value)
        {
            this.uniforms.offset.value = value;
        }
    },

    /**
     * This radius of the twist.
     *
     * @member {number}
     * @memberof TwistFilter#
     */
    radius: {
        get: function ()
        {
            return this.uniforms.radius.value;
        },
        set: function (value)
        {
            this.uniforms.radius.value = value;
        }
    },

    /**
     * This angle of the twist.
     *
     * @member {number}
     * @memberof TwistFilter#
     */
    angle: {
        get: function ()
        {
            return this.uniforms.angle.value;
        },
        set: function (value)
        {
            this.uniforms.angle.value = value;
        }
    }
});

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/index.js":[function(require,module,exports){
// run the polyfills
require('./polyfill');

var core = module.exports = require('./core');

// add core plugins.
core.extras         = require('./extras');
core.filters        = require('./filters');
core.interaction    = require('./interaction');
core.loaders        = require('./loaders');
core.mesh           = require('./mesh');
core.spine          = require('./spine');

// export a premade loader instance
core.loader = new core.loaders.Loader();

// mixin the deprecation features.
Object.assign(core, require('./deprecation'));

},{"./core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js","./deprecation":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/deprecation.js","./extras":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/index.js","./filters":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/filters/index.js","./interaction":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/interaction/index.js","./loaders":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/index.js","./mesh":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/mesh/index.js","./polyfill":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/polyfill/index.js","./spine":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/spine/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/interaction/InteractionData.js":[function(require,module,exports){
var core = require('../core');

/**
 * Holds all information related to an Interaction event
 *
 * @class
 * @memberof PIXI.interaction
 */
function InteractionData()
{
    /**
     * This point stores the global coords of where the touch/mouse event happened
     *
     * @member {Point}
     */
    this.global = new core.Point();

    /**
     * The target Sprite that was interacted with
     *
     * @member {Sprite}
     */
    this.target = null;

    /**
     * When passed to an event handler, this will be the original DOM Event that was captured
     *
     * @member {Event}
     */
    this.originalEvent = null;
}

InteractionData.prototype.constructor = InteractionData;
module.exports = InteractionData;

/**
 * This will return the local coordinates of the specified displayObject for this InteractionData
 *
 * @param displayObject {DisplayObject} The DisplayObject that you would like the local coords off
 * @param [point] {Point} A Point object in which to store the value, optional (otherwise will create a new point)
 * param [globalPos] {Point} A Point object containing your custom global coords, optional (otherwise will use the current global coords)
 * @return {Point} A point containing the coordinates of the InteractionData position relative to the DisplayObject
 */
InteractionData.prototype.getLocalPosition = function (displayObject, point, globalPos)
{
    var worldTransform = displayObject.worldTransform;
    var global = globalPos ? globalPos : this.global;

    // do a cheeky transform to get the mouse coords;
    var a00 = worldTransform.a, a01 = worldTransform.c, a02 = worldTransform.tx,
        a10 = worldTransform.b, a11 = worldTransform.d, a12 = worldTransform.ty,
        id = 1 / (a00 * a11 + a01 * -a10);

    point = point || new core.math.Point();

    point.x = a11 * id * global.x + -a01 * id * global.y + (a12 * a01 - a02 * a11) * id;
    point.y = a00 * id * global.y + -a10 * id * global.x + (-a12 * a00 + a02 * a10) * id;

    // set the mouse coords...
    return point;
};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/interaction/InteractionManager.js":[function(require,module,exports){
var core = require('../core'),
    InteractionData = require('./InteractionData');

// Mix interactiveTarget into core.DisplayObject.prototype
Object.assign(
    core.DisplayObject.prototype,
    require('./interactiveTarget')
);

/**
 * The interaction manager deals with mouse and touch events. Any DisplayObject can be interactive
 * if its interactive parameter is set to true
 * This manager also supports multitouch.
 *
 * @class
 * @memberof PIXI.interaction
 * @param renderer {CanvasRenderer|WebGLRenderer} A reference to the current renderer
 * @param [options] {object}
 * @param [options.autoPreventDefault=true] {boolean} Should the manager automatically prevent default browser actions.
 * @param [options.interactionFrequency=10] {number} Frequency increases the interaction events will be checked.
 */
function InteractionManager(renderer, options)
{
    options = options || {};

    /**
     * The renderer this interaction manager works for.
     *
     * @member {SystemRenderer}
     */
    this.renderer = renderer;

    /**
     * Should default browser actions automatically be prevented.
     *
     * @member {boolean}
     * @default true
     */
    this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;

    /**
     * As this frequency increases the interaction events will be checked more often.
     *
     * @member {number}
     * @default 10
     */
    this.interactionFrequency = options.interactionFrequency || 10;

    /**
     * The mouse data
     *
     * @member {InteractionData}
     */
    this.mouse = new InteractionData();

    /**
     * An event data object to handle all the event tracking/dispatching
     *
     * @member {EventData}
     */
    this.eventData = {
        stopped: false,
        target: null,
        type: null,
        data: this.mouse
    };

    /**
     * Tiny little interactiveData pool !
     *
     * @member {Array}
     */
    this.interactiveDataPool = [];

    /**
     * The DOM element to bind to.
     *
     * @member {HTMLElement}
     * @private
     */
    this.interactionDOMElement = null;

    /**
     * Have events been attached to the dom element?
     *
     * @member {boolean}
     * @private
     */
    this.eventsAdded = false;

    //this will make it so that you don't have to call bind all the time

    /**
     * @member {Function}
     */
    this.onMouseUp = this.onMouseUp.bind(this);
    this.processMouseUp = this.processMouseUp.bind( this );


    /**
     * @member {Function}
     */
    this.onMouseDown = this.onMouseDown.bind(this);
    this.processMouseDown = this.processMouseDown.bind( this );

    /**
     * @member {Function}
     */
    this.onMouseMove = this.onMouseMove.bind( this );
    this.processMouseMove = this.processMouseMove.bind( this );

    /**
     * @member {Function}
     */
    this.onMouseOut = this.onMouseOut.bind(this);
    this.processMouseOverOut = this.processMouseOverOut.bind( this );


    /**
     * @member {Function}
     */
    this.onTouchStart = this.onTouchStart.bind(this);
    this.processTouchStart = this.processTouchStart.bind(this);

    /**
     * @member {Function}
     */
    this.onTouchEnd = this.onTouchEnd.bind(this);
    this.processTouchEnd = this.processTouchEnd.bind(this);

    /**
     * @member {Function}
     */
    this.onTouchMove = this.onTouchMove.bind(this);
    this.processTouchMove = this.processTouchMove.bind(this);

    /**
     * @member {number}
     */
    this.last = 0;

    /**
     * The css style of the cursor that is being used
     * @member {string}
     */
    this.currentCursorStyle = 'inherit';

    /**
     * Internal cached var
     * @member {Point}
     * @private
     */
    this._tempPoint = new core.Point();

    /**
     * The current resolution
     * @member {number}
     */
    this.resolution = 1;

    /**
     * The update method bound to our context.
     *
     * @member {function}
     * @private
     */
    this.updateBound = this.update.bind(this);

    this.setTargetElement(this.renderer.view, this.renderer.resolution);

    this.update();
}

InteractionManager.prototype.constructor = InteractionManager;
module.exports = InteractionManager;

/**
 * Sets the DOM element which will receive mouse/touch events. This is useful for when you have
 * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate
 * another DOM element to receive those events.
 *
 * @param element {HTMLElement} the DOM element which will receive mouse and touch events.
 * @param [resolution=1] {number} THe resolution of the new element (relative to the canvas).
 * @private
 */
InteractionManager.prototype.setTargetElement = function (element, resolution)
{
    this.removeEvents();

    this.interactionDOMElement = element;

    this.resolution = resolution || 1;

    this.addEvents();
};

/**
 * Registers all the DOM events
 * @private
 */
InteractionManager.prototype.addEvents = function ()
{
    if (!this.interactionDOMElement)
    {
        return;
    }

    if (window.navigator.msPointerEnabled)
    {
        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
        this.interactionDOMElement.style['-ms-touch-action'] = 'none';
    }

    this.interactionDOMElement.addEventListener('mousemove',    this.onMouseMove, true);
    this.interactionDOMElement.addEventListener('mousedown',    this.onMouseDown, true);
    this.interactionDOMElement.addEventListener('mouseout',     this.onMouseOut, true);

    this.interactionDOMElement.addEventListener('touchstart',   this.onTouchStart, true);
    this.interactionDOMElement.addEventListener('touchend',     this.onTouchEnd, true);
    this.interactionDOMElement.addEventListener('touchmove',    this.onTouchMove, true);

    window.addEventListener('mouseup',  this.onMouseUp, true);

    this.eventsAdded = true;
};

/**
 * Removes all the DOM events that were previously registered
 * @private
 */
InteractionManager.prototype.removeEvents = function ()
{
    if (!this.interactionDOMElement)
    {
        return;
    }

    if (window.navigator.msPointerEnabled)
    {
        this.interactionDOMElement.style['-ms-content-zooming'] = '';
        this.interactionDOMElement.style['-ms-touch-action'] = '';
    }

    this.interactionDOMElement.removeEventListener('mousemove', this.onMouseMove, true);
    this.interactionDOMElement.removeEventListener('mousedown', this.onMouseDown, true);
    this.interactionDOMElement.removeEventListener('mouseout',  this.onMouseOut, true);

    this.interactionDOMElement.removeEventListener('touchstart', this.onTouchStart, true);
    this.interactionDOMElement.removeEventListener('touchend',  this.onTouchEnd, true);
    this.interactionDOMElement.removeEventListener('touchmove', this.onTouchMove, true);

    this.interactionDOMElement = null;

    window.removeEventListener('mouseup',  this.onMouseUp, true);

    this.eventsAdded = false;
};

/**
 * updates the state of interactive objects
 *
 * @private
 */
InteractionManager.prototype.update = function ()
{
    requestAnimationFrame(this.updateBound);

    if( this.throttleUpdate() || !this.interactionDOMElement)
    {
        return;
    }

    // if the user move the mouse this check has already been dfone using the mouse move!
    if(this.didMove)
    {
        this.didMove = false;
        return;
    }

    this.cursor = 'inherit';

    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered , this.processMouseOverOut.bind(this) , true );

    if (this.currentCursorStyle !== this.cursor)
    {
        this.currentCursorStyle = this.cursor;
        this.interactionDOMElement.style.cursor = this.cursor;
    }

    //TODO
};

/**
 * Dispatches an event on the display object that was interacted with
 * @param displayObject {Container|Sprite|TilingSprite} the display object in question
 * @param eventString {string} the name of the event (e.g, mousedown)
 * @param eventData {EventData} the event data object
 * @private
 */
InteractionManager.prototype.dispatchEvent = function ( displayObject, eventString, eventData )
{
    if(!eventData.stopped)
    {
        eventData.target = displayObject;
        eventData.type = eventString;

        displayObject.emit( eventString, eventData );

        if( displayObject[eventString] )
        {
            displayObject[eventString]( eventData );
        }
    }
};

/**
 * Ensures the interaction checks don't happen too often by delaying the update loop
 *
 * @private
 */
InteractionManager.prototype.throttleUpdate = function ()
{
    // frequency of 30fps??
    var now = Date.now();
    var diff = now - this.last;

    diff = (diff * this.interactionFrequency ) / 1000;

    if (diff < 1)
    {
        return true;
    }

    this.last = now;

    return false;
};

/**
 * Maps x and y coords from a DOM object and maps them correctly to the pixi view. The resulting value is stored in the point.
 * This takes into account the fact that the DOM element could be scaled and positioned anywhere on the screen.
 *
 * @param  {Point} point the point that the result will be stored in
 * @param  {number} x     the x coord of the position to map
 * @param  {number} y     the y coord of the position to map
 */
InteractionManager.prototype.mapPositionToPoint = function ( point, x, y )
{
    var rect = this.interactionDOMElement.getBoundingClientRect();
    point.x = ( ( x - rect.left ) * (this.interactionDOMElement.width  / rect.width  ) ) / this.resolution;
    point.y = ( ( y - rect.top  ) * (this.interactionDOMElement.height / rect.height ) ) / this.resolution;
};

/**
 * This function is provides a neat way of crawling through the scene graph and running a specified function on all interactive objects it finds.
 * It will also take care of hit testing the interactive objects and passes the hit across in the function.
 *
 * @param  {Point} point the point that is tested for collision
 * @param  {Container|Sprite|TilingSprite} displayObject the displayObject that will be hit test (recurcsivly crawls its children)
 * @param  {function} func the function that will be called on each interactive object. The displayObject and hit will be passed to the function
 * @param  {boolean} hitTest this indicates if the objects inside should be hit test against the point
 * @return {boolean} returns true if the displayObject hit the point
 */
InteractionManager.prototype.processInteractive = function (point, displayObject, func, hitTest, interactive )
{
    if(!displayObject.visible)
    {
        return false;
    }

    var children = displayObject.children;

    var hit = false;

    // if the object is interactive we must hit test all its children..
    interactive = interactive || displayObject.interactive;

    if(displayObject.interactiveChildren)
    {

        for (var i = children.length-1; i >= 0; i--)
        {
            if(! hit  && hitTest)
            {
                hit = this.processInteractive(point, children[i], func, true, interactive );
            }
            else
            {
                // now we know we can miss it all!
                this.processInteractive(point, children[i], func, false, false );
            }
        }

    }

    if(interactive)
    {
        if(hitTest)
        {
            if(displayObject.hitArea)
            {
                // lets use the hit object first!
                displayObject.worldTransform.applyInverse(point,  this._tempPoint);
                hit = displayObject.hitArea.contains( this._tempPoint.x, this._tempPoint.y );
            }
            else if(displayObject.containsPoint)
            {
                hit = displayObject.containsPoint(point);
            }
        }

        if(displayObject.interactive)
        {
            func(displayObject, hit);
        }
    }

    return hit;
};




/**
 * Is called when the mouse button is pressed down on the renderer element
 *
 * @param event {Event} The DOM event of a mouse button being pressed down
 * @private
 */
InteractionManager.prototype.onMouseDown = function (event)
{
    this.mouse.originalEvent = event;
    this.eventData.data = this.mouse;
    this.eventData.stopped = false;

    if (this.autoPreventDefault)
    {
        this.mouse.originalEvent.preventDefault();
    }

    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseDown, true );
};

/**
 * Processes the result of the mouse down check and dispatches the event if need be
 *
 * @param displayObject {Container|Sprite|TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the dispay object
 * @private
 */
InteractionManager.prototype.processMouseDown = function ( displayObject, hit )
{
    var e = this.mouse.originalEvent;

    var isRightButton = e.button === 2 || e.which === 3;

    if(hit)
    {
        displayObject[ isRightButton ? '_isRightDown' : '_isLeftDown' ] = true;
        this.dispatchEvent( displayObject, isRightButton ? 'rightdown' : 'mousedown', this.eventData );
    }
};



/**
 * Is called when the mouse button is released on the renderer element
 *
 * @param event {Event} The DOM event of a mouse button being released
 * @private
 */
InteractionManager.prototype.onMouseUp = function (event)
{
    this.mouse.originalEvent = event;
    this.eventData.data = this.mouse;
    this.eventData.stopped = false;

    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseUp, true );
};

/**
 * Processes the result of the mouse up check and dispatches the event if need be
 *
 * @param displayObject {Container|Sprite|TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processMouseUp = function ( displayObject, hit )
{
    var e = this.mouse.originalEvent;

    var isRightButton = e.button === 2 || e.which === 3;
    var isDown =  isRightButton ? '_isRightDown' : '_isLeftDown';

    if(hit)
    {
        this.dispatchEvent( displayObject, isRightButton ? 'rightup' : 'mouseup', this.eventData );

        if( displayObject[ isDown ] )
        {
            displayObject[ isDown ] = false;
            this.dispatchEvent( displayObject, isRightButton ? 'rightclick' : 'click', this.eventData );
        }
    }
    else
    {
        if( displayObject[ isDown ] )
        {
            displayObject[ isDown ] = false;
            this.dispatchEvent( displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', this.eventData );
        }
    }
};


/**
 * Is called when the mouse moves across the renderer element
 *
 * @param event {Event} The DOM event of the mouse moving
 * @private
 */
InteractionManager.prototype.onMouseMove = function (event)
{
    this.mouse.originalEvent = event;
    this.eventData.data = this.mouse;
    this.eventData.stopped = false;

    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY);

    this.didMove = true;

    this.cursor = 'inherit';

    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseMove, true );

    if (this.currentCursorStyle !== this.cursor)
    {
        this.currentCursorStyle = this.cursor;
        this.interactionDOMElement.style.cursor = this.cursor;
    }

    //TODO BUG for parents ineractive object (border order issue)
};

/**
 * Processes the result of the mouse move check and dispatches the event if need be
 *
 * @param displayObject {Container|Sprite|TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processMouseMove = function ( displayObject, hit )
{
    this.dispatchEvent( displayObject, 'mousemove', this.eventData);
    this.processMouseOverOut(displayObject, hit);
};


/**
 * Is called when the mouse is moved out of the renderer element
 *
 * @param event {Event} The DOM event of a mouse being moved out
 * @private
 */
InteractionManager.prototype.onMouseOut = function (event)
{
    this.mouse.originalEvent = event;
    this.eventData.stopped = false;

    this.interactionDOMElement.style.cursor = 'inherit';

    // TODO optimize by not check EVERY TIME! maybe half as often? //
    this.mapPositionToPoint( this.mouse.global, event.clientX, event.clientY );

    this.processInteractive( this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, false );
};

/**
 * Processes the result of the mouse over/out check and dispatches the event if need be
 *
 * @param displayObject {Container|Sprite|TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processMouseOverOut = function ( displayObject, hit )
{
    if(hit)
    {
        if(!displayObject._over)
        {
            displayObject._over = true;
            this.dispatchEvent( displayObject, 'mouseover', this.eventData );
        }

        if (displayObject.buttonMode)
        {
            this.cursor = displayObject.defaultCursor;
        }
    }
    else
    {
        if(displayObject._over)
        {
            displayObject._over = false;
            this.dispatchEvent( displayObject, 'mouseout', this.eventData);
        }
    }
};


/**
 * Is called when a touch is started on the renderer element
 *
 * @param event {Event} The DOM event of a touch starting on the renderer view
 * @private
 */
InteractionManager.prototype.onTouchStart = function (event)
{
    if (this.autoPreventDefault)
    {
        event.preventDefault();
    }

    var changedTouches = event.changedTouches;
    var cLength = changedTouches.length;

    for (var i=0; i < cLength; i++)
    {
        var touchEvent = changedTouches[i];
        //TODO POOL
        var touchData = this.getTouchData( touchEvent );

        touchData.originalEvent = event;

        this.eventData.data = touchData;
        this.eventData.stopped = false;

        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchStart, true );

        this.returnTouchData( touchData );
    }
};

/**
 * Processes the result of a touch check and dispatches the event if need be
 *
 * @param displayObject {Container|Sprite|TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processTouchStart = function ( displayObject, hit )
{
    //console.log("hit" + hit)
    if(hit)
    {
        displayObject._touchDown = true;
        this.dispatchEvent( displayObject, 'touchstart', this.eventData );
    }
};


/**
 * Is called when a touch ends on the renderer element
 * @param event {Event} The DOM event of a touch ending on the renderer view
 *
 */
InteractionManager.prototype.onTouchEnd = function (event)
{
    if (this.autoPreventDefault)
    {
        event.preventDefault();
    }

    var changedTouches = event.changedTouches;
    var cLength = changedTouches.length;

    for (var i=0; i < cLength; i++)
    {
        var touchEvent = changedTouches[i];

        var touchData = this.getTouchData( touchEvent );

        touchData.originalEvent = event;

        //TODO this should be passed along.. no set
        this.eventData.data = touchData;
        this.eventData.stopped = false;


        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchEnd, true );

        this.returnTouchData( touchData );
    }
};

/**
 * Processes the result of the end of a touch and dispatches the event if need be
 *
 * @param displayObject {Container|Sprite|TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processTouchEnd = function ( displayObject, hit )
{
    if(hit)
    {
        this.dispatchEvent( displayObject, 'touchend', this.eventData );

        if( displayObject._touchDown )
        {
            displayObject._touchDown = false;
            this.dispatchEvent( displayObject, 'tap', this.eventData );
        }
    }
    else
    {
        if( displayObject._touchDown )
        {
            displayObject._touchDown = false;
            this.dispatchEvent( displayObject, 'touchendoutside', this.eventData );
        }
    }
};

/**
 * Is called when a touch is moved across the renderer element
 *
 * @param event {Event} The DOM event of a touch moving across the renderer view
 * @private
 */
InteractionManager.prototype.onTouchMove = function (event)
{
    if (this.autoPreventDefault)
    {
        event.preventDefault();
    }

    var changedTouches = event.changedTouches;
    var cLength = changedTouches.length;

    for (var i=0; i < cLength; i++)
    {
        var touchEvent = changedTouches[i];

        var touchData = this.getTouchData( touchEvent );

        touchData.originalEvent = event;

        this.eventData.data = touchData;
        this.eventData.stopped = false;

        this.processInteractive( touchData.global, this.renderer._lastObjectRendered, this.processTouchMove, false );

        this.returnTouchData( touchData );
    }
};

/**
 * Processes the result of a touch move check and dispatches the event if need be
 *
 * @param displayObject {Container|Sprite|TilingSprite} The display object that was tested
 * @param hit {boolean} the result of the hit test on the display object
 * @private
 */
InteractionManager.prototype.processTouchMove = function ( displayObject, hit )
{
    hit = hit;
    this.dispatchEvent( displayObject, 'touchmove', this.eventData);
};

/**
 * Grabs an interaction data object from the internal pool
 *
 * @param touchEvent {EventData} The touch event we need to pair with an interactionData object
 *
 * @private
 */
InteractionManager.prototype.getTouchData = function (touchEvent)
{
    var touchData = this.interactiveDataPool.pop();

    if(!touchData)
    {
        touchData = new InteractionData();
    }

    touchData.identifier = touchEvent.identifier;
    this.mapPositionToPoint( touchData.global, touchEvent.clientX, touchEvent.clientY );

    touchEvent.globalX = touchData.global.x;
    touchEvent.globalY = touchData.global.y;

    return touchData;
};

/**
 * Returns an interaction data object to the internal pool
 *
 * @param touchData {InteractionData} The touch data object we want to return to the pool
 *
 * @private
 */
InteractionManager.prototype.returnTouchData = function ( touchData )
{
    this.interactiveDataPool.push( touchData );
};

/**
 * Destroys the interaction manager
 */
InteractionManager.prototype.destroy = function () {
    this.renderer = null;

    this.mouse = null;

    this.eventData = null;

    this.interactiveDataPool = null;

    this.interactionDOMElement = null;

    this.onMouseUp = null;
    this.processMouseUp = null;


    this.onMouseDown = null;
    this.processMouseDown = null;

    this.onMouseMove = null;
    this.processMouseMove = null;

    this.onMouseOut = null;
    this.processMouseOverOut = null;


    this.onTouchStart = null;
    this.processTouchStart = null;

    this.onTouchEnd = null;
    this.processTouchEnd = null;

    this.onTouchMove = null;
    this.processTouchMove = null;

    this._tempPoint = null;

    this.updateBound = null;
};

core.WebGLRenderer.registerPlugin('interaction', InteractionManager);
core.CanvasRenderer.registerPlugin('interaction', InteractionManager);

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js","./InteractionData":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/interaction/InteractionData.js","./interactiveTarget":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/interaction/interactiveTarget.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/interaction/index.js":[function(require,module,exports){
/**
 * @file        Main export of the PIXI interactions library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.interaction
 */
module.exports = {
    InteractionData:    require('./InteractionData'),
    InteractionManager: require('./InteractionManager'),
    interactiveTarget: require('./interactiveTarget')
};

},{"./InteractionData":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/interaction/InteractionData.js","./InteractionManager":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/interaction/InteractionManager.js","./interactiveTarget":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/interaction/interactiveTarget.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/interaction/interactiveTarget.js":[function(require,module,exports){
/**
 * Default property values of interactive objects
 * used by {@link PIXI.interaction.InteractionManager}.
 *
 * @mixin
 * @memberof PIXI.interaction
 * @example
 *      function MyObject() {}
 *
 *      Object.assign(
 *          MyObject.prototype,
 *          PIXI.interaction.interactiveTarget)
 *      );
 */

module.exports = {
    /**
     * @todo
     */
    interactive: false,
    /**
     * @todo
     */
    buttonMode: false,
    /**
     * @todo
     */
    interactiveChildren: true,
    /**
     * @todo
     */
    defaultCursor: 'pointer',

    // some internal checks..

    /**
     * @todo
     * @private
     */
    _over: false,
    /**
     * @todo
     * @private
     */
    _touchDown: false
};

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/bitmapFontParser.js":[function(require,module,exports){
var Resource = require('resource-loader').Resource,
    core = require('../core'),
    extras = require('../extras'),
    path = require('path');

module.exports = function ()
{
    return function (resource, next)
    {
        // skip if no data
        if (!resource.data)
        {
            return next();
        }

        var name = resource.data.nodeName && resource.data.nodeName.toLowerCase();

        // skip if not xml data
        if (!name || (name !== '#document' && name !== 'div'))
        {
            return next();
        }

        // skip if not bitmap font data, using some silly duck-typing
        if (
            resource.data.getElementsByTagName('page').length === 0 ||
            resource.data.getElementsByTagName('info').length === 0 ||
            resource.data.getElementsByTagName('info')[0].getAttribute('face') === null
            )
        {
            return next();
        }

        var xmlUrl = path.dirname(resource.url);

        if (xmlUrl === '.') {
            xmlUrl = '';
        }

        if (this.baseUrl && xmlUrl) {
            // if baseurl has a trailing slash then add one to xmlUrl so the replace works below
            if (this.baseUrl.charAt(this.baseUrl.length - 1) === '/') {
                xmlUrl += '/';
            }

            // remove baseUrl from xmlUrl
            xmlUrl = xmlUrl.replace(this.baseUrl, '');
        }

        // if there is an xmlUrl now, it needs a trailing slash. Ensure that it does if the string isn't empty.
        if (xmlUrl && xmlUrl.charAt(xmlUrl.length - 1) !== '/') {
            xmlUrl += '/';
        }

        var textureUrl = xmlUrl + resource.data.getElementsByTagName('page')[0].getAttribute('file');
        var loadOptions = {
            crossOrigin: resource.crossOrigin,
            loadType: Resource.LOAD_TYPE.IMAGE
        };

        // load the texture for the font
        this.add(resource.name + '_image', textureUrl, loadOptions, function (res)
        {
            var data = {};
            var info = resource.data.getElementsByTagName('info')[0];
            var common = resource.data.getElementsByTagName('common')[0];

            data.font = info.getAttribute('face');
            data.size = parseInt(info.getAttribute('size'), 10);
            data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);
            data.chars = {};

            //parse letters
            var letters = resource.data.getElementsByTagName('char');

            for (var i = 0; i < letters.length; i++)
            {
                var charCode = parseInt(letters[i].getAttribute('id'), 10);

                var textureRect = new core.math.Rectangle(
                    parseInt(letters[i].getAttribute('x'), 10),
                    parseInt(letters[i].getAttribute('y'), 10),
                    parseInt(letters[i].getAttribute('width'), 10),
                    parseInt(letters[i].getAttribute('height'), 10)
                );

                data.chars[charCode] = {
                    xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),
                    yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),
                    xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10),
                    kerning: {},
                    texture: core.utils.TextureCache[charCode] = new core.Texture(res.texture.baseTexture, textureRect)

                };
            }

            //parse kernings
            var kernings = resource.data.getElementsByTagName('kerning');
            for (i = 0; i < kernings.length; i++)
            {
                var first = parseInt(kernings[i].getAttribute('first'), 10);
                var second = parseInt(kernings[i].getAttribute('second'), 10);
                var amount = parseInt(kernings[i].getAttribute('amount'), 10);

                data.chars[second].kerning[first] = amount;

            }

            resource.bitmapFont = data;

            // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3
            // but it's very likely to change
            extras.BitmapText.fonts[data.font] = data;

            next();
        });
    };
};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js","../extras":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/extras/index.js","path":"/Users/tyemilldeveloper/space-game/node_modules/browserify/node_modules/path-browserify/index.js","resource-loader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/index.js":[function(require,module,exports){
/**
 * @file        Main export of the PIXI loaders library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.loaders
 */
module.exports = {
    Loader:             require('./loader'),

    // parsers
    bitmapFontParser:   require('./bitmapFontParser'),
    spineAtlasParser:   require('./spineAtlasParser'),
    spritesheetParser:  require('./spritesheetParser'),
    textureParser:      require('./textureParser')
};

},{"./bitmapFontParser":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/bitmapFontParser.js","./loader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/loader.js","./spineAtlasParser":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/spineAtlasParser.js","./spritesheetParser":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/spritesheetParser.js","./textureParser":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/textureParser.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/loader.js":[function(require,module,exports){
var ResourceLoader = require('resource-loader'),
    textureParser = require('./textureParser'),
    spritesheetParser = require('./spritesheetParser'),
    spineAtlasParser = require('./spineAtlasParser'),
    bitmapFontParser = require('./bitmapFontParser');

/**
 *
 * The new loader, extends Resource Loader by Chad Engler : https://github.com/englercj/resource-loader
 *
 * ```js
 * var loader = new PIXI.loader();
 *
 * loader.add('spineboy',"data/spineboy.json");
 *
 * loader.once('complete',onAssetsLoaded);
 *
 * loader.load();
 * ```
 *
 * @class
 * @extends ResourceLoader
 * @memberof PIXI.loaders
 * @param [baseUrl=''] {string} The base url for all resources loaded by this loader.
 * @param [concurrency=10] {number} The number of resources to load concurrently.
 */
function Loader(baseUrl, concurrency)
{
    ResourceLoader.call(this, baseUrl, concurrency);

    // parse any blob into more usable objects (e.g. Image)
    this.use(ResourceLoader.middleware.parsing.blob());

    // parse any Image objects into textures
    this.use(textureParser());

    // parse any spritesheet data into multiple textures
    this.use(spritesheetParser());

    // parse any spine data into a spine object
    this.use(spineAtlasParser());

    // parse any spritesheet data into multiple textures
    this.use(bitmapFontParser());
}

Loader.prototype = Object.create(ResourceLoader.prototype);
Loader.prototype.constructor = Loader;

module.exports = Loader;

},{"./bitmapFontParser":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/bitmapFontParser.js","./spineAtlasParser":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/spineAtlasParser.js","./spritesheetParser":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/spritesheetParser.js","./textureParser":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/textureParser.js","resource-loader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/spineAtlasParser.js":[function(require,module,exports){
var Resource = require('resource-loader').Resource,
    async = require('async'),
    spine = require('../spine');

module.exports = function ()
{
    return function (resource, next)
    {
        // skip if no data
        if (!resource.data || !resource.data.bones)
        {
            return next();
        }

        /**
         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files
         * that correspond to the spine file are in the same base URL and that the .json and .atlas files
         * have the same name
         */
        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + '.atlas';
        var atlasOptions = {
            crossOrigin: resource.crossOrigin,
            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT
        };
        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);


        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res)
        {
            // create a spine atlas using the loaded text
            var spineAtlas = new spine.SpineRuntime.Atlas(this.xhr.responseText, baseUrl, res.crossOrigin);

            // spine animation
            var spineJsonParser = new spine.SpineRuntime.SkeletonJsonParser(new spine.SpineRuntime.AtlasAttachmentParser(spineAtlas));
            var skeletonData = spineJsonParser.readSkeletonData(resource.data);

            resource.spineData = skeletonData;
            resource.spineAtlas = spineAtlas;

            // Go through each spineAtlas.pages and wait for page.rendererObject (a baseTexture) to
            // load. Once all loaded, then call the next function.
            async.each(spineAtlas.pages, function (page, done)
            {
                if (page.rendererObject.hasLoaded)
                {
                    done();
                }
                else
                {
                    page.rendererObject.once('loaded', done);
                }
            }, next);
        });
    };
};

},{"../spine":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/spine/index.js","async":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/async/lib/async.js","resource-loader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/spritesheetParser.js":[function(require,module,exports){
var Resource = require('resource-loader').Resource,
    path = require('path'),
    core = require('../core');

module.exports = function ()
{
    return function (resource, next)
    {
        // skip if no data
        if (!resource.data || !resource.data.frames)
        {
            return next();
        }

        var loadOptions = {
            crossOrigin: resource.crossOrigin,
            loadType: Resource.LOAD_TYPE.IMAGE
        };

        var route = path.dirname(resource.url.replace(this.baseUrl, ''));

        var resolution = core.utils.getResolutionOfUrl( resource.url );

        // load the image for this sheet
        this.add(resource.name + '_image', route + '/' + resource.data.meta.image, loadOptions, function (res)
        {
            resource.textures = {};

            var frames = resource.data.frames;

            for (var i in frames)
            {
                var rect = frames[i].frame;

                if (rect)
                {
                    var size = null;
                    var trim = null;

                    if (frames[i].rotated) {
                        size = new core.math.Rectangle(rect.x, rect.y, rect.h, rect.w);
                    }
                    else {
                        size = new core.math.Rectangle(rect.x, rect.y, rect.w, rect.h);
                    }

                    //  Check to see if the sprite is trimmed
                    if (frames[i].trimmed)
                    {
                        trim = new core.math.Rectangle(
                            frames[i].spriteSourceSize.x / resolution,
                            frames[i].spriteSourceSize.y / resolution,
                            frames[i].sourceSize.w / resolution,
                            frames[i].sourceSize.h / resolution
                         );
                    }

                    // flip the width and height!
                    if (frames[i].rotated)
                    {
                        var temp = size.width;
                        size.width = size.height;
                        size.height = temp;
                    }

                    size.x /= resolution;
                    size.y /= resolution;
                    size.width /= resolution;
                    size.height /= resolution;

                    resource.textures[i] = new core.Texture(res.texture.baseTexture, size, size.clone(), trim, frames[i].rotated);

                    // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions
                    core.utils.TextureCache[i] = resource.textures[i];
                }
            }

            next();
        });
    };
};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js","path":"/Users/tyemilldeveloper/space-game/node_modules/browserify/node_modules/path-browserify/index.js","resource-loader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/resource-loader/src/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/loaders/textureParser.js":[function(require,module,exports){
var core = require('../core');

module.exports = function ()
{
    return function (resource, next)
    {
        // create a new texture if the data is an Image object
        if (resource.data && resource.data.nodeName && resource.data.nodeName.toLowerCase() === 'img')
        {
            resource.texture = new core.Texture(new core.BaseTexture(resource.data, null, core.utils.getResolutionOfUrl(resource.url)));
            // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions
            core.utils.TextureCache[resource.url] = resource.texture;
        }

        next();
    };
};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/mesh/Mesh.js":[function(require,module,exports){
var core = require('../core');

/**
 * Base mesh class
 * @class
 * @extends Container
 * @memberof PIXI.mesh
 * @param texture {Texture} The texture to use
 * @param [vertices] {Float32Arrif you want to specify the vertices
 * @param [uvs] {Float32Array} if you want to specify the uvs
 * @param [indices] {Uint16Array} if you want to specify the indices
 * @param [drawMode] {number} the drawMode, can be any of the Mesh.DRAW_MODES consts
 */
function Mesh(texture, vertices, uvs, indices, drawMode)
{
    core.Container.call(this);

    /**
     * The texture of the Mesh
     *
     * @member {Texture}
     */
    this.texture = texture;

    /**
     * The Uvs of the Mesh
     *
     * @member {Float32Array}
     */
    this.uvs = uvs || new Float32Array([0, 1,
                                 1, 1,
                                 1, 0,
                                 0, 1]);

    /**
     * An array of vertices
     *
     * @member {Float32Array}
     */
    this.vertices = vertices || new Float32Array([0, 0,
                                      100, 0,
                                      100, 100,
                                      0, 100]);

    /*
     * @member {Uint16Array} An array containing the indices of the vertices
     */
    //  TODO auto generate this based on draw mode!
    this.indices = indices || new Uint16Array([0, 1, 2, 3]);

    /**
     * Whether the Mesh is dirty or not
     *
     * @member {boolean}
     */
    this.dirty = true;

    /**
     * The blend mode to be applied to the sprite. Set to blendModes.NORMAL to remove any blend mode.
     *
     * @member {number}
     * @default CONST.BLEND_MODES.NORMAL;
     */
    this.blendMode = core.BLEND_MODES.NORMAL;

    /**
     * Triangles in canvas mode are automatically antialiased, use this value to force triangles to overlap a bit with each other.
     *
     * @member {number}
     */
    this.canvasPadding = 0;

    /**
     * The way the Mesh should be drawn, can be any of the Mesh.DRAW_MODES consts
     *
     * @member {number}
     */
    this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;
}

// constructor
Mesh.prototype = Object.create(core.Container.prototype);
Mesh.prototype.constructor = Mesh;
module.exports = Mesh;

/**
 * Renders the object using the WebGL renderer
 *
 * @param renderer {WebGLRenderer} a reference to the WebGL renderer
 * @private
 */
Mesh.prototype._renderWebGL = function (renderer)
{
    renderer.setObjectRenderer(renderer.plugins.mesh);
    renderer.plugins.mesh.render(this);
};

/**
 * Renders the object using the Canvas renderer
 *
 * @param renderer {CanvasRenderer}
 * @private
 */
Mesh.prototype._renderCanvas = function (renderer)
{
    var context = renderer.context;

    var transform = this.worldTransform;

    if (renderer.roundPixels)
    {
        context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx | 0, transform.ty | 0);
    }
    else
    {
        context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
    }

    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH)
    {
        this._renderCanvasTriangleMesh(context);
    }
    else
    {
        this._renderCanvasTriangles(context);
    }
};

/**
 * Draws the object in Triangle Mesh mode using canvas
 *
 * @param context {CanvasRenderingContext2D} the current drawing context
 * @private
 */
Mesh.prototype._renderCanvasTriangleMesh = function (context)
{
    // draw triangles!!
    var vertices = this.vertices;
    var uvs = this.uvs;

    var length = vertices.length / 2;
    // this.count++;

    for (var i = 0; i < length - 2; i++)
    {
        // draw some triangles!
        var index = i * 2;
        this._renderCanvasDrawTriangle(context, vertices, uvs, index, (index + 2), (index + 4));
    }
};

/**
 * Draws the object in triangle mode using canvas
 *
 * @param context {CanvasRenderingContext2D} the current drawing context
 * @private
 */
Mesh.prototype._renderCanvasTriangles = function (context)
{
    // draw triangles!!
    var vertices = this.vertices;
    var uvs = this.uvs;
    var indices = this.indices;

    var length = indices.length;
    // this.count++;

    for (var i = 0; i < length; i += 3)
    {
        // draw some triangles!
        var index0 = indices[i] * 2, index1 = indices[i + 1] * 2, index2 = indices[i + 2] * 2;
        this._renderCanvasDrawTriangle(context, vertices, uvs, index0, index1, index2);
    }
};

/**
 * Draws one of the triangles that form this Mesh
 *
 * @param context {CanvasRenderingContext2D} the current drawing context
 * @param vertices {Float32Array} a reference to the vertices of the Mesh
 * @param uvs {Float32Array} a reference to the uvs of the Mesh
 * @param index0 {number} the index of the first vertex
 * @param index1 {number} the index of the second vertex
 * @param index2 {number} the index of the third vertex
 * @private
 */
Mesh.prototype._renderCanvasDrawTriangle = function (context, vertices, uvs, index0, index1, index2)
{
    var textureSource = this.texture.baseTexture.source;
    var textureWidth = this.texture.width;
    var textureHeight = this.texture.height;

    var x0 = vertices[index0], x1 = vertices[index1], x2 = vertices[index2];
    var y0 = vertices[index0 + 1], y1 = vertices[index1 + 1], y2 = vertices[index2 + 1];

    var u0 = uvs[index0] * textureWidth, u1 = uvs[index1] * textureWidth, u2 = uvs[index2] * textureWidth;
    var v0 = uvs[index0 + 1] * textureHeight, v1 = uvs[index1 + 1] * textureHeight, v2 = uvs[index2 + 1] * textureHeight;

    if (this.canvasPadding > 0)
    {
        var paddingX = this.canvasPadding / this.worldTransform.a;
        var paddingY = this.canvasPadding / this.worldTransform.d;
        var centerX = (x0 + x1 + x2) / 3;
        var centerY = (y0 + y1 + y2) / 3;

        var normX = x0 - centerX;
        var normY = y0 - centerY;

        var dist = Math.sqrt(normX * normX + normY * normY);
        x0 = centerX + (normX / dist) * (dist + paddingX);
        y0 = centerY + (normY / dist) * (dist + paddingY);

        //

        normX = x1 - centerX;
        normY = y1 - centerY;

        dist = Math.sqrt(normX * normX + normY * normY);
        x1 = centerX + (normX / dist) * (dist + paddingX);
        y1 = centerY + (normY / dist) * (dist + paddingY);

        normX = x2 - centerX;
        normY = y2 - centerY;

        dist = Math.sqrt(normX * normX + normY * normY);
        x2 = centerX + (normX / dist) * (dist + paddingX);
        y2 = centerY + (normY / dist) * (dist + paddingY);
    }

    context.save();
    context.beginPath();


    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);

    context.closePath();

    context.clip();

    // Compute matrix transform
    var delta =  (u0 * v1)      + (v0 * u2)      + (u1 * v2)      - (v1 * u2)      - (v0 * u1)      - (u0 * v2);
    var deltaA = (x0 * v1)      + (v0 * x2)      + (x1 * v2)      - (v1 * x2)      - (v0 * x1)      - (x0 * v2);
    var deltaB = (u0 * x1)      + (x0 * u2)      + (u1 * x2)      - (x1 * u2)      - (x0 * u1)      - (u0 * x2);
    var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
    var deltaD = (y0 * v1)      + (v0 * y2)      + (y1 * v2)      - (v1 * y2)      - (v0 * y1)      - (y0 * v2);
    var deltaE = (u0 * y1)      + (y0 * u2)      + (u1 * y2)      - (y1 * u2)      - (y0 * u1)      - (u0 * y2);
    var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);

    context.transform(deltaA / delta, deltaD / delta,
        deltaB / delta, deltaE / delta,
        deltaC / delta, deltaF / delta);

    context.drawImage(textureSource, 0, 0);
    context.restore();
};



/**
 * Renders a flat Mesh
 *
 * @param Mesh {Mesh} The Mesh to render
 * @private
 */
Mesh.prototype.renderMeshFlat = function (Mesh)
{
    var context = this.context;
    var vertices = Mesh.vertices;

    var length = vertices.length/2;
    // this.count++;

    context.beginPath();
    for (var i=1; i < length-2; i++)
    {
        // draw some triangles!
        var index = i*2;

        var x0 = vertices[index],   x1 = vertices[index+2], x2 = vertices[index+4];
        var y0 = vertices[index+1], y1 = vertices[index+3], y2 = vertices[index+5];

        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
    }

    context.fillStyle = '#FF0000';
    context.fill();
    context.closePath();
};

/*
Mesh.prototype.setTexture = function (texture)
{
    //TODO SET THE TEXTURES
    //TODO VISIBILITY
    //TODO SETTER

    // stop current texture
    this.texture = texture;
    this.width   = texture.frame.width;
    this.height  = texture.frame.height;
    this.updateFrame = true;
};
 */

/**
 * When the texture is updated, this event will fire to update the scale and frame
 *
 * @param event
 * @private
 */

Mesh.prototype.onTextureUpdate = function ()
{
    this.updateFrame = true;
};

/**
 * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
 *
 * @param matrix {Matrix} the transformation matrix of the sprite
 * @return {Rectangle} the framing rectangle
 */
Mesh.prototype.getBounds = function (matrix)
{
    var worldTransform = matrix || this.worldTransform;

    var a = worldTransform.a;
    var b = worldTransform.b;
    var c = worldTransform.c;
    var d = worldTransform.d;
    var tx = worldTransform.tx;
    var ty = worldTransform.ty;

    var maxX = -Infinity;
    var maxY = -Infinity;

    var minX = Infinity;
    var minY = Infinity;

    var vertices = this.vertices;
    for (var i = 0, n = vertices.length; i < n; i += 2)
    {
        var rawX = vertices[i], rawY = vertices[i + 1];
        var x = (a * rawX) + (c * rawY) + tx;
        var y = (d * rawY) + (b * rawX) + ty;

        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;

        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
    }

    if (minX === -Infinity || maxY === Infinity)
    {
        return core.math.Rectangle.EMPTY;
    }

    var bounds = this._bounds;

    bounds.x = minX;
    bounds.width = maxX - minX;

    bounds.y = minY;
    bounds.height = maxY - minY;

    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate
    this._currentBounds = bounds;

    return bounds;
};

/**
 * Different drawing buffer modes supported
 *
 * @static
 * @constant
 * @property {object} DRAW_MODES
 * @property {number} DRAW_MODES.TRIANGLE_MESH
 * @property {number} DRAW_MODES.TRIANGLES
 */
Mesh.DRAW_MODES = {
    TRIANGLE_MESH: 0,
    TRIANGLES: 1
};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/mesh/Rope.js":[function(require,module,exports){
var Mesh = require('./Mesh');

/**
 * The rope allows you to draw a texture across several points and them manipulate these points
 *
 *```js
 * for (var i = 0; i < 20; i++) {
 *     points.push(new PIXI.Point(i * 50, 0));
 * };
 * var rope = new PIXI.Rope(PIXI.Texture.fromImage("snake.png"), points);
 *  ```
 *
 * @class
 * @extends Mesh
 * @memberof PIXI.mesh
 * @param {Texture} texture - The texture to use on the rope.
 * @param {Array} points - An array of {Point} objects to construct this rope.
 *
 */
function Rope(texture, points)
{
    Mesh.call(this, texture);

    /*
     * @member {Array} An array of points that determine the rope
     */
    this.points = points;

    /*
     * @member {Float32Array} An array of vertices used to construct this rope.
     */
    this.vertices = new Float32Array(points.length * 4);

    /*
     * @member {Float32Array} The WebGL Uvs of the rope.
     */
    this.uvs = new Float32Array(points.length * 4);

    /*
     * @member {Float32Array} An array containing the color components
     */
    this.colors = new Float32Array(points.length * 2);

    /*
     * @member {Uint16Array} An array containing the indices of the vertices
     */
    this.indices = new Uint16Array(points.length * 2);

    this.refresh();
}


// constructor
Rope.prototype = Object.create(Mesh.prototype);
Rope.prototype.constructor = Rope;
module.exports = Rope;

/**
 * Refreshes
 *
 */
Rope.prototype.refresh = function ()
{
    var points = this.points;

    if (points.length < 1)
    {
        return;
    }

    var uvs = this.uvs;

    var indices = this.indices;
    var colors = this.colors;

    // this.count -= 0.2;

    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;

    colors[0] = 1;
    colors[1] = 1;

    indices[0] = 0;
    indices[1] = 1;

    var total = points.length,
        point, index, amount;

    for (var i = 1; i < total; i++)
    {
        point = points[i];
        index = i * 4;
        // time to do some smart drawing!
        amount = i / (total-1);

        if (i%2)
        {
            uvs[index] = amount;
            uvs[index+1] = 0;

            uvs[index+2] = amount;
            uvs[index+3] = 1;
        }
        else
        {
            uvs[index] = amount;
            uvs[index+1] = 0;

            uvs[index+2] = amount;
            uvs[index+3] = 1;
        }

        index = i * 2;
        colors[index] = 1;
        colors[index+1] = 1;

        index = i * 2;
        indices[index] = index;
        indices[index + 1] = index + 1;
    }
};

/*
 * Updates the object transform for rendering
 *
 * @private
 */
Rope.prototype.updateTransform = function ()
{
    var points = this.points;

    if (points.length < 1)
    {
        return;
    }

    var lastPoint = points[0];
    var nextPoint;
    var perpX = 0;
    var perpY = 0;

    // this.count -= 0.2;

    var vertices = this.vertices;
    var total = points.length,
        point, index, ratio, perpLength, num;

    for (var i = 0; i < total; i++)
    {
        point = points[i];
        index = i * 4;

        if (i < points.length-1)
        {
            nextPoint = points[i+1];
        }
        else
        {
            nextPoint = point;
        }

        perpY = -(nextPoint.x - lastPoint.x);
        perpX = nextPoint.y - lastPoint.y;

        ratio = (1 - (i / (total-1))) * 10;

        if (ratio > 1)
        {
            ratio = 1;
        }

        perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
        num = this.texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;
        perpX /= perpLength;
        perpY /= perpLength;

        perpX *= num;
        perpY *= num;

        vertices[index] = point.x + perpX;
        vertices[index+1] = point.y + perpY;
        vertices[index+2] = point.x - perpX;
        vertices[index+3] = point.y - perpY;

        lastPoint = point;
    }

    this.containerUpdateTransform();
};

},{"./Mesh":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/mesh/Mesh.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/mesh/index.js":[function(require,module,exports){
/**
 * @file        Main export of the PIXI extras library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.mesh
 */
module.exports = {
    Mesh:           require('./Mesh'),
    Rope:           require('./Rope'),
    MeshRenderer:   require('./webgl/MeshRenderer'),
    MeshShader:     require('./webgl/MeshShader')
};

},{"./Mesh":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/mesh/Mesh.js","./Rope":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/mesh/Rope.js","./webgl/MeshRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/mesh/webgl/MeshRenderer.js","./webgl/MeshShader":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/mesh/webgl/MeshShader.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/mesh/webgl/MeshRenderer.js":[function(require,module,exports){
var ObjectRenderer = require('../../core/renderers/webgl/utils/ObjectRenderer'),
    WebGLRenderer = require('../../core/renderers/webgl/WebGLRenderer');

/**
 * @author Mat Groves
 *
 * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
 * for creating the original pixi version!
 * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer
 *
 * Heavily inspired by LibGDX's MeshRenderer:
 * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/MeshRenderer.java
 */

/**
 *
 * @class
 * @private
 * @memberof PIXI.mesh
 * @extends ObjectRenderer
 * @param renderer {WebGLRenderer} The renderer this sprite batch works for.
 */
function MeshRenderer(renderer)
{
    ObjectRenderer.call(this, renderer);


    /**
     * Holds the indices
     *
     * @member {Uint16Array}
     */
    this.indices = new Uint16Array(15000);

    //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers
    for (var i=0, j=0; i < 15000; i += 6, j += 4)
    {
        this.indices[i + 0] = j + 0;
        this.indices[i + 1] = j + 1;
        this.indices[i + 2] = j + 2;
        this.indices[i + 3] = j + 0;
        this.indices[i + 4] = j + 2;
        this.indices[i + 5] = j + 3;
    }
}

MeshRenderer.prototype = Object.create(ObjectRenderer.prototype);
MeshRenderer.prototype.constructor = MeshRenderer;
module.exports = MeshRenderer;

WebGLRenderer.registerPlugin('mesh', MeshRenderer);

/**
 * Sets up the renderer context and necessary buffers.
 *
 * @private
 * @param gl {WebGLRenderingContext} the current WebGL drawing context
 */
MeshRenderer.prototype.onContextChange = function ()
{

};

/**
 * Renders the sprite object.
 *
 * @param mesh {Mesh} the mesh to render
 */
MeshRenderer.prototype.render = function (mesh)
{
//    return;
    if(!mesh._vertexBuffer)
    {
        this._initWebGL(mesh);
    }

    var renderer = this.renderer,
        gl = renderer.gl,
        texture = mesh.texture.baseTexture,
        shader = renderer.shaderManager.plugins.meshShader;

//    var drawMode = mesh.drawMode === Strip.DRAW_MODES.TRIANGLE_STRIP ? gl.TRIANGLE_STRIP : gl.TRIANGLES;
    var drawMode =  gl.TRIANGLE_STRIP;

    renderer.blendModeManager.setBlendMode(mesh.blendMode);


    // set uniforms
    gl.uniformMatrix3fv(shader.uniforms.translationMatrix._location, false, mesh.worldTransform.toArray(true));

    gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, renderer.currentRenderTarget.projectionMatrix.toArray(true));
    gl.uniform1f(shader.uniforms.alpha._location, mesh.worldAlpha);

    if (!mesh.dirty)
    {

        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, mesh.vertices);
        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);


        // update the uvs
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
        gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);


        gl.activeTexture(gl.TEXTURE0);

       if (!texture._glTextures[gl.id])
        {
            this.renderer.updateTexture(texture);
        }
        else
        {
            // bind the current texture
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        }
    }
    else
    {

        mesh.dirty = false;
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.STATIC_DRAW);
        gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);

        // update the uvs
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.uvs, gl.STATIC_DRAW);
         gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 0);

         gl.activeTexture(gl.TEXTURE0);

       if (!texture._glTextures[gl.id])
        {
            this.renderer.updateTexture(texture);
        }
        else
        {
            // bind the current texture
            gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);
        }

        // dont need to upload!
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);

    }

    gl.drawElements(drawMode, mesh.indices.length, gl.UNSIGNED_SHORT, 0);

};

/**
 * Prepares all the buffers to render this mesh
 * @param mesh {Mesh} the mesh to render
 */
MeshRenderer.prototype._initWebGL = function (mesh)
{
    // build the strip!
    var gl = this.renderer.gl;

    mesh._vertexBuffer = gl.createBuffer();
    mesh._indexBuffer = gl.createBuffer();
    mesh._uvBuffer = gl.createBuffer();
    mesh._colorBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, mesh._uvBuffer);
    gl.bufferData(gl.ARRAY_BUFFER,  mesh.uvs, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, mesh._colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, mesh.colors, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);
};


/**
 * Empties the current batch.
 *
 */
MeshRenderer.prototype.flush = function ()
{

};

/**
 * Starts a new mesh renderer.
 *
 */
MeshRenderer.prototype.start = function ()
{
    var shader = this.renderer.shaderManager.plugins.meshShader;

    this.renderer.shaderManager.setShader(shader);
};

/**
 * Destroys the Mesh renderer
 *
 */
MeshRenderer.prototype.destroy = function ()
{
};

},{"../../core/renderers/webgl/WebGLRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/WebGLRenderer.js","../../core/renderers/webgl/utils/ObjectRenderer":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/renderers/webgl/utils/ObjectRenderer.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/mesh/webgl/MeshShader.js":[function(require,module,exports){
var core = require('../../core');

/**
 * @class
 * @extends Shader
 * @memberof PIXI.mesh
 * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.
 */
function StripShader(shaderManager)
{
    core.Shader.call(this,
        shaderManager,
        // vertex shader
        [
            'precision lowp float;',
            'attribute vec2 aVertexPosition;',
            'attribute vec2 aTextureCoord;',

            'uniform mat3 translationMatrix;',
            'uniform mat3 projectionMatrix;',

            'varying vec2 vTextureCoord;',

            'void main(void){',
            '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',
            '   vTextureCoord = aTextureCoord;',
            '}'
        ].join('\n'),
        [
            'precision lowp float;',

            'varying vec2 vTextureCoord;',
            'uniform float alpha;',

            'uniform sampler2D uSampler;',

            'void main(void){',
            '   gl_FragColor = texture2D(uSampler, vTextureCoord) * alpha ;',
            '}'
        ].join('\n'),
        // custom uniforms
        {
            alpha:  { type: '1f', value: 0 },
            translationMatrix: { type: 'mat3', value: new Float32Array(9) },
            projectionMatrix: { type: 'mat3', value: new Float32Array(9) }
        },
        // custom attributes
        {
            aVertexPosition:0,
            aTextureCoord:0
        }
    );
}

StripShader.prototype = Object.create(core.Shader.prototype);
StripShader.prototype.constructor = StripShader;
module.exports = StripShader;

core.ShaderManager.registerPlugin('meshShader', StripShader);

},{"../../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/polyfill/Object.assign.js":[function(require,module,exports){
// References:
// https://github.com/sindresorhus/object-assign
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

if (!Object.assign)
{
    Object.assign = require('object-assign');
}

},{"object-assign":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/node_modules/object-assign/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/polyfill/index.js":[function(require,module,exports){
require('./Object.assign');
require('./requestAnimationFrame');

},{"./Object.assign":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/polyfill/Object.assign.js","./requestAnimationFrame":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/polyfill/requestAnimationFrame.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/polyfill/requestAnimationFrame.js":[function(require,module,exports){
(function (global){
// References:
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// https://gist.github.com/1579671
// http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
// https://gist.github.com/timhall/4078614
// https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame

// Expected to be used with Browserfiy
// Browserify automatically detects the use of `global` and passes the
// correct reference of `global`, `self`, and finally `window`

// Date.now
if (!(Date.now && Date.prototype.getTime)) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

// performance.now
if (!(global.performance && global.performance.now)) {
    var startTime = Date.now();
    if (!global.performance) {
        global.performance = {};
    }
    global.performance.now = function () {
        return Date.now() - startTime;
    };
}

// requestAnimationFrame
var lastTime = Date.now();
var vendors = ['ms', 'moz', 'webkit', 'o'];

for(var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
    global.requestAnimationFrame = global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame = global[vendors[x] + 'CancelAnimationFrame'] ||
        global[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!global.requestAnimationFrame) {
    global.requestAnimationFrame = function (callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(callback + 'is not a function');
        }

        var currentTime = Date.now(),
            delay = 16 + lastTime - currentTime;

        if (delay < 0) {
            delay = 0;
        }

        lastTime = currentTime;

        return setTimeout(function () {
            lastTime = Date.now();
            callback(global.performance.now());
        }, delay);
    };
}

if (!global.cancelAnimationFrame) {
    global.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/spine/Spine.js":[function(require,module,exports){
var core = require('../core'),
    spine = require('./SpineRuntime');

/* Esoteric Software SPINE wrapper for pixi.js */

spine.Bone.yDown = true;

/**
 * A class that enables the you to import and run your spine animations in pixi.
 * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class
 * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source
 *
 * ```js
 * var spineAnimation = new PIXI.Spine(spineData);
 * ```
 *
 * @class
 * @extends Container
 * @memberof PIXI.spine
 * @param spineData {object} The spine data loaded from a spine atlas.
 */
function Spine(spineData)
{
    core.Container.call(this);

    if (!spineData)
    {
        throw new Error('The spineData param is required.');
    }

    /**
     * The spineData object
     *
     * @member {object}
     */
    this.spineData = spineData;

    /**
     * A spine Skeleton object
     *
     * @member {object}
     */
    this.skeleton = new spine.Skeleton(spineData);
    this.skeleton.updateWorldTransform();

    /**
     * A spine AnimationStateData object created from the spine data passed in the constructor
     *
     * @member {object}
     */
    this.stateData = new spine.AnimationStateData(spineData);

    /**
     * A spine AnimationState object created from the spine AnimationStateData object
     *
     * @member {object}
     */
    this.state = new spine.AnimationState(this.stateData);

    /**
     * An array of containers
     *
     * @member {Container[]}
     */
    this.slotContainers = [];

    for (var i = 0, n = this.skeleton.drawOrder.length; i < n; i++)
    {
        var slot = this.skeleton.drawOrder[i];
        var attachment = slot.attachment;
        var slotContainer = new core.Container();
        this.slotContainers.push(slotContainer);
        this.addChild(slotContainer);

        if (attachment instanceof spine.RegionAttachment)
        {
            var spriteName = attachment.rendererObject.name;
            var sprite = this.createSprite(slot, attachment);
            slot.currentSprite = sprite;
            slot.currentSpriteName = spriteName;
            slotContainer.addChild(sprite);
        }
        else if (attachment instanceof spine.MeshAttachment)
        {
            var mesh = this.createMesh(slot, attachment);
            slot.currentMesh = mesh;
            slot.currentMeshName = attachment.name;
            slotContainer.addChild(mesh);
        }
        else
        {
            continue;
        }

    }

    /**
     * Should the Spine object update its transforms
     *
     * @member {boolean}
     */
    this.autoUpdate = true;
}

Spine.prototype = Object.create(core.Container.prototype);
Spine.prototype.constructor = Spine;
module.exports = Spine;

Object.defineProperties(Spine.prototype, {
    /**
     * If this flag is set to true, the spine animation will be autoupdated every time
     * the object id drawn. The down side of this approach is that the delta time is
     * automatically calculated and you could miss out on cool effects like slow motion,
     * pause, skip ahead and the sorts. Most of these effects can be achieved even with
     * autoupdate enabled but are harder to achieve.
     *
     * @member {boolean}
     * @memberof Spine#
     * @default true
     */
    autoUpdate: {
        get: function ()
        {
            return (this.updateTransform === Spine.prototype.autoUpdateTransform);
        },

        set: function (value)
        {
            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : core.Container.prototype.updateTransform;
        }
    }
});

/**
 * Update the spine skeleton and its animations by delta time (dt)
 *
 * @param dt {number} Delta time. Time by which the animation should be updated
 */
Spine.prototype.update = function (dt)
{
    this.state.update(dt);
    this.state.apply(this.skeleton);
    this.skeleton.updateWorldTransform();

    var drawOrder = this.skeleton.drawOrder;
    for (var i = 0, n = drawOrder.length; i < n; i++)
    {
        var slot = drawOrder[i];
        var attachment = slot.attachment;
        var slotContainer = this.slotContainers[i];

        if (!attachment)
        {
            slotContainer.visible = false;
            continue;
        }

        var type = attachment.type;
        if (type === spine.AttachmentType.region)
        {
            if (attachment.rendererObject)
            {
                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)
                {
                    var spriteName = attachment.rendererObject.name;
                    if (slot.currentSprite !== undefined)
                    {
                        slot.currentSprite.visible = false;
                    }
                    slot.sprites = slot.sprites || {};
                    if (slot.sprites[spriteName] !== undefined)
                    {
                        slot.sprites[spriteName].visible = true;
                    }
                    else
                    {
                        var sprite = this.createSprite(slot, attachment);
                        slotContainer.addChild(sprite);
                    }
                    slot.currentSprite = slot.sprites[spriteName];
                    slot.currentSpriteName = spriteName;
                }
            }

            var bone = slot.bone;

            slotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01;
            slotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11;
            slotContainer.scale.x = bone.worldScaleX;
            slotContainer.scale.y = bone.worldScaleY;

            slotContainer.rotation = -(slot.bone.worldRotation * spine.degRad);

            slot.currentSprite.tint = core.utils.rgb2hex([slot.r,slot.g,slot.b]);
        }
        else if (type === spine.AttachmentType.skinnedmesh)
        {
            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)
            {
                var meshName = attachment.name;
                if (slot.currentMesh !== undefined)
                {
                    slot.currentMesh.visible = false;
                }

                slot.meshes = slot.meshes || {};

                if (slot.meshes[meshName] !== undefined)
                {
                    slot.meshes[meshName].visible = true;
                }
                else
                {
                    var mesh = this.createMesh(slot, attachment);
                    slotContainer.addChild(mesh);
                }

                slot.currentMesh = slot.meshes[meshName];
                slot.currentMeshName = meshName;
            }

            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);

        }
        else
        {
            slotContainer.visible = false;
            continue;
        }
        slotContainer.visible = true;

        slotContainer.alpha = slot.a;
    }
};

/**
 * When autoupdate is set to yes this function is used as pixi's updateTransform function
 *
 * @private
 */
Spine.prototype.autoUpdateTransform = function ()
{
    this.lastTime = this.lastTime || Date.now();
    var timeDelta = (Date.now() - this.lastTime) * 0.001;
    this.lastTime = Date.now();

    this.update(timeDelta);

    core.Container.prototype.updateTransform.call(this);
};

/**
 * Create a new sprite to be used with spine.RegionAttachment
 *
 * @param slot {spine.Slot} The slot to which the attachment is parented
 * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent
 * @private
 */
Spine.prototype.createSprite = function (slot, attachment)
{
    var descriptor = attachment.rendererObject;
    var baseTexture = descriptor.page.rendererObject;
    var spriteRect = new core.math.Rectangle(descriptor.x,
                                        descriptor.y,
                                        descriptor.rotate ? descriptor.height : descriptor.width,
                                        descriptor.rotate ? descriptor.width : descriptor.height);
    var spriteTexture = new core.Texture(baseTexture, spriteRect);
    var sprite = new core.Sprite(spriteTexture);

    var baseRotation = descriptor.rotate ? Math.PI * 0.5 : 0.0;
    sprite.scale.set(descriptor.width / descriptor.originalWidth, descriptor.height / descriptor.originalHeight);
    sprite.rotation = baseRotation - (attachment.rotation * spine.degRad);
    sprite.anchor.x = sprite.anchor.y = 0.5;

    slot.sprites = slot.sprites || {};
    slot.sprites[descriptor.name] = sprite;
    return sprite;
};

/**
 * Creates a Strip from the spine data
 * @param slot {spine.Slot} The slot to which the attachment is parented
 * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent
 * @private
 */
Spine.prototype.createMesh = function (slot, attachment)
{
    var descriptor = attachment.rendererObject;
    var baseTexture = descriptor.page.rendererObject;
    var texture = new core.Texture(baseTexture);

    var strip = new core.Strip(texture);
    strip.drawMode = core.Strip.DRAW_MODES.TRIANGLES;
    strip.canvasPadding = 1.5;

    strip.vertices = new Float32Array(attachment.uvs.length);
    strip.uvs = attachment.uvs;
    strip.indices = attachment.triangles;

    slot.meshes = slot.meshes || {};
    slot.meshes[attachment.name] = strip;

    return strip;
};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js","./SpineRuntime":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/spine/SpineRuntime.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/spine/SpineRuntime.js":[function(require,module,exports){
/******************************************************************************
 * Spine Runtimes Software License
 * Version 2.1
 *
 * Copyright (c) 2013, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to install, execute and perform the Spine Runtimes
 * Software (the "Software") solely for internal use. Without the written
 * permission of Esoteric Software (typically granted by licensing Spine), you
 * may not (a) modify, translate, adapt or otherwise create derivative works,
 * improvements of the Software or develop new applications using the Software
 * or (b) remove, delete, alter or obscure any trademarks or any copyright,
 * trademark, patent or other intellectual property or proprietary rights
 * notices on or in the Software, including any copy thereof. Redistributions
 * in binary or source form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/
var core = require('../core');


var spine = module.exports = {
	radDeg: 180 / Math.PI,
	degRad: Math.PI / 180,
	temp: [],
    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,
    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array
};

spine.BoneData = function (name, parent)
{
	this.name = name;
	this.parent = parent;
};
spine.BoneData.prototype = {
	length: 0,
	x: 0, y: 0,
	rotation: 0,
	scaleX: 1, scaleY: 1,
	inheritScale: true,
	inheritRotation: true,
	flipX: false, flipY: false
};

spine.SlotData = function (name, boneData)
{
	this.name = name;
	this.boneData = boneData;
};
spine.SlotData.prototype = {
	r: 1, g: 1, b: 1, a: 1,
	attachmentName: null,
	additiveBlending: false
};

spine.IkConstraintData = function (name)
{
	this.name = name;
	this.bones = [];
};
spine.IkConstraintData.prototype = {
	target: null,
	bendDirection: 1,
	mix: 1
};

spine.Bone = function (boneData, skeleton, parent)
{
	this.data = boneData;
	this.skeleton = skeleton;
	this.parent = parent;
	this.setToSetupPose();
};
spine.Bone.yDown = false;
spine.Bone.prototype = {
	x: 0, y: 0,
	rotation: 0, rotationIK: 0,
	scaleX: 1, scaleY: 1,
	flipX: false, flipY: false,
	m00: 0, m01: 0, worldX: 0, // a b x
	m10: 0, m11: 0, worldY: 0, // c d y
	worldRotation: 0,
	worldScaleX: 1, worldScaleY: 1,
	worldFlipX: false, worldFlipY: false,
    updateWorldTransform: function ()
    {
		var parent = this.parent;
        if (parent)
        {
			this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;
			this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;
            if (this.data.inheritScale)
            {
				this.worldScaleX = parent.worldScaleX * this.scaleX;
				this.worldScaleY = parent.worldScaleY * this.scaleY;
			} else {
				this.worldScaleX = this.scaleX;
				this.worldScaleY = this.scaleY;
			}
			this.worldRotation = this.data.inheritRotation ? (parent.worldRotation + this.rotationIK) : this.rotationIK;
			this.worldFlipX = parent.worldFlipX != this.flipX;
			this.worldFlipY = parent.worldFlipY != this.flipY;
		} else {
			var skeletonFlipX = this.skeleton.flipX, skeletonFlipY = this.skeleton.flipY;
			this.worldX = skeletonFlipX ? -this.x : this.x;
			this.worldY = (skeletonFlipY != spine.Bone.yDown) ? -this.y : this.y;
			this.worldScaleX = this.scaleX;
			this.worldScaleY = this.scaleY;
			this.worldRotation = this.rotationIK;
			this.worldFlipX = skeletonFlipX != this.flipX;
			this.worldFlipY = skeletonFlipY != this.flipY;
		}
		var radians = this.worldRotation * spine.degRad;
		var cos = Math.cos(radians);
		var sin = Math.sin(radians);
        if (this.worldFlipX)
        {
			this.m00 = -cos * this.worldScaleX;
			this.m01 = sin * this.worldScaleY;
		} else {
			this.m00 = cos * this.worldScaleX;
			this.m01 = -sin * this.worldScaleY;
		}
        if (this.worldFlipY != spine.Bone.yDown)
        {
			this.m10 = -sin * this.worldScaleX;
			this.m11 = -cos * this.worldScaleY;
		} else {
			this.m10 = sin * this.worldScaleX;
			this.m11 = cos * this.worldScaleY;
		}
	},
    setToSetupPose: function ()
    {
		var data = this.data;
		this.x = data.x;
		this.y = data.y;
		this.rotation = data.rotation;
		this.rotationIK = this.rotation;
		this.scaleX = data.scaleX;
		this.scaleY = data.scaleY;
		this.flipX = data.flipX;
		this.flipY = data.flipY;
	},
    worldToLocal: function (world)
    {
		var dx = world[0] - this.worldX, dy = world[1] - this.worldY;
		var m00 = this.m00, m10 = this.m10, m01 = this.m01, m11 = this.m11;
        if (this.worldFlipX != (this.worldFlipY != spine.Bone.yDown))
        {
			m00 = -m00;
			m11 = -m11;
		}
		var invDet = 1 / (m00 * m11 - m01 * m10);
		world[0] = dx * m00 * invDet - dy * m01 * invDet;
		world[1] = dy * m11 * invDet - dx * m10 * invDet;
	},
    localToWorld: function (local)
    {
		var localX = local[0], localY = local[1];
		local[0] = localX * this.m00 + localY * this.m01 + this.worldX;
		local[1] = localX * this.m10 + localY * this.m11 + this.worldY;
	}
};

spine.Slot = function (slotData, bone)
{
	this.data = slotData;
	this.bone = bone;
	this.setToSetupPose();
};
spine.Slot.prototype = {
	r: 1, g: 1, b: 1, a: 1,
	_attachmentTime: 0,
	attachment: null,
	attachmentVertices: [],
    setAttachment: function (attachment)
    {
		this.attachment = attachment;
		this._attachmentTime = this.bone.skeleton.time;
		this.attachmentVertices.length = 0;
	},
    setAttachmentTime: function (time)
    {
		this._attachmentTime = this.bone.skeleton.time - time;
	},
    getAttachmentTime: function ()
    {
		return this.bone.skeleton.time - this._attachmentTime;
	},
    setToSetupPose: function ()
    {
		var data = this.data;
		this.r = data.r;
		this.g = data.g;
		this.b = data.b;
		this.a = data.a;

		var slotDatas = this.bone.skeleton.data.slots;
        for (var i = 0, n = slotDatas.length; i < n; i++)
        {
            if (slotDatas[i] == data)
            {
				this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));
				break;
			}
		}
	}
};

spine.IkConstraint = function (data, skeleton)
{
	this.data = data;
	this.mix = data.mix;
	this.bendDirection = data.bendDirection;

	this.bones = [];
	for (var i = 0, n = data.bones.length; i < n; i++)
		this.bones.push(skeleton.findBone(data.bones[i].name));
	this.target = skeleton.findBone(data.target.name);
};
spine.IkConstraint.prototype = {
    apply: function ()
    {
		var target = this.target;
		var bones = this.bones;
        switch (bones.length)
        {
		case 1:
			spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);
			break;
		case 2:
			spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);
			break;
		}
	}
};
/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world
 * coordinate system. */
spine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)
{
	var parentRotation = (!bone.data.inheritRotation || !bone.parent) ? 0 : bone.parent.worldRotation;
	var rotation = bone.rotation;
	var rotationIK = Math.atan2(targetY - bone.worldY, targetX - bone.worldX) * spine.radDeg - parentRotation;
	bone.rotationIK = rotation + (rotationIK - rotation) * alpha;
};
/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The
 * target is specified in the world coordinate system.
 * @param child Any descendant bone of the parent. */
spine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDirection, alpha)
{
	var childRotation = child.rotation, parentRotation = parent.rotation;
    if (!alpha)
    {
		child.rotationIK = childRotation;
		parent.rotationIK = parentRotation;
		return;
	}
	var positionX, positionY, tempPosition = spine.temp;
	var parentParent = parent.parent;
    if (parentParent)
    {
		tempPosition[0] = targetX;
		tempPosition[1] = targetY;
		parentParent.worldToLocal(tempPosition);
		targetX = (tempPosition[0] - parent.x) * parentParent.worldScaleX;
		targetY = (tempPosition[1] - parent.y) * parentParent.worldScaleY;
	} else {
		targetX -= parent.x;
		targetY -= parent.y;
	}
    if (child.parent == parent)
    {
		positionX = child.x;
		positionY = child.y;
	} else {
		tempPosition[0] = child.x;
		tempPosition[1] = child.y;
		child.parent.localToWorld(tempPosition);
		parent.worldToLocal(tempPosition);
		positionX = tempPosition[0];
		positionY = tempPosition[1];
	}
	var childX = positionX * parent.worldScaleX, childY = positionY * parent.worldScaleY;
	var offset = Math.atan2(childY, childX);
	var len1 = Math.sqrt(childX * childX + childY * childY), len2 = child.data.length * child.worldScaleX;
	// Based on code by Ryan Juckett with permission: Copyright (c) 2008-2009 Ryan Juckett, http://www.ryanjuckett.com/
	var cosDenom = 2 * len1 * len2;
    if (cosDenom < 0.0001)
    {
		child.rotationIK = childRotation + (Math.atan2(targetY, targetX) * spine.radDeg - parentRotation - childRotation) * alpha;
		return;
	}
	var cos = (targetX * targetX + targetY * targetY - len1 * len1 - len2 * len2) / cosDenom;
	if (cos < -1)
		cos = -1;
	else if (cos > 1)
		cos = 1;
	var childAngle = Math.acos(cos) * bendDirection;
	var adjacent = len1 + len2 * cos, opposite = len2 * Math.sin(childAngle);
	var parentAngle = Math.atan2(targetY * adjacent - targetX * opposite, targetX * adjacent + targetY * opposite);
	var rotation = (parentAngle - offset) * spine.radDeg - parentRotation;
	if (rotation > 180)
		rotation -= 360;
	else if (rotation < -180) //
		rotation += 360;
	parent.rotationIK = parentRotation + rotation * alpha;
	rotation = (childAngle + offset) * spine.radDeg - childRotation;
	if (rotation > 180)
		rotation -= 360;
	else if (rotation < -180) //
		rotation += 360;
	child.rotationIK = childRotation + (rotation + parent.worldRotation - child.parent.worldRotation) * alpha;
};

spine.Skin = function (name)
{
	this.name = name;
	this.attachments = {};
};
spine.Skin.prototype = {
    addAttachment: function (slotIndex, name, attachment)
    {
		this.attachments[slotIndex + ":" + name] = attachment;
	},
    getAttachment: function (slotIndex, name)
    {
		return this.attachments[slotIndex + ":" + name];
	},
    _attachAll: function (skeleton, oldSkin)
    {
        for (var key in oldSkin.attachments)
        {
			var colon = key.indexOf(":");
			var slotIndex = parseInt(key.substring(0, colon));
			var name = key.substring(colon + 1);
			var slot = skeleton.slots[slotIndex];
            if (slot.attachment && slot.attachment.name == name)
            {
				var attachment = this.getAttachment(slotIndex, name);
				if (attachment) slot.setAttachment(attachment);
			}
		}
	}
};

spine.Animation = function (name, timelines, duration)
{
	this.name = name;
	this.timelines = timelines;
	this.duration = duration;
};
spine.Animation.prototype = {
    apply: function (skeleton, lastTime, time, loop, events)
    {
        if (loop && this.duration != 0)
        {
			time %= this.duration;
			lastTime %= this.duration;
		}
		var timelines = this.timelines;
		for (var i = 0, n = timelines.length; i < n; i++)
			timelines[i].apply(skeleton, lastTime, time, events, 1);
	},
    mix: function (skeleton, lastTime, time, loop, events, alpha)
    {
        if (loop && this.duration != 0)
        {
			time %= this.duration;
			lastTime %= this.duration;
		}
		var timelines = this.timelines;
		for (var i = 0, n = timelines.length; i < n; i++)
			timelines[i].apply(skeleton, lastTime, time, events, alpha);
	}
};
spine.Animation.binarySearch = function (values, target, step)
{
	var low = 0;
	var high = Math.floor(values.length / step) - 2;
	if (!high) return step;
	var current = high >>> 1;
    while (true)
    {
		if (values[(current + 1) * step] <= target)
			low = current + 1;
		else
			high = current;
		if (low == high) return (low + 1) * step;
		current = (low + high) >>> 1;
	}
};
spine.Animation.binarySearch1 = function (values, target)
{
	var low = 0;
	var high = values.length - 2;
	if (!high) return 1;
	var current = high >>> 1;
    while (true)
    {
		if (values[current + 1] <= target)
			low = current + 1;
		else
			high = current;
		if (low == high) return low + 1;
		current = (low + high) >>> 1;
	}
};
spine.Animation.linearSearch = function (values, target, step)
{
	for (var i = 0, last = values.length - step; i <= last; i += step)
		if (values[i] > target) return i;
	return -1;
};

spine.Curves = function (frameCount)
{
	this.curves = []; // type, x, y, ...
	//this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;
};
spine.Curves.prototype = {
    setLinear: function (frameIndex)
    {
		this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;
	},
    setStepped: function (frameIndex)
    {
		this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;
	},
	/** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
	 * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
	 * the difference between the keyframe's values. */
    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)
    {
		var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;
		var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;
		var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;
		var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;
		var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;
		var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;

		var i = frameIndex * 19/*BEZIER_SIZE*/;
		var curves = this.curves;
		curves[i++] = 2/*BEZIER*/;

		var x = dfx, y = dfy;
        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)
        {
			curves[i] = x;
			curves[i + 1] = y;
			dfx += ddfx;
			dfy += ddfy;
			ddfx += dddfx;
			ddfy += dddfy;
			x += dfx;
			y += dfy;
		}
	},
    getCurvePercent: function (frameIndex, percent)
    {
		percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);
		var curves = this.curves;
		var i = frameIndex * 19/*BEZIER_SIZE*/;
		var type = curves[i];
		if (type === 0/*LINEAR*/) return percent;
		if (type == 1/*STEPPED*/) return 0;
		i++;
		var x = 0;
        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)
        {
			x = curves[i];
            if (x >= percent)
            {
				var prevX, prevY;
                if (i == start)
                {
					prevX = 0;
					prevY = 0;
				} else {
					prevX = curves[i - 2];
					prevY = curves[i - 1];
				}
				return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
			}
		}
		var y = curves[i - 1];
		return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.
	}
};

spine.RotateTimeline = function (frameCount)
{
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, angle, ...
	this.frames.length = frameCount * 2;
};
spine.RotateTimeline.prototype = {
	boneIndex: 0,
    getFrameCount: function ()
    {
		return this.frames.length / 2;
	},
    setFrame: function (frameIndex, time, angle)
    {
		frameIndex *= 2;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = angle;
	},
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 2])
        { // Time is after last frame.
			var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;
			while (amount > 180)
				amount -= 360;
			while (amount < -180)
				amount += 360;
			bone.rotation += amount * alpha;
			return;
		}

		// Interpolate between the previous frame and the current frame.
		var frameIndex = spine.Animation.binarySearch(frames, time, 2);
		var prevFrameValue = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);

		var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;
		while (amount > 180)
			amount -= 360;
		while (amount < -180)
			amount += 360;
		amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;
		while (amount > 180)
			amount -= 360;
		while (amount < -180)
			amount += 360;
		bone.rotation += amount * alpha;
	}
};

spine.TranslateTimeline = function (frameCount)
{
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, x, y, ...
	this.frames.length = frameCount * 3;
};
spine.TranslateTimeline.prototype = {
	boneIndex: 0,
    getFrameCount: function ()
    {
		return this.frames.length / 3;
	},
    setFrame: function (frameIndex, time, x, y)
    {
		frameIndex *= 3;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = x;
		this.frames[frameIndex + 2] = y;
	},
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 3])
        { // Time is after last frame.
			bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;
			bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;
			return;
		}

		// Interpolate between the previous frame and the current frame.
		var frameIndex = spine.Animation.binarySearch(frames, time, 3);
		var prevFrameX = frames[frameIndex - 2];
		var prevFrameY = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

		bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;
		bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;
	}
};

spine.ScaleTimeline = function (frameCount)
{
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, x, y, ...
	this.frames.length = frameCount * 3;
};
spine.ScaleTimeline.prototype = {
	boneIndex: 0,
    getFrameCount: function ()
    {
		return this.frames.length / 3;
	},
    setFrame: function (frameIndex, time, x, y)
    {
		frameIndex *= 3;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = x;
		this.frames[frameIndex + 2] = y;
	},
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var bone = skeleton.bones[this.boneIndex];

        if (time >= frames[frames.length - 3])
        { // Time is after last frame.
			bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;
			bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;
			return;
		}

		// Interpolate between the previous frame and the current frame.
		var frameIndex = spine.Animation.binarySearch(frames, time, 3);
		var prevFrameX = frames[frameIndex - 2];
		var prevFrameY = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

		bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;
		bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;
	}
};

spine.ColorTimeline = function (frameCount)
{
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, r, g, b, a, ...
	this.frames.length = frameCount * 5;
};
spine.ColorTimeline.prototype = {
	slotIndex: 0,
    getFrameCount: function ()
    {
		return this.frames.length / 5;
	},
    setFrame: function (frameIndex, time, r, g, b, a)
    {
		frameIndex *= 5;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = r;
		this.frames[frameIndex + 2] = g;
		this.frames[frameIndex + 3] = b;
		this.frames[frameIndex + 4] = a;
	},
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var r, g, b, a;
        if (time >= frames[frames.length - 5])
        {
			// Time is after last frame.
			var i = frames.length - 1;
			r = frames[i - 3];
			g = frames[i - 2];
			b = frames[i - 1];
			a = frames[i];
		} else {
			// Interpolate between the previous frame and the current frame.
			var frameIndex = spine.Animation.binarySearch(frames, time, 5);
			var prevFrameR = frames[frameIndex - 4];
			var prevFrameG = frames[frameIndex - 3];
			var prevFrameB = frames[frameIndex - 2];
			var prevFrameA = frames[frameIndex - 1];
			var frameTime = frames[frameIndex];
			var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);
			percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);

			r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;
			g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;
			b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;
			a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;
		}
		var slot = skeleton.slots[this.slotIndex];
        if (alpha < 1)
        {
			slot.r += (r - slot.r) * alpha;
			slot.g += (g - slot.g) * alpha;
			slot.b += (b - slot.b) * alpha;
			slot.a += (a - slot.a) * alpha;
		} else {
			slot.r = r;
			slot.g = g;
			slot.b = b;
			slot.a = a;
		}
	}
};

spine.AttachmentTimeline = function (frameCount)
{
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, ...
	this.frames.length = frameCount;
	this.attachmentNames = [];
	this.attachmentNames.length = frameCount;
};
spine.AttachmentTimeline.prototype = {
	slotIndex: 0,
    getFrameCount: function ()
    {
		return this.frames.length;
	},
    setFrame: function (frameIndex, time, attachmentName)
    {
		this.frames[frameIndex] = time;
		this.attachmentNames[frameIndex] = attachmentName;
	},
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
		var frames = this.frames;
        if (time < frames[0])
        {
			if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);
			return;
		} else if (lastTime > time) //
			lastTime = -1;

		var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;
		if (frames[frameIndex] < lastTime) return;

		var attachmentName = this.attachmentNames[frameIndex];
		skeleton.slots[this.slotIndex].setAttachment(
			!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));
	}
};

spine.EventTimeline = function (frameCount)
{
	this.frames = []; // time, ...
	this.frames.length = frameCount;
	this.events = [];
	this.events.length = frameCount;
};
spine.EventTimeline.prototype = {
    getFrameCount: function ()
    {
		return this.frames.length;
	},
    setFrame: function (frameIndex, time, event)
    {
		this.frames[frameIndex] = time;
		this.events[frameIndex] = event;
	},
	/** Fires events for frames > lastTime and <= time. */
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
		if (!firedEvents) return;

		var frames = this.frames;
		var frameCount = frames.length;

        if (lastTime > time)
        { // Fire events after last time for looped animations.
			this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);
			lastTime = -1;
		} else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.
			return;
		if (time < frames[0]) return; // Time is before first frame.

		var frameIndex;
		if (lastTime < frames[0])
			frameIndex = 0;
        else
        {
			frameIndex = spine.Animation.binarySearch1(frames, lastTime);
			var frame = frames[frameIndex];
            while (frameIndex > 0)
            { // Fire multiple events with the same frame.
				if (frames[frameIndex - 1] != frame) break;
				frameIndex--;
			}
		}
		var events = this.events;
		for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)
			firedEvents.push(events[frameIndex]);
	}
};

spine.DrawOrderTimeline = function (frameCount)
{
	this.frames = []; // time, ...
	this.frames.length = frameCount;
	this.drawOrders = [];
	this.drawOrders.length = frameCount;
};
spine.DrawOrderTimeline.prototype = {
    getFrameCount: function ()
    {
		return this.frames.length;
	},
    setFrame: function (frameIndex, time, drawOrder)
    {
		this.frames[frameIndex] = time;
		this.drawOrders[frameIndex] = drawOrder;
	},
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var frameIndex;
		if (time >= frames[frames.length - 1]) // Time is after last frame.
			frameIndex = frames.length - 1;
		else
			frameIndex = spine.Animation.binarySearch1(frames, time) - 1;

		var drawOrder = skeleton.drawOrder;
		var slots = skeleton.slots;
		var drawOrderToSetupIndex = this.drawOrders[frameIndex];
        if (!drawOrderToSetupIndex)
        {
			for (var i = 0, n = slots.length; i < n; i++)
				drawOrder[i] = slots[i];
		} else {
			for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
				drawOrder[i] = skeleton.slots[drawOrderToSetupIndex[i]];
		}

	}
};

spine.FfdTimeline = function (frameCount)
{
	this.curves = new spine.Curves(frameCount);
	this.frames = [];
	this.frames.length = frameCount;
	this.frameVertices = [];
	this.frameVertices.length = frameCount;
};
spine.FfdTimeline.prototype = {
	slotIndex: 0,
	attachment: 0,
    getFrameCount: function ()
    {
		return this.frames.length;
	},
    setFrame: function (frameIndex, time, vertices)
    {
		this.frames[frameIndex] = time;
		this.frameVertices[frameIndex] = vertices;
	},
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
		var slot = skeleton.slots[this.slotIndex];
		if (slot.attachment != this.attachment) return;

		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var frameVertices = this.frameVertices;
		var vertexCount = frameVertices[0].length;

		var vertices = slot.attachmentVertices;
		if (vertices.length != vertexCount) alpha = 1;
		vertices.length = vertexCount;

        if (time >= frames[frames.length - 1])
        { // Time is after last frame.
			var lastVertices = frameVertices[frames.length - 1];
            if (alpha < 1)
            {
				for (var i = 0; i < vertexCount; i++)
					vertices[i] += (lastVertices[i] - vertices[i]) * alpha;
			} else {
				for (var i = 0; i < vertexCount; i++)
					vertices[i] = lastVertices[i];
			}
			return;
		}

		// Interpolate between the previous frame and the current frame.
		var frameIndex = spine.Animation.binarySearch1(frames, time);
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));

		var prevVertices = frameVertices[frameIndex - 1];
		var nextVertices = frameVertices[frameIndex];

        if (alpha < 1)
        {
            for (var i = 0; i < vertexCount; i++)
            {
				var prev = prevVertices[i];
				vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;
			}
		} else {
            for (var i = 0; i < vertexCount; i++)
            {
				var prev = prevVertices[i];
				vertices[i] = prev + (nextVertices[i] - prev) * percent;
			}
		}
	}
};

spine.IkConstraintTimeline = function (frameCount)
{
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, mix, bendDirection, ...
	this.frames.length = frameCount * 3;
};
spine.IkConstraintTimeline.prototype = {
	ikConstraintIndex: 0,
    getFrameCount: function ()
    {
		return this.frames.length / 3;
	},
    setFrame: function (frameIndex, time, mix, bendDirection)
    {
		frameIndex *= 3;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = mix;
		this.frames[frameIndex + 2] = bendDirection;
	},
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];

        if (time >= frames[frames.length - 3])
        { // Time is after last frame.
			ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;
			ikConstraint.bendDirection = frames[frames.length - 1];
			return;
		}

		// Interpolate between the previous frame and the current frame.
		var frameIndex = spine.Animation.binarySearch(frames, time, 3);
		var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

		var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;
		ikConstraint.mix += (mix - ikConstraint.mix) * alpha;
		ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];
	}
};

spine.FlipXTimeline = function (frameCount)
{
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, flip, ...
	this.frames.length = frameCount * 2;
};
spine.FlipXTimeline.prototype = {
	boneIndex: 0,
    getFrameCount: function ()
    {
		return this.frames.length / 2;
	},
    setFrame: function (frameIndex, time, flip)
    {
		frameIndex *= 2;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = flip ? 1 : 0;
	},
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
		var frames = this.frames;
        if (time < frames[0])
        {
			if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);
			return;
		} else if (lastTime > time) //
			lastTime = -1;
		var frameIndex = (time >= frames[frames.length - 2] ? frames.length : spine.Animation.binarySearch(frames, time, 2)) - 2;
		if (frames[frameIndex] < lastTime) return;
		skeleton.bones[boneIndex].flipX = frames[frameIndex + 1] != 0;
	}
};

spine.FlipYTimeline = function (frameCount)
{
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, flip, ...
	this.frames.length = frameCount * 2;
};
spine.FlipYTimeline.prototype = {
	boneIndex: 0,
    getFrameCount: function ()
    {
		return this.frames.length / 2;
	},
    setFrame: function (frameIndex, time, flip)
    {
		frameIndex *= 2;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = flip ? 1 : 0;
	},
    apply: function (skeleton, lastTime, time, firedEvents, alpha)
    {
		var frames = this.frames;
        if (time < frames[0])
        {
			if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);
			return;
		} else if (lastTime > time) //
			lastTime = -1;
		var frameIndex = (time >= frames[frames.length - 2] ? frames.length : spine.Animation.binarySearch(frames, time, 2)) - 2;
		if (frames[frameIndex] < lastTime) return;
		skeleton.bones[boneIndex].flipY = frames[frameIndex + 1] != 0;
	}
};

spine.SkeletonData = function ()
{
	this.bones = [];
	this.slots = [];
	this.skins = [];
	this.events = [];
	this.animations = [];
	this.ikConstraints = [];
};
spine.SkeletonData.prototype = {
	name: null,
	defaultSkin: null,
	width: 0, height: 0,
	version: null, hash: null,
	/** @return May be null. */
    findBone: function (boneName)
    {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			if (bones[i].name == boneName) return bones[i];
		return null;
	},
	/** @return -1 if the bone was not found. */
    findBoneIndex: function (boneName)
    {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			if (bones[i].name == boneName) return i;
		return -1;
	},
	/** @return May be null. */
    findSlot: function (slotName)
    {
		var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
        {
			if (slots[i].name == slotName) return slot[i];
		}
		return null;
	},
	/** @return -1 if the bone was not found. */
    findSlotIndex: function (slotName)
    {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++)
			if (slots[i].name == slotName) return i;
		return -1;
	},
	/** @return May be null. */
    findSkin: function (skinName)
    {
		var skins = this.skins;
		for (var i = 0, n = skins.length; i < n; i++)
			if (skins[i].name == skinName) return skins[i];
		return null;
	},
	/** @return May be null. */
    findEvent: function (eventName)
    {
		var events = this.events;
		for (var i = 0, n = events.length; i < n; i++)
			if (events[i].name == eventName) return events[i];
		return null;
	},
	/** @return May be null. */
    findAnimation: function (animationName)
    {
		var animations = this.animations;
		for (var i = 0, n = animations.length; i < n; i++)
			if (animations[i].name == animationName) return animations[i];
		return null;
	},
	/** @return May be null. */
    findIkConstraint: function (ikConstraintName)
    {
		var ikConstraints = this.ikConstraints;
		for (var i = 0, n = ikConstraints.length; i < n; i++)
			if (ikConstraints[i].name == ikConstraintName) return ikConstraints[i];
		return null;
	}
};

spine.Skeleton = function (skeletonData)
{
	this.data = skeletonData;

	this.bones = [];
    for (var i = 0, n = skeletonData.bones.length; i < n; i++)
    {
		var boneData = skeletonData.bones[i];
		var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];
		this.bones.push(new spine.Bone(boneData, this, parent));
	}

	this.slots = [];
	this.drawOrder = [];
    for (var i = 0, n = skeletonData.slots.length; i < n; i++)
    {
		var slotData = skeletonData.slots[i];
		var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];
		var slot = new spine.Slot(slotData, bone);
		this.slots.push(slot);
		this.drawOrder.push(slot);
	}

	this.ikConstraints = [];
	for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)
		this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));

	this.boneCache = [];
	this.updateCache();
};
spine.Skeleton.prototype = {
	x: 0, y: 0,
	skin: null,
	r: 1, g: 1, b: 1, a: 1,
	time: 0,
	flipX: false, flipY: false,
	/** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */
    updateCache: function ()
    {
		var ikConstraints = this.ikConstraints;
		var ikConstraintsCount = ikConstraints.length;

		var arrayCount = ikConstraintsCount + 1;
		var boneCache = this.boneCache;
		if (boneCache.length > arrayCount) boneCache.length = arrayCount;
		for (var i = 0, n = boneCache.length; i < n; i++)
			boneCache[i].length = 0;
		while (boneCache.length < arrayCount)
			boneCache[boneCache.length] = [];

		var nonIkBones = boneCache[0];
		var bones = this.bones;

		outer:
        for (var i = 0, n = bones.length; i < n; i++)
        {
			var bone = bones[i];
			var current = bone;
			do {
                for (var ii = 0; ii < ikConstraintsCount; ii++)
                {
					var ikConstraint = ikConstraints[ii];
					var parent = ikConstraint.bones[0];
					var child= ikConstraint.bones[ikConstraint.bones.length - 1];
                    while (true)
                    {
                        if (current == child)
                        {
							boneCache[ii].push(bone);
							boneCache[ii + 1].push(bone);
							continue outer;
						}
						if (child == parent) break;
						child = child.parent;
					}
				}
				current = current.parent;
			} while (current);
			nonIkBones[nonIkBones.length] = bone;
		}
	},
	/** Updates the world transform for each bone. */
    updateWorldTransform: function ()
    {
		var bones = this.bones;
        for (var i = 0, n = bones.length; i < n; i++)
        {
			var bone = bones[i];
			bone.rotationIK = bone.rotation;
		}
		var i = 0, last = this.boneCache.length - 1;
        while (true)
        {
			var cacheBones = this.boneCache[i];
			for (var ii = 0, nn = cacheBones.length; ii < nn; ii++)
				cacheBones[ii].updateWorldTransform();
			if (i == last) break;
			this.ikConstraints[i].apply();
			i++;
		}
	},
	/** Sets the bones and slots to their setup pose values. */
    setToSetupPose: function ()
    {
		this.setBonesToSetupPose();
		this.setSlotsToSetupPose();
	},
    setBonesToSetupPose: function ()
    {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			bones[i].setToSetupPose();

		var ikConstraints = this.ikConstraints;
        for (var i = 0, n = ikConstraints.length; i < n; i++)
        {
			var ikConstraint = ikConstraints[i];
			ikConstraint.bendDirection = ikConstraint.data.bendDirection;
			ikConstraint.mix = ikConstraint.data.mix;
		}
	},
    setSlotsToSetupPose: function ()
    {
		var slots = this.slots;
		var drawOrder = this.drawOrder;
        for (var i = 0, n = slots.length; i < n; i++)
        {
			drawOrder[i] = slots[i];
			slots[i].setToSetupPose(i);
		}
	},
	/** @return May return null. */
    getRootBone: function ()
    {
		return this.bones.length ? this.bones[0] : null;
	},
	/** @return May be null. */
    findBone: function (boneName)
    {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			if (bones[i].data.name == boneName) return bones[i];
		return null;
	},
	/** @return -1 if the bone was not found. */
    findBoneIndex: function (boneName)
    {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			if (bones[i].data.name == boneName) return i;
		return -1;
	},
	/** @return May be null. */
    findSlot: function (slotName)
    {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++)
			if (slots[i].data.name == slotName) return slots[i];
		return null;
	},
	/** @return -1 if the bone was not found. */
    findSlotIndex: function (slotName)
    {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++)
			if (slots[i].data.name == slotName) return i;
		return -1;
	},
    setSkinByName: function (skinName)
    {
		var skin = this.data.findSkin(skinName);
		if (!skin) throw "Skin not found: " + skinName;
		this.setSkin(skin);
	},
	/** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.
	 * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was
	 * no old skin, each slot's setup mode attachment is attached from the new skin.
	 * @param newSkin May be null. */
    setSkin: function (newSkin)
    {
        if (newSkin)
        {
			if (this.skin)
				newSkin._attachAll(this, this.skin);
            else
            {
				var slots = this.slots;
                for (var i = 0, n = slots.length; i < n; i++)
                {
					var slot = slots[i];
					var name = slot.data.attachmentName;
                    if (name)
                    {
						var attachment = newSkin.getAttachment(i, name);
						if (attachment) slot.setAttachment(attachment);
					}
				}
			}
		}
		this.skin = newSkin;
	},
	/** @return May be null. */
    getAttachmentBySlotName: function (slotName, attachmentName)
    {
		return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);
	},
	/** @return May be null. */
    getAttachmentBySlotIndex: function (slotIndex, attachmentName)
    {
        if (this.skin)
        {
			var attachment = this.skin.getAttachment(slotIndex, attachmentName);
			if (attachment) return attachment;
		}
		if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
		return null;
	},
	/** @param attachmentName May be null. */
    setAttachment: function (slotName, attachmentName)
    {
		var slots = this.slots;
        for (var i = 0, n = slots.length; i < n; i++)
        {
			var slot = slots[i];
            if (slot.data.name == slotName)
            {
				var attachment = null;
                if (attachmentName)
                {
					attachment = this.getAttachmentBySlotIndex(i, attachmentName);
					if (!attachment) throw "Attachment not found: " + attachmentName + ", for slot: " + slotName;
				}
				slot.setAttachment(attachment);
				return;
			}
		}
		throw "Slot not found: " + slotName;
	},
	/** @return May be null. */
    findIkConstraint: function (ikConstraintName)
    {
		var ikConstraints = this.ikConstraints;
		for (var i = 0, n = ikConstraints.length; i < n; i++)
			if (ikConstraints[i].data.name == ikConstraintName) return ikConstraints[i];
		return null;
	},
    update: function (delta)
    {
		this.time += delta;
	}
};

spine.EventData = function (name)
{
	this.name = name;
};
spine.EventData.prototype = {
	intValue: 0,
	floatValue: 0,
	stringValue: null
};

spine.Event = function (data)
{
	this.data = data;
};
spine.Event.prototype = {
	intValue: 0,
	floatValue: 0,
	stringValue: null
};

spine.AttachmentType = {
	region: 0,
	boundingbox: 1,
	mesh: 2,
	skinnedmesh: 3
};

spine.RegionAttachment = function (name)
{
	this.name = name;
	this.offset = [];
	this.offset.length = 8;
	this.uvs = [];
	this.uvs.length = 8;
};
spine.RegionAttachment.prototype = {
	type: spine.AttachmentType.region,
	x: 0, y: 0,
	rotation: 0,
	scaleX: 1, scaleY: 1,
	width: 0, height: 0,
	r: 1, g: 1, b: 1, a: 1,
	path: null,
	rendererObject: null,
	regionOffsetX: 0, regionOffsetY: 0,
	regionWidth: 0, regionHeight: 0,
	regionOriginalWidth: 0, regionOriginalHeight: 0,
    setUVs: function (u, v, u2, v2, rotate)
    {
		var uvs = this.uvs;
        if (rotate)
        {
			uvs[2/*X2*/] = u;
			uvs[3/*Y2*/] = v2;
			uvs[4/*X3*/] = u;
			uvs[5/*Y3*/] = v;
			uvs[6/*X4*/] = u2;
			uvs[7/*Y4*/] = v;
			uvs[0/*X1*/] = u2;
			uvs[1/*Y1*/] = v2;
		} else {
			uvs[0/*X1*/] = u;
			uvs[1/*Y1*/] = v2;
			uvs[2/*X2*/] = u;
			uvs[3/*Y2*/] = v;
			uvs[4/*X3*/] = u2;
			uvs[5/*Y3*/] = v;
			uvs[6/*X4*/] = u2;
			uvs[7/*Y4*/] = v2;
		}
	},
    updateOffset: function ()
    {
		var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;
		var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;
		var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;
		var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;
		var localX2 = localX + this.regionWidth * regionScaleX;
		var localY2 = localY + this.regionHeight * regionScaleY;
		var radians = this.rotation * spine.degRad;
		var cos = Math.cos(radians);
		var sin = Math.sin(radians);
		var localXCos = localX * cos + this.x;
		var localXSin = localX * sin;
		var localYCos = localY * cos + this.y;
		var localYSin = localY * sin;
		var localX2Cos = localX2 * cos + this.x;
		var localX2Sin = localX2 * sin;
		var localY2Cos = localY2 * cos + this.y;
		var localY2Sin = localY2 * sin;
		var offset = this.offset;
		offset[0/*X1*/] = localXCos - localYSin;
		offset[1/*Y1*/] = localYCos + localXSin;
		offset[2/*X2*/] = localXCos - localY2Sin;
		offset[3/*Y2*/] = localY2Cos + localXSin;
		offset[4/*X3*/] = localX2Cos - localY2Sin;
		offset[5/*Y3*/] = localY2Cos + localX2Sin;
		offset[6/*X4*/] = localX2Cos - localYSin;
		offset[7/*Y4*/] = localYCos + localX2Sin;
	},
    computeVertices: function (x, y, bone, vertices)
    {
		x += bone.worldX;
		y += bone.worldY;
		var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;
		var offset = this.offset;
		vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;
		vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;
		vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;
		vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;
		vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;
		vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;
		vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;
		vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;
	}
};

spine.MeshAttachment = function (name)
{
	this.name = name;
};
spine.MeshAttachment.prototype = {
	type: spine.AttachmentType.mesh,
	vertices: null,
	uvs: null,
	regionUVs: null,
	triangles: null,
	hullLength: 0,
	r: 1, g: 1, b: 1, a: 1,
	path: null,
	rendererObject: null,
	regionU: 0, regionV: 0, regionU2: 0, regionV2: 0, regionRotate: false,
	regionOffsetX: 0, regionOffsetY: 0,
	regionWidth: 0, regionHeight: 0,
	regionOriginalWidth: 0, regionOriginalHeight: 0,
	edges: null,
	width: 0, height: 0,
    updateUVs: function ()
    {
		var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;
		var n = this.regionUVs.length;
        if (!this.uvs || this.uvs.length != n)
        {
            this.uvs = new spine.Float32Array(n);
		}
        if (this.regionRotate)
        {
            for (var i = 0; i < n; i += 2)
            {
                this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;
                this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;
			}
		} else {
            for (var i = 0; i < n; i += 2)
            {
                this.uvs[i] = this.regionU + this.regionUVs[i] * width;
                this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;
			}
		}
	},
    computeWorldVertices: function (x, y, slot, worldVertices)
    {
		var bone = slot.bone;
		x += bone.worldX;
		y += bone.worldY;
		var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;
		var vertices = this.vertices;
		var verticesCount = vertices.length;
		if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;
        for (var i = 0; i < verticesCount; i += 2)
        {
			var vx = vertices[i];
			var vy = vertices[i + 1];
			worldVertices[i] = vx * m00 + vy * m01 + x;
			worldVertices[i + 1] = vx * m10 + vy * m11 + y;
		}
	}
};

spine.SkinnedMeshAttachment = function (name)
{
	this.name = name;
};
spine.SkinnedMeshAttachment.prototype = {
	type: spine.AttachmentType.skinnedmesh,
	bones: null,
	weights: null,
	uvs: null,
	regionUVs: null,
	triangles: null,
	hullLength: 0,
	r: 1, g: 1, b: 1, a: 1,
	path: null,
	rendererObject: null,
	regionU: 0, regionV: 0, regionU2: 0, regionV2: 0, regionRotate: false,
	regionOffsetX: 0, regionOffsetY: 0,
	regionWidth: 0, regionHeight: 0,
	regionOriginalWidth: 0, regionOriginalHeight: 0,
	edges: null,
	width: 0, height: 0,
    updateUVs: function (u, v, u2, v2, rotate)
    {
		var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;
		var n = this.regionUVs.length;
        if (!this.uvs || this.uvs.length != n)
        {
            this.uvs = new spine.Float32Array(n);
		}
        if (this.regionRotate)
        {
            for (var i = 0; i < n; i += 2)
            {
                this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;
                this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;
			}
		} else {
            for (var i = 0; i < n; i += 2)
            {
                this.uvs[i] = this.regionU + this.regionUVs[i] * width;
                this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;
			}
		}
	},
    computeWorldVertices: function (x, y, slot, worldVertices)
    {
		var skeletonBones = slot.bone.skeleton.bones;
		var weights = this.weights;
		var bones = this.bones;

		var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;
		var wx, wy, bone, vx, vy, weight;
        if (!slot.attachmentVertices.length)
        {
            for (; v < n; w += 2)
            {
				wx = 0;
				wy = 0;
				nn = bones[v++] + v;
                for (; v < nn; v++, b += 3)
                {
					bone = skeletonBones[bones[v]];
					vx = weights[b];
					vy = weights[b + 1];
					weight = weights[b + 2];
					wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;
					wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;
				}
				worldVertices[w] = wx + x;
				worldVertices[w + 1] = wy + y;
			}
		} else {
			var ffd = slot.attachmentVertices;
            for (; v < n; w += 2)
            {
				wx = 0;
				wy = 0;
				nn = bones[v++] + v;
                for (; v < nn; v++, b += 3, f += 2)
                {
					bone = skeletonBones[bones[v]];
					vx = weights[b] + ffd[f];
					vy = weights[b + 1] + ffd[f + 1];
					weight = weights[b + 2];
					wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;
					wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;
				}
				worldVertices[w] = wx + x;
				worldVertices[w + 1] = wy + y;
			}
		}
	}
};

spine.BoundingBoxAttachment = function (name)
{
	this.name = name;
	this.vertices = [];
};
spine.BoundingBoxAttachment.prototype = {
	type: spine.AttachmentType.boundingbox,
    computeWorldVertices: function (x, y, bone, worldVertices)
    {
		x += bone.worldX;
		y += bone.worldY;
		var m00 = bone.m00, m01 = bone.m01, m10 = bone.m10, m11 = bone.m11;
		var vertices = this.vertices;
        for (var i = 0, n = vertices.length; i < n; i += 2)
        {
			var px = vertices[i];
			var py = vertices[i + 1];
			worldVertices[i] = px * m00 + py * m01 + x;
			worldVertices[i + 1] = px * m10 + py * m11 + y;
		}
	}
};

spine.AnimationStateData = function (skeletonData)
{
	this.skeletonData = skeletonData;
	this.animationToMixTime = {};
};
spine.AnimationStateData.prototype = {
	defaultMix: 0,
    setMixByName: function (fromName, toName, duration)
    {
		var from = this.skeletonData.findAnimation(fromName);
		if (!from) throw "Animation not found: " + fromName;
		var to = this.skeletonData.findAnimation(toName);
		if (!to) throw "Animation not found: " + toName;
		this.setMix(from, to, duration);
	},
    setMix: function (from, to, duration)
    {
		this.animationToMixTime[from.name + ":" + to.name] = duration;
	},
    getMix: function (from, to)
    {
		var key = from.name + ":" + to.name;
		return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;
	}
};

spine.TrackEntry = function ()
{};
spine.TrackEntry.prototype = {
	next: null, previous: null,
	animation: null,
	loop: false,
	delay: 0, time: 0, lastTime: -1, endTime: 0,
	timeScale: 1,
	mixTime: 0, mixDuration: 0, mix: 1,
	onStart: null, onEnd: null, onComplete: null, onEvent: null
};

spine.AnimationState = function (stateData)
{
	this.data = stateData;
	this.tracks = [];
	this.events = [];
};
spine.AnimationState.prototype = {
	onStart: null,
	onEnd: null,
	onComplete: null,
	onEvent: null,
	timeScale: 1,
    update: function (delta)
    {
		delta *= this.timeScale;
        for (var i = 0; i < this.tracks.length; i++)
        {
			var current = this.tracks[i];
			if (!current) continue;

			current.time += delta * current.timeScale;
            if (current.previous)
            {
				var previousDelta = delta * current.previous.timeScale;
				current.previous.time += previousDelta;
				current.mixTime += previousDelta;
			}

			var next = current.next;
            if (next)
            {
				next.time = current.lastTime - next.delay;
				if (next.time >= 0) this.setCurrent(i, next);
			} else {
				// End non-looping animation when it reaches its end time and there is no next entry.
				if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);
			}
		}
	},
    apply: function (skeleton)
    {
        for (var i = 0; i < this.tracks.length; i++)
        {
			var current = this.tracks[i];
			if (!current) continue;

			this.events.length = 0;

			var time = current.time;
			var lastTime = current.lastTime;
			var endTime = current.endTime;
			var loop = current.loop;
			if (!loop && time > endTime) time = endTime;

			var previous = current.previous;
            if (!previous)
            {
				if (current.mix == 1)
					current.animation.apply(skeleton, current.lastTime, time, loop, this.events);
				else
					current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);
			} else {
				var previousTime = previous.time;
				if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;
				previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);

				var alpha = current.mixTime / current.mixDuration * current.mix;
                if (alpha >= 1)
                {
					alpha = 1;
					current.previous = null;
				}
				current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);
			}

            for (var ii = 0, nn = this.events.length; ii < nn; ii++)
            {
				var event = this.events[ii];
				if (current.onEvent) current.onEvent(i, event);
				if (this.onEvent) this.onEvent(i, event);
			}

			// Check if completed the animation or a loop iteration.
            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))
            {
				var count = Math.floor(time / endTime);
				if (current.onComplete) current.onComplete(i, count);
				if (this.onComplete) this.onComplete(i, count);
			}

			current.lastTime = current.time;
		}
	},
    clearTracks: function ()
    {
		for (var i = 0, n = this.tracks.length; i < n; i++)
			this.clearTrack(i);
		this.tracks.length = 0;
	},
    clearTrack: function (trackIndex)
    {
		if (trackIndex >= this.tracks.length) return;
		var current = this.tracks[trackIndex];
		if (!current) return;

		if (current.onEnd) current.onEnd(trackIndex);
		if (this.onEnd) this.onEnd(trackIndex);

		this.tracks[trackIndex] = null;
	},
    _expandToIndex: function (index)
    {
		if (index < this.tracks.length) return this.tracks[index];
		while (index >= this.tracks.length)
			this.tracks.push(null);
		return null;
	},
    setCurrent: function (index, entry)
    {
		var current = this._expandToIndex(index);
        if (current)
        {
			var previous = current.previous;
			current.previous = null;

			if (current.onEnd) current.onEnd(index);
			if (this.onEnd) this.onEnd(index);

			entry.mixDuration = this.data.getMix(current.animation, entry.animation);
            if (entry.mixDuration > 0)
            {
				entry.mixTime = 0;
				// If a mix is in progress, mix from the closest animation.
				if (previous && current.mixTime / current.mixDuration < 0.5)
					entry.previous = previous;
				else
					entry.previous = current;
			}
		}

		this.tracks[index] = entry;

		if (entry.onStart) entry.onStart(index);
		if (this.onStart) this.onStart(index);
	},
    setAnimationByName: function (trackIndex, animationName, loop)
    {
		var animation = this.data.skeletonData.findAnimation(animationName);
		if (!animation) throw "Animation not found: " + animationName;
		return this.setAnimation(trackIndex, animation, loop);
	},
	/** Set the current animation. Any queued animations are cleared. */
    setAnimation: function (trackIndex, animation, loop)
    {
		var entry = new spine.TrackEntry();
		entry.animation = animation;
		entry.loop = loop;
		entry.endTime = animation.duration;
		this.setCurrent(trackIndex, entry);
		return entry;
	},
    addAnimationByName: function (trackIndex, animationName, loop, delay)
    {
		var animation = this.data.skeletonData.findAnimation(animationName);
		if (!animation) throw "Animation not found: " + animationName;
		return this.addAnimation(trackIndex, animation, loop, delay);
	},
	/** Adds an animation to be played delay seconds after the current or last queued animation.
	 * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */
    addAnimation: function (trackIndex, animation, loop, delay)
    {
		var entry = new spine.TrackEntry();
		entry.animation = animation;
		entry.loop = loop;
		entry.endTime = animation.duration;

		var last = this._expandToIndex(trackIndex);
        if (last)
        {
			while (last.next)
				last = last.next;
			last.next = entry;
		} else
			this.tracks[trackIndex] = entry;

        if (delay <= 0)
        {
			if (last)
				delay += last.endTime - this.data.getMix(last.animation, animation);
			else
				delay = 0;
		}
		entry.delay = delay;

		return entry;
	},
	/** May be null. */
    getCurrent: function (trackIndex)
    {
		if (trackIndex >= this.tracks.length) return null;
		return this.tracks[trackIndex];
	}
};

spine.SkeletonJsonParser = function (attachmentLoader)
{
	this.attachmentLoader = attachmentLoader;
};
spine.SkeletonJsonParser.prototype = {
	scale: 1,
    readSkeletonData: function (root, name)
    {
		var skeletonData = new spine.SkeletonData();
		skeletonData.name = name;

		// Skeleton.
		var skeletonMap = root["skeleton"];
        if (skeletonMap)
        {
			skeletonData.hash = skeletonMap["hash"];
			skeletonData.version = skeletonMap["spine"];
			skeletonData.width = skeletonMap["width"] || 0;
			skeletonData.height = skeletonMap["height"] || 0;
		}

		// Bones.
		var bones = root["bones"];
        for (var i = 0, n = bones.length; i < n; i++)
        {
			var boneMap = bones[i];
			var parent = null;
            if (boneMap["parent"])
            {
				parent = skeletonData.findBone(boneMap["parent"]);
				if (!parent) throw "Parent bone not found: " + boneMap["parent"];
			}
			var boneData = new spine.BoneData(boneMap["name"], parent);
			boneData.length = (boneMap["length"] || 0) * this.scale;
			boneData.x = (boneMap["x"] || 0) * this.scale;
			boneData.y = (boneMap["y"] || 0) * this.scale;
			boneData.rotation = (boneMap["rotation"] || 0);
			boneData.scaleX = boneMap.hasOwnProperty("scaleX") ? boneMap["scaleX"] : 1;
			boneData.scaleY = boneMap.hasOwnProperty("scaleY") ? boneMap["scaleY"] : 1;
			boneData.inheritScale = boneMap.hasOwnProperty("inheritScale") ? boneMap["inheritScale"] : true;
			boneData.inheritRotation = boneMap.hasOwnProperty("inheritRotation") ? boneMap["inheritRotation"] : true;
			skeletonData.bones.push(boneData);
		}

		// IK constraints.
		var ik = root["ik"];
        if (ik)
        {
            for (var i = 0, n = ik.length; i < n; i++)
            {
				var ikMap = ik[i];
				var ikConstraintData = new spine.IkConstraintData(ikMap["name"]);

				var bones = ikMap["bones"];
                for (var ii = 0, nn = bones.length; ii < nn; ii++)
                {
					var bone = skeletonData.findBone(bones[ii]);
					if (!bone) throw "IK bone not found: " + bones[ii];
					ikConstraintData.bones.push(bone);
				}

				ikConstraintData.target = skeletonData.findBone(ikMap["target"]);
				if (!ikConstraintData.target) throw "Target bone not found: " + ikMap["target"];

				ikConstraintData.bendDirection = (!ikMap.hasOwnProperty("bendPositive") || ikMap["bendPositive"]) ? 1 : -1;
				ikConstraintData.mix = ikMap.hasOwnProperty("mix") ? ikMap["mix"] : 1;

				skeletonData.ikConstraints.push(ikConstraintData);
			}
		}

		// Slots.
		var slots = root["slots"];
        for (var i = 0, n = slots.length; i < n; i++)
        {
			var slotMap = slots[i];
			var boneData = skeletonData.findBone(slotMap["bone"]);
			if (!boneData) throw "Slot bone not found: " + slotMap["bone"];
			var slotData = new spine.SlotData(slotMap["name"], boneData);

			var color = slotMap["color"];
            if (color)
            {
				slotData.r = this.toColor(color, 0);
				slotData.g = this.toColor(color, 1);
				slotData.b = this.toColor(color, 2);
				slotData.a = this.toColor(color, 3);
			}

			slotData.attachmentName = slotMap["attachment"];
			slotData.additiveBlending = slotMap["additive"] && slotMap["additive"] == "true";

			skeletonData.slots.push(slotData);
		}

		// Skins.
		var skins = root["skins"];
        for (var skinName in skins)
        {
			if (!skins.hasOwnProperty(skinName)) continue;
			var skinMap = skins[skinName];
			var skin = new spine.Skin(skinName);
            for (var slotName in skinMap)
            {
				if (!skinMap.hasOwnProperty(slotName)) continue;
				var slotIndex = skeletonData.findSlotIndex(slotName);
				var slotEntry = skinMap[slotName];
                for (var attachmentName in slotEntry)
                {
					if (!slotEntry.hasOwnProperty(attachmentName)) continue;
					var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);
					if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);
				}
			}
			skeletonData.skins.push(skin);
			if (skin.name == "default") skeletonData.defaultSkin = skin;
		}

		// Events.
		var events = root["events"];
        for (var eventName in events)
        {
			if (!events.hasOwnProperty(eventName)) continue;
			var eventMap = events[eventName];
			var eventData = new spine.EventData(eventName);
			eventData.intValue = eventMap["int"] || 0;
			eventData.floatValue = eventMap["float"] || 0;
			eventData.stringValue = eventMap["string"] || null;
			skeletonData.events.push(eventData);
		}

		// Animations.
		var animations = root["animations"];
        for (var animationName in animations)
        {
			if (!animations.hasOwnProperty(animationName)) continue;
			this.readAnimation(animationName, animations[animationName], skeletonData);
		}

		return skeletonData;
	},
    readAttachment: function (skin, name, map)
    {
		name = map["name"] || name;

		var type = spine.AttachmentType[map["type"] || "region"];
		var path = map["path"] || name;

		var scale = this.scale;
        if (type == spine.AttachmentType.region)
        {
			var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
			if (!region) return null;
			region.path = path;
			region.x = (map["x"] || 0) * scale;
			region.y = (map["y"] || 0) * scale;
			region.scaleX = map.hasOwnProperty("scaleX") ? map["scaleX"] : 1;
			region.scaleY = map.hasOwnProperty("scaleY") ? map["scaleY"] : 1;
			region.rotation = map["rotation"] || 0;
			region.width = (map["width"] || 0) * scale;
			region.height = (map["height"] || 0) * scale;

			var color = map["color"];
            if (color)
            {
				region.r = this.toColor(color, 0);
				region.g = this.toColor(color, 1);
				region.b = this.toColor(color, 2);
				region.a = this.toColor(color, 3);
			}

			region.updateOffset();
			return region;
        } else if (type == spine.AttachmentType.mesh)
        {
			var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
			if (!mesh) return null;
			mesh.path = path;
			mesh.vertices = this.getFloatArray(map, "vertices", scale);
			mesh.triangles = this.getIntArray(map, "triangles");
			mesh.regionUVs = this.getFloatArray(map, "uvs", 1);
			mesh.updateUVs();

			color = map["color"];
            if (color)
            {
				mesh.r = this.toColor(color, 0);
				mesh.g = this.toColor(color, 1);
				mesh.b = this.toColor(color, 2);
				mesh.a = this.toColor(color, 3);
			}

			mesh.hullLength = (map["hull"] || 0) * 2;
			if (map["edges"]) mesh.edges = this.getIntArray(map, "edges");
			mesh.width = (map["width"] || 0) * scale;
			mesh.height = (map["height"] || 0) * scale;
			return mesh;
        } else if (type == spine.AttachmentType.skinnedmesh)
        {
			var mesh = this.attachmentLoader.newSkinnedMeshAttachment(skin, name, path);
			if (!mesh) return null;
			mesh.path = path;

			var uvs = this.getFloatArray(map, "uvs", 1);
			var vertices = this.getFloatArray(map, "vertices", 1);
			var weights = [];
			var bones = [];
            for (var i = 0, n = vertices.length; i < n; )
            {
				var boneCount = vertices[i++] | 0;
				bones[bones.length] = boneCount;
                for (var nn = i + boneCount * 4; i < nn; )
                {
					bones[bones.length] = vertices[i];
					weights[weights.length] = vertices[i + 1] * scale;
					weights[weights.length] = vertices[i + 2] * scale;
					weights[weights.length] = vertices[i + 3];
					i += 4;
				}
			}
			mesh.bones = bones;
			mesh.weights = weights;
			mesh.triangles = this.getIntArray(map, "triangles");
			mesh.regionUVs = uvs;
			mesh.updateUVs();

			color = map["color"];
            if (color)
            {
				mesh.r = this.toColor(color, 0);
				mesh.g = this.toColor(color, 1);
				mesh.b = this.toColor(color, 2);
				mesh.a = this.toColor(color, 3);
			}

			mesh.hullLength = (map["hull"] || 0) * 2;
			if (map["edges"]) mesh.edges = this.getIntArray(map, "edges");
			mesh.width = (map["width"] || 0) * scale;
			mesh.height = (map["height"] || 0) * scale;
			return mesh;
        } else if (type == spine.AttachmentType.boundingbox)
        {
			var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
			var vertices = map["vertices"];
			for (var i = 0, n = vertices.length; i < n; i++)
				attachment.vertices.push(vertices[i] * scale);
			return attachment;
		}
		throw "Unknown attachment type: " + type;
	},
    readAnimation: function (name, map, skeletonData)
    {
		var timelines = [];
		var duration = 0;

		var slots = map["slots"];
        for (var slotName in slots)
        {
			if (!slots.hasOwnProperty(slotName)) continue;
			var slotMap = slots[slotName];
			var slotIndex = skeletonData.findSlotIndex(slotName);

            for (var timelineName in slotMap)
            {
				if (!slotMap.hasOwnProperty(timelineName)) continue;
				var values = slotMap[timelineName];
                if (timelineName == "color")
                {
					var timeline = new spine.ColorTimeline(values.length);
					timeline.slotIndex = slotIndex;

					var frameIndex = 0;
                    for (var i = 0, n = values.length; i < n; i++)
                    {
						var valueMap = values[i];
						var color = valueMap["color"];
						var r = this.toColor(color, 0);
						var g = this.toColor(color, 1);
						var b = this.toColor(color, 2);
						var a = this.toColor(color, 3);
						timeline.setFrame(frameIndex, valueMap["time"], r, g, b, a);
						this.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);

                } else if (timelineName == "attachment")
                {
					var timeline = new spine.AttachmentTimeline(values.length);
					timeline.slotIndex = slotIndex;

					var frameIndex = 0;
                    for (var i = 0, n = values.length; i < n; i++)
                    {
						var valueMap = values[i];
						timeline.setFrame(frameIndex++, valueMap["time"], valueMap["name"]);
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);

				} else
					throw "Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")";
			}
		}

		var bones = map["bones"];
        for (var boneName in bones)
        {
			if (!bones.hasOwnProperty(boneName)) continue;
			var boneIndex = skeletonData.findBoneIndex(boneName);
			if (boneIndex == -1) throw "Bone not found: " + boneName;
			var boneMap = bones[boneName];

            for (var timelineName in boneMap)
            {
				if (!boneMap.hasOwnProperty(timelineName)) continue;
				var values = boneMap[timelineName];
                if (timelineName == "rotate")
                {
					var timeline = new spine.RotateTimeline(values.length);
					timeline.boneIndex = boneIndex;

					var frameIndex = 0;
                    for (var i = 0, n = values.length; i < n; i++)
                    {
						var valueMap = values[i];
						timeline.setFrame(frameIndex, valueMap["time"], valueMap["angle"]);
						this.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);

                } else if (timelineName == "translate" || timelineName == "scale")
                {
					var timeline;
					var timelineScale = 1;
					if (timelineName == "scale")
						timeline = new spine.ScaleTimeline(values.length);
                    else
                    {
						timeline = new spine.TranslateTimeline(values.length);
						timelineScale = this.scale;
					}
					timeline.boneIndex = boneIndex;

					var frameIndex = 0;
                    for (var i = 0, n = values.length; i < n; i++)
                    {
						var valueMap = values[i];
						var x = (valueMap["x"] || 0) * timelineScale;
						var y = (valueMap["y"] || 0) * timelineScale;
						timeline.setFrame(frameIndex, valueMap["time"], x, y);
						this.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);

                } else if (timelineName == "flipX" || timelineName == "flipY")
                {
					var x = timelineName == "flipX";
					var timeline = x ? new spine.FlipXTimeline(values.length) : new spine.FlipYTimeline(values.length);
					timeline.boneIndex = boneIndex;

					var field = x ? "x" : "y";
					var frameIndex = 0;
                    for (var i = 0, n = values.length; i < n; i++)
                    {
						var valueMap = values[i];
						timeline.setFrame(frameIndex, valueMap["time"], valueMap[field] || false);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);
				} else
					throw "Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")";
			}
		}

		var ikMap = map["ik"];
        for (var ikConstraintName in ikMap)
        {
			if (!ikMap.hasOwnProperty(ikConstraintName)) continue;
			var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);
			var values = ikMap[ikConstraintName];
			var timeline = new spine.IkConstraintTimeline(values.length);
			timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);
			var frameIndex = 0;
            for (var i = 0, n = values.length; i < n; i++)
            {
				var valueMap = values[i];
				var mix = valueMap.hasOwnProperty("mix") ? valueMap["mix"] : 1;
				var bendDirection = (!valueMap.hasOwnProperty("bendPositive") || valueMap["bendPositive"]) ? 1 : -1;
				timeline.setFrame(frameIndex, valueMap["time"], mix, bendDirection);
				this.readCurve(timeline, frameIndex, valueMap);
				frameIndex++;
			}
			timelines.push(timeline);
			duration = Math.max(duration, timeline.frames[timeline.frameCount * 3 - 3]);
		}

		var ffd = map["ffd"];
        for (var skinName in ffd)
        {
			var skin = skeletonData.findSkin(skinName);
			var slotMap = ffd[skinName];
            for (slotName in slotMap)
            {
				var slotIndex = skeletonData.findSlotIndex(slotName);
				var meshMap = slotMap[slotName];
                for (var meshName in meshMap)
                {
					var values = meshMap[meshName];
					var timeline = new spine.FfdTimeline(values.length);
					var attachment = skin.getAttachment(slotIndex, meshName);
					if (!attachment) throw "FFD attachment not found: " + meshName;
					timeline.slotIndex = slotIndex;
					timeline.attachment = attachment;

					var isMesh = attachment.type == spine.AttachmentType.mesh;
					var vertexCount;
					if (isMesh)
						vertexCount = attachment.vertices.length;
					else
						vertexCount = attachment.weights.length / 3 * 2;

					var frameIndex = 0;
                    for (var i = 0, n = values.length; i < n; i++)
                    {
						var valueMap = values[i];
						var vertices;
                        if (!valueMap["vertices"])
                        {
							if (isMesh)
								vertices = attachment.vertices;
                            else
                            {
								vertices = [];
								vertices.length = vertexCount;
							}
						} else {
							var verticesValue = valueMap["vertices"];
							var vertices = [];
							vertices.length = vertexCount;
							var start = valueMap["offset"] || 0;
							var nn = verticesValue.length;
                            if (this.scale == 1)
                            {
								for (var ii = 0; ii < nn; ii++)
									vertices[ii + start] = verticesValue[ii];
							} else {
								for (var ii = 0; ii < nn; ii++)
									vertices[ii + start] = verticesValue[ii] * this.scale;
							}
                            if (isMesh)
                            {
								var meshVertices = attachment.vertices;
								for (var ii = 0, nn = vertices.length; ii < nn; ii++)
									vertices[ii] += meshVertices[ii];
							}
						}

						timeline.setFrame(frameIndex, valueMap["time"], vertices);
						this.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines[timelines.length] = timeline;
					duration = Math.max(duration, timeline.frames[timeline.frameCount - 1]);
				}
			}
		}

		var drawOrderValues = map["drawOrder"];
		if (!drawOrderValues) drawOrderValues = map["draworder"];
        if (drawOrderValues)
        {
			var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);
			var slotCount = skeletonData.slots.length;
			var frameIndex = 0;
            for (var i = 0, n = drawOrderValues.length; i < n; i++)
            {
				var drawOrderMap = drawOrderValues[i];
				var drawOrder = null;
                if (drawOrderMap["offsets"])
                {
					drawOrder = [];
					drawOrder.length = slotCount;
					for (var ii = slotCount - 1; ii >= 0; ii--)
						drawOrder[ii] = -1;
					var offsets = drawOrderMap["offsets"];
					var unchanged = [];
					unchanged.length = slotCount - offsets.length;
					var originalIndex = 0, unchangedIndex = 0;
                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)
                    {
						var offsetMap = offsets[ii];
						var slotIndex = skeletonData.findSlotIndex(offsetMap["slot"]);
						if (slotIndex == -1) throw "Slot not found: " + offsetMap["slot"];
						// Collect unchanged items.
						while (originalIndex != slotIndex)
							unchanged[unchangedIndex++] = originalIndex++;
						// Set changed items.
						drawOrder[originalIndex + offsetMap["offset"]] = originalIndex++;
					}
					// Collect remaining unchanged items.
					while (originalIndex < slotCount)
						unchanged[unchangedIndex++] = originalIndex++;
					// Fill in unchanged items.
					for (var ii = slotCount - 1; ii >= 0; ii--)
						if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];
				}
				timeline.setFrame(frameIndex++, drawOrderMap["time"], drawOrder);
			}
			timelines.push(timeline);
			duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
		}

		var events = map["events"];
        if (events)
        {
			var timeline = new spine.EventTimeline(events.length);
			var frameIndex = 0;
            for (var i = 0, n = events.length; i < n; i++)
            {
				var eventMap = events[i];
				var eventData = skeletonData.findEvent(eventMap["name"]);
				if (!eventData) throw "Event not found: " + eventMap["name"];
				var event = new spine.Event(eventData);
				event.intValue = eventMap.hasOwnProperty("int") ? eventMap["int"] : eventData.intValue;
				event.floatValue = eventMap.hasOwnProperty("float") ? eventMap["float"] : eventData.floatValue;
				event.stringValue = eventMap.hasOwnProperty("string") ? eventMap["string"] : eventData.stringValue;
				timeline.setFrame(frameIndex++, eventMap["time"], event);
			}
			timelines.push(timeline);
			duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
		}

		skeletonData.animations.push(new spine.Animation(name, timelines, duration));
	},
    readCurve: function (timeline, frameIndex, valueMap)
    {
		var curve = valueMap["curve"];
		if (!curve)
			timeline.curves.setLinear(frameIndex);
		else if (curve == "stepped")
			timeline.curves.setStepped(frameIndex);
		else if (curve instanceof Array)
			timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
	},
    toColor: function (hexString, colorIndex)
    {
		if (hexString.length != 8) throw "Color hexidecimal length must be 8, recieved: " + hexString;
		return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;
	},
    getFloatArray: function (map, name, scale)
    {
		var list = map[name];
		var values = new spine.Float32Array(list.length);
		var i = 0, n = list.length;
        if (scale == 1)
        {
			for (; i < n; i++)
				values[i] = list[i];
		} else {
			for (; i < n; i++)
				values[i] = list[i] * scale;
		}
		return values;
	},
    getIntArray: function (map, name)
    {
		var list = map[name];
		var values = new spine.Uint16Array(list.length);
		for (var i = 0, n = list.length; i < n; i++)
			values[i] = list[i] | 0;
		return values;
	}
};

spine.Atlas = function (atlasText, baseUrl, crossOrigin)
{
    if (baseUrl && baseUrl.indexOf('/') !== baseUrl.length)
    {
        baseUrl += '/';
    }

	this.pages = [];
	this.regions = [];

    this.texturesLoading = 0;

    var self = this;

	var reader = new spine.AtlasReader(atlasText);
	var tuple = [];
	tuple.length = 4;
	var page = null;
    while (true)
    {
		var line = reader.readLine();
		if (line === null) break;
		line = reader.trim(line);
		if (!line.length)
			page = null;
        else if (!page)
        {
			page = new spine.AtlasPage();
			page.name = line;

            if (reader.readTuple(tuple) == 2)
            { // size is only optional for an atlas packed with an old TexturePacker.
				page.width = parseInt(tuple[0]);
				page.height = parseInt(tuple[1]);
				reader.readTuple(tuple);
			}
			page.format = spine.Atlas.Format[tuple[0]];

			reader.readTuple(tuple);
			page.minFilter = spine.Atlas.TextureFilter[tuple[0]];
			page.magFilter = spine.Atlas.TextureFilter[tuple[1]];

			var direction = reader.readValue();
			page.uWrap = spine.Atlas.TextureWrap.clampToEdge;
			page.vWrap = spine.Atlas.TextureWrap.clampToEdge;
			if (direction == "x")
				page.uWrap = spine.Atlas.TextureWrap.repeat;
			else if (direction == "y")
				page.vWrap = spine.Atlas.TextureWrap.repeat;
			else if (direction == "xy")
				page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;

            page.rendererObject = core.BaseTexture.fromImage(baseUrl + line, crossOrigin);

			this.pages.push(page);

		} else {
			var region = new spine.AtlasRegion();
			region.name = line;
			region.page = page;

			region.rotate = reader.readValue() == "true";

			reader.readTuple(tuple);
			var x = parseInt(tuple[0]);
			var y = parseInt(tuple[1]);

			reader.readTuple(tuple);
			var width = parseInt(tuple[0]);
			var height = parseInt(tuple[1]);

			region.u = x / page.width;
			region.v = y / page.height;
            if (region.rotate)
            {
				region.u2 = (x + height) / page.width;
				region.v2 = (y + width) / page.height;
			} else {
				region.u2 = (x + width) / page.width;
				region.v2 = (y + height) / page.height;
			}
			region.x = x;
			region.y = y;
			region.width = Math.abs(width);
			region.height = Math.abs(height);

            if (reader.readTuple(tuple) == 4)
            { // split is optional
				region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];

                if (reader.readTuple(tuple) == 4)
                { // pad is optional, but only present with splits
					region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];

					reader.readTuple(tuple);
				}
			}

			region.originalWidth = parseInt(tuple[0]);
			region.originalHeight = parseInt(tuple[1]);

			reader.readTuple(tuple);
			region.offsetX = parseInt(tuple[0]);
			region.offsetY = parseInt(tuple[1]);

			region.index = parseInt(reader.readValue());

			this.regions.push(region);
		}
	}
};
spine.Atlas.prototype = {
    findRegion: function (name)
    {
		var regions = this.regions;
		for (var i = 0, n = regions.length; i < n; i++)
			if (regions[i].name == name) return regions[i];
		return null;
	},
    dispose: function ()
    {
		var pages = this.pages;
		for (var i = 0, n = pages.length; i < n; i++)
			pages[i].rendererObject.destroy(true);
	},
    updateUVs: function (page)
    {
		var regions = this.regions;
        for (var i = 0, n = regions.length; i < n; i++)
        {
			var region = regions[i];
			if (region.page != page) continue;
			region.u = region.x / page.width;
			region.v = region.y / page.height;
            if (region.rotate)
            {
				region.u2 = (region.x + region.height) / page.width;
				region.v2 = (region.y + region.width) / page.height;
			} else {
				region.u2 = (region.x + region.width) / page.width;
				region.v2 = (region.y + region.height) / page.height;
			}
		}
	}
};

spine.Atlas.Format = {
	alpha: 0,
	intensity: 1,
	luminanceAlpha: 2,
	rgb565: 3,
	rgba4444: 4,
	rgb888: 5,
	rgba8888: 6
};

spine.Atlas.TextureFilter = {
	nearest: 0,
	linear: 1,
	mipMap: 2,
	mipMapNearestNearest: 3,
	mipMapLinearNearest: 4,
	mipMapNearestLinear: 5,
	mipMapLinearLinear: 6
};

spine.Atlas.TextureWrap = {
	mirroredRepeat: 0,
	clampToEdge: 1,
	repeat: 2
};

spine.AtlasPage = function ()
{};
spine.AtlasPage.prototype = {
	name: null,
	format: null,
	minFilter: null,
	magFilter: null,
	uWrap: null,
	vWrap: null,
	rendererObject: null,
	width: 0,
	height: 0
};

spine.AtlasRegion = function ()
{};
spine.AtlasRegion.prototype = {
	page: null,
	name: null,
	x: 0, y: 0,
	width: 0, height: 0,
	u: 0, v: 0, u2: 0, v2: 0,
	offsetX: 0, offsetY: 0,
	originalWidth: 0, originalHeight: 0,
	index: 0,
	rotate: false,
	splits: null,
	pads: null
};

spine.AtlasReader = function (text)
{
	this.lines = text.split(/\r\n|\r|\n/);
};
spine.AtlasReader.prototype = {
	index: 0,
    trim: function (value)
    {
		return value.replace(/^\s+|\s+$/g, "");
	},
    readLine: function ()
    {
		if (this.index >= this.lines.length) return null;
		return this.lines[this.index++];
	},
    readValue: function ()
    {
		var line = this.readLine();
		var colon = line.indexOf(":");
		if (colon == -1) throw "Invalid line: " + line;
		return this.trim(line.substring(colon + 1));
	},
	/** Returns the number of tuple values read (1, 2 or 4). */
    readTuple: function (tuple)
    {
		var line = this.readLine();
		var colon = line.indexOf(":");
		if (colon == -1) throw "Invalid line: " + line;
		var i = 0, lastMatch = colon + 1;
        for (; i < 3; i++)
        {
			var comma = line.indexOf(",", lastMatch);
			if (comma == -1) break;
			tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));
			lastMatch = comma + 1;
		}
		tuple[i] = this.trim(line.substring(lastMatch));
		return i + 1;
	}
};

spine.AtlasAttachmentParser = function (atlas)
{
	this.atlas = atlas;
};
spine.AtlasAttachmentParser.prototype = {
    newRegionAttachment: function (skin, name, path)
    {
		var region = this.atlas.findRegion(path);
		if (!region) throw "Region not found in atlas: " + path + " (region attachment: " + name + ")";
		var attachment = new spine.RegionAttachment(name);
		attachment.rendererObject = region;
		attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);
		attachment.regionOffsetX = region.offsetX;
		attachment.regionOffsetY = region.offsetY;
		attachment.regionWidth = region.width;
		attachment.regionHeight = region.height;
		attachment.regionOriginalWidth = region.originalWidth;
		attachment.regionOriginalHeight = region.originalHeight;
		return attachment;
	},
    newMeshAttachment: function (skin, name, path)
    {
		var region = this.atlas.findRegion(path);
		if (!region) throw "Region not found in atlas: " + path + " (mesh attachment: " + name + ")";
		var attachment = new spine.MeshAttachment(name);
		attachment.rendererObject = region;
		attachment.regionU = region.u;
		attachment.regionV = region.v;
		attachment.regionU2 = region.u2;
		attachment.regionV2 = region.v2;
		attachment.regionRotate = region.rotate;
		attachment.regionOffsetX = region.offsetX;
		attachment.regionOffsetY = region.offsetY;
		attachment.regionWidth = region.width;
		attachment.regionHeight = region.height;
		attachment.regionOriginalWidth = region.originalWidth;
		attachment.regionOriginalHeight = region.originalHeight;
		return attachment;
	},
    newSkinnedMeshAttachment: function (skin, name, path)
    {
		var region = this.atlas.findRegion(path);
		if (!region) throw "Region not found in atlas: " + path + " (skinned mesh attachment: " + name + ")";
		var attachment = new spine.SkinnedMeshAttachment(name);
		attachment.rendererObject = region;
		attachment.regionU = region.u;
		attachment.regionV = region.v;
		attachment.regionU2 = region.u2;
		attachment.regionV2 = region.v2;
		attachment.regionRotate = region.rotate;
		attachment.regionOffsetX = region.offsetX;
		attachment.regionOffsetY = region.offsetY;
		attachment.regionWidth = region.width;
		attachment.regionHeight = region.height;
		attachment.regionOriginalWidth = region.originalWidth;
		attachment.regionOriginalHeight = region.originalHeight;
		return attachment;
	},
    newBoundingBoxAttachment: function (skin, name)
    {
		return new spine.BoundingBoxAttachment(name);
	}
};

spine.SkeletonBounds = function ()
{
	this.polygonPool = [];
	this.polygons = [];
	this.boundingBoxes = [];
};
spine.SkeletonBounds.prototype = {
	minX: 0, minY: 0, maxX: 0, maxY: 0,
    update: function (skeleton, updateAabb)
    {
		var slots = skeleton.slots;
		var slotCount = slots.length;
		var x = skeleton.x, y = skeleton.y;
		var boundingBoxes = this.boundingBoxes;
		var polygonPool = this.polygonPool;
		var polygons = this.polygons;

		boundingBoxes.length = 0;
		for (var i = 0, n = polygons.length; i < n; i++)
			polygonPool.push(polygons[i]);
		polygons.length = 0;

        for (var i = 0; i < slotCount; i++)
        {
			var slot = slots[i];
			var boundingBox = slot.attachment;
			if (boundingBox.type != spine.AttachmentType.boundingbox) continue;
			boundingBoxes.push(boundingBox);

			var poolCount = polygonPool.length, polygon;
            if (poolCount > 0)
            {
				polygon = polygonPool[poolCount - 1];
				polygonPool.splice(poolCount - 1, 1);
			} else
				polygon = [];
			polygons.push(polygon);

			polygon.length = boundingBox.vertices.length;
			boundingBox.computeWorldVertices(x, y, slot.bone, polygon);
		}

		if (updateAabb) this.aabbCompute();
	},
    aabbCompute: function ()
    {
		var polygons = this.polygons;
		var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;
        for (var i = 0, n = polygons.length; i < n; i++)
        {
			var vertices = polygons[i];
            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)
            {
				var x = vertices[ii];
				var y = vertices[ii + 1];
				minX = Math.min(minX, x);
				minY = Math.min(minY, y);
				maxX = Math.max(maxX, x);
				maxY = Math.max(maxY, y);
			}
		}
		this.minX = minX;
		this.minY = minY;
		this.maxX = maxX;
		this.maxY = maxY;
	},
	/** Returns true if the axis aligned bounding box contains the point. */
    aabbContainsPoint: function (x, y)
    {
		return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
	},
	/** Returns true if the axis aligned bounding box intersects the line segment. */
    aabbIntersectsSegment: function (x1, y1, x2, y2)
    {
		var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
		if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))
			return false;
		var m = (y2 - y1) / (x2 - x1);
		var y = m * (minX - x1) + y1;
		if (y > minY && y < maxY) return true;
		y = m * (maxX - x1) + y1;
		if (y > minY && y < maxY) return true;
		var x = (minY - y1) / m + x1;
		if (x > minX && x < maxX) return true;
		x = (maxY - y1) / m + x1;
		if (x > minX && x < maxX) return true;
		return false;
	},
	/** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */
    aabbIntersectsSkeleton: function (bounds)
    {
		return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
	},
	/** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
	 * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */
    containsPoint: function (x, y)
    {
		var polygons = this.polygons;
		for (var i = 0, n = polygons.length; i < n; i++)
			if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];
		return null;
	},
	/** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually
	 * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */
    intersectsSegment: function (x1, y1, x2, y2)
    {
		var polygons = this.polygons;
		for (var i = 0, n = polygons.length; i < n; i++)
			if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];
		return null;
	},
	/** Returns true if the polygon contains the point. */
    polygonContainsPoint: function (polygon, x, y)
    {
		var nn = polygon.length;
		var prevIndex = nn - 2;
		var inside = false;
        for (var ii = 0; ii < nn; ii += 2)
        {
			var vertexY = polygon[ii + 1];
			var prevY = polygon[prevIndex + 1];
            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))
            {
				var vertexX = polygon[ii];
				if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;
			}
			prevIndex = ii;
		}
		return inside;
	},
	/** Returns true if the polygon contains the line segment. */
    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)
    {
		var nn = polygon.length;
		var width12 = x1 - x2, height12 = y1 - y2;
		var det1 = x1 * y2 - y1 * x2;
		var x3 = polygon[nn - 2], y3 = polygon[nn - 1];
        for (var ii = 0; ii < nn; ii += 2)
        {
			var x4 = polygon[ii], y4 = polygon[ii + 1];
			var det2 = x3 * y4 - y3 * x4;
			var width34 = x3 - x4, height34 = y3 - y4;
			var det3 = width12 * height34 - height12 * width34;
			var x = (det1 * width34 - width12 * det2) / det3;
            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))
            {
				var y = (det1 * height34 - height12 * det2) / det3;
				if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;
			}
			x3 = x4;
			y3 = y4;
		}
		return false;
	},
    getPolygon: function (attachment)
    {
		var index = this.boundingBoxes.indexOf(attachment);
		return index == -1 ? null : this.polygons[index];
	},
    getWidth: function ()
    {
		return this.maxX - this.minX;
	},
    getHeight: function ()
    {
		return this.maxY - this.minY;
	}
};

},{"../core":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/core/index.js"}],"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/spine/index.js":[function(require,module,exports){
/**
 * @file        Main export of the PIXI spine library
 * @author      Mat Groves <mat@goodboydigital.com>
 * @copyright   2013-2015 GoodBoyDigital
 * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}
 */

/**
 * @namespace PIXI.spine
 */
module.exports = {
    Spine:      require('./Spine'),
    SpineRuntime:    require('./SpineRuntime')
};

},{"./Spine":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/spine/Spine.js","./SpineRuntime":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/spine/SpineRuntime.js"}],"/Users/tyemilldeveloper/space-game/src/BlueprintEditor.coffee":[function(require,module,exports){
var BlueprintEditor, Core, Entity, Hull, IO, Interior, PartLabel, Pixi, Thruster, Util,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Core = require('ship/Core');

Entity = require('Entity');

Hull = require('ship/Hull');

Interior = require('ship/Interior');

IO = require('IO');

Pixi = require('pixi.js');

Thruster = require('ship/Thruster');

Util = require('util/Util');

PartLabel = (function(superClass) {
  extend(PartLabel, superClass);

  function PartLabel() {
    this.layer = 'hud';
    this.sprite = new Pixi.Text('part', {
      font: '20px Arial',
      fill: '#FFFFFF'
    });
  }

  return PartLabel;

})(Entity);

BlueprintEditor = (function(superClass) {
  var K_CLOSE, K_NEXT_PART, K_PREVIOUS_PART, K_ROTATE_LEFT, K_ROTATE_RIGHT;

  extend(BlueprintEditor, superClass);

  K_NEXT_PART = 81;

  K_PREVIOUS_PART = 69;

  K_ROTATE_LEFT = 65;

  K_ROTATE_RIGHT = 68;

  K_CLOSE = 32;

  function BlueprintEditor(blueprint, onclose) {
    this.blueprint = blueprint;
    this.onclose = onclose != null ? onclose : null;
    this.destroyed = bind(this.destroyed, this);
    this.onKeyDown = bind(this.onKeyDown, this);
    this.rotate = bind(this.rotate, this);
    this.nextPart = bind(this.nextPart, this);
    this.onRightClick = bind(this.onRightClick, this);
    this.onClick = bind(this.onClick, this);
    this.render = bind(this.render, this);
    this.getHoverSquare = bind(this.getHoverSquare, this);
    this.added = bind(this.added, this);
    this.sprite = new Pixi.Container();
    this.layer = 'world';
    this.background = new Pixi.Graphics();
    this.background.beginFill(0x111711);
    this.background.endFill();
    this.sprite.addChild(this.background);
    this.sprite.addChild(this.blueprint.sprite);
    this.selector = new Pixi.Graphics();
    this.sprite.addChild(this.selector);
    this.partLabel = new PartLabel();
    this.direction = 0;
    this.partClasses = [Hull, Thruster, Interior];
    this.partIndex = 0;
    this.nextPart(0);
  }

  BlueprintEditor.prototype.added = function() {
    return this.game.addEntity(this.partLabel);
  };

  BlueprintEditor.prototype.getHoverSquare = function() {
    return this.game.camera.toWorld(this.game.io.mousePosition).map(Math.round);
  };

  BlueprintEditor.prototype.render = function() {
    var angle, canAdd, color, hoverPart, squrePos;
    this.selector.clear();
    squrePos = this.getHoverSquare();
    hoverPart = this.blueprint.partGrid.get(squrePos);
    if (hoverPart == null) {
      this.selector.beginFill(this.Part.type.color);
      this.selector.drawRect(-0.5, -0.5, 1, 1);
      this.selector.endFill();
    }
    canAdd = !hoverPart;
    if (hoverPart != null) {
      color = 0xFFFFFF;
    } else if (canAdd) {
      color = 0x33FF33;
    } else {
      color = 0xFF3333;
    }
    this.selector.lineStyle(0.05, color);
    this.selector.drawRect(-1, -1, 1, 1);
    if (this.Part.type.directional) {
      this.selector.lineStyle(0.05, 0xFFFFFF, 0.5);
      this.selector.moveTo(-0.5, -0.5);
      angle = (this.direction + 3) * Math.PI / 2;
      this.selector.lineTo(Math.cos(angle) * 0.5 - 0.5, Math.sin(angle) * 0.5 - 0.5);
    }
    if (game.io.buttons[0]) {
      this.onClick();
    }
    if (game.io.buttons[2]) {
      this.onRightClick();
    }
    return this.selector.x = squrePos[0], this.selector.y = squrePos[1], squrePos;
  };

  BlueprintEditor.prototype.onClick = function(mousePosition) {
    var args, part, ref, x, y;
    ref = this.getHoverSquare(), x = ref[0], y = ref[1];
    if (this.blueprint.partGrid.get([x, y]) == null) {
      args = [x, y];
      if (this.Part.type.directional) {
        args.push(this.direction);
      }
      part = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this.Part, args, function(){});
      return this.blueprint.addPart(part);
    }
  };

  BlueprintEditor.prototype.onRightClick = function(mousePosition) {
    var part;
    part = this.blueprint.partGrid.get(this.getHoverSquare());
    if ((part != null) && part.type !== Core.type) {
      return this.blueprint.removePart(part);
    }
  };

  BlueprintEditor.prototype.nextPart = function(i) {
    if (i == null) {
      i = 1;
    }
    this.partIndex = Util.mod(this.partIndex + i, this.partClasses.length);
    this.Part = this.partClasses[this.partIndex];
    return this.partLabel.sprite.text = this.Part.type.name;
  };

  BlueprintEditor.prototype.rotate = function(i) {
    if (i == null) {
      i = 1;
    }
    return this.direction = Util.mod(this.direction + i, 4);
  };

  BlueprintEditor.prototype.onKeyDown = function(key) {
    switch (key) {
      case K_CLOSE:
        return this.destroy();
      case K_NEXT_PART:
        return this.nextPart(1);
      case K_PREVIOUS_PART:
        return this.nextPart(-1);
      case K_ROTATE_LEFT:
        return this.rotate(-1);
      case K_ROTATE_RIGHT:
        return this.rotate(1);
    }
  };

  BlueprintEditor.prototype.destroyed = function() {
    this.partLabel.destroy();
    if (this.onclose != null) {
      return this.onclose(this.blueprint);
    }
  };

  return BlueprintEditor;

})(Entity);

module.exports = BlueprintEditor;



},{"Entity":"/Users/tyemilldeveloper/space-game/src/Entity.coffee","IO":"/Users/tyemilldeveloper/space-game/src/IO.coffee","pixi.js":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/index.js","ship/Core":"/Users/tyemilldeveloper/space-game/src/ship/Core.coffee","ship/Hull":"/Users/tyemilldeveloper/space-game/src/ship/Hull.coffee","ship/Interior":"/Users/tyemilldeveloper/space-game/src/ship/Interior.coffee","ship/Thruster":"/Users/tyemilldeveloper/space-game/src/ship/Thruster.coffee","util/Util":"/Users/tyemilldeveloper/space-game/src/util/Util.coffee"}],"/Users/tyemilldeveloper/space-game/src/Camera.coffee":[function(require,module,exports){
var Camera, Matrix, Pixi, Point,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Pixi = require('pixi.js');

Matrix = Pixi.Matrix;

Point = Pixi.Point;

Camera = (function() {
  function Camera(renderer, x1, y1, z, angle) {
    this.renderer = renderer;
    this.x = x1 != null ? x1 : 0;
    this.y = y1 != null ? y1 : 0;
    this.z = z != null ? z : 30.0;
    this.angle = angle != null ? angle : 0;
    this.updateLayer = bind(this.updateLayer, this);
    this.getMatrix = bind(this.getMatrix, this);
    this.toScreen = bind(this.toScreen, this);
    this.toWorld = bind(this.toWorld, this);
    this.getViewportSize = bind(this.getViewportSize, this);
    this.tick = bind(this.tick, this);
    this.follow = bind(this.follow, this);
    this.following = null;
  }

  Camera.prototype.follow = function(thing) {
    return this.following = thing;
  };

  Camera.prototype.tick = function() {
    var ref;
    if (this.following != null) {
      return ref = this.following.position, this.x = ref[0], this.y = ref[1], ref;
    }
  };

  Camera.prototype.getViewportSize = function() {
    return [this.renderer.pixiRenderer.width, this.renderer.pixiRenderer.height];
  };

  Camera.prototype.toWorld = function(arg, depth) {
    var h, p, ref, w, x, y;
    x = arg[0], y = arg[1];
    if (depth == null) {
      depth = 1.0;
    }
    ref = this.getViewportSize(), w = ref[0], h = ref[1];
    p = new Point(x, y);
    p = this.getMatrix(depth).applyInverse(p, p);
    return [p.x, p.y];
  };

  Camera.prototype.toScreen = function(arg, depth) {
    var h, p, ref, w, x, y;
    x = arg[0], y = arg[1];
    if (depth == null) {
      depth = 1.0;
    }
    ref = this.getViewportSize(), w = ref[0], h = ref[1];
    p = new Point(x, y);
    p = this.getMatrix(depth).apply(p, p);
    return [p.x, p.y];
  };

  Camera.prototype.getMatrix = function(depth) {
    var h, m, ref, w;
    if (depth == null) {
      depth = 1.0;
    }
    ref = this.getViewportSize(), w = ref[0], h = ref[1];
    m = new Matrix();
    m.translate(-this.x * depth, -this.y * depth);
    m.scale(this.z * depth, this.z * depth);
    m.rotate(this.angle);
    m.translate(w / 2, h / 2);
    return m;
  };

  Camera.prototype.updateLayer = function(layerInfo) {
    var h, layer, ref, ref1, scroll, w;
    scroll = layerInfo.scroll;
    if (scroll !== 0) {
      layer = layerInfo.layer;
      ref = this.getViewportSize(), w = ref[0], h = ref[1];
      ref1 = this.toScreen([0, 0]), layer.x = ref1[0], layer.y = ref1[1];
      layer.rotation = this.angle;
      return layer.scale.set(this.z, this.z);
    }
  };

  return Camera;

})();

module.exports = Camera;



},{"pixi.js":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/index.js"}],"/Users/tyemilldeveloper/space-game/src/CollisionGroups.coffee":[function(require,module,exports){
var CollisionGroups, group,
  slice = [].slice;

group = function() {
  var groups, i, j, len, mask;
  groups = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  mask = 0;
  for (j = 0, len = groups.length; j < len; j++) {
    i = groups[j];
    mask |= Math.pow(2, i);
  }
  console.log("mask: " + mask + " for groups " + groups);
  return mask;
};

CollisionGroups = (function() {
  function CollisionGroups() {}

  CollisionGroups.SHIP_EXTERIOR = group(0);

  CollisionGroups.SHIP_INTERIOR = group(1);

  CollisionGroups.PERSON = group(2);

  CollisionGroups.ALL = group.apply(null, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);

  CollisionGroups.OBSTACLES = CollisionGroups.ALL ^ CollisionGroups.SHIP_INTERIOR;

  return CollisionGroups;

})();

console.log(CollisionGroups.OBSTACLES);

module.exports = CollisionGroups;



},{}],"/Users/tyemilldeveloper/space-game/src/Entity.coffee":[function(require,module,exports){
var Entity,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Entity = (function() {
  function Entity() {
    this.destroy = bind(this.destroy, this);
  }

  Entity.prototype.destroy = function() {
    return this.game.removeEntity(this);
  };


  /* OPTIONAL PARAMETERS */

  return Entity;

})();

module.exports = Entity;



},{}],"/Users/tyemilldeveloper/space-game/src/Game.coffee":[function(require,module,exports){
var Game, GameRenderer, IO, p2,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

GameRenderer = require('GameRenderer');

IO = require('IO');

p2 = require('p2');

Game = (function() {
  function Game() {
    this.render = bind(this.render, this);
    this.afterTick = bind(this.afterTick, this);
    this.tick = bind(this.tick, this);
    this.cleanupEntities = bind(this.cleanupEntities, this);
    this.removeEntity = bind(this.removeEntity, this);
    this.addEntity = bind(this.addEntity, this);
    this.loop = bind(this.loop, this);
    this.start = bind(this.start, this);
    this.entities = {
      all: [],
      render: [],
      tick: [],
      beforeTick: [],
      afterTick: [],
      toRemove: []
    };
    this.renderer = new GameRenderer();
    this.camera = this.renderer.camera;
    this.world = new p2.World({
      gravity: [0, 0]
    });
    this.io = new IO(this.renderer.pixiRenderer.view);
  }

  Game.prototype.start = function() {
    console.log("Game Started");
    return window.requestAnimationFrame(this.loop);
  };

  Game.prototype.loop = function() {
    window.requestAnimationFrame(this.loop);
    this.tick();
    this.world.step(1 / 60);
    this.render();
    this.renderer.render();
    return this.afterTick();
  };

  Game.prototype.addEntity = function(entity) {
    entity.game = this;
    if (entity.added != null) {
      entity.added(this);
    }
    this.entities.all.push(entity);
    if (entity.render != null) {
      this.entities.render.push(entity);
    }
    if (entity.beforeTick != null) {
      this.entities.beforeTick.push(entity);
    }
    if (entity.tick != null) {
      this.entities.tick.push(entity);
    }
    if (entity.afterTick != null) {
      this.entities.afterTick.push(entity);
    }
    if (entity.sprite != null) {
      this.renderer.add(entity.sprite, entity.layer);
    }
    if (entity.body != null) {
      this.world.addBody(entity.body);
    }
    if (entity.onClick != null) {
      this.io.on(IO.CLICK, entity.onClick);
    }
    if (entity.onMouseDown != null) {
      this.io.on(IO.MOUSE_DOWN, entity.onMouseDown);
    }
    if (entity.onMouseUp != null) {
      this.io.on(IO.MOUSE_UP, entity.onMouseUp);
    }
    if (entity.onRightClick != null) {
      this.io.on(IO.RIGHT_CLICK, entity.onRightClick);
    }
    if (entity.onRightDown != null) {
      this.io.on(IO.RIGHT_DOWN, entity.onRightDown);
    }
    if (entity.onRightUp != null) {
      this.io.on(IO.RIGHT_UP, entity.onRightUp);
    }
    if (entity.onKeyDown != null) {
      this.io.on(IO.KEY_DOWN, entity.onKeyDown);
    }
    if (entity.afterAdded != null) {
      return entity.afterAdded(this);
    }
  };

  Game.prototype.removeEntity = function(entity) {
    return this.entities.toRemove.push(entity);
  };

  Game.prototype.cleanupEntities = function() {
    var entity, results;
    results = [];
    while (this.entities.toRemove.length) {
      entity = this.entities.toRemove.pop();
      this.entities.all.splice(this.entities.all.indexOf(entity), 1);
      if (entity.render != null) {
        this.entities.render.splice(this.entities.render.indexOf(entity), 1);
      }
      if (entity.tick != null) {
        this.entities.tick.splice(this.entities.tick.indexOf(entity), 1);
      }
      if (entity.afterTick != null) {
        this.entities.afterTick.splice(this.entities.afterTick.indexOf(entity), 1);
      }
      if (entity.sprite != null) {
        this.renderer.remove(entity.sprite, entity.layer);
      }
      if (entity.body != null) {
        this.world.removeBody(entity.body);
      }
      if (entity.onClick != null) {
        this.io.off(IO.CLICK, entity.onClick);
      }
      if (entity.onMouseDown != null) {
        this.io.off(IO.MOUSE_DOWN, entity.onMouseDown);
      }
      if (entity.onMouseUp != null) {
        this.io.off(IO.MOUSE_UP, entity.onMouseUp);
      }
      if (entity.onRightClick != null) {
        this.io.off(IO.RIGHT_CLICK, entity.onRightClick);
      }
      if (entity.onRightDown != null) {
        this.io.off(IO.RIGHT_DOWN, entity.onRightDown);
      }
      if (entity.onRightUp != null) {
        this.io.off(IO.RIGHT_UP, entity.onRightUp);
      }
      if (entity.onKeyDown != null) {
        this.io.off(IO.KEY_DOWN, entity.onKeyDown);
      }
      if (entity.destroyed != null) {
        entity.destroyed(this);
      }
      results.push(entity.game = null);
    }
    return results;
  };

  Game.prototype.tick = function() {
    var entity, i, j, len, len1, ref, ref1, results;
    this.cleanupEntities();
    ref = this.entities.beforeTick;
    for (i = 0, len = ref.length; i < len; i++) {
      entity = ref[i];
      entity.beforeTick();
    }
    this.cleanupEntities();
    ref1 = this.entities.tick;
    results = [];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      entity = ref1[j];
      results.push(entity.tick());
    }
    return results;
  };

  Game.prototype.afterTick = function() {
    var entity, i, len, ref, results;
    this.cleanupEntities();
    ref = this.entities.afterTick;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      entity = ref[i];
      results.push(entity.afterTick());
    }
    return results;
  };

  Game.prototype.render = function() {
    var entity, i, len, ref, results;
    this.cleanupEntities();
    ref = this.entities.render;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      entity = ref[i];
      results.push(entity.render());
    }
    return results;
  };

  return Game;

})();

module.exports = Game;



},{"GameRenderer":"/Users/tyemilldeveloper/space-game/src/GameRenderer.coffee","IO":"/Users/tyemilldeveloper/space-game/src/IO.coffee","p2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/p2.js"}],"/Users/tyemilldeveloper/space-game/src/GameRenderer.coffee":[function(require,module,exports){
var Camera, GameRenderer, Pixi,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Pixi = require('pixi.js');

Camera = require('Camera');

GameRenderer = (function() {
  function GameRenderer() {
    this.remove = bind(this.remove, this);
    this.add = bind(this.add, this);
    this.render = bind(this.render, this);
    var h, i, j, layer, layerInfo, len, name, order, ref, w;
    ref = [window.innerWidth, window.innerHeight], w = ref[0], h = ref[1];
    this.pixiRenderer = Pixi.autoDetectRenderer(w, h, {
      antialias: false
    });
    document.body.appendChild(this.pixiRenderer.view);
    this.stage = new Pixi.Container();
    this.camera = new Camera(this);
    this.layerInfos = {};
    this.layerInfos['menu'] = {
      scroll: 0
    };
    this.layerInfos['hud'] = {
      scroll: 0
    };
    this.layerInfos['world_overlay'] = {
      scroll: 1
    };
    this.layerInfos['world_front'] = {
      scroll: 1
    };
    this.layerInfos['world'] = {
      scroll: 1
    };
    this.layerInfos['world_back'] = {
      scroll: 1
    };
    order = ['menu', 'hud', 'world_overlay', 'world_front', 'world', 'world_back'];
    for (i = j = 0, len = order.length; j < len; i = ++j) {
      name = order[i];
      layerInfo = this.layerInfos[name];
      layerInfo.name = name;
      layer = new Pixi.Container();
      layerInfo.index = i;
      layerInfo.layer = layer;
      this.stage.addChildAt(layer, i);
    }
  }

  GameRenderer.prototype.render = function(engine) {
    var info, name, ref;
    this.camera.tick();
    ref = this.layerInfos;
    for (name in ref) {
      info = ref[name];
      this.camera.updateLayer(info);
    }
    return this.pixiRenderer.render(this.stage);
  };

  GameRenderer.prototype.add = function(sprite, layer) {
    if (layer == null) {
      layer = 'world';
    }
    return this.layerInfos[layer.toLowerCase()].layer.addChild(sprite);
  };

  GameRenderer.prototype.remove = function(sprite, layer) {
    if (layer == null) {
      layer = 'world';
    }
    return this.layerInfos[layer.toLowerCase()].layer.removeChild(sprite);
  };

  return GameRenderer;

})();

module.exports = GameRenderer;



},{"Camera":"/Users/tyemilldeveloper/space-game/src/Camera.coffee","pixi.js":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/index.js"}],"/Users/tyemilldeveloper/space-game/src/IO.coffee":[function(require,module,exports){
var IO,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

IO = (function() {
  var CLICK, KEY_DOWN, KEY_UP, LMB, MMB, MOUSE_DOWN, MOUSE_MOVE, MOUSE_UP, RIGHT_CLICK, RIGHT_DOWN, RIGHT_UP, RMB;

  IO.LMB = LMB = 0;

  IO.RMB = RMB = 2;

  IO.MMB = MMB = 1;

  IO.ESCAPE = 27;

  IO.SPACE = 32;

  IO.MOUSE_MOVE = MOUSE_MOVE = 'mousemove';

  IO.CLICK = CLICK = 'click';

  IO.RIGHT_CLICK = RIGHT_CLICK = 'rightclick';

  IO.RIGHT_UP = RIGHT_UP = 'rightup';

  IO.RIGHT_DOWN = RIGHT_DOWN = 'rightdown';

  IO.MOUSE_UP = MOUSE_UP = 'mouseup';

  IO.MOUSE_DOWN = MOUSE_DOWN = 'mousedown';

  IO.MOUSE_MOVE = MOUSE_MOVE = 'mousemove';

  IO.KEY_DOWN = KEY_DOWN = 'keydown';

  IO.KEY_UP = KEY_UP = 'keyup';

  function IO(view) {
    var i, j;
    this.view = view;
    this.keyup = bind(this.keyup, this);
    this.keydown = bind(this.keydown, this);
    this.mouseup = bind(this.mouseup, this);
    this.mousedown = bind(this.mousedown, this);
    this.click = bind(this.click, this);
    this.mousemove = bind(this.mousemove, this);
    this.off = bind(this.off, this);
    this.on = bind(this.on, this);
    this.view.onclick = this.click;
    this.view.onmousedown = this.mousedown;
    this.view.onmouseup = this.mouseup;
    this.view.onmousemove = this.mousemove;
    this.view.onmousemove = this.mousemove;
    document.onkeydown = this.keydown;
    document.onkeyup = this.keyup;
    this.view.oncontextmenu = (function(_this) {
      return function(e) {
        e.preventDefault();
        _this.click(e);
        return false;
      };
    })(this);
    this.keys = [];
    for (i = j = 0; j <= 256; i = ++j) {
      this.keys.push(false);
    }
    this.mousePosition = [0, 0];
    this.callbacks = {};
    this.callbacks[CLICK] = [];
    this.callbacks[RIGHT_CLICK] = [];
    this.callbacks[RIGHT_UP] = [];
    this.callbacks[RIGHT_DOWN] = [];
    this.callbacks[MOUSE_UP] = [];
    this.callbacks[MOUSE_DOWN] = [];
    this.callbacks[MOUSE_MOVE] = [];
    this.callbacks[KEY_DOWN] = [];
    this.callbacks[KEY_UP] = [];
    this.buttons = [false, false, false, false, false, false];
  }

  IO.prototype.on = function(e, callback) {
    var base;
    if ((base = this.callbacks)[e] == null) {
      base[e] = [];
    }
    return this.callbacks[e].push(callback);
  };

  IO.prototype.off = function(e, callback) {
    return this.callbacks[e].splice(this.callbacks[e].indexOf(callback), 1);
  };

  IO.prototype.mousemove = function(e) {
    var callback, j, len, ref, results;
    this.mousePosition = [e.clientX, e.clientY];
    ref = this.callbacks[MOUSE_MOVE];
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      callback = ref[j];
      results.push(callback(this.mousePosition));
    }
    return results;
  };

  IO.prototype.click = function(e) {
    var callback, j, k, len, len1, ref, ref1, results, results1;
    this.mousePosition = [e.clientX, e.clientY];
    switch (e.button) {
      case LMB:
        ref = this.callbacks[CLICK];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          callback = ref[j];
          results.push(callback(this.mousePosition));
        }
        return results;
        break;
      case RMB:
        ref1 = this.callbacks[RIGHT_CLICK];
        results1 = [];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          callback = ref1[k];
          results1.push(callback(this.mousePosition));
        }
        return results1;
    }
  };

  IO.prototype.mousedown = function(e) {
    var callback, j, k, len, len1, ref, ref1, results, results1;
    this.mousePosition = [e.clientX, e.clientY];
    this.buttons[e.button] = true;
    switch (e.button) {
      case LMB:
        ref = this.callbacks[MOUSE_UP];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          callback = ref[j];
          results.push(callback(this.mousePosition));
        }
        return results;
        break;
      case RMB:
        ref1 = this.callbacks[RIGHT_UP];
        results1 = [];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          callback = ref1[k];
          results1.push(callback(this.mousePosition));
        }
        return results1;
    }
  };

  IO.prototype.mouseup = function(e) {
    var callback, j, k, len, len1, ref, ref1, results, results1;
    this.mousePosition = [e.clientX, e.clientY];
    this.buttons[e.button] = false;
    switch (e.button) {
      case LMB:
        ref = this.callbacks[MOUSE_DOWN];
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          callback = ref[j];
          results.push(callback(this.mousePosition));
        }
        return results;
        break;
      case RMB:
        ref1 = this.callbacks[RIGHT_DOWN];
        results1 = [];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          callback = ref1[k];
          results1.push(callback(this.mousePosition));
        }
        return results1;
    }
  };

  IO.prototype.keydown = function(e) {
    var callback, j, key, len, ref, results, wasPressed;
    key = e.which;
    wasPressed = this.keys[key];
    this.keys[key] = true;
    if (!wasPressed) {
      ref = this.callbacks[KEY_DOWN];
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        callback = ref[j];
        results.push(callback(key));
      }
      return results;
    }
  };

  IO.prototype.keyup = function(e) {
    var callback, j, key, len, ref, results;
    key = e.which;
    this.keys[key] = false;
    ref = this.callbacks[KEY_UP];
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      callback = ref[j];
      results.push(callback(key));
    }
    return results;
  };

  return IO;

})();

module.exports = IO;



},{}],"/Users/tyemilldeveloper/space-game/src/Person.coffee":[function(require,module,exports){
var CollisionGroups, Entity, Person, Pixi, p2,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CollisionGroups = require('CollisionGroups');

Entity = require('Entity');

p2 = require('p2');

Pixi = require('pixi.js');

Person = (function(superClass) {
  var JETPACK_FORCE, MAXIMUM_FRICTION, RADIUS, WALK_FORCE;

  extend(Person, superClass);

  RADIUS = 0.1;

  WALK_FORCE = 5;

  JETPACK_FORCE = 0.3;

  MAXIMUM_FRICTION = 10;

  function Person(x, y, ship) {
    var shape;
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    if (ship == null) {
      ship = null;
    }
    this.tick = bind(this.tick, this);
    this.render = bind(this.render, this);
    this.move = bind(this.move, this);
    this.board = bind(this.board, this);
    this.body = new p2.Body({
      position: [x, y],
      mass: 0.1,
      angularDamping: 0.01,
      damping: 0
    });
    shape = new p2.Circle(RADIUS);
    shape.collisionGroup = CollisionGroups.PERSON;
    shape.collisionMask = CollisionGroups.OBSTACLES;
    this.body.addShape(shape);
    this.sprite = new Pixi.Graphics();
    this.sprite.beginFill(0x00FF00);
    this.sprite.drawCircle(0, 0, RADIUS);
    this.sprite.endFill();
    this.board(ship);
  }

  Person.property('position', {
    get: function() {
      return this.body.position;
    }
  });

  Person.prototype.board = function(ship) {
    this.ship = ship;
    if (ship != null) {
      return this.shipPosition = this.ship.worldToLocal(this.body.position);
    } else {
      return this.shipPosition = null;
    }
  };

  Person.prototype.move = function(arg) {
    var speed, x, y;
    x = arg[0], y = arg[1];
    speed = this.ship != null ? WALK_FORCE : JETPACK_FORCE;
    this.body.force[0] += x * speed;
    return this.body.force[1] += y * speed;
  };

  Person.prototype.render = function() {
    var ref;
    return ref = this.body.position, this.sprite.x = ref[0], this.sprite.y = ref[1], ref;
  };

  Person.prototype.tick = function() {
    var dx, dy, magnitude, shipVelocity;
    if (this.ship != null) {
      shipVelocity = this.ship.velocityAtWorldPoint(this.position);
      dx = shipVelocity[0] - this.body.velocity[0];
      dy = shipVelocity[1] - this.body.velocity[1];
      dx *= 0.5;
      dy *= 0.5;
      magnitude = Math.sqrt(dx * dx + dy * dy);
      if (magnitude > MAXIMUM_FRICTION) {
        dx *= MAXIMUM_FRICTION / magnitude;
        dy *= MAXIMUM_FRICTION / magnitude;
      }
      this.body.force[0] += dx / this.body.mass;
      return this.body.force[1] += dy / this.body.mass;
    }
  };

  return Person;

})(Entity);

module.exports = Person;



},{"CollisionGroups":"/Users/tyemilldeveloper/space-game/src/CollisionGroups.coffee","Entity":"/Users/tyemilldeveloper/space-game/src/Entity.coffee","p2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/p2.js","pixi.js":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/index.js"}],"/Users/tyemilldeveloper/space-game/src/PlayerPersonController.coffee":[function(require,module,exports){
var Entity, PlayerPersonController,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Entity = require('Entity');

PlayerPersonController = (function(superClass) {
  var K_BACKWARD, K_FORWARD, K_LEFT, K_RIGHT, K_WALK;

  extend(PlayerPersonController, superClass);

  K_FORWARD = 87;

  K_BACKWARD = 83;

  K_LEFT = 65;

  K_RIGHT = 68;

  K_WALK = 16;

  function PlayerPersonController(person) {
    this.person = person;
    this.beforeTick = bind(this.beforeTick, this);
  }

  PlayerPersonController.prototype.beforeTick = function() {
    var modifier, x, y;
    modifier = this.game.io.keys[K_WALK] ? 0.4 : 1;
    x = (this.game.io.keys[K_RIGHT] - this.game.io.keys[K_LEFT]) * modifier;
    y = -(this.game.io.keys[K_FORWARD] - this.game.io.keys[K_BACKWARD]) * modifier;
    return this.person.move([x, y]);
  };

  return PlayerPersonController;

})(Entity);

module.exports = PlayerPersonController;



},{"Entity":"/Users/tyemilldeveloper/space-game/src/Entity.coffee"}],"/Users/tyemilldeveloper/space-game/src/PlayerShipController.coffee":[function(require,module,exports){
var Entity, PlayerShipController, Util, normalize,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Entity = require('Entity');

Util = require('util/Util');

normalize = function(value) {
  var epsilon;
  epsilon = 0.05;
  if (value > epsilon) {
    return value - epsilon;
  }
  if (value < -1 * epsilon) {
    return value + epsilon;
  }
  return 0;
};

PlayerShipController = (function(superClass) {
  var K_BACKWARD, K_FORWARD, K_LEFT, K_RIGHT, K_STABILIZE, K_TURN_LEFT, K_TURN_RIGHT;

  extend(PlayerShipController, superClass);

  K_FORWARD = 87;

  K_BACKWARD = 83;

  K_LEFT = 65;

  K_RIGHT = 68;

  K_TURN_LEFT = 81;

  K_TURN_RIGHT = 69;

  K_STABILIZE = 16;

  function PlayerShipController(ship) {
    this.ship = ship;
    this.beforeTick = bind(this.beforeTick, this);
  }

  PlayerShipController.prototype.beforeTick = function() {
    var forward, side, turn;
    forward = this.game.io.keys[K_FORWARD] - this.game.io.keys[K_BACKWARD];
    side = this.game.io.keys[K_RIGHT] - this.game.io.keys[K_LEFT];
    turn = this.game.io.keys[K_TURN_RIGHT] - this.game.io.keys[K_TURN_LEFT];
    if (this.game.io.keys[K_STABILIZE]) {
      turn += Util.clamp(-this.ship.body.angularVelocity * 2);
    }
    forward = Util.clamp(forward);
    side = Util.clamp(side);
    turn = Util.clamp(turn);
    return this.ship.thrustBalancer.balance(forward, side, turn);
  };

  return PlayerShipController;

})(Entity);

module.exports = PlayerShipController;



},{"Entity":"/Users/tyemilldeveloper/space-game/src/Entity.coffee","util/Util":"/Users/tyemilldeveloper/space-game/src/util/Util.coffee"}],"/Users/tyemilldeveloper/space-game/src/ShipHud.coffee":[function(require,module,exports){
var Entity, Pixi, ShipHud,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Entity = require('Entity');

Pixi = require('pixi.js');

ShipHud = (function(superClass) {
  extend(ShipHud, superClass);

  function ShipHud(ship) {
    this.ship = ship;
    this.render = bind(this.render, this);
    this.makeText = bind(this.makeText, this);
    this.added = bind(this.added, this);
    this.sprite = new Pixi.Container();
    this.layer = 'hud';
    this.text = new Pixi.Text('', {
      font: '20px Arial',
      fill: '#FFFFFF'
    });
    this.sprite.addChild(this.text);
  }

  ShipHud.prototype.added = function() {
    return console.log('added');
  };

  ShipHud.prototype.makeText = function() {
    var velocity, xspeed, yspeed;
    velocity = this.ship.body.velocity;
    xspeed = Math.round(velocity[0]);
    yspeed = Math.round(velocity[1]);
    return "Velocity: <" + xspeed + ", " + yspeed + ">";
  };

  ShipHud.prototype.render = function() {
    return this.text.text = this.makeText();
  };

  return ShipHud;

})(Entity);

module.exports = ShipHud;



},{"Entity":"/Users/tyemilldeveloper/space-game/src/Entity.coffee","pixi.js":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/index.js"}],"/Users/tyemilldeveloper/space-game/src/ship/Blueprint.coffee":[function(require,module,exports){
var Blueprint, Core, Entity, Grid, Pixi,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Core = require('ship/Core');

Entity = require('Entity');

Grid = require('util/Grid');

Pixi = require('pixi.js');

Blueprint = (function(superClass) {
  var BASE_MASS;

  extend(Blueprint, superClass);

  BASE_MASS = 0.1;

  function Blueprint(x, y) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    this.removePart = bind(this.removePart, this);
    this.addPart = bind(this.addPart, this);
    this.sprite = new Pixi.Graphics();
    this.layer = 'world';
    this.parts = [];
    this.partGrid = new Grid();
    this.core = this.addPart(new Core());
  }

  Blueprint.prototype.addPart = function(part) {
    var angle;
    this.parts.push(part);
    angle = part.direction != null ? Math.PI / 2 * part.direction : 0;
    if (part.sprite != null) {
      this.sprite.addChild(part.sprite);
    }
    this.partGrid.set([part.x, part.y], part);
    return part;
  };

  Blueprint.prototype.removePart = function(part) {
    this.parts.splice(this.parts.indexOf(part), 1);
    if (part.sprite != null) {
      this.sprite.removeChild(part.sprite);
    }
    this.partGrid.remove([part.x, part.y]);
    return part;
  };

  return Blueprint;

})(Entity);

module.exports = Blueprint;



},{"Entity":"/Users/tyemilldeveloper/space-game/src/Entity.coffee","pixi.js":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/index.js","ship/Core":"/Users/tyemilldeveloper/space-game/src/ship/Core.coffee","util/Grid":"/Users/tyemilldeveloper/space-game/src/util/Grid.coffee"}],"/Users/tyemilldeveloper/space-game/src/ship/Core.coffee":[function(require,module,exports){
var Core, Part,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Part = require('ship/Part');

Core = (function(superClass) {
  var type;

  extend(Core, superClass);

  Core.type = type = new Part.Type('Core', 1, 1, 0x55AAFF, 1000);

  function Core(x, y) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    this.clone = bind(this.clone, this);
    Core.__super__.constructor.call(this, x, y, type);
  }

  Core.prototype.clone = function() {
    return new Core(this.x, this.y);
  };

  return Core;

})(Part);

module.exports = Core;



},{"ship/Part":"/Users/tyemilldeveloper/space-game/src/ship/Part.coffee"}],"/Users/tyemilldeveloper/space-game/src/ship/Hull.coffee":[function(require,module,exports){
var Hull, Part,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Part = require('ship/Part');

Hull = (function(superClass) {
  var type;

  extend(Hull, superClass);

  Hull.type = type = new Part.Type('Hull', 1, 1, 0xBBBBBB, 300);

  function Hull(x, y) {
    this.clone = bind(this.clone, this);
    Hull.__super__.constructor.call(this, x, y, type);
  }

  Hull.prototype.clone = function() {
    return new Hull(this.x, this.y);
  };

  return Hull;

})(Part);

module.exports = Hull;



},{"ship/Part":"/Users/tyemilldeveloper/space-game/src/ship/Part.coffee"}],"/Users/tyemilldeveloper/space-game/src/ship/Interior.coffee":[function(require,module,exports){
var Interior, Part,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Part = require("ship/Part");

Interior = (function(superClass) {
  var type;

  extend(Interior, superClass);

  Interior.type = type = new Part.Type('Interior', 1, 1, 0xDDDDDD, 80);

  type.interior = true;

  function Interior(x, y) {
    this.clone = bind(this.clone, this);
    Interior.__super__.constructor.call(this, x, y, type);
  }

  Interior.prototype.clone = function() {
    return new Interior(this.x, this.y);
  };

  return Interior;

})(Part);

module.exports = Interior;



},{"ship/Part":"/Users/tyemilldeveloper/space-game/src/ship/Part.coffee"}],"/Users/tyemilldeveloper/space-game/src/ship/Part.coffee":[function(require,module,exports){
var CollisionGroups, Part, Pixi, p2,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

p2 = require('p2');

Pixi = require('pixi.js');

CollisionGroups = require('CollisionGroups');

Part = (function() {
  function Part(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.toString = bind(this.toString, this);
    this.clone = bind(this.clone, this);
    this.makeSprite = bind(this.makeSprite, this);
    this.makeShape = bind(this.makeShape, this);
    this.shape = this.makeShape();
    this.shape.owner = this;
    this.sprite = this.makeSprite();
    this.sprite.x = this.x;
    this.sprite.y = this.y;
    this.health = this.maxHealth;
  }

  ['mass', 'width', 'height', 'maxHealth'].forEach(function(field) {
    return Part.property(field, {
      get: function() {
        return this.type[field];
      }
    });
  });

  Part.prototype.makeShape = function() {
    var shape;
    shape = new p2.Rectangle(this.width, this.height);
    if (this.type.interior) {
      console.log("interior part");
      shape.collisionGroup = CollisionGroups.SHIP_INTERIOR;
    } else {
      console.log("exterior part");
      shape.collisionGroup = CollisionGroups.SHIP_EXTERIOR;
    }
    shape.collisionMask = CollisionGroups.ALL;
    return shape;
  };

  Part.prototype.makeSprite = function() {
    var sprite;
    sprite = new Pixi.Graphics();
    sprite.beginFill(this.type.color);
    sprite.drawRect(-0.5 * this.width, -0.5 * this.height, this.width, this.height);
    sprite.endFill();
    return sprite;
  };

  Part.prototype.clone = function() {
    return new Part(this.x, this.y, this.type);
  };

  Part.prototype.toString = function() {
    return "<" + this.type + " at (" + this.x + "," + this.y + ")>";
  };

  return Part;

})();

Part.Type = (function() {
  function Type(name, width, height, color, maxHealth) {
    this.name = name;
    this.width = width != null ? width : 1;
    this.height = height != null ? height : 1;
    this.color = color != null ? color : 0xBBBBBB;
    this.maxHealth = maxHealth != null ? maxHealth : 100;
    this.toString = bind(this.toString, this);
    this.mass = this.width * this.height;
  }

  Type.prototype.toString = function() {
    return this.name;
  };

  return Type;

})();

module.exports = Part;



},{"CollisionGroups":"/Users/tyemilldeveloper/space-game/src/CollisionGroups.coffee","p2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/p2.js","pixi.js":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/index.js"}],"/Users/tyemilldeveloper/space-game/src/ship/Ship.coffee":[function(require,module,exports){
var Blueprint, Entity, Hull, Pixi, Ship, ThrustBalancer, Thruster, Util, p2,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Blueprint = require('ship/Blueprint');

Entity = require('Entity');

Hull = require('ship/Hull');

p2 = require('p2');

Pixi = require('pixi.js');

ThrustBalancer = require('ship/ThrustBalancer');

Thruster = require('ship/Thruster');

Util = require('util/Util');

Ship = (function(superClass) {
  var BASE_MASS;

  extend(Ship, superClass);

  BASE_MASS = 0.1;

  function Ship(blueprint, x, y) {
    var i, len, part, ref;
    this.blueprint = blueprint;
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    this.velocityAtWorldPoint = bind(this.velocityAtWorldPoint, this);
    this.gridToWorld = bind(this.gridToWorld, this);
    this.worldToLocal = bind(this.worldToLocal, this);
    this.localToWorld = bind(this.localToWorld, this);
    this.gridToLocal = bind(this.gridToLocal, this);
    this.recenter = bind(this.recenter, this);
    this.removePart = bind(this.removePart, this);
    this.addPart = bind(this.addPart, this);
    this.tick = bind(this.tick, this);
    this.render = bind(this.render, this);
    if (this.blueprint == null) {
      this.blueprint = new Blueprint();
    }
    this.sprite = new Pixi.Graphics();
    this.layer = 'world';
    this.parts = [];
    this.tickableParts = [];
    this.thrustBalancer = new ThrustBalancer(this);
    this.offset = [0, 0];
    this.body = new p2.Body({
      position: [x, y],
      mass: BASE_MASS,
      angularDamping: 0.01,
      damping: 0.0
    });
    ref = this.blueprint.parts;
    for (i = 0, len = ref.length; i < len; i++) {
      part = ref[i];
      this.addPart(part.clone());
    }
  }

  Ship.property('position', {
    get: function() {
      return this.body.position;
    }
  });

  Ship.prototype.render = function() {
    var ref;
    this.sprite.clear();
    this.sprite.beginFill(0x00FFFF);
    this.sprite.drawCircle(-this.offset[0], -this.offset[1], 0.1);
    this.sprite.endFill();
    ref = this.gridToWorld([0, 0]), this.sprite.x = ref[0], this.sprite.y = ref[1];
    return this.sprite.rotation = this.body.angle;
  };

  Ship.prototype.tick = function() {
    var i, len, part, ref, results;
    ref = this.tickableParts;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      part = ref[i];
      results.push(part.tick(this));
    }
    return results;
  };

  Ship.prototype.addPart = function(part) {
    var angle, shapePosition;
    this.parts.push(part);
    if (part.tick != null) {
      this.tickableParts.push(part);
    }
    angle = part.direction != null ? Math.PI / 2 * part.direction : 0;
    if (part.sprite != null) {
      this.sprite.addChild(part.sprite);
      this.sprite.rotation = angle;
    }
    if (part.shape != null) {
      shapePosition = [part.x + this.offset[0], part.y + this.offset[1]];
      this.body.addShape(part.shape, shapePosition, angle);
      this.body.mass += part.mass;
      this.recenter();
    }
    if (part.type.thruster) {
      return this.thrustBalancer.addThruster(part);
    }
  };

  Ship.prototype.removePart = function(part) {
    this.parts.splice(this.parts.indexOf(part), 1);
    if (part.tick != null) {
      this.tickableParts.splice(this.tickableParts.indexOf(part), 1);
    }
    if (part.sprite != null) {
      this.sprite.removeChild(part.sprite);
    }
    if (part.shape != null) {
      this.body.removeShape(part.shape);
    }
    if (part.type.thruster) {
      this.thrustBalancer.removeThruster(part);
    }
    this.body.mass -= part.mass;
    return this.recenter();
  };

  Ship.prototype.recenter = function() {
    var before, beforeLocal, dx, dy;
    before = [this.body.position[0], this.body.position[1]];
    this.body.adjustCenterOfMass();
    dx = this.body.position[0] - before[0];
    dy = this.body.position[1] - before[1];
    beforeLocal = this.worldToLocal(before);
    this.offset[0] += beforeLocal[0];
    this.offset[1] += beforeLocal[1];
    return console.log("recentered: " + beforeLocal[0] + ", " + beforeLocal[1]);
  };

  Ship.prototype.gridToLocal = function(point) {
    return [point[0] + this.offset[0], point[1] + this.offset[1]];
  };

  Ship.prototype.localToWorld = function(point) {
    var world;
    world = [0, 0];
    this.body.toWorldFrame(world, point);
    return world;
  };

  Ship.prototype.worldToLocal = function(point) {
    var local;
    local = [0, 0];
    this.body.toLocalFrame(local, point);
    return local;
  };

  Ship.prototype.gridToWorld = function(point) {
    return this.localToWorld(this.gridToLocal(point));
  };

  Ship.prototype.velocityAtWorldPoint = function(point) {
    var r, ref, tangentialSpeed, theta, x, xl, xt, y, yl, yt;
    ref = this.body.velocity, xl = ref[0], yl = ref[1];
    x = point[0] - this.body.position[0];
    y = point[1] - this.body.position[1];
    theta = Math.atan2(y, x) + Math.PI / 2;
    r = Math.sqrt(x * x + y * y);
    tangentialSpeed = this.body.angularVelocity * r;
    xt = Math.cos(theta) * tangentialSpeed;
    yt = Math.sin(theta) * tangentialSpeed;
    return [xl + xt, yl + yt];
  };

  return Ship;

})(Entity);

module.exports = Ship;



},{"Entity":"/Users/tyemilldeveloper/space-game/src/Entity.coffee","p2":"/Users/tyemilldeveloper/space-game/node_modules/p2/src/p2.js","pixi.js":"/Users/tyemilldeveloper/space-game/node_modules/pixi.js/src/index.js","ship/Blueprint":"/Users/tyemilldeveloper/space-game/src/ship/Blueprint.coffee","ship/Hull":"/Users/tyemilldeveloper/space-game/src/ship/Hull.coffee","ship/ThrustBalancer":"/Users/tyemilldeveloper/space-game/src/ship/ThrustBalancer.coffee","ship/Thruster":"/Users/tyemilldeveloper/space-game/src/ship/Thruster.coffee","util/Util":"/Users/tyemilldeveloper/space-game/src/util/Util.coffee"}],"/Users/tyemilldeveloper/space-game/src/ship/ThrustBalancer.coffee":[function(require,module,exports){
var ThrustBalancer, Util,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Util = require('util/Util');

ThrustBalancer = (function() {
  function ThrustBalancer(ship) {
    this.ship = ship;
    this.balance = bind(this.balance, this);
    this.removeThruster = bind(this.removeThruster, this);
    this.addThruster = bind(this.addThruster, this);
    this.thrusters = [];
  }

  ThrustBalancer.prototype.addThruster = function(thruster) {
    console.log("thruster added");
    return this.thrusters.push(thruster);
  };

  ThrustBalancer.prototype.removeThruster = function(thruster) {
    return this.thrusters.splice(this.thrusters.indexOf(thruster), 1);
  };

  ThrustBalancer.prototype.balance = function(forward, side, turn) {
    var i, len, ref, results, throttle, thruster, x, y;
    if (forward == null) {
      forward = 0;
    }
    if (side == null) {
      side = 0;
    }
    if (turn == null) {
      turn = 0;
    }
    ref = this.thrusters;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      thruster = ref[i];
      throttle = 0;
      x = thruster.x - this.ship.offset[0];
      y = thruster.y - this.ship.offset[1];
      switch (thruster.direction) {
        case 0:
          if (forward > 0) {
            throttle += forward;
          }
          if (turn > 0 && x < 0) {
            throttle += turn;
          }
          if (turn < 0 && x > 0) {
            throttle += -turn;
          }
          break;
        case 1:
          if (side > 0) {
            throttle += side;
          }
          if (turn > 0 && y < 0) {
            throttle += turn;
          }
          if (turn < 0 && y > 0) {
            throttle += -turn;
          }
          break;
        case 2:
          if (forward < 0) {
            throttle += -forward;
          }
          if (turn > 0 && x > 0) {
            throttle += turn;
          }
          if (turn < 0 && x < 0) {
            throttle += -turn;
          }
          break;
        case 3:
          if (side < 0) {
            throttle += -side;
          }
          if (turn > 0 && y < 0) {
            throttle += turn;
          }
          if (turn < 0 && y > 0) {
            throttle += -turn;
          }
      }
      throttle = Util.clamp(throttle);
      results.push(thruster.setThrottle(throttle));
    }
    return results;
  };

  return ThrustBalancer;

})();

module.exports = ThrustBalancer;



},{"util/Util":"/Users/tyemilldeveloper/space-game/src/util/Util.coffee"}],"/Users/tyemilldeveloper/space-game/src/ship/Thruster.coffee":[function(require,module,exports){
var Part, Thruster, type,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Part = require('ship/Part');

type = new Part.Type('Thruster', 1, 1, 0x666666);

type.directional = true;

type.thruster = true;

Thruster = (function(superClass) {
  extend(Thruster, superClass);

  Thruster.type = type;

  function Thruster(x, y, direction) {
    this.direction = direction != null ? direction : 0;
    this.clone = bind(this.clone, this);
    this.tick = bind(this.tick, this);
    this.setThrottle = bind(this.setThrottle, this);
    this.makeSprite = bind(this.makeSprite, this);
    Thruster.__super__.constructor.call(this, x, y, type);
    this.throttle = 0;
    this.maxThrust = 200;
  }

  Thruster.prototype.makeSprite = function() {
    var sprite;
    sprite = Thruster.__super__.makeSprite.call(this);
    sprite.lineStyle(0.08, 0xFFAA00);
    sprite.moveTo(-1, -1);
    sprite.lineTo(0, -1);
    sprite.rotation = (this.direction + 2) * Math.PI / 2;
    return sprite;
  };

  Thruster.prototype.setThrottle = function(value) {
    return this.throttle = value;
  };

  Thruster.prototype.tick = function(ship) {
    var angle, force, power, world;
    world = ship.gridToWorld([this.x, this.y]);
    angle = ship.body.angle + (this.direction + 3) * Math.PI / 2;
    power = this.throttle * this.maxThrust;
    force = [Math.cos(angle) * power, Math.sin(angle) * power];
    return ship.body.applyForce(force, world);
  };

  Thruster.prototype.clone = function() {
    return new Thruster(this.x, this.y, this.direction);
  };

  return Thruster;

})(Part);

module.exports = Thruster;



},{"ship/Part":"/Users/tyemilldeveloper/space-game/src/ship/Part.coffee"}],"/Users/tyemilldeveloper/space-game/src/util/FPSCounter.coffee":[function(require,module,exports){
var Entity, FPSCounter,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Entity = require('Entity');

FPSCounter = (function(superClass) {
  extend(FPSCounter, superClass);

  function FPSCounter() {
    this.tick = bind(this.tick, this);
    this.frame = 0;
    this.lastTick = Date.now();
    this.fps = 60;
  }

  FPSCounter.prototype.tick = function() {
    var now;
    this.frame++;
    now = Date.now();
    this.fps = 0.9 * this.fps + 0.1 * (1000 / (now - this.lastTick));
    this.lastTick = now;
    if (this.frame % 60 === 0) {
      return console.log(Math.round(this.fps));
    }
  };

  return FPSCounter;

})(Entity);

module.exports = FPSCounter;



},{"Entity":"/Users/tyemilldeveloper/space-game/src/Entity.coffee"}],"/Users/tyemilldeveloper/space-game/src/util/Grid.coffee":[function(require,module,exports){
var Grid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Grid = (function() {
  function Grid() {
    this.remove = bind(this.remove, this);
    this.get = bind(this.get, this);
    this.set = bind(this.set, this);
    this.data = {};
  }

  Grid.prototype.set = function(arg, value) {
    var base, x, y;
    x = arg[0], y = arg[1];
    if ((base = this.data)[x] == null) {
      base[x] = {};
    }
    return this.data[x][y] = value;
  };

  Grid.prototype.get = function(arg) {
    var base, x, y;
    x = arg[0], y = arg[1];
    if ((base = this.data)[x] == null) {
      base[x] = {};
    }
    return this.data[x][y];
  };

  Grid.prototype.remove = function(arg) {
    var base, x, y;
    x = arg[0], y = arg[1];
    if ((base = this.data)[x] == null) {
      base[x] = {};
    }
    return delete this.data[x][y];
  };

  return Grid;

})();

module.exports = Grid;



},{}],"/Users/tyemilldeveloper/space-game/src/util/Util.coffee":[function(require,module,exports){
var Util;

Util = {
  mod: function(a, b) {
    return ((a % b) + b) % b;
  },
  clamp: function(value, min, max) {
    if (min == null) {
      min = -1;
    }
    if (max == null) {
      max = 1;
    }
    return Math.max(min, Math.min(max, value));
  }
};

module.exports = Util;



},{}]},{},["./src/main.coffee"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvdHllbWlsbGRldmVsb3Blci9zcGFjZS1nYW1lL3NyYy9tYWluLmNvZmZlZSIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3AyL25vZGVfbW9kdWxlcy9wb2x5LWRlY29tcC9zcmMvTGluZS5qcyIsIm5vZGVfbW9kdWxlcy9wMi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL1BvaW50LmpzIiwibm9kZV9tb2R1bGVzL3AyL25vZGVfbW9kdWxlcy9wb2x5LWRlY29tcC9zcmMvUG9seWdvbi5qcyIsIm5vZGVfbW9kdWxlcy9wMi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL1NjYWxhci5qcyIsIm5vZGVfbW9kdWxlcy9wMi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3AyL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvY29sbGlzaW9uL0FBQkIuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9Ccm9hZHBoYXNlLmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9jb2xsaXNpb24vR3JpZEJyb2FkcGhhc2UuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9OYXJyb3dwaGFzZS5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvY29sbGlzaW9uL1JheS5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvY29sbGlzaW9uL1JheWNhc3RSZXN1bHQuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlLmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9jb25zdHJhaW50cy9Db25zdHJhaW50LmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnQuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL2NvbnN0cmFpbnRzL0dlYXJDb25zdHJhaW50LmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9jb25zdHJhaW50cy9Mb2NrQ29uc3RyYWludC5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvY29uc3RyYWludHMvUHJpc21hdGljQ29uc3RyYWludC5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvY29uc3RyYWludHMvUmV2b2x1dGVDb25zdHJhaW50LmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9lcXVhdGlvbnMvQW5nbGVMb2NrRXF1YXRpb24uanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24uanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL2VxdWF0aW9ucy9FcXVhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24uanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9lcXVhdGlvbnMvUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24uanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL2V2ZW50cy9FdmVudEVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbC5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvbWF0ZXJpYWwvTWF0ZXJpYWwuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL21hdGgvcG9seWsuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL21hdGgvdmVjMi5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvb2JqZWN0cy9Cb2R5LmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9vYmplY3RzL0xpbmVhclNwcmluZy5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvb2JqZWN0cy9Sb3RhdGlvbmFsU3ByaW5nLmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9vYmplY3RzL1NwcmluZy5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvcDIuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9DYXBzdWxlLmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9zaGFwZXMvQ2lyY2xlLmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9zaGFwZXMvQ29udmV4LmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9zaGFwZXMvSGVpZ2h0ZmllbGQuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9MaW5lLmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9zaGFwZXMvUGFydGljbGUuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9QbGFuZS5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvc2hhcGVzL1JlY3RhbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvc2hhcGVzL1NoYXBlLmpzIiwibm9kZV9tb2R1bGVzL3AyL3NyYy9zb2x2ZXIvR1NTb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL3NvbHZlci9Tb2x2ZXIuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL092ZXJsYXBLZWVwZXIuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL1R1cGxlRGljdGlvbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvdXRpbHMvVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcDIvc3JjL3dvcmxkL0lzbGFuZC5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvd29ybGQvSXNsYW5kTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvd29ybGQvSXNsYW5kTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9wMi9zcmMvd29ybGQvV29ybGQuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvYXN5bmMvbGliL2FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9yZXNvdXJjZS1sb2FkZXIvc3JjL0xvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9yZXNvdXJjZS1sb2FkZXIvc3JjL1Jlc291cmNlLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL3Jlc291cmNlLWxvYWRlci9zcmMvYjY0LmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvbm9kZV9tb2R1bGVzL3Jlc291cmNlLWxvYWRlci9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9ub2RlX21vZHVsZXMvcmVzb3VyY2UtbG9hZGVyL3NyYy9taWRkbGV3YXJlcy9jYWNoaW5nL21lbW9yeS5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL25vZGVfbW9kdWxlcy9yZXNvdXJjZS1sb2FkZXIvc3JjL21pZGRsZXdhcmVzL3BhcnNpbmcvYmxvYi5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL2NvbnN0LmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvZGlzcGxheS9Db250YWluZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS9kaXNwbGF5L0Rpc3BsYXlPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS9ncmFwaGljcy9HcmFwaGljcy5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL2dyYXBoaWNzL0dyYXBoaWNzRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL2dyYXBoaWNzL3dlYmdsL0dyYXBoaWNzUmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS9ncmFwaGljcy93ZWJnbC9XZWJHTEdyYXBoaWNzRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvbWF0aC9NYXRyaXguanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS9tYXRoL1BvaW50LmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvbWF0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL21hdGgvc2hhcGVzL0NpcmNsZS5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL21hdGgvc2hhcGVzL0VsbGlwc2UuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS9tYXRoL3NoYXBlcy9Qb2x5Z29uLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvbWF0aC9zaGFwZXMvUmVjdGFuZ2xlLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvbWF0aC9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3BhcnRpY2xlcy9QYXJ0aWNsZUNvbnRhaW5lci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3BhcnRpY2xlcy93ZWJnbC9QYXJ0aWNsZUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3BhcnRpY2xlcy93ZWJnbC9QYXJ0aWNsZVJlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvcGFydGljbGVzL3dlYmdsL1BhcnRpY2xlU2hhZGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL1N5c3RlbVJlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy9DYW52YXNSZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy9jYW52YXMvdXRpbHMvQ2FudmFzQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNHcmFwaGljcy5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy9jYW52YXMvdXRpbHMvQ2FudmFzTWFza01hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc1RpbnRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9XZWJHTFJlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvQWJzdHJhY3RGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvZmlsdGVycy9GWEFBRmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvU3ByaXRlTWFza0ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9CbGVuZE1vZGVNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL21hbmFnZXJzL0ZpbHRlck1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvTWFza01hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvU2hhZGVyTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9TdGVuY2lsTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC9tYW5hZ2Vycy9XZWJHTE1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS9yZW5kZXJlcnMvd2ViZ2wvc2hhZGVycy9Db21wbGV4UHJpbWl0aXZlU2hhZGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3NoYWRlcnMvUHJpbWl0aXZlU2hhZGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3NoYWRlcnMvU2hhZGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3NoYWRlcnMvVGV4dHVyZVNoYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9PYmplY3RSZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9RdWFkLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1JlbmRlclRhcmdldC5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9TdGVuY2lsTWFza1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvc3ByaXRlcy9TcHJpdGUuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS9zcHJpdGVzL3dlYmdsL1Nwcml0ZVJlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvdGV4dC9UZXh0LmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvdGV4dHVyZXMvQmFzZVRleHR1cmUuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS90ZXh0dXJlcy9SZW5kZXJUZXh0dXJlLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvdGV4dHVyZXMvVGV4dHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3RleHR1cmVzL1RleHR1cmVVdnMuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS90ZXh0dXJlcy9WaWRlb0Jhc2VUZXh0dXJlLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2NvcmUvdXRpbHMvUG9seUsuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvY29yZS91dGlscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9jb3JlL3V0aWxzL3BsdWdpblRhcmdldC5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9kZXByZWNhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9leHRyYXMvQml0bWFwVGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9leHRyYXMvTW92aWVDbGlwLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2V4dHJhcy9UaWNrZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZXh0cmFzL1RpbGluZ1Nwcml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9leHRyYXMvY2FjaGVBc0JpdG1hcC5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9leHRyYXMvZ2V0Q2hpbGRCeU5hbWUuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZXh0cmFzL2dldEdsb2JhbFBvc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2V4dHJhcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9maWx0ZXJzL2FzY2lpL0FzY2lpRmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2ZpbHRlcnMvYmxvb20vQmxvb21GaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZmlsdGVycy9ibHVyL0JsdXJGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZmlsdGVycy9ibHVyL0JsdXJYRmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2ZpbHRlcnMvYmx1ci9CbHVyWUZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9maWx0ZXJzL2JsdXIvU21hcnRCbHVyRmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2ZpbHRlcnMvY29sb3IvQ29sb3JNYXRyaXhGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZmlsdGVycy9jb2xvci9Db2xvclN0ZXBGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZmlsdGVycy9jb252b2x1dGlvbi9Db252b2x1dGlvbkZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9maWx0ZXJzL2Nyb3NzaGF0Y2gvQ3Jvc3NIYXRjaEZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9maWx0ZXJzL2Rpc3BsYWNlbWVudC9EaXNwbGFjZW1lbnRGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZmlsdGVycy9kb3QvRG90U2NyZWVuRmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2ZpbHRlcnMvZHJvcHNoYWRvdy9CbHVyWVRpbnRGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZmlsdGVycy9kcm9wc2hhZG93L0Ryb3BTaGFkb3dGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZmlsdGVycy9ncmF5L0dyYXlGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZmlsdGVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9maWx0ZXJzL2ludmVydC9JbnZlcnRGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZmlsdGVycy9ub2lzZS9Ob2lzZUZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9maWx0ZXJzL25vcm1hbC9Ob3JtYWxNYXBGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZmlsdGVycy9waXhlbGF0ZS9QaXhlbGF0ZUZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9maWx0ZXJzL3JnYi9SR0JTcGxpdEZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9maWx0ZXJzL3NlcGlhL1NlcGlhRmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2ZpbHRlcnMvc2hvY2t3YXZlL1Nob2Nrd2F2ZUZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9maWx0ZXJzL3RpbHRzaGlmdC9UaWx0U2hpZnRBeGlzRmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2ZpbHRlcnMvdGlsdHNoaWZ0L1RpbHRTaGlmdEZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9maWx0ZXJzL3RpbHRzaGlmdC9UaWx0U2hpZnRYRmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2ZpbHRlcnMvdGlsdHNoaWZ0L1RpbHRTaGlmdFlGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvZmlsdGVycy90d2lzdC9Ud2lzdEZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbkRhdGEuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb25NYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2ludGVyYWN0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2ludGVyYWN0aW9uL2ludGVyYWN0aXZlVGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2xvYWRlcnMvYml0bWFwRm9udFBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9sb2FkZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2xvYWRlcnMvbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2xvYWRlcnMvc3BpbmVBdGxhc1BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9sb2FkZXJzL3Nwcml0ZXNoZWV0UGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL2xvYWRlcnMvdGV4dHVyZVBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9tZXNoL01lc2guanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvbWVzaC9Sb3BlLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL21lc2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvbWVzaC93ZWJnbC9NZXNoUmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvbWVzaC93ZWJnbC9NZXNoU2hhZGVyLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL3BvbHlmaWxsL09iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvcG9seWZpbGwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGl4aS5qcy9zcmMvcG9seWZpbGwvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL3NwaW5lL1NwaW5lLmpzIiwibm9kZV9tb2R1bGVzL3BpeGkuanMvc3JjL3NwaW5lL1NwaW5lUnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9waXhpLmpzL3NyYy9zcGluZS9pbmRleC5qcyIsIi9Vc2Vycy90eWVtaWxsZGV2ZWxvcGVyL3NwYWNlLWdhbWUvc3JjL0JsdWVwcmludEVkaXRvci5jb2ZmZWUiLCIvVXNlcnMvdHllbWlsbGRldmVsb3Blci9zcGFjZS1nYW1lL3NyYy9DYW1lcmEuY29mZmVlIiwiL1VzZXJzL3R5ZW1pbGxkZXZlbG9wZXIvc3BhY2UtZ2FtZS9zcmMvQ29sbGlzaW9uR3JvdXBzLmNvZmZlZSIsIi9Vc2Vycy90eWVtaWxsZGV2ZWxvcGVyL3NwYWNlLWdhbWUvc3JjL0VudGl0eS5jb2ZmZWUiLCIvVXNlcnMvdHllbWlsbGRldmVsb3Blci9zcGFjZS1nYW1lL3NyYy9HYW1lLmNvZmZlZSIsIi9Vc2Vycy90eWVtaWxsZGV2ZWxvcGVyL3NwYWNlLWdhbWUvc3JjL0dhbWVSZW5kZXJlci5jb2ZmZWUiLCIvVXNlcnMvdHllbWlsbGRldmVsb3Blci9zcGFjZS1nYW1lL3NyYy9JTy5jb2ZmZWUiLCIvVXNlcnMvdHllbWlsbGRldmVsb3Blci9zcGFjZS1nYW1lL3NyYy9QZXJzb24uY29mZmVlIiwiL1VzZXJzL3R5ZW1pbGxkZXZlbG9wZXIvc3BhY2UtZ2FtZS9zcmMvUGxheWVyUGVyc29uQ29udHJvbGxlci5jb2ZmZWUiLCIvVXNlcnMvdHllbWlsbGRldmVsb3Blci9zcGFjZS1nYW1lL3NyYy9QbGF5ZXJTaGlwQ29udHJvbGxlci5jb2ZmZWUiLCIvVXNlcnMvdHllbWlsbGRldmVsb3Blci9zcGFjZS1nYW1lL3NyYy9TaGlwSHVkLmNvZmZlZSIsIi9Vc2Vycy90eWVtaWxsZGV2ZWxvcGVyL3NwYWNlLWdhbWUvc3JjL3NoaXAvQmx1ZXByaW50LmNvZmZlZSIsIi9Vc2Vycy90eWVtaWxsZGV2ZWxvcGVyL3NwYWNlLWdhbWUvc3JjL3NoaXAvQ29yZS5jb2ZmZWUiLCIvVXNlcnMvdHllbWlsbGRldmVsb3Blci9zcGFjZS1nYW1lL3NyYy9zaGlwL0h1bGwuY29mZmVlIiwiL1VzZXJzL3R5ZW1pbGxkZXZlbG9wZXIvc3BhY2UtZ2FtZS9zcmMvc2hpcC9JbnRlcmlvci5jb2ZmZWUiLCIvVXNlcnMvdHllbWlsbGRldmVsb3Blci9zcGFjZS1nYW1lL3NyYy9zaGlwL1BhcnQuY29mZmVlIiwiL1VzZXJzL3R5ZW1pbGxkZXZlbG9wZXIvc3BhY2UtZ2FtZS9zcmMvc2hpcC9TaGlwLmNvZmZlZSIsIi9Vc2Vycy90eWVtaWxsZGV2ZWxvcGVyL3NwYWNlLWdhbWUvc3JjL3NoaXAvVGhydXN0QmFsYW5jZXIuY29mZmVlIiwiL1VzZXJzL3R5ZW1pbGxkZXZlbG9wZXIvc3BhY2UtZ2FtZS9zcmMvc2hpcC9UaHJ1c3Rlci5jb2ZmZWUiLCIvVXNlcnMvdHllbWlsbGRldmVsb3Blci9zcGFjZS1nYW1lL3NyYy91dGlsL0ZQU0NvdW50ZXIuY29mZmVlIiwiL1VzZXJzL3R5ZW1pbGxkZXZlbG9wZXIvc3BhY2UtZ2FtZS9zcmMvdXRpbC9HcmlkLmNvZmZlZSIsIi9Vc2Vycy90eWVtaWxsZGV2ZWxvcGVyL3NwYWNlLWdhbWUvc3JjL3V0aWwvVXRpbC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNFQSxJQUFBLHVIQUFBOztBQUFBLFFBQVEsQ0FBQSxTQUFFLENBQUEsUUFBVixHQUFxQixTQUFDLElBQUQsRUFBTyxJQUFQLEdBQUE7U0FDbkIsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsSUFBSSxDQUFDLFNBQTNCLEVBQXNDLElBQXRDLEVBQTRDLElBQTVDLEVBRG1CO0FBQUEsQ0FBckIsQ0FBQTs7QUFBQSxTQUdBLEdBQVksT0FBQSxDQUFRLGdCQUFSLENBSFosQ0FBQTs7QUFBQSxlQUlBLEdBQWtCLE9BQUEsQ0FBUSxpQkFBUixDQUpsQixDQUFBOztBQUFBLFVBS0EsR0FBYSxPQUFBLENBQVEsaUJBQVIsQ0FMYixDQUFBOztBQUFBLElBTUEsR0FBTyxPQUFBLENBQVEsTUFBUixDQU5QLENBQUE7O0FBQUEsSUFPQSxHQUFPLE9BQUEsQ0FBUSxXQUFSLENBUFAsQ0FBQTs7QUFBQSxNQVFBLEdBQVMsT0FBQSxDQUFRLFFBQVIsQ0FSVCxDQUFBOztBQUFBLG9CQVNBLEdBQXVCLE9BQUEsQ0FBUSxzQkFBUixDQVR2QixDQUFBOztBQUFBLHNCQVVBLEdBQXlCLE9BQUEsQ0FBUSx3QkFBUixDQVZ6QixDQUFBOztBQUFBLElBV0EsR0FBTyxPQUFBLENBQVEsV0FBUixDQVhQLENBQUE7O0FBQUEsT0FZQSxHQUFVLE9BQUEsQ0FBUSxTQUFSLENBWlYsQ0FBQTs7QUFBQSxNQWNNLENBQUMsTUFBUCxHQUFnQixTQUFBLEdBQUE7QUFDZCxNQUFBLGNBQUE7QUFBQSxFQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksUUFBWixDQUFBLENBQUE7QUFBQSxFQUNBLE1BQU0sQ0FBQyxJQUFQLEdBQWMsSUFBQSxHQUFXLElBQUEsSUFBQSxDQUFBLENBRHpCLENBQUE7QUFBQSxFQUVBLElBQUksQ0FBQyxLQUFMLENBQUEsQ0FGQSxDQUFBO0FBQUEsRUFVQSxRQUFBLEdBQVcsU0FBQyxFQUFELEdBQUE7QUFDVCxRQUFBLHVCQUFBO0FBQUEsSUFBQSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQVosR0FBZ0IsRUFBaEIsQ0FBQTtBQUFBLElBQ0EsTUFBTSxDQUFDLElBQVAsR0FBa0IsSUFBQSxJQUFBLENBQUssRUFBTCxDQURsQixDQUFBO0FBQUEsSUFFQSxNQUFBLEdBQWEsSUFBQSxNQUFBLENBQUEsQ0FGYixDQUFBO0FBQUEsSUFHQSxNQUFNLENBQUMsS0FBUCxDQUFhLElBQWIsQ0FIQSxDQUFBO0FBQUEsSUFLQSxVQUFBLEdBQWlCLElBQUEsb0JBQUEsQ0FBcUIsSUFBckIsQ0FMakIsQ0FBQTtBQUFBLElBTUEsR0FBQSxHQUFVLElBQUEsT0FBQSxDQUFRLElBQVIsQ0FOVixDQUFBO0FBQUEsSUFPQSxJQUFJLENBQUMsU0FBTCxDQUFlLElBQWYsQ0FQQSxDQUFBO0FBQUEsSUFRQSxJQUFJLENBQUMsU0FBTCxDQUFlLE1BQWYsQ0FSQSxDQUFBO0FBQUEsSUFTQSxJQUFJLENBQUMsU0FBTCxDQUFlLFVBQWYsQ0FUQSxDQUFBO0FBQUEsSUFVQSxJQUFJLENBQUMsU0FBTCxDQUFlLEdBQWYsQ0FWQSxDQUFBO1dBV0EsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFaLENBQW1CLElBQW5CLEVBWlM7RUFBQSxDQVZYLENBQUE7U0F3QkEsSUFBSSxDQUFDLFNBQUwsQ0FBbUIsSUFBQSxlQUFBLENBQWdCLEdBQUEsQ0FBQSxTQUFoQixFQUErQixRQUEvQixDQUFuQixFQXpCYztBQUFBLENBZGhCLENBQUE7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzllQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDejBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDempCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW5DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1M0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25pQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25nQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3I1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBLElBQUEsa0ZBQUE7RUFBQTs7a0ZBQUE7O0FBQUEsSUFBQSxHQUFPLE9BQUEsQ0FBUSxXQUFSLENBQVAsQ0FBQTs7QUFBQSxNQUNBLEdBQVMsT0FBQSxDQUFRLFFBQVIsQ0FEVCxDQUFBOztBQUFBLElBRUEsR0FBTyxPQUFBLENBQVEsV0FBUixDQUZQLENBQUE7O0FBQUEsUUFHQSxHQUFXLE9BQUEsQ0FBUSxlQUFSLENBSFgsQ0FBQTs7QUFBQSxFQUlBLEdBQUssT0FBQSxDQUFRLElBQVIsQ0FKTCxDQUFBOztBQUFBLElBS0EsR0FBTyxPQUFBLENBQVEsU0FBUixDQUxQLENBQUE7O0FBQUEsUUFNQSxHQUFXLE9BQUEsQ0FBUSxlQUFSLENBTlgsQ0FBQTs7QUFBQSxJQU9BLEdBQU8sT0FBQSxDQUFRLFdBQVIsQ0FQUCxDQUFBOztBQUFBO0FBVUUsK0JBQUEsQ0FBQTs7QUFBYSxFQUFBLG1CQUFBLEdBQUE7QUFDWCxJQUFBLElBQUMsQ0FBQSxLQUFELEdBQVMsS0FBVCxDQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsTUFBRCxHQUFjLElBQUEsSUFBSSxDQUFDLElBQUwsQ0FBVSxNQUFWLEVBQWtCO0FBQUEsTUFDOUIsSUFBQSxFQUFNLFlBRHdCO0FBQUEsTUFFOUIsSUFBQSxFQUFNLFNBRndCO0tBQWxCLENBRGQsQ0FEVztFQUFBLENBQWI7O21CQUFBOztHQURzQixPQVR4QixDQUFBOztBQUFBO0FBb0JFLE1BQUEsb0VBQUE7O0FBQUEscUNBQUEsQ0FBQTs7QUFBQSxFQUFBLFdBQUEsR0FBYyxFQUFkLENBQUE7O0FBQUEsRUFDQSxlQUFBLEdBQWtCLEVBRGxCLENBQUE7O0FBQUEsRUFFQSxhQUFBLEdBQWdCLEVBRmhCLENBQUE7O0FBQUEsRUFHQSxjQUFBLEdBQWlCLEVBSGpCLENBQUE7O0FBQUEsRUFJQSxPQUFBLEdBQVUsRUFKVixDQUFBOztBQU9hLEVBQUEseUJBQUMsU0FBRCxFQUFhLE9BQWIsR0FBQTtBQUNYLElBRFksSUFBQyxDQUFBLFlBQUQsU0FDWixDQUFBO0FBQUEsSUFEd0IsSUFBQyxDQUFBLDRCQUFELFVBQVcsSUFDbkMsQ0FBQTtBQUFBLCtDQUFBLENBQUE7QUFBQSwrQ0FBQSxDQUFBO0FBQUEseUNBQUEsQ0FBQTtBQUFBLDZDQUFBLENBQUE7QUFBQSxxREFBQSxDQUFBO0FBQUEsMkNBQUEsQ0FBQTtBQUFBLHlDQUFBLENBQUE7QUFBQSx5REFBQSxDQUFBO0FBQUEsdUNBQUEsQ0FBQTtBQUFBLElBQUEsSUFBQyxDQUFBLE1BQUQsR0FBYyxJQUFBLElBQUksQ0FBQyxTQUFMLENBQUEsQ0FBZCxDQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsS0FBRCxHQUFTLE9BRFQsQ0FBQTtBQUFBLElBRUEsSUFBQyxDQUFBLFVBQUQsR0FBa0IsSUFBQSxJQUFJLENBQUMsUUFBTCxDQUFBLENBRmxCLENBQUE7QUFBQSxJQUdBLElBQUMsQ0FBQSxVQUFVLENBQUMsU0FBWixDQUFzQixRQUF0QixDQUhBLENBQUE7QUFBQSxJQUlBLElBQUMsQ0FBQSxVQUFVLENBQUMsT0FBWixDQUFBLENBSkEsQ0FBQTtBQUFBLElBTUEsSUFBQyxDQUFBLE1BQU0sQ0FBQyxRQUFSLENBQWlCLElBQUMsQ0FBQSxVQUFsQixDQU5BLENBQUE7QUFBQSxJQU9BLElBQUMsQ0FBQSxNQUFNLENBQUMsUUFBUixDQUFpQixJQUFDLENBQUEsU0FBUyxDQUFDLE1BQTVCLENBUEEsQ0FBQTtBQUFBLElBU0EsSUFBQyxDQUFBLFFBQUQsR0FBZ0IsSUFBQSxJQUFJLENBQUMsUUFBTCxDQUFBLENBVGhCLENBQUE7QUFBQSxJQVVBLElBQUMsQ0FBQSxNQUFNLENBQUMsUUFBUixDQUFpQixJQUFDLENBQUEsUUFBbEIsQ0FWQSxDQUFBO0FBQUEsSUFZQSxJQUFDLENBQUEsU0FBRCxHQUFpQixJQUFBLFNBQUEsQ0FBQSxDQVpqQixDQUFBO0FBQUEsSUFjQSxJQUFDLENBQUEsU0FBRCxHQUFhLENBZGIsQ0FBQTtBQUFBLElBZUEsSUFBQyxDQUFBLFdBQUQsR0FBZSxDQUFDLElBQUQsRUFBTyxRQUFQLEVBQWlCLFFBQWpCLENBZmYsQ0FBQTtBQUFBLElBZ0JBLElBQUMsQ0FBQSxTQUFELEdBQWEsQ0FoQmIsQ0FBQTtBQUFBLElBaUJBLElBQUMsQ0FBQSxRQUFELENBQVUsQ0FBVixDQWpCQSxDQURXO0VBQUEsQ0FQYjs7QUFBQSw0QkEyQkEsS0FBQSxHQUFPLFNBQUEsR0FBQTtXQUNMLElBQUMsQ0FBQSxJQUFJLENBQUMsU0FBTixDQUFnQixJQUFDLENBQUEsU0FBakIsRUFESztFQUFBLENBM0JQLENBQUE7O0FBQUEsNEJBK0JBLGNBQUEsR0FBZ0IsU0FBQSxHQUFBO0FBQ2QsV0FBTyxJQUFDLENBQUEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFiLENBQXFCLElBQUMsQ0FBQSxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQTlCLENBQTRDLENBQUMsR0FBN0MsQ0FBaUQsSUFBSSxDQUFDLEtBQXRELENBQVAsQ0FEYztFQUFBLENBL0JoQixDQUFBOztBQUFBLDRCQWtDQSxNQUFBLEdBQVEsU0FBQSxHQUFBO0FBQ04sUUFBQSx5Q0FBQTtBQUFBLElBQUEsSUFBQyxDQUFBLFFBQVEsQ0FBQyxLQUFWLENBQUEsQ0FBQSxDQUFBO0FBQUEsSUFDQSxRQUFBLEdBQVcsSUFBQyxDQUFBLGNBQUQsQ0FBQSxDQURYLENBQUE7QUFBQSxJQUVBLFNBQUEsR0FBWSxJQUFDLENBQUEsU0FBUyxDQUFDLFFBQVEsQ0FBQyxHQUFwQixDQUF3QixRQUF4QixDQUZaLENBQUE7QUFHQSxJQUFBLElBQU8saUJBQVA7QUFDRSxNQUFBLElBQUMsQ0FBQSxRQUFRLENBQUMsU0FBVixDQUFvQixJQUFDLENBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUEvQixDQUFBLENBQUE7QUFBQSxNQUNBLElBQUMsQ0FBQSxRQUFRLENBQUMsUUFBVixDQUFtQixDQUFBLEdBQW5CLEVBQXlCLENBQUEsR0FBekIsRUFBK0IsQ0FBL0IsRUFBa0MsQ0FBbEMsQ0FEQSxDQUFBO0FBQUEsTUFFQSxJQUFDLENBQUEsUUFBUSxDQUFDLE9BQVYsQ0FBQSxDQUZBLENBREY7S0FIQTtBQUFBLElBUUEsTUFBQSxHQUFTLENBQUEsU0FSVCxDQUFBO0FBU0EsSUFBQSxJQUFHLGlCQUFIO0FBQ0UsTUFBQSxLQUFBLEdBQVEsUUFBUixDQURGO0tBQUEsTUFFSyxJQUFHLE1BQUg7QUFDSCxNQUFBLEtBQUEsR0FBUSxRQUFSLENBREc7S0FBQSxNQUFBO0FBR0gsTUFBQSxLQUFBLEdBQVEsUUFBUixDQUhHO0tBWEw7QUFBQSxJQWdCQSxJQUFDLENBQUEsUUFBUSxDQUFDLFNBQVYsQ0FBb0IsSUFBcEIsRUFBMEIsS0FBMUIsQ0FoQkEsQ0FBQTtBQUFBLElBaUJBLElBQUMsQ0FBQSxRQUFRLENBQUMsUUFBVixDQUFtQixDQUFBLENBQW5CLEVBQXVCLENBQUEsQ0FBdkIsRUFBMkIsQ0FBM0IsRUFBOEIsQ0FBOUIsQ0FqQkEsQ0FBQTtBQW1CQSxJQUFBLElBQUcsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBZDtBQUNFLE1BQUEsSUFBQyxDQUFBLFFBQVEsQ0FBQyxTQUFWLENBQW9CLElBQXBCLEVBQTBCLFFBQTFCLEVBQW9DLEdBQXBDLENBQUEsQ0FBQTtBQUFBLE1BQ0EsSUFBQyxDQUFBLFFBQVEsQ0FBQyxNQUFWLENBQWlCLENBQUEsR0FBakIsRUFBdUIsQ0FBQSxHQUF2QixDQURBLENBQUE7QUFBQSxNQUVBLEtBQUEsR0FBUSxDQUFDLElBQUMsQ0FBQSxTQUFELEdBQWEsQ0FBZCxDQUFBLEdBQW1CLElBQUksQ0FBQyxFQUF4QixHQUE2QixDQUZyQyxDQUFBO0FBQUEsTUFHQSxJQUFDLENBQUEsUUFBUSxDQUFDLE1BQVYsQ0FBaUIsSUFBSSxDQUFDLEdBQUwsQ0FBUyxLQUFULENBQUEsR0FBa0IsR0FBbEIsR0FBd0IsR0FBekMsRUFBOEMsSUFBSSxDQUFDLEdBQUwsQ0FBUyxLQUFULENBQUEsR0FBa0IsR0FBbEIsR0FBd0IsR0FBdEUsQ0FIQSxDQURGO0tBbkJBO0FBeUJBLElBQUEsSUFBRyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQVEsQ0FBQSxDQUFBLENBQW5CO0FBQ0UsTUFBQSxJQUFDLENBQUEsT0FBRCxDQUFBLENBQUEsQ0FERjtLQXpCQTtBQTRCQSxJQUFBLElBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFRLENBQUEsQ0FBQSxDQUFuQjtBQUNFLE1BQUEsSUFBQyxDQUFBLFlBQUQsQ0FBQSxDQUFBLENBREY7S0E1QkE7V0ErQkMsSUFBQyxDQUFBLFFBQVEsQ0FBQyxlQUFYLEVBQWMsSUFBQyxDQUFBLFFBQVEsQ0FBQyxlQUF4QixFQUE2QixTQWhDdkI7RUFBQSxDQWxDUixDQUFBOztBQUFBLDRCQXFFQSxPQUFBLEdBQVMsU0FBQyxhQUFELEdBQUE7QUFDUCxRQUFBLHFCQUFBO0FBQUEsSUFBQSxNQUFTLElBQUMsQ0FBQSxjQUFELENBQUEsQ0FBVCxFQUFDLFVBQUQsRUFBSSxVQUFKLENBQUE7QUFDQSxJQUFBLElBQU8sMkNBQVA7QUFDRSxNQUFBLElBQUEsR0FBTyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVAsQ0FBQTtBQUNBLE1BQUEsSUFBRyxJQUFDLENBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFkO0FBQ0UsUUFBQSxJQUFJLENBQUMsSUFBTCxDQUFVLElBQUMsQ0FBQSxTQUFYLENBQUEsQ0FERjtPQURBO0FBQUEsTUFHQSxJQUFBLEdBQVc7Ozs7U0FBQSxJQUFDLENBQUEsSUFBRCxFQUFNLElBQU4sZUFIWCxDQUFBO2FBSUEsSUFBQyxDQUFBLFNBQVMsQ0FBQyxPQUFYLENBQW1CLElBQW5CLEVBTEY7S0FGTztFQUFBLENBckVULENBQUE7O0FBQUEsNEJBK0VBLFlBQUEsR0FBYyxTQUFDLGFBQUQsR0FBQTtBQUNaLFFBQUEsSUFBQTtBQUFBLElBQUEsSUFBQSxHQUFPLElBQUMsQ0FBQSxTQUFTLENBQUMsUUFBUSxDQUFDLEdBQXBCLENBQXdCLElBQUMsQ0FBQSxjQUFELENBQUEsQ0FBeEIsQ0FBUCxDQUFBO0FBQ0EsSUFBQSxJQUFHLGNBQUEsSUFBVSxJQUFJLENBQUMsSUFBTCxLQUFlLElBQUksQ0FBQyxJQUFqQzthQUNFLElBQUMsQ0FBQSxTQUFTLENBQUMsVUFBWCxDQUFzQixJQUF0QixFQURGO0tBRlk7RUFBQSxDQS9FZCxDQUFBOztBQUFBLDRCQXFGQSxRQUFBLEdBQVUsU0FBQyxDQUFELEdBQUE7O01BQUMsSUFBRTtLQUNYO0FBQUEsSUFBQSxJQUFDLENBQUEsU0FBRCxHQUFhLElBQUksQ0FBQyxHQUFMLENBQVMsSUFBQyxDQUFBLFNBQUQsR0FBYSxDQUF0QixFQUF5QixJQUFDLENBQUEsV0FBVyxDQUFDLE1BQXRDLENBQWIsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFDLENBQUEsV0FBWSxDQUFBLElBQUMsQ0FBQSxTQUFELENBRHJCLENBQUE7V0FFQSxJQUFDLENBQUEsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFsQixHQUF5QixJQUFDLENBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUg1QjtFQUFBLENBckZWLENBQUE7O0FBQUEsNEJBMkZBLE1BQUEsR0FBUSxTQUFDLENBQUQsR0FBQTs7TUFBQyxJQUFFO0tBQ1Q7V0FBQSxJQUFDLENBQUEsU0FBRCxHQUFhLElBQUksQ0FBQyxHQUFMLENBQVMsSUFBQyxDQUFBLFNBQUQsR0FBYSxDQUF0QixFQUF5QixDQUF6QixFQURQO0VBQUEsQ0EzRlIsQ0FBQTs7QUFBQSw0QkErRkEsU0FBQSxHQUFXLFNBQUMsR0FBRCxHQUFBO0FBQ1QsWUFBTyxHQUFQO0FBQUEsV0FDTyxPQURQO2VBQ29CLElBQUMsQ0FBQSxPQUFELENBQUEsRUFEcEI7QUFBQSxXQUVPLFdBRlA7ZUFFd0IsSUFBQyxDQUFBLFFBQUQsQ0FBVSxDQUFWLEVBRnhCO0FBQUEsV0FHTyxlQUhQO2VBRzRCLElBQUMsQ0FBQSxRQUFELENBQVUsQ0FBQSxDQUFWLEVBSDVCO0FBQUEsV0FJTyxhQUpQO2VBSTBCLElBQUMsQ0FBQSxNQUFELENBQVEsQ0FBQSxDQUFSLEVBSjFCO0FBQUEsV0FLTyxjQUxQO2VBSzJCLElBQUMsQ0FBQSxNQUFELENBQVEsQ0FBUixFQUwzQjtBQUFBLEtBRFM7RUFBQSxDQS9GWCxDQUFBOztBQUFBLDRCQXVHQSxTQUFBLEdBQVcsU0FBQSxHQUFBO0FBQ1QsSUFBQSxJQUFDLENBQUEsU0FBUyxDQUFDLE9BQVgsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLElBQUcsb0JBQUg7YUFDRSxJQUFDLENBQUEsT0FBRCxDQUFTLElBQUMsQ0FBQSxTQUFWLEVBREY7S0FGUztFQUFBLENBdkdYLENBQUE7O3lCQUFBOztHQUY0QixPQWxCOUIsQ0FBQTs7QUFBQSxNQWtJTSxDQUFDLE9BQVAsR0FBaUIsZUFsSWpCLENBQUE7Ozs7O0FDQUEsSUFBQSwyQkFBQTtFQUFBLGdGQUFBOztBQUFBLElBQUEsR0FBTyxPQUFBLENBQVEsU0FBUixDQUFQLENBQUE7O0FBQUEsTUFDQSxHQUFTLElBQUksQ0FBQyxNQURkLENBQUE7O0FBQUEsS0FFQSxHQUFRLElBQUksQ0FBQyxLQUZiLENBQUE7O0FBQUE7QUFNZSxFQUFBLGdCQUFDLFFBQUQsRUFBWSxFQUFaLEVBQW9CLEVBQXBCLEVBQTRCLENBQTVCLEVBQXVDLEtBQXZDLEdBQUE7QUFDWCxJQURZLElBQUMsQ0FBQSxXQUFELFFBQ1osQ0FBQTtBQUFBLElBRHVCLElBQUMsQ0FBQSxpQkFBRCxLQUFLLENBQzVCLENBQUE7QUFBQSxJQUQrQixJQUFDLENBQUEsaUJBQUQsS0FBSyxDQUNwQyxDQUFBO0FBQUEsSUFEdUMsSUFBQyxDQUFBLGdCQUFELElBQUssSUFDNUMsQ0FBQTtBQUFBLElBRGtELElBQUMsQ0FBQSx3QkFBRCxRQUFTLENBQzNELENBQUE7QUFBQSxtREFBQSxDQUFBO0FBQUEsK0NBQUEsQ0FBQTtBQUFBLDZDQUFBLENBQUE7QUFBQSwyQ0FBQSxDQUFBO0FBQUEsMkRBQUEsQ0FBQTtBQUFBLHFDQUFBLENBQUE7QUFBQSx5Q0FBQSxDQUFBO0FBQUEsSUFBQSxJQUFDLENBQUEsU0FBRCxHQUFhLElBQWIsQ0FEVztFQUFBLENBQWI7O0FBQUEsbUJBSUEsTUFBQSxHQUFRLFNBQUMsS0FBRCxHQUFBO1dBQ04sSUFBQyxDQUFBLFNBQUQsR0FBYSxNQURQO0VBQUEsQ0FKUixDQUFBOztBQUFBLG1CQU9BLElBQUEsR0FBTSxTQUFBLEdBQUE7QUFDSixRQUFBLEdBQUE7QUFBQSxJQUFBLElBQUcsc0JBQUg7YUFDRSxNQUFXLElBQUMsQ0FBQSxTQUFTLENBQUMsUUFBdEIsRUFBQyxJQUFDLENBQUEsVUFBRixFQUFLLElBQUMsQ0FBQSxVQUFOLEVBQUEsSUFERjtLQURJO0VBQUEsQ0FQTixDQUFBOztBQUFBLG1CQWFBLGVBQUEsR0FBaUIsU0FBQSxHQUFBO0FBQ2YsV0FBTyxDQUFDLElBQUMsQ0FBQSxRQUFRLENBQUMsWUFBWSxDQUFDLEtBQXhCLEVBQStCLElBQUMsQ0FBQSxRQUFRLENBQUMsWUFBWSxDQUFDLE1BQXRELENBQVAsQ0FEZTtFQUFBLENBYmpCLENBQUE7O0FBQUEsbUJBaUJBLE9BQUEsR0FBUyxTQUFDLEdBQUQsRUFBUyxLQUFULEdBQUE7QUFDUCxRQUFBLGtCQUFBO0FBQUEsSUFEUyxZQUFHLFVBQ1osQ0FBQTs7TUFEZ0IsUUFBUTtLQUN4QjtBQUFBLElBQUEsTUFBUyxJQUFDLENBQUEsZUFBRCxDQUFBLENBQVQsRUFBQyxVQUFELEVBQUksVUFBSixDQUFBO0FBQUEsSUFDQSxDQUFBLEdBQVEsSUFBQSxLQUFBLENBQU0sQ0FBTixFQUFTLENBQVQsQ0FEUixDQUFBO0FBQUEsSUFFQSxDQUFBLEdBQUksSUFBQyxDQUFBLFNBQUQsQ0FBVyxLQUFYLENBQWlCLENBQUMsWUFBbEIsQ0FBK0IsQ0FBL0IsRUFBa0MsQ0FBbEMsQ0FGSixDQUFBO0FBR0EsV0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFILEVBQU0sQ0FBQyxDQUFDLENBQVIsQ0FBUCxDQUpPO0VBQUEsQ0FqQlQsQ0FBQTs7QUFBQSxtQkF3QkEsUUFBQSxHQUFVLFNBQUMsR0FBRCxFQUFTLEtBQVQsR0FBQTtBQUNSLFFBQUEsa0JBQUE7QUFBQSxJQURVLFlBQUcsVUFDYixDQUFBOztNQURpQixRQUFRO0tBQ3pCO0FBQUEsSUFBQSxNQUFTLElBQUMsQ0FBQSxlQUFELENBQUEsQ0FBVCxFQUFDLFVBQUQsRUFBSSxVQUFKLENBQUE7QUFBQSxJQUNBLENBQUEsR0FBUSxJQUFBLEtBQUEsQ0FBTSxDQUFOLEVBQVMsQ0FBVCxDQURSLENBQUE7QUFBQSxJQUVBLENBQUEsR0FBSSxJQUFDLENBQUEsU0FBRCxDQUFXLEtBQVgsQ0FBaUIsQ0FBQyxLQUFsQixDQUF3QixDQUF4QixFQUEyQixDQUEzQixDQUZKLENBQUE7QUFHQSxXQUFPLENBQUMsQ0FBQyxDQUFDLENBQUgsRUFBTSxDQUFDLENBQUMsQ0FBUixDQUFQLENBSlE7RUFBQSxDQXhCVixDQUFBOztBQUFBLG1CQStCQSxTQUFBLEdBQVcsU0FBQyxLQUFELEdBQUE7QUFDVCxRQUFBLFlBQUE7O01BRFUsUUFBUTtLQUNsQjtBQUFBLElBQUEsTUFBUyxJQUFDLENBQUEsZUFBRCxDQUFBLENBQVQsRUFBQyxVQUFELEVBQUksVUFBSixDQUFBO0FBQUEsSUFDQSxDQUFBLEdBQVEsSUFBQSxNQUFBLENBQUEsQ0FEUixDQUFBO0FBQUEsSUFFQSxDQUFDLENBQUMsU0FBRixDQUFZLENBQUEsSUFBRSxDQUFBLENBQUYsR0FBTSxLQUFsQixFQUF5QixDQUFBLElBQUUsQ0FBQSxDQUFGLEdBQU0sS0FBL0IsQ0FGQSxDQUFBO0FBQUEsSUFHQSxDQUFDLENBQUMsS0FBRixDQUFRLElBQUMsQ0FBQSxDQUFELEdBQUssS0FBYixFQUFvQixJQUFDLENBQUEsQ0FBRCxHQUFLLEtBQXpCLENBSEEsQ0FBQTtBQUFBLElBSUEsQ0FBQyxDQUFDLE1BQUYsQ0FBUyxJQUFDLENBQUEsS0FBVixDQUpBLENBQUE7QUFBQSxJQUtBLENBQUMsQ0FBQyxTQUFGLENBQVksQ0FBQSxHQUFJLENBQWhCLEVBQW1CLENBQUEsR0FBSSxDQUF2QixDQUxBLENBQUE7QUFNQSxXQUFPLENBQVAsQ0FQUztFQUFBLENBL0JYLENBQUE7O0FBQUEsbUJBeUNBLFdBQUEsR0FBYSxTQUFDLFNBQUQsR0FBQTtBQUNYLFFBQUEsOEJBQUE7QUFBQSxJQUFBLE1BQUEsR0FBUyxTQUFTLENBQUMsTUFBbkIsQ0FBQTtBQUNBLElBQUEsSUFBRyxNQUFBLEtBQVUsQ0FBYjtBQUNFLE1BQUEsS0FBQSxHQUFRLFNBQVMsQ0FBQyxLQUFsQixDQUFBO0FBQUEsTUFDQSxNQUFTLElBQUMsQ0FBQSxlQUFELENBQUEsQ0FBVCxFQUFDLFVBQUQsRUFBSSxVQURKLENBQUE7QUFBQSxNQUVBLE9BQXFCLElBQUMsQ0FBQSxRQUFELENBQVUsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFWLENBQXJCLEVBQUMsS0FBSyxDQUFDLFdBQVAsRUFBVSxLQUFLLENBQUMsV0FGaEIsQ0FBQTtBQUFBLE1BR0EsS0FBSyxDQUFDLFFBQU4sR0FBaUIsSUFBQyxDQUFBLEtBSGxCLENBQUE7YUFJQSxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQVosQ0FBZ0IsSUFBQyxDQUFBLENBQWpCLEVBQW9CLElBQUMsQ0FBQSxDQUFyQixFQUxGO0tBRlc7RUFBQSxDQXpDYixDQUFBOztnQkFBQTs7SUFORixDQUFBOztBQUFBLE1Bd0RNLENBQUMsT0FBUCxHQUFpQixNQXhEakIsQ0FBQTs7Ozs7QUNBQSxJQUFBLHNCQUFBO0VBQUEsZ0JBQUE7O0FBQUEsS0FBQSxHQUFRLFNBQUEsR0FBQTtBQUNOLE1BQUEsdUJBQUE7QUFBQSxFQURPLDhEQUNQLENBQUE7QUFBQSxFQUFBLElBQUEsR0FBTyxDQUFQLENBQUE7QUFDQSxPQUFBLHdDQUFBO2tCQUFBO0FBQ0UsSUFBQSxJQUFBLElBQVEsSUFBSSxDQUFDLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBWixDQUFSLENBREY7QUFBQSxHQURBO0FBQUEsRUFHQSxPQUFPLENBQUMsR0FBUixDQUFZLFFBQUEsR0FBUyxJQUFULEdBQWMsY0FBZCxHQUE0QixNQUF4QyxDQUhBLENBQUE7QUFJQSxTQUFPLElBQVAsQ0FMTTtBQUFBLENBQVIsQ0FBQTs7QUFBQTsrQkFRRTs7QUFBQSxFQUFBLGVBQUMsQ0FBQSxhQUFELEdBQWlCLEtBQUEsQ0FBTSxDQUFOLENBQWpCLENBQUE7O0FBQUEsRUFDQSxlQUFDLENBQUEsYUFBRCxHQUFpQixLQUFBLENBQU0sQ0FBTixDQURqQixDQUFBOztBQUFBLEVBRUEsZUFBQyxDQUFBLE1BQUQsR0FBVSxLQUFBLENBQU0sQ0FBTixDQUZWLENBQUE7O0FBQUEsRUFHQSxlQUFDLENBQUEsR0FBRCxHQUFPLEtBQUEsYUFBTSxzREFBTixDQUhQLENBQUE7O0FBQUEsRUFJQSxlQUFDLENBQUEsU0FBRCxHQUFhLGVBQUMsQ0FBQSxHQUFELEdBQU8sZUFBQyxDQUFBLGFBSnJCLENBQUE7O3lCQUFBOztJQVJGLENBQUE7O0FBQUEsT0FjTyxDQUFDLEdBQVIsQ0FBWSxlQUFlLENBQUMsU0FBNUIsQ0FkQSxDQUFBOztBQUFBLE1BZ0JNLENBQUMsT0FBUCxHQUFpQixlQWhCakIsQ0FBQTs7Ozs7QUN1QkEsSUFBQSxNQUFBO0VBQUEsZ0ZBQUE7O0FBQUE7OztHQUNFOztBQUFBLG1CQUFBLE9BQUEsR0FBUyxTQUFBLEdBQUE7V0FDUCxJQUFDLENBQUEsSUFBSSxDQUFDLFlBQU4sQ0FBbUIsSUFBbkIsRUFETztFQUFBLENBQVQsQ0FBQTs7QUFHQTtBQUFBLDJCQUhBOztnQkFBQTs7SUFERixDQUFBOztBQUFBLE1BYU0sQ0FBQyxPQUFQLEdBQWlCLE1BYmpCLENBQUE7Ozs7O0FDdkJBLElBQUEsMEJBQUE7RUFBQSxnRkFBQTs7QUFBQSxZQUFBLEdBQWUsT0FBQSxDQUFRLGNBQVIsQ0FBZixDQUFBOztBQUFBLEVBQ0EsR0FBSyxPQUFBLENBQVEsSUFBUixDQURMLENBQUE7O0FBQUEsRUFFQSxHQUFLLE9BQUEsQ0FBUSxJQUFSLENBRkwsQ0FBQTs7QUFBQTtBQU1lLEVBQUEsY0FBQSxHQUFBO0FBQ1gseUNBQUEsQ0FBQTtBQUFBLCtDQUFBLENBQUE7QUFBQSxxQ0FBQSxDQUFBO0FBQUEsMkRBQUEsQ0FBQTtBQUFBLHFEQUFBLENBQUE7QUFBQSwrQ0FBQSxDQUFBO0FBQUEscUNBQUEsQ0FBQTtBQUFBLHVDQUFBLENBQUE7QUFBQSxJQUFBLElBQUMsQ0FBQSxRQUFELEdBQVk7QUFBQSxNQUNWLEdBQUEsRUFBSyxFQURLO0FBQUEsTUFFVixNQUFBLEVBQVEsRUFGRTtBQUFBLE1BR1YsSUFBQSxFQUFNLEVBSEk7QUFBQSxNQUlWLFVBQUEsRUFBWSxFQUpGO0FBQUEsTUFLVixTQUFBLEVBQVcsRUFMRDtBQUFBLE1BTVYsUUFBQSxFQUFVLEVBTkE7S0FBWixDQUFBO0FBQUEsSUFRQSxJQUFDLENBQUEsUUFBRCxHQUFnQixJQUFBLFlBQUEsQ0FBQSxDQVJoQixDQUFBO0FBQUEsSUFTQSxJQUFDLENBQUEsTUFBRCxHQUFVLElBQUMsQ0FBQSxRQUFRLENBQUMsTUFUcEIsQ0FBQTtBQUFBLElBVUEsSUFBQyxDQUFBLEtBQUQsR0FBYSxJQUFBLEVBQUUsQ0FBQyxLQUFILENBQVM7QUFBQSxNQUNwQixPQUFBLEVBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQURXO0tBQVQsQ0FWYixDQUFBO0FBQUEsSUFhQSxJQUFDLENBQUEsRUFBRCxHQUFVLElBQUEsRUFBQSxDQUFHLElBQUMsQ0FBQSxRQUFRLENBQUMsWUFBWSxDQUFDLElBQTFCLENBYlYsQ0FEVztFQUFBLENBQWI7O0FBQUEsaUJBaUJBLEtBQUEsR0FBTyxTQUFBLEdBQUE7QUFDTCxJQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksY0FBWixDQUFBLENBQUE7V0FDQSxNQUFNLENBQUMscUJBQVAsQ0FBNkIsSUFBQyxDQUFBLElBQTlCLEVBRks7RUFBQSxDQWpCUCxDQUFBOztBQUFBLGlCQXFCQSxJQUFBLEdBQU0sU0FBQSxHQUFBO0FBQ0osSUFBQSxNQUFNLENBQUMscUJBQVAsQ0FBNkIsSUFBQyxDQUFBLElBQTlCLENBQUEsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLElBQUQsQ0FBQSxDQURBLENBQUE7QUFBQSxJQUVBLElBQUMsQ0FBQSxLQUFLLENBQUMsSUFBUCxDQUFZLENBQUEsR0FBSSxFQUFoQixDQUZBLENBQUE7QUFBQSxJQUdBLElBQUMsQ0FBQSxNQUFELENBQUEsQ0FIQSxDQUFBO0FBQUEsSUFJQSxJQUFDLENBQUEsUUFBUSxDQUFDLE1BQVYsQ0FBQSxDQUpBLENBQUE7V0FLQSxJQUFDLENBQUEsU0FBRCxDQUFBLEVBTkk7RUFBQSxDQXJCTixDQUFBOztBQUFBLGlCQThCQSxTQUFBLEdBQVcsU0FBQyxNQUFELEdBQUE7QUFDVCxJQUFBLE1BQU0sQ0FBQyxJQUFQLEdBQWMsSUFBZCxDQUFBO0FBQ0EsSUFBQSxJQUFHLG9CQUFIO0FBQXNCLE1BQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSxJQUFiLENBQUEsQ0FBdEI7S0FEQTtBQUFBLElBRUEsSUFBQyxDQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBZCxDQUFtQixNQUFuQixDQUZBLENBQUE7QUFHQSxJQUFBLElBQUcscUJBQUg7QUFBdUIsTUFBQSxJQUFDLENBQUEsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFqQixDQUFzQixNQUF0QixDQUFBLENBQXZCO0tBSEE7QUFJQSxJQUFBLElBQUcseUJBQUg7QUFBMkIsTUFBQSxJQUFDLENBQUEsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFyQixDQUEwQixNQUExQixDQUFBLENBQTNCO0tBSkE7QUFLQSxJQUFBLElBQUcsbUJBQUg7QUFBcUIsTUFBQSxJQUFDLENBQUEsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFmLENBQW9CLE1BQXBCLENBQUEsQ0FBckI7S0FMQTtBQU1BLElBQUEsSUFBRyx3QkFBSDtBQUEwQixNQUFBLElBQUMsQ0FBQSxRQUFRLENBQUMsU0FBUyxDQUFDLElBQXBCLENBQXlCLE1BQXpCLENBQUEsQ0FBMUI7S0FOQTtBQU9BLElBQUEsSUFBRyxxQkFBSDtBQUF1QixNQUFBLElBQUMsQ0FBQSxRQUFRLENBQUMsR0FBVixDQUFjLE1BQU0sQ0FBQyxNQUFyQixFQUE2QixNQUFNLENBQUMsS0FBcEMsQ0FBQSxDQUF2QjtLQVBBO0FBUUEsSUFBQSxJQUFHLG1CQUFIO0FBQXFCLE1BQUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxPQUFQLENBQWUsTUFBTSxDQUFDLElBQXRCLENBQUEsQ0FBckI7S0FSQTtBQVVBLElBQUEsSUFBRyxzQkFBSDtBQUF3QixNQUFBLElBQUMsQ0FBQSxFQUFFLENBQUMsRUFBSixDQUFPLEVBQUUsQ0FBQyxLQUFWLEVBQWlCLE1BQU0sQ0FBQyxPQUF4QixDQUFBLENBQXhCO0tBVkE7QUFXQSxJQUFBLElBQUcsMEJBQUg7QUFBNEIsTUFBQSxJQUFDLENBQUEsRUFBRSxDQUFDLEVBQUosQ0FBTyxFQUFFLENBQUMsVUFBVixFQUFzQixNQUFNLENBQUMsV0FBN0IsQ0FBQSxDQUE1QjtLQVhBO0FBWUEsSUFBQSxJQUFHLHdCQUFIO0FBQTBCLE1BQUEsSUFBQyxDQUFBLEVBQUUsQ0FBQyxFQUFKLENBQU8sRUFBRSxDQUFDLFFBQVYsRUFBb0IsTUFBTSxDQUFDLFNBQTNCLENBQUEsQ0FBMUI7S0FaQTtBQWFBLElBQUEsSUFBRywyQkFBSDtBQUE2QixNQUFBLElBQUMsQ0FBQSxFQUFFLENBQUMsRUFBSixDQUFPLEVBQUUsQ0FBQyxXQUFWLEVBQXVCLE1BQU0sQ0FBQyxZQUE5QixDQUFBLENBQTdCO0tBYkE7QUFjQSxJQUFBLElBQUcsMEJBQUg7QUFBNEIsTUFBQSxJQUFDLENBQUEsRUFBRSxDQUFDLEVBQUosQ0FBTyxFQUFFLENBQUMsVUFBVixFQUFzQixNQUFNLENBQUMsV0FBN0IsQ0FBQSxDQUE1QjtLQWRBO0FBZUEsSUFBQSxJQUFHLHdCQUFIO0FBQTBCLE1BQUEsSUFBQyxDQUFBLEVBQUUsQ0FBQyxFQUFKLENBQU8sRUFBRSxDQUFDLFFBQVYsRUFBb0IsTUFBTSxDQUFDLFNBQTNCLENBQUEsQ0FBMUI7S0FmQTtBQWdCQSxJQUFBLElBQUcsd0JBQUg7QUFBMEIsTUFBQSxJQUFDLENBQUEsRUFBRSxDQUFDLEVBQUosQ0FBTyxFQUFFLENBQUMsUUFBVixFQUFvQixNQUFNLENBQUMsU0FBM0IsQ0FBQSxDQUExQjtLQWhCQTtBQWtCQSxJQUFBLElBQUcseUJBQUg7YUFBMkIsTUFBTSxDQUFDLFVBQVAsQ0FBa0IsSUFBbEIsRUFBM0I7S0FuQlM7RUFBQSxDQTlCWCxDQUFBOztBQUFBLGlCQW9EQSxZQUFBLEdBQWMsU0FBQyxNQUFELEdBQUE7V0FDWixJQUFDLENBQUEsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFuQixDQUF3QixNQUF4QixFQURZO0VBQUEsQ0FwRGQsQ0FBQTs7QUFBQSxpQkF3REEsZUFBQSxHQUFpQixTQUFBLEdBQUE7QUFFZixRQUFBLGVBQUE7QUFBQTtXQUFNLElBQUMsQ0FBQSxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQXpCLEdBQUE7QUFDRSxNQUFBLE1BQUEsR0FBUyxJQUFDLENBQUEsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFuQixDQUFBLENBQVQsQ0FBQTtBQUFBLE1BQ0EsSUFBQyxDQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBZCxDQUFxQixJQUFDLENBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFkLENBQXNCLE1BQXRCLENBQXJCLEVBQW9ELENBQXBELENBREEsQ0FBQTtBQUVBLE1BQUEsSUFBRyxxQkFBSDtBQUNFLFFBQUEsSUFBQyxDQUFBLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBakIsQ0FBd0IsSUFBQyxDQUFBLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBakIsQ0FBeUIsTUFBekIsQ0FBeEIsRUFBMEQsQ0FBMUQsQ0FBQSxDQURGO09BRkE7QUFJQSxNQUFBLElBQUcsbUJBQUg7QUFDRSxRQUFBLElBQUMsQ0FBQSxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQWYsQ0FBc0IsSUFBQyxDQUFBLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBZixDQUF1QixNQUF2QixDQUF0QixFQUFzRCxDQUF0RCxDQUFBLENBREY7T0FKQTtBQU1BLE1BQUEsSUFBRyx3QkFBSDtBQUNFLFFBQUEsSUFBQyxDQUFBLFFBQVEsQ0FBQyxTQUFTLENBQUMsTUFBcEIsQ0FBMkIsSUFBQyxDQUFBLFFBQVEsQ0FBQyxTQUFTLENBQUMsT0FBcEIsQ0FBNEIsTUFBNUIsQ0FBM0IsRUFBZ0UsQ0FBaEUsQ0FBQSxDQURGO09BTkE7QUFTQSxNQUFBLElBQUcscUJBQUg7QUFDRSxRQUFBLElBQUMsQ0FBQSxRQUFRLENBQUMsTUFBVixDQUFpQixNQUFNLENBQUMsTUFBeEIsRUFBZ0MsTUFBTSxDQUFDLEtBQXZDLENBQUEsQ0FERjtPQVRBO0FBV0EsTUFBQSxJQUFHLG1CQUFIO0FBQ0UsUUFBQSxJQUFDLENBQUEsS0FBSyxDQUFDLFVBQVAsQ0FBa0IsTUFBTSxDQUFDLElBQXpCLENBQUEsQ0FERjtPQVhBO0FBY0EsTUFBQSxJQUFHLHNCQUFIO0FBQXdCLFFBQUEsSUFBQyxDQUFBLEVBQUUsQ0FBQyxHQUFKLENBQVEsRUFBRSxDQUFDLEtBQVgsRUFBa0IsTUFBTSxDQUFDLE9BQXpCLENBQUEsQ0FBeEI7T0FkQTtBQWVBLE1BQUEsSUFBRywwQkFBSDtBQUE0QixRQUFBLElBQUMsQ0FBQSxFQUFFLENBQUMsR0FBSixDQUFRLEVBQUUsQ0FBQyxVQUFYLEVBQXVCLE1BQU0sQ0FBQyxXQUE5QixDQUFBLENBQTVCO09BZkE7QUFnQkEsTUFBQSxJQUFHLHdCQUFIO0FBQTBCLFFBQUEsSUFBQyxDQUFBLEVBQUUsQ0FBQyxHQUFKLENBQVEsRUFBRSxDQUFDLFFBQVgsRUFBcUIsTUFBTSxDQUFDLFNBQTVCLENBQUEsQ0FBMUI7T0FoQkE7QUFpQkEsTUFBQSxJQUFHLDJCQUFIO0FBQTZCLFFBQUEsSUFBQyxDQUFBLEVBQUUsQ0FBQyxHQUFKLENBQVEsRUFBRSxDQUFDLFdBQVgsRUFBd0IsTUFBTSxDQUFDLFlBQS9CLENBQUEsQ0FBN0I7T0FqQkE7QUFrQkEsTUFBQSxJQUFHLDBCQUFIO0FBQTRCLFFBQUEsSUFBQyxDQUFBLEVBQUUsQ0FBQyxHQUFKLENBQVEsRUFBRSxDQUFDLFVBQVgsRUFBdUIsTUFBTSxDQUFDLFdBQTlCLENBQUEsQ0FBNUI7T0FsQkE7QUFtQkEsTUFBQSxJQUFHLHdCQUFIO0FBQTBCLFFBQUEsSUFBQyxDQUFBLEVBQUUsQ0FBQyxHQUFKLENBQVEsRUFBRSxDQUFDLFFBQVgsRUFBcUIsTUFBTSxDQUFDLFNBQTVCLENBQUEsQ0FBMUI7T0FuQkE7QUFvQkEsTUFBQSxJQUFHLHdCQUFIO0FBQTBCLFFBQUEsSUFBQyxDQUFBLEVBQUUsQ0FBQyxHQUFKLENBQVEsRUFBRSxDQUFDLFFBQVgsRUFBcUIsTUFBTSxDQUFDLFNBQTVCLENBQUEsQ0FBMUI7T0FwQkE7QUFzQkEsTUFBQSxJQUFHLHdCQUFIO0FBQ0UsUUFBQSxNQUFNLENBQUMsU0FBUCxDQUFpQixJQUFqQixDQUFBLENBREY7T0F0QkE7QUFBQSxtQkF3QkEsTUFBTSxDQUFDLElBQVAsR0FBYyxLQXhCZCxDQURGO0lBQUEsQ0FBQTttQkFGZTtFQUFBLENBeERqQixDQUFBOztBQUFBLGlCQXNGQSxJQUFBLEdBQU0sU0FBQSxHQUFBO0FBQ0osUUFBQSwyQ0FBQTtBQUFBLElBQUEsSUFBQyxDQUFBLGVBQUQsQ0FBQSxDQUFBLENBQUE7QUFDQTtBQUFBLFNBQUEscUNBQUE7c0JBQUE7QUFDRSxNQUFBLE1BQU0sQ0FBQyxVQUFQLENBQUEsQ0FBQSxDQURGO0FBQUEsS0FEQTtBQUFBLElBR0EsSUFBQyxDQUFBLGVBQUQsQ0FBQSxDQUhBLENBQUE7QUFJQTtBQUFBO1NBQUEsd0NBQUE7dUJBQUE7QUFDRSxtQkFBQSxNQUFNLENBQUMsSUFBUCxDQUFBLEVBQUEsQ0FERjtBQUFBO21CQUxJO0VBQUEsQ0F0Rk4sQ0FBQTs7QUFBQSxpQkErRkEsU0FBQSxHQUFXLFNBQUEsR0FBQTtBQUNULFFBQUEsNEJBQUE7QUFBQSxJQUFBLElBQUMsQ0FBQSxlQUFELENBQUEsQ0FBQSxDQUFBO0FBQ0E7QUFBQTtTQUFBLHFDQUFBO3NCQUFBO0FBQ0UsbUJBQUEsTUFBTSxDQUFDLFNBQVAsQ0FBQSxFQUFBLENBREY7QUFBQTttQkFGUztFQUFBLENBL0ZYLENBQUE7O0FBQUEsaUJBcUdBLE1BQUEsR0FBUSxTQUFBLEdBQUE7QUFDTixRQUFBLDRCQUFBO0FBQUEsSUFBQSxJQUFDLENBQUEsZUFBRCxDQUFBLENBQUEsQ0FBQTtBQUNBO0FBQUE7U0FBQSxxQ0FBQTtzQkFBQTtBQUNFLG1CQUFBLE1BQU0sQ0FBQyxNQUFQLENBQUEsRUFBQSxDQURGO0FBQUE7bUJBRk07RUFBQSxDQXJHUixDQUFBOztjQUFBOztJQU5GLENBQUE7O0FBQUEsTUFnSE0sQ0FBQyxPQUFQLEdBQWlCLElBaEhqQixDQUFBOzs7OztBQ0FBLElBQUEsMEJBQUE7RUFBQSxnRkFBQTs7QUFBQSxJQUFBLEdBQU8sT0FBQSxDQUFRLFNBQVIsQ0FBUCxDQUFBOztBQUFBLE1BQ0EsR0FBUyxPQUFBLENBQVEsUUFBUixDQURULENBQUE7O0FBQUE7QUFPZSxFQUFBLHNCQUFBLEdBQUE7QUFDWCx5Q0FBQSxDQUFBO0FBQUEsbUNBQUEsQ0FBQTtBQUFBLHlDQUFBLENBQUE7QUFBQSxRQUFBLG1EQUFBO0FBQUEsSUFBQSxNQUFTLENBQUMsTUFBTSxDQUFDLFVBQVIsRUFBb0IsTUFBTSxDQUFDLFdBQTNCLENBQVQsRUFBQyxVQUFELEVBQUksVUFBSixDQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsWUFBRCxHQUFnQixJQUFJLENBQUMsa0JBQUwsQ0FBd0IsQ0FBeEIsRUFBMkIsQ0FBM0IsRUFBOEI7QUFBQSxNQUFDLFNBQUEsRUFBVyxLQUFaO0tBQTlCLENBRGhCLENBQUE7QUFBQSxJQUVBLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBZCxDQUEwQixJQUFDLENBQUEsWUFBWSxDQUFDLElBQXhDLENBRkEsQ0FBQTtBQUFBLElBR0EsSUFBQyxDQUFBLEtBQUQsR0FBYSxJQUFBLElBQUksQ0FBQyxTQUFMLENBQUEsQ0FIYixDQUFBO0FBQUEsSUFJQSxJQUFDLENBQUEsTUFBRCxHQUFjLElBQUEsTUFBQSxDQUFPLElBQVAsQ0FKZCxDQUFBO0FBQUEsSUFNQSxJQUFDLENBQUEsVUFBRCxHQUFjLEVBTmQsQ0FBQTtBQUFBLElBT0EsSUFBQyxDQUFBLFVBQVcsQ0FBQSxNQUFBLENBQVosR0FBc0I7QUFBQSxNQUFFLE1BQUEsRUFBUSxDQUFWO0tBUHRCLENBQUE7QUFBQSxJQVFBLElBQUMsQ0FBQSxVQUFXLENBQUEsS0FBQSxDQUFaLEdBQXFCO0FBQUEsTUFBRSxNQUFBLEVBQVEsQ0FBVjtLQVJyQixDQUFBO0FBQUEsSUFTQSxJQUFDLENBQUEsVUFBVyxDQUFBLGVBQUEsQ0FBWixHQUErQjtBQUFBLE1BQUUsTUFBQSxFQUFRLENBQVY7S0FUL0IsQ0FBQTtBQUFBLElBVUEsSUFBQyxDQUFBLFVBQVcsQ0FBQSxhQUFBLENBQVosR0FBNkI7QUFBQSxNQUFFLE1BQUEsRUFBUSxDQUFWO0tBVjdCLENBQUE7QUFBQSxJQVdBLElBQUMsQ0FBQSxVQUFXLENBQUEsT0FBQSxDQUFaLEdBQXVCO0FBQUEsTUFBRSxNQUFBLEVBQVEsQ0FBVjtLQVh2QixDQUFBO0FBQUEsSUFZQSxJQUFDLENBQUEsVUFBVyxDQUFBLFlBQUEsQ0FBWixHQUE0QjtBQUFBLE1BQUUsTUFBQSxFQUFRLENBQVY7S0FaNUIsQ0FBQTtBQUFBLElBY0EsS0FBQSxHQUFRLENBQUMsTUFBRCxFQUFTLEtBQVQsRUFBZ0IsZUFBaEIsRUFBaUMsYUFBakMsRUFBZ0QsT0FBaEQsRUFBeUQsWUFBekQsQ0FkUixDQUFBO0FBZUEsU0FBQSwrQ0FBQTtzQkFBQTtBQUNFLE1BQUEsU0FBQSxHQUFZLElBQUMsQ0FBQSxVQUFXLENBQUEsSUFBQSxDQUF4QixDQUFBO0FBQUEsTUFDQSxTQUFTLENBQUMsSUFBVixHQUFpQixJQURqQixDQUFBO0FBQUEsTUFFQSxLQUFBLEdBQVksSUFBQSxJQUFJLENBQUMsU0FBTCxDQUFBLENBRlosQ0FBQTtBQUFBLE1BR0EsU0FBUyxDQUFDLEtBQVYsR0FBa0IsQ0FIbEIsQ0FBQTtBQUFBLE1BSUEsU0FBUyxDQUFDLEtBQVYsR0FBa0IsS0FKbEIsQ0FBQTtBQUFBLE1BS0EsSUFBQyxDQUFBLEtBQUssQ0FBQyxVQUFQLENBQWtCLEtBQWxCLEVBQXlCLENBQXpCLENBTEEsQ0FERjtBQUFBLEtBaEJXO0VBQUEsQ0FBYjs7QUFBQSx5QkF5QkEsTUFBQSxHQUFRLFNBQUMsTUFBRCxHQUFBO0FBQ04sUUFBQSxlQUFBO0FBQUEsSUFBQSxJQUFDLENBQUEsTUFBTSxDQUFDLElBQVIsQ0FBQSxDQUFBLENBQUE7QUFDQTtBQUFBLFNBQUEsV0FBQTt1QkFBQTtBQUNFLE1BQUEsSUFBQyxDQUFBLE1BQU0sQ0FBQyxXQUFSLENBQW9CLElBQXBCLENBQUEsQ0FERjtBQUFBLEtBREE7V0FJQSxJQUFDLENBQUEsWUFBWSxDQUFDLE1BQWQsQ0FBcUIsSUFBQyxDQUFBLEtBQXRCLEVBTE07RUFBQSxDQXpCUixDQUFBOztBQUFBLHlCQWlDQSxHQUFBLEdBQUssU0FBQyxNQUFELEVBQVMsS0FBVCxHQUFBOztNQUFTLFFBQU07S0FDbEI7V0FBQSxJQUFDLENBQUEsVUFBVyxDQUFBLEtBQUssQ0FBQyxXQUFOLENBQUEsQ0FBQSxDQUFvQixDQUFDLEtBQUssQ0FBQyxRQUF2QyxDQUFnRCxNQUFoRCxFQURHO0VBQUEsQ0FqQ0wsQ0FBQTs7QUFBQSx5QkFxQ0EsTUFBQSxHQUFRLFNBQUMsTUFBRCxFQUFTLEtBQVQsR0FBQTs7TUFBUyxRQUFNO0tBQ3JCO1dBQUEsSUFBQyxDQUFBLFVBQVcsQ0FBQSxLQUFLLENBQUMsV0FBTixDQUFBLENBQUEsQ0FBb0IsQ0FBQyxLQUFLLENBQUMsV0FBdkMsQ0FBbUQsTUFBbkQsRUFETTtFQUFBLENBckNSLENBQUE7O3NCQUFBOztJQVBGLENBQUE7O0FBQUEsTUErQ00sQ0FBQyxPQUFQLEdBQWlCLFlBL0NqQixDQUFBOzs7OztBQ0VBLElBQUEsRUFBQTtFQUFBLGdGQUFBOztBQUFBO0FBQ0UsTUFBQSwyR0FBQTs7QUFBQSxFQUFBLEVBQUMsQ0FBQSxHQUFELEdBQU8sR0FBQSxHQUFNLENBQWIsQ0FBQTs7QUFBQSxFQUNBLEVBQUMsQ0FBQSxHQUFELEdBQU8sR0FBQSxHQUFNLENBRGIsQ0FBQTs7QUFBQSxFQUVBLEVBQUMsQ0FBQSxHQUFELEdBQU8sR0FBQSxHQUFNLENBRmIsQ0FBQTs7QUFBQSxFQUlBLEVBQUMsQ0FBQSxNQUFELEdBQVUsRUFKVixDQUFBOztBQUFBLEVBS0EsRUFBQyxDQUFBLEtBQUQsR0FBUyxFQUxULENBQUE7O0FBQUEsRUFPQSxFQUFDLENBQUEsVUFBRCxHQUFjLFVBQUEsR0FBYSxXQVAzQixDQUFBOztBQUFBLEVBUUEsRUFBQyxDQUFBLEtBQUQsR0FBUyxLQUFBLEdBQVEsT0FSakIsQ0FBQTs7QUFBQSxFQVNBLEVBQUMsQ0FBQSxXQUFELEdBQWUsV0FBQSxHQUFjLFlBVDdCLENBQUE7O0FBQUEsRUFVQSxFQUFDLENBQUEsUUFBRCxHQUFZLFFBQUEsR0FBVyxTQVZ2QixDQUFBOztBQUFBLEVBV0EsRUFBQyxDQUFBLFVBQUQsR0FBYyxVQUFBLEdBQWEsV0FYM0IsQ0FBQTs7QUFBQSxFQVlBLEVBQUMsQ0FBQSxRQUFELEdBQVksUUFBQSxHQUFXLFNBWnZCLENBQUE7O0FBQUEsRUFhQSxFQUFDLENBQUEsVUFBRCxHQUFjLFVBQUEsR0FBYSxXQWIzQixDQUFBOztBQUFBLEVBY0EsRUFBQyxDQUFBLFVBQUQsR0FBYyxVQUFBLEdBQWEsV0FkM0IsQ0FBQTs7QUFBQSxFQWVBLEVBQUMsQ0FBQSxRQUFELEdBQVksUUFBQSxHQUFXLFNBZnZCLENBQUE7O0FBQUEsRUFnQkEsRUFBQyxDQUFBLE1BQUQsR0FBVSxNQUFBLEdBQVMsT0FoQm5CLENBQUE7O0FBa0JhLEVBQUEsWUFBQyxJQUFELEdBQUE7QUFDWCxRQUFBLElBQUE7QUFBQSxJQURZLElBQUMsQ0FBQSxPQUFELElBQ1osQ0FBQTtBQUFBLHVDQUFBLENBQUE7QUFBQSwyQ0FBQSxDQUFBO0FBQUEsMkNBQUEsQ0FBQTtBQUFBLCtDQUFBLENBQUE7QUFBQSx1Q0FBQSxDQUFBO0FBQUEsK0NBQUEsQ0FBQTtBQUFBLG1DQUFBLENBQUE7QUFBQSxpQ0FBQSxDQUFBO0FBQUEsSUFBQSxJQUFDLENBQUEsSUFBSSxDQUFDLE9BQU4sR0FBZ0IsSUFBQyxDQUFBLEtBQWpCLENBQUE7QUFBQSxJQUNBLElBQUMsQ0FBQSxJQUFJLENBQUMsV0FBTixHQUFvQixJQUFDLENBQUEsU0FEckIsQ0FBQTtBQUFBLElBRUEsSUFBQyxDQUFBLElBQUksQ0FBQyxTQUFOLEdBQWtCLElBQUMsQ0FBQSxPQUZuQixDQUFBO0FBQUEsSUFHQSxJQUFDLENBQUEsSUFBSSxDQUFDLFdBQU4sR0FBb0IsSUFBQyxDQUFBLFNBSHJCLENBQUE7QUFBQSxJQUlBLElBQUMsQ0FBQSxJQUFJLENBQUMsV0FBTixHQUFvQixJQUFDLENBQUEsU0FKckIsQ0FBQTtBQUFBLElBS0EsUUFBUSxDQUFDLFNBQVQsR0FBcUIsSUFBQyxDQUFBLE9BTHRCLENBQUE7QUFBQSxJQU1BLFFBQVEsQ0FBQyxPQUFULEdBQW1CLElBQUMsQ0FBQSxLQU5wQixDQUFBO0FBQUEsSUFPQSxJQUFDLENBQUEsSUFBSSxDQUFDLGFBQU4sR0FBc0IsQ0FBQSxTQUFBLEtBQUEsR0FBQTthQUFBLFNBQUMsQ0FBRCxHQUFBO0FBQ3BCLFFBQUEsQ0FBQyxDQUFDLGNBQUYsQ0FBQSxDQUFBLENBQUE7QUFBQSxRQUNBLEtBQUMsQ0FBQSxLQUFELENBQU8sQ0FBUCxDQURBLENBQUE7ZUFFQSxNQUhvQjtNQUFBLEVBQUE7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBUHRCLENBQUE7QUFBQSxJQVlBLElBQUMsQ0FBQSxJQUFELEdBQVEsRUFaUixDQUFBO0FBYUEsU0FBUyw0QkFBVCxHQUFBO0FBQ0UsTUFBQSxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxLQUFYLENBQUEsQ0FERjtBQUFBLEtBYkE7QUFBQSxJQWdCQSxJQUFDLENBQUEsYUFBRCxHQUFpQixDQUFDLENBQUQsRUFBSSxDQUFKLENBaEJqQixDQUFBO0FBQUEsSUFrQkEsSUFBQyxDQUFBLFNBQUQsR0FBYSxFQWxCYixDQUFBO0FBQUEsSUFtQkEsSUFBQyxDQUFBLFNBQVUsQ0FBQSxLQUFBLENBQVgsR0FBb0IsRUFuQnBCLENBQUE7QUFBQSxJQW9CQSxJQUFDLENBQUEsU0FBVSxDQUFBLFdBQUEsQ0FBWCxHQUEwQixFQXBCMUIsQ0FBQTtBQUFBLElBcUJBLElBQUMsQ0FBQSxTQUFVLENBQUEsUUFBQSxDQUFYLEdBQXVCLEVBckJ2QixDQUFBO0FBQUEsSUFzQkEsSUFBQyxDQUFBLFNBQVUsQ0FBQSxVQUFBLENBQVgsR0FBeUIsRUF0QnpCLENBQUE7QUFBQSxJQXVCQSxJQUFDLENBQUEsU0FBVSxDQUFBLFFBQUEsQ0FBWCxHQUF1QixFQXZCdkIsQ0FBQTtBQUFBLElBd0JBLElBQUMsQ0FBQSxTQUFVLENBQUEsVUFBQSxDQUFYLEdBQXlCLEVBeEJ6QixDQUFBO0FBQUEsSUF5QkEsSUFBQyxDQUFBLFNBQVUsQ0FBQSxVQUFBLENBQVgsR0FBeUIsRUF6QnpCLENBQUE7QUFBQSxJQTBCQSxJQUFDLENBQUEsU0FBVSxDQUFBLFFBQUEsQ0FBWCxHQUF1QixFQTFCdkIsQ0FBQTtBQUFBLElBMkJBLElBQUMsQ0FBQSxTQUFVLENBQUEsTUFBQSxDQUFYLEdBQXFCLEVBM0JyQixDQUFBO0FBQUEsSUE2QkEsSUFBQyxDQUFBLE9BQUQsR0FBVyxDQUFDLEtBQUQsRUFBUSxLQUFSLEVBQWUsS0FBZixFQUFzQixLQUF0QixFQUE2QixLQUE3QixFQUFvQyxLQUFwQyxDQTdCWCxDQURXO0VBQUEsQ0FsQmI7O0FBQUEsZUFtREEsRUFBQSxHQUFJLFNBQUMsQ0FBRCxFQUFJLFFBQUosR0FBQTtBQUNGLFFBQUEsSUFBQTs7VUFBVyxDQUFBLENBQUEsSUFBTTtLQUFqQjtXQUNBLElBQUMsQ0FBQSxTQUFVLENBQUEsQ0FBQSxDQUFFLENBQUMsSUFBZCxDQUFtQixRQUFuQixFQUZFO0VBQUEsQ0FuREosQ0FBQTs7QUFBQSxlQXdEQSxHQUFBLEdBQUssU0FBQyxDQUFELEVBQUksUUFBSixHQUFBO1dBQ0gsSUFBQyxDQUFBLFNBQVUsQ0FBQSxDQUFBLENBQUUsQ0FBQyxNQUFkLENBQXFCLElBQUMsQ0FBQSxTQUFVLENBQUEsQ0FBQSxDQUFFLENBQUMsT0FBZCxDQUFzQixRQUF0QixDQUFyQixFQUFzRCxDQUF0RCxFQURHO0VBQUEsQ0F4REwsQ0FBQTs7QUFBQSxlQTREQSxTQUFBLEdBQVcsU0FBQyxDQUFELEdBQUE7QUFDVCxRQUFBLDhCQUFBO0FBQUEsSUFBQSxJQUFDLENBQUEsYUFBRCxHQUFpQixDQUFDLENBQUMsQ0FBQyxPQUFILEVBQVksQ0FBQyxDQUFDLE9BQWQsQ0FBakIsQ0FBQTtBQUNBO0FBQUE7U0FBQSxxQ0FBQTt3QkFBQTtBQUNFLG1CQUFBLFFBQUEsQ0FBUyxJQUFDLENBQUEsYUFBVixFQUFBLENBREY7QUFBQTttQkFGUztFQUFBLENBNURYLENBQUE7O0FBQUEsZUFrRUEsS0FBQSxHQUFPLFNBQUMsQ0FBRCxHQUFBO0FBQ0wsUUFBQSx1REFBQTtBQUFBLElBQUEsSUFBQyxDQUFBLGFBQUQsR0FBaUIsQ0FBQyxDQUFDLENBQUMsT0FBSCxFQUFZLENBQUMsQ0FBQyxPQUFkLENBQWpCLENBQUE7QUFDQSxZQUFPLENBQUMsQ0FBQyxNQUFUO0FBQUEsV0FDTyxHQURQO0FBRUk7QUFBQTthQUFBLHFDQUFBOzRCQUFBO0FBQ0UsdUJBQUEsUUFBQSxDQUFTLElBQUMsQ0FBQSxhQUFWLEVBQUEsQ0FERjtBQUFBO3VCQUZKO0FBQ087QUFEUCxXQUlPLEdBSlA7QUFLSTtBQUFBO2FBQUEsd0NBQUE7NkJBQUE7QUFDRSx3QkFBQSxRQUFBLENBQVMsSUFBQyxDQUFBLGFBQVYsRUFBQSxDQURGO0FBQUE7d0JBTEo7QUFBQSxLQUZLO0VBQUEsQ0FsRVAsQ0FBQTs7QUFBQSxlQTZFQSxTQUFBLEdBQVcsU0FBQyxDQUFELEdBQUE7QUFDVCxRQUFBLHVEQUFBO0FBQUEsSUFBQSxJQUFDLENBQUEsYUFBRCxHQUFpQixDQUFDLENBQUMsQ0FBQyxPQUFILEVBQVksQ0FBQyxDQUFDLE9BQWQsQ0FBakIsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLE9BQVEsQ0FBQSxDQUFDLENBQUMsTUFBRixDQUFULEdBQXFCLElBRHJCLENBQUE7QUFFQSxZQUFPLENBQUMsQ0FBQyxNQUFUO0FBQUEsV0FDTyxHQURQO0FBRUk7QUFBQTthQUFBLHFDQUFBOzRCQUFBO0FBQ0UsdUJBQUEsUUFBQSxDQUFTLElBQUMsQ0FBQSxhQUFWLEVBQUEsQ0FERjtBQUFBO3VCQUZKO0FBQ087QUFEUCxXQUlPLEdBSlA7QUFLSTtBQUFBO2FBQUEsd0NBQUE7NkJBQUE7QUFDRSx3QkFBQSxRQUFBLENBQVMsSUFBQyxDQUFBLGFBQVYsRUFBQSxDQURGO0FBQUE7d0JBTEo7QUFBQSxLQUhTO0VBQUEsQ0E3RVgsQ0FBQTs7QUFBQSxlQXlGQSxPQUFBLEdBQVMsU0FBQyxDQUFELEdBQUE7QUFDUCxRQUFBLHVEQUFBO0FBQUEsSUFBQSxJQUFDLENBQUEsYUFBRCxHQUFpQixDQUFDLENBQUMsQ0FBQyxPQUFILEVBQVksQ0FBQyxDQUFDLE9BQWQsQ0FBakIsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLE9BQVEsQ0FBQSxDQUFDLENBQUMsTUFBRixDQUFULEdBQXFCLEtBRHJCLENBQUE7QUFFQSxZQUFPLENBQUMsQ0FBQyxNQUFUO0FBQUEsV0FDTyxHQURQO0FBRUk7QUFBQTthQUFBLHFDQUFBOzRCQUFBO0FBQ0UsdUJBQUEsUUFBQSxDQUFTLElBQUMsQ0FBQSxhQUFWLEVBQUEsQ0FERjtBQUFBO3VCQUZKO0FBQ087QUFEUCxXQUlPLEdBSlA7QUFLSTtBQUFBO2FBQUEsd0NBQUE7NkJBQUE7QUFDRSx3QkFBQSxRQUFBLENBQVMsSUFBQyxDQUFBLGFBQVYsRUFBQSxDQURGO0FBQUE7d0JBTEo7QUFBQSxLQUhPO0VBQUEsQ0F6RlQsQ0FBQTs7QUFBQSxlQXFHQSxPQUFBLEdBQVMsU0FBQyxDQUFELEdBQUE7QUFDUCxRQUFBLCtDQUFBO0FBQUEsSUFBQSxHQUFBLEdBQU0sQ0FBQyxDQUFDLEtBQVIsQ0FBQTtBQUFBLElBQ0EsVUFBQSxHQUFhLElBQUMsQ0FBQSxJQUFLLENBQUEsR0FBQSxDQURuQixDQUFBO0FBQUEsSUFFQSxJQUFDLENBQUEsSUFBSyxDQUFBLEdBQUEsQ0FBTixHQUFhLElBRmIsQ0FBQTtBQUdBLElBQUEsSUFBRyxDQUFBLFVBQUg7QUFDRTtBQUFBO1dBQUEscUNBQUE7MEJBQUE7QUFDRSxxQkFBQSxRQUFBLENBQVMsR0FBVCxFQUFBLENBREY7QUFBQTtxQkFERjtLQUpPO0VBQUEsQ0FyR1QsQ0FBQTs7QUFBQSxlQThHQSxLQUFBLEdBQU8sU0FBQyxDQUFELEdBQUE7QUFDTCxRQUFBLG1DQUFBO0FBQUEsSUFBQSxHQUFBLEdBQU0sQ0FBQyxDQUFDLEtBQVIsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLElBQUssQ0FBQSxHQUFBLENBQU4sR0FBYSxLQURiLENBQUE7QUFFQTtBQUFBO1NBQUEscUNBQUE7d0JBQUE7QUFDRSxtQkFBQSxRQUFBLENBQVMsR0FBVCxFQUFBLENBREY7QUFBQTttQkFISztFQUFBLENBOUdQLENBQUE7O1lBQUE7O0lBREYsQ0FBQTs7QUFBQSxNQXNITSxDQUFDLE9BQVAsR0FBaUIsRUF0SGpCLENBQUE7Ozs7O0FDRkEsSUFBQSx5Q0FBQTtFQUFBOzs2QkFBQTs7QUFBQSxlQUFBLEdBQWtCLE9BQUEsQ0FBUSxpQkFBUixDQUFsQixDQUFBOztBQUFBLE1BQ0EsR0FBUyxPQUFBLENBQVEsUUFBUixDQURULENBQUE7O0FBQUEsRUFFQSxHQUFLLE9BQUEsQ0FBUSxJQUFSLENBRkwsQ0FBQTs7QUFBQSxJQUdBLEdBQU8sT0FBQSxDQUFRLFNBQVIsQ0FIUCxDQUFBOztBQUFBO0FBT0UsTUFBQSxtREFBQTs7QUFBQSw0QkFBQSxDQUFBOztBQUFBLEVBQUEsTUFBQSxHQUFTLEdBQVQsQ0FBQTs7QUFBQSxFQUNBLFVBQUEsR0FBYSxDQURiLENBQUE7O0FBQUEsRUFFQSxhQUFBLEdBQWdCLEdBRmhCLENBQUE7O0FBQUEsRUFHQSxnQkFBQSxHQUFtQixFQUhuQixDQUFBOztBQUthLEVBQUEsZ0JBQUMsQ0FBRCxFQUFNLENBQU4sRUFBVyxJQUFYLEdBQUE7QUFDWCxRQUFBLEtBQUE7O01BRFksSUFBRTtLQUNkOztNQURpQixJQUFFO0tBQ25COztNQURzQixPQUFLO0tBQzNCO0FBQUEscUNBQUEsQ0FBQTtBQUFBLHlDQUFBLENBQUE7QUFBQSxxQ0FBQSxDQUFBO0FBQUEsdUNBQUEsQ0FBQTtBQUFBLElBQUEsSUFBQyxDQUFBLElBQUQsR0FBWSxJQUFBLEVBQUUsQ0FBQyxJQUFILENBQVE7QUFBQSxNQUNsQixRQUFBLEVBQVUsQ0FBQyxDQUFELEVBQUksQ0FBSixDQURRO0FBQUEsTUFFbEIsSUFBQSxFQUFNLEdBRlk7QUFBQSxNQUdsQixjQUFBLEVBQWdCLElBSEU7QUFBQSxNQUlsQixPQUFBLEVBQVMsQ0FKUztLQUFSLENBQVosQ0FBQTtBQUFBLElBTUEsS0FBQSxHQUFZLElBQUEsRUFBRSxDQUFDLE1BQUgsQ0FBVSxNQUFWLENBTlosQ0FBQTtBQUFBLElBT0EsS0FBSyxDQUFDLGNBQU4sR0FBdUIsZUFBZSxDQUFDLE1BUHZDLENBQUE7QUFBQSxJQVFBLEtBQUssQ0FBQyxhQUFOLEdBQXNCLGVBQWUsQ0FBQyxTQVJ0QyxDQUFBO0FBQUEsSUFTQSxJQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBZSxLQUFmLENBVEEsQ0FBQTtBQUFBLElBV0EsSUFBQyxDQUFBLE1BQUQsR0FBYyxJQUFBLElBQUksQ0FBQyxRQUFMLENBQUEsQ0FYZCxDQUFBO0FBQUEsSUFZQSxJQUFDLENBQUEsTUFBTSxDQUFDLFNBQVIsQ0FBa0IsUUFBbEIsQ0FaQSxDQUFBO0FBQUEsSUFhQSxJQUFDLENBQUEsTUFBTSxDQUFDLFVBQVIsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsRUFBeUIsTUFBekIsQ0FiQSxDQUFBO0FBQUEsSUFjQSxJQUFDLENBQUEsTUFBTSxDQUFDLE9BQVIsQ0FBQSxDQWRBLENBQUE7QUFBQSxJQWdCQSxJQUFDLENBQUEsS0FBRCxDQUFPLElBQVAsQ0FoQkEsQ0FEVztFQUFBLENBTGI7O0FBQUEsRUF3QkEsTUFBQyxDQUFBLFFBQUQsQ0FBVSxVQUFWLEVBQ0U7QUFBQSxJQUFBLEdBQUEsRUFBSyxTQUFBLEdBQUE7QUFDSCxhQUFPLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBYixDQURHO0lBQUEsQ0FBTDtHQURGLENBeEJBLENBQUE7O0FBQUEsbUJBNEJBLEtBQUEsR0FBTyxTQUFDLElBQUQsR0FBQTtBQUNMLElBQUEsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFSLENBQUE7QUFDQSxJQUFBLElBQUcsWUFBSDthQUNFLElBQUMsQ0FBQSxZQUFELEdBQWdCLElBQUMsQ0FBQSxJQUFJLENBQUMsWUFBTixDQUFtQixJQUFDLENBQUEsSUFBSSxDQUFDLFFBQXpCLEVBRGxCO0tBQUEsTUFBQTthQUdFLElBQUMsQ0FBQSxZQUFELEdBQWdCLEtBSGxCO0tBRks7RUFBQSxDQTVCUCxDQUFBOztBQUFBLG1CQW1DQSxJQUFBLEdBQU0sU0FBQyxHQUFELEdBQUE7QUFDSixRQUFBLFdBQUE7QUFBQSxJQURNLFlBQUcsVUFDVCxDQUFBO0FBQUEsSUFBQSxLQUFBLEdBQVcsaUJBQUgsR0FBZSxVQUFmLEdBQStCLGFBQXZDLENBQUE7QUFBQSxJQUNBLElBQUMsQ0FBQSxJQUFJLENBQUMsS0FBTSxDQUFBLENBQUEsQ0FBWixJQUFrQixDQUFBLEdBQUksS0FEdEIsQ0FBQTtXQUVBLElBQUMsQ0FBQSxJQUFJLENBQUMsS0FBTSxDQUFBLENBQUEsQ0FBWixJQUFrQixDQUFBLEdBQUksTUFIbEI7RUFBQSxDQW5DTixDQUFBOztBQUFBLG1CQXdDQSxNQUFBLEdBQVEsU0FBQSxHQUFBO0FBQ04sUUFBQSxHQUFBO1dBQUEsTUFBeUIsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUEvQixFQUFDLElBQUMsQ0FBQSxNQUFNLENBQUMsVUFBVCxFQUFZLElBQUMsQ0FBQSxNQUFNLENBQUMsVUFBcEIsRUFBQSxJQURNO0VBQUEsQ0F4Q1IsQ0FBQTs7QUFBQSxtQkEyQ0EsSUFBQSxHQUFNLFNBQUEsR0FBQTtBQUNKLFFBQUEsK0JBQUE7QUFBQSxJQUFBLElBQUcsaUJBQUg7QUFDRSxNQUFBLFlBQUEsR0FBZSxJQUFDLENBQUEsSUFBSSxDQUFDLG9CQUFOLENBQTJCLElBQUMsQ0FBQSxRQUE1QixDQUFmLENBQUE7QUFBQSxNQUVBLEVBQUEsR0FBSyxZQUFhLENBQUEsQ0FBQSxDQUFiLEdBQWtCLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBUyxDQUFBLENBQUEsQ0FGdEMsQ0FBQTtBQUFBLE1BR0EsRUFBQSxHQUFLLFlBQWEsQ0FBQSxDQUFBLENBQWIsR0FBa0IsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFTLENBQUEsQ0FBQSxDQUh0QyxDQUFBO0FBQUEsTUFLQSxFQUFBLElBQU0sR0FMTixDQUFBO0FBQUEsTUFNQSxFQUFBLElBQU0sR0FOTixDQUFBO0FBQUEsTUFRQSxTQUFBLEdBQVksSUFBSSxDQUFDLElBQUwsQ0FBVSxFQUFBLEdBQUssRUFBTCxHQUFVLEVBQUEsR0FBSyxFQUF6QixDQVJaLENBQUE7QUFTQSxNQUFBLElBQUcsU0FBQSxHQUFZLGdCQUFmO0FBQ0UsUUFBQSxFQUFBLElBQU0sZ0JBQUEsR0FBbUIsU0FBekIsQ0FBQTtBQUFBLFFBQ0EsRUFBQSxJQUFNLGdCQUFBLEdBQW1CLFNBRHpCLENBREY7T0FUQTtBQUFBLE1BYUEsSUFBQyxDQUFBLElBQUksQ0FBQyxLQUFNLENBQUEsQ0FBQSxDQUFaLElBQWtCLEVBQUEsR0FBSyxJQUFDLENBQUEsSUFBSSxDQUFDLElBYjdCLENBQUE7YUFjQSxJQUFDLENBQUEsSUFBSSxDQUFDLEtBQU0sQ0FBQSxDQUFBLENBQVosSUFBa0IsRUFBQSxHQUFLLElBQUMsQ0FBQSxJQUFJLENBQUMsS0FmL0I7S0FESTtFQUFBLENBM0NOLENBQUE7O2dCQUFBOztHQURtQixPQU5yQixDQUFBOztBQUFBLE1Bb0VNLENBQUMsT0FBUCxHQUFpQixNQXBFakIsQ0FBQTs7Ozs7QUNBQSxJQUFBLDhCQUFBO0VBQUE7OzZCQUFBOztBQUFBLE1BQUEsR0FBUyxPQUFBLENBQVEsUUFBUixDQUFULENBQUE7O0FBQUE7QUFHRSxNQUFBLDhDQUFBOztBQUFBLDRDQUFBLENBQUE7O0FBQUEsRUFBQSxTQUFBLEdBQVksRUFBWixDQUFBOztBQUFBLEVBQ0EsVUFBQSxHQUFhLEVBRGIsQ0FBQTs7QUFBQSxFQUVBLE1BQUEsR0FBUyxFQUZULENBQUE7O0FBQUEsRUFHQSxPQUFBLEdBQVUsRUFIVixDQUFBOztBQUFBLEVBSUEsTUFBQSxHQUFTLEVBSlQsQ0FBQTs7QUFNYSxFQUFBLGdDQUFDLE1BQUQsR0FBQTtBQUFXLElBQVYsSUFBQyxDQUFBLFNBQUQsTUFBVSxDQUFBO0FBQUEsaURBQUEsQ0FBWDtFQUFBLENBTmI7O0FBQUEsbUNBUUEsVUFBQSxHQUFZLFNBQUEsR0FBQTtBQUNWLFFBQUEsY0FBQTtBQUFBLElBQUEsUUFBQSxHQUFjLElBQUMsQ0FBQSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUssQ0FBQSxNQUFBLENBQWpCLEdBQThCLEdBQTlCLEdBQXVDLENBQWxELENBQUE7QUFBQSxJQUNBLENBQUEsR0FBSSxDQUFDLElBQUMsQ0FBQSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUssQ0FBQSxPQUFBLENBQWQsR0FBeUIsSUFBQyxDQUFBLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSyxDQUFBLE1BQUEsQ0FBeEMsQ0FBQSxHQUFtRCxRQUR2RCxDQUFBO0FBQUEsSUFFQSxDQUFBLEdBQUksQ0FBQSxDQUFFLElBQUMsQ0FBQSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUssQ0FBQSxTQUFBLENBQWQsR0FBMkIsSUFBQyxDQUFBLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSyxDQUFBLFVBQUEsQ0FBMUMsQ0FBRCxHQUEwRCxRQUY5RCxDQUFBO1dBR0EsSUFBQyxDQUFBLE1BQU0sQ0FBQyxJQUFSLENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFiLEVBSlU7RUFBQSxDQVJaLENBQUE7O2dDQUFBOztHQURtQyxPQUZyQyxDQUFBOztBQUFBLE1Ba0JNLENBQUMsT0FBUCxHQUFpQixzQkFsQmpCLENBQUE7Ozs7O0FDQUEsSUFBQSw2Q0FBQTtFQUFBOzs2QkFBQTs7QUFBQSxNQUFBLEdBQVMsT0FBQSxDQUFRLFFBQVIsQ0FBVCxDQUFBOztBQUFBLElBQ0EsR0FBTyxPQUFBLENBQVEsV0FBUixDQURQLENBQUE7O0FBQUEsU0FHQSxHQUFZLFNBQUMsS0FBRCxHQUFBO0FBQ1YsTUFBQSxPQUFBO0FBQUEsRUFBQSxPQUFBLEdBQVUsSUFBVixDQUFBO0FBQ0EsRUFBQSxJQUFHLEtBQUEsR0FBUSxPQUFYO0FBQ0UsV0FBTyxLQUFBLEdBQVEsT0FBZixDQURGO0dBREE7QUFHQSxFQUFBLElBQUcsS0FBQSxHQUFRLENBQUEsQ0FBQSxHQUFLLE9BQWhCO0FBQ0UsV0FBTyxLQUFBLEdBQVEsT0FBZixDQURGO0dBSEE7QUFLQSxTQUFPLENBQVAsQ0FOVTtBQUFBLENBSFosQ0FBQTs7QUFBQTtBQWFFLE1BQUEsOEVBQUE7O0FBQUEsMENBQUEsQ0FBQTs7QUFBQSxFQUFBLFNBQUEsR0FBWSxFQUFaLENBQUE7O0FBQUEsRUFDQSxVQUFBLEdBQWEsRUFEYixDQUFBOztBQUFBLEVBRUEsTUFBQSxHQUFTLEVBRlQsQ0FBQTs7QUFBQSxFQUdBLE9BQUEsR0FBVSxFQUhWLENBQUE7O0FBQUEsRUFJQSxXQUFBLEdBQWMsRUFKZCxDQUFBOztBQUFBLEVBS0EsWUFBQSxHQUFlLEVBTGYsQ0FBQTs7QUFBQSxFQU1BLFdBQUEsR0FBYyxFQU5kLENBQUE7O0FBUWEsRUFBQSw4QkFBQyxJQUFELEdBQUE7QUFBUyxJQUFSLElBQUMsQ0FBQSxPQUFELElBQVEsQ0FBQTtBQUFBLGlEQUFBLENBQVQ7RUFBQSxDQVJiOztBQUFBLGlDQVdBLFVBQUEsR0FBWSxTQUFBLEdBQUE7QUFDVixRQUFBLG1CQUFBO0FBQUEsSUFBQSxPQUFBLEdBQVUsSUFBQyxDQUFBLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSyxDQUFBLFNBQUEsQ0FBZCxHQUEyQixJQUFDLENBQUEsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFLLENBQUEsVUFBQSxDQUFuRCxDQUFBO0FBQUEsSUFDQSxJQUFBLEdBQU8sSUFBQyxDQUFBLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSyxDQUFBLE9BQUEsQ0FBZCxHQUF5QixJQUFDLENBQUEsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFLLENBQUEsTUFBQSxDQUQ5QyxDQUFBO0FBQUEsSUFFQSxJQUFBLEdBQU8sSUFBQyxDQUFBLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSyxDQUFBLFlBQUEsQ0FBZCxHQUE4QixJQUFDLENBQUEsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFLLENBQUEsV0FBQSxDQUZuRCxDQUFBO0FBSUEsSUFBQSxJQUFHLElBQUMsQ0FBQSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUssQ0FBQSxXQUFBLENBQWpCO0FBQ0UsTUFBQSxJQUFBLElBQVEsSUFBSSxDQUFDLEtBQUwsQ0FBVyxDQUFBLElBQUUsQ0FBQSxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQVosR0FBOEIsQ0FBekMsQ0FBUixDQURGO0tBSkE7QUFBQSxJQWdCQSxPQUFBLEdBQVUsSUFBSSxDQUFDLEtBQUwsQ0FBVyxPQUFYLENBaEJWLENBQUE7QUFBQSxJQWlCQSxJQUFBLEdBQU8sSUFBSSxDQUFDLEtBQUwsQ0FBVyxJQUFYLENBakJQLENBQUE7QUFBQSxJQWtCQSxJQUFBLEdBQU8sSUFBSSxDQUFDLEtBQUwsQ0FBVyxJQUFYLENBbEJQLENBQUE7V0FvQkEsSUFBQyxDQUFBLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBckIsQ0FBNkIsT0FBN0IsRUFBc0MsSUFBdEMsRUFBNEMsSUFBNUMsRUFyQlU7RUFBQSxDQVhaLENBQUE7OzhCQUFBOztHQURpQyxPQVpuQyxDQUFBOztBQUFBLE1BZ0RNLENBQUMsT0FBUCxHQUFpQixvQkFoRGpCLENBQUE7Ozs7O0FDQUEsSUFBQSxxQkFBQTtFQUFBOzs2QkFBQTs7QUFBQSxNQUFBLEdBQVMsT0FBQSxDQUFRLFFBQVIsQ0FBVCxDQUFBOztBQUFBLElBQ0EsR0FBTyxPQUFBLENBQVEsU0FBUixDQURQLENBQUE7O0FBQUE7QUFLRSw2QkFBQSxDQUFBOztBQUFhLEVBQUEsaUJBQUMsSUFBRCxHQUFBO0FBQ1gsSUFEWSxJQUFDLENBQUEsT0FBRCxJQUNaLENBQUE7QUFBQSx5Q0FBQSxDQUFBO0FBQUEsNkNBQUEsQ0FBQTtBQUFBLHVDQUFBLENBQUE7QUFBQSxJQUFBLElBQUMsQ0FBQSxNQUFELEdBQWMsSUFBQSxJQUFJLENBQUMsU0FBTCxDQUFBLENBQWQsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLEtBQUQsR0FBUyxLQURULENBQUE7QUFBQSxJQUVBLElBQUMsQ0FBQSxJQUFELEdBQVksSUFBQSxJQUFJLENBQUMsSUFBTCxDQUFVLEVBQVYsRUFBYztBQUFBLE1BQ3hCLElBQUEsRUFBTSxZQURrQjtBQUFBLE1BRXhCLElBQUEsRUFBTSxTQUZrQjtLQUFkLENBRlosQ0FBQTtBQUFBLElBTUEsSUFBQyxDQUFBLE1BQU0sQ0FBQyxRQUFSLENBQWlCLElBQUMsQ0FBQSxJQUFsQixDQU5BLENBRFc7RUFBQSxDQUFiOztBQUFBLG9CQVNBLEtBQUEsR0FBTyxTQUFBLEdBQUE7V0FDTCxPQUFPLENBQUMsR0FBUixDQUFZLE9BQVosRUFESztFQUFBLENBVFAsQ0FBQTs7QUFBQSxvQkFhQSxRQUFBLEdBQVUsU0FBQSxHQUFBO0FBQ1IsUUFBQSx3QkFBQTtBQUFBLElBQUEsUUFBQSxHQUFXLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQXRCLENBQUE7QUFBQSxJQUNBLE1BQUEsR0FBUyxJQUFJLENBQUMsS0FBTCxDQUFXLFFBQVMsQ0FBQSxDQUFBLENBQXBCLENBRFQsQ0FBQTtBQUFBLElBRUEsTUFBQSxHQUFTLElBQUksQ0FBQyxLQUFMLENBQVcsUUFBUyxDQUFBLENBQUEsQ0FBcEIsQ0FGVCxDQUFBO0FBR0EsV0FBTyxhQUFBLEdBQWMsTUFBZCxHQUFxQixJQUFyQixHQUF5QixNQUF6QixHQUFnQyxHQUF2QyxDQUpRO0VBQUEsQ0FiVixDQUFBOztBQUFBLG9CQW1CQSxNQUFBLEdBQVEsU0FBQSxHQUFBO1dBQ04sSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLEdBQWEsSUFBQyxDQUFBLFFBQUQsQ0FBQSxFQURQO0VBQUEsQ0FuQlIsQ0FBQTs7aUJBQUE7O0dBRG9CLE9BSnRCLENBQUE7O0FBQUEsTUEyQk0sQ0FBQyxPQUFQLEdBQWlCLE9BM0JqQixDQUFBOzs7OztBQ0FBLElBQUEsbUNBQUE7RUFBQTs7NkJBQUE7O0FBQUEsSUFBQSxHQUFPLE9BQUEsQ0FBUSxXQUFSLENBQVAsQ0FBQTs7QUFBQSxNQUNBLEdBQVMsT0FBQSxDQUFRLFFBQVIsQ0FEVCxDQUFBOztBQUFBLElBRUEsR0FBTyxPQUFBLENBQVEsV0FBUixDQUZQLENBQUE7O0FBQUEsSUFHQSxHQUFPLE9BQUEsQ0FBUSxTQUFSLENBSFAsQ0FBQTs7QUFBQTtBQU9FLE1BQUEsU0FBQTs7QUFBQSwrQkFBQSxDQUFBOztBQUFBLEVBQUEsU0FBQSxHQUFZLEdBQVosQ0FBQTs7QUFFYSxFQUFBLG1CQUFDLENBQUQsRUFBUSxDQUFSLEdBQUE7O01BQUMsSUFBSTtLQUNoQjs7TUFEbUIsSUFBSTtLQUN2QjtBQUFBLGlEQUFBLENBQUE7QUFBQSwyQ0FBQSxDQUFBO0FBQUEsSUFBQSxJQUFDLENBQUEsTUFBRCxHQUFjLElBQUEsSUFBSSxDQUFDLFFBQUwsQ0FBQSxDQUFkLENBQUE7QUFBQSxJQUNBLElBQUMsQ0FBQSxLQUFELEdBQVMsT0FEVCxDQUFBO0FBQUEsSUFFQSxJQUFDLENBQUEsS0FBRCxHQUFTLEVBRlQsQ0FBQTtBQUFBLElBR0EsSUFBQyxDQUFBLFFBQUQsR0FBZ0IsSUFBQSxJQUFBLENBQUEsQ0FIaEIsQ0FBQTtBQUFBLElBSUEsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFDLENBQUEsT0FBRCxDQUFhLElBQUEsSUFBQSxDQUFBLENBQWIsQ0FKUixDQURXO0VBQUEsQ0FGYjs7QUFBQSxzQkFVQSxPQUFBLEdBQVMsU0FBQyxJQUFELEdBQUE7QUFDUCxRQUFBLEtBQUE7QUFBQSxJQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsSUFBUCxDQUFZLElBQVosQ0FBQSxDQUFBO0FBQUEsSUFDQSxLQUFBLEdBQVcsc0JBQUgsR0FBd0IsSUFBSSxDQUFDLEVBQUwsR0FBVSxDQUFWLEdBQWMsSUFBSSxDQUFDLFNBQTNDLEdBQTBELENBRGxFLENBQUE7QUFFQSxJQUFBLElBQUcsbUJBQUg7QUFDRSxNQUFBLElBQUMsQ0FBQSxNQUFNLENBQUMsUUFBUixDQUFpQixJQUFJLENBQUMsTUFBdEIsQ0FBQSxDQURGO0tBRkE7QUFBQSxJQUtBLElBQUMsQ0FBQSxRQUFRLENBQUMsR0FBVixDQUFjLENBQUMsSUFBSSxDQUFDLENBQU4sRUFBUyxJQUFJLENBQUMsQ0FBZCxDQUFkLEVBQWdDLElBQWhDLENBTEEsQ0FBQTtBQU1BLFdBQU8sSUFBUCxDQVBPO0VBQUEsQ0FWVCxDQUFBOztBQUFBLHNCQW9CQSxVQUFBLEdBQVksU0FBQyxJQUFELEdBQUE7QUFDVixJQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsTUFBUCxDQUFjLElBQUMsQ0FBQSxLQUFLLENBQUMsT0FBUCxDQUFlLElBQWYsQ0FBZCxFQUFvQyxDQUFwQyxDQUFBLENBQUE7QUFDQSxJQUFBLElBQUcsbUJBQUg7QUFDRSxNQUFBLElBQUMsQ0FBQSxNQUFNLENBQUMsV0FBUixDQUFvQixJQUFJLENBQUMsTUFBekIsQ0FBQSxDQURGO0tBREE7QUFBQSxJQUlBLElBQUMsQ0FBQSxRQUFRLENBQUMsTUFBVixDQUFpQixDQUFDLElBQUksQ0FBQyxDQUFOLEVBQVMsSUFBSSxDQUFDLENBQWQsQ0FBakIsQ0FKQSxDQUFBO0FBTUEsV0FBTyxJQUFQLENBUFU7RUFBQSxDQXBCWixDQUFBOzttQkFBQTs7R0FEc0IsT0FOeEIsQ0FBQTs7QUFBQSxNQW9DTSxDQUFDLE9BQVAsR0FBaUIsU0FwQ2pCLENBQUE7Ozs7O0FDQUEsSUFBQSxVQUFBO0VBQUE7OzZCQUFBOztBQUFBLElBQUEsR0FBTyxPQUFBLENBQVEsV0FBUixDQUFQLENBQUE7O0FBQUE7QUFJRSxNQUFBLElBQUE7O0FBQUEsMEJBQUEsQ0FBQTs7QUFBQSxFQUFBLElBQUMsQ0FBQSxJQUFELEdBQVEsSUFBQSxHQUFXLElBQUEsSUFBSSxDQUFDLElBQUwsQ0FBVSxNQUFWLEVBQWtCLENBQWxCLEVBQXFCLENBQXJCLEVBQXdCLFFBQXhCLEVBQWtDLElBQWxDLENBQW5CLENBQUE7O0FBRWEsRUFBQSxjQUFDLENBQUQsRUFBTSxDQUFOLEdBQUE7O01BQUMsSUFBRTtLQUNkOztNQURpQixJQUFFO0tBQ25CO0FBQUEsdUNBQUEsQ0FBQTtBQUFBLElBQUEsc0NBQU0sQ0FBTixFQUFTLENBQVQsRUFBWSxJQUFaLENBQUEsQ0FEVztFQUFBLENBRmI7O0FBQUEsaUJBS0EsS0FBQSxHQUFPLFNBQUEsR0FBQTtBQUNMLFdBQVcsSUFBQSxJQUFBLENBQUssSUFBQyxDQUFBLENBQU4sRUFBUyxJQUFDLENBQUEsQ0FBVixDQUFYLENBREs7RUFBQSxDQUxQLENBQUE7O2NBQUE7O0dBRGlCLEtBSG5CLENBQUE7O0FBQUEsTUFZTSxDQUFDLE9BQVAsR0FBaUIsSUFaakIsQ0FBQTs7Ozs7QUNBQSxJQUFBLFVBQUE7RUFBQTs7NkJBQUE7O0FBQUEsSUFBQSxHQUFPLE9BQUEsQ0FBUSxXQUFSLENBQVAsQ0FBQTs7QUFBQTtBQUlFLE1BQUEsSUFBQTs7QUFBQSwwQkFBQSxDQUFBOztBQUFBLEVBQUEsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFBLEdBQVcsSUFBQSxJQUFJLENBQUMsSUFBTCxDQUFVLE1BQVYsRUFBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsRUFBd0IsUUFBeEIsRUFBa0MsR0FBbEMsQ0FBbkIsQ0FBQTs7QUFFYSxFQUFBLGNBQUMsQ0FBRCxFQUFJLENBQUosR0FBQTtBQUNYLHVDQUFBLENBQUE7QUFBQSxJQUFBLHNDQUFNLENBQU4sRUFBUyxDQUFULEVBQVksSUFBWixDQUFBLENBRFc7RUFBQSxDQUZiOztBQUFBLGlCQUtBLEtBQUEsR0FBTyxTQUFBLEdBQUE7QUFDTCxXQUFXLElBQUEsSUFBQSxDQUFLLElBQUMsQ0FBQSxDQUFOLEVBQVMsSUFBQyxDQUFBLENBQVYsQ0FBWCxDQURLO0VBQUEsQ0FMUCxDQUFBOztjQUFBOztHQURpQixLQUhuQixDQUFBOztBQUFBLE1BWU0sQ0FBQyxPQUFQLEdBQWlCLElBWmpCLENBQUE7Ozs7O0FDQUEsSUFBQSxjQUFBO0VBQUE7OzZCQUFBOztBQUFBLElBQUEsR0FBTyxPQUFBLENBQVEsV0FBUixDQUFQLENBQUE7O0FBQUE7QUFJRSxNQUFBLElBQUE7O0FBQUEsOEJBQUEsQ0FBQTs7QUFBQSxFQUFBLFFBQUMsQ0FBQSxJQUFELEdBQVEsSUFBQSxHQUFXLElBQUEsSUFBSSxDQUFDLElBQUwsQ0FBVSxVQUFWLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLEVBQTRCLFFBQTVCLEVBQXNDLEVBQXRDLENBQW5CLENBQUE7O0FBQUEsRUFDQSxJQUFJLENBQUMsUUFBTCxHQUFnQixJQURoQixDQUFBOztBQUdhLEVBQUEsa0JBQUMsQ0FBRCxFQUFJLENBQUosR0FBQTtBQUNYLHVDQUFBLENBQUE7QUFBQSxJQUFBLDBDQUFNLENBQU4sRUFBUyxDQUFULEVBQVksSUFBWixDQUFBLENBRFc7RUFBQSxDQUhiOztBQUFBLHFCQU1BLEtBQUEsR0FBTyxTQUFBLEdBQUE7QUFDTCxXQUFXLElBQUEsUUFBQSxDQUFTLElBQUMsQ0FBQSxDQUFWLEVBQWEsSUFBQyxDQUFBLENBQWQsQ0FBWCxDQURLO0VBQUEsQ0FOUCxDQUFBOztrQkFBQTs7R0FEcUIsS0FIdkIsQ0FBQTs7QUFBQSxNQWFNLENBQUMsT0FBUCxHQUFpQixRQWJqQixDQUFBOzs7OztBQ0FBLElBQUEsK0JBQUE7RUFBQSxnRkFBQTs7QUFBQSxFQUFBLEdBQUssT0FBQSxDQUFRLElBQVIsQ0FBTCxDQUFBOztBQUFBLElBQ0EsR0FBTyxPQUFBLENBQVEsU0FBUixDQURQLENBQUE7O0FBQUEsZUFFQSxHQUFrQixPQUFBLENBQVEsaUJBQVIsQ0FGbEIsQ0FBQTs7QUFBQTtBQU1lLEVBQUEsY0FBQyxDQUFELEVBQUssQ0FBTCxFQUFTLElBQVQsR0FBQTtBQUNYLElBRFksSUFBQyxDQUFBLElBQUQsQ0FDWixDQUFBO0FBQUEsSUFEZ0IsSUFBQyxDQUFBLElBQUQsQ0FDaEIsQ0FBQTtBQUFBLElBRG9CLElBQUMsQ0FBQSxPQUFELElBQ3BCLENBQUE7QUFBQSw2Q0FBQSxDQUFBO0FBQUEsdUNBQUEsQ0FBQTtBQUFBLGlEQUFBLENBQUE7QUFBQSwrQ0FBQSxDQUFBO0FBQUEsSUFBQSxJQUFDLENBQUEsS0FBRCxHQUFTLElBQUMsQ0FBQSxTQUFELENBQUEsQ0FBVCxDQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsS0FBSyxDQUFDLEtBQVAsR0FBZSxJQURmLENBQUE7QUFBQSxJQUVBLElBQUMsQ0FBQSxNQUFELEdBQVUsSUFBQyxDQUFBLFVBQUQsQ0FBQSxDQUZWLENBQUE7QUFBQSxJQUdBLElBQUMsQ0FBQSxNQUFNLENBQUMsQ0FBUixHQUFZLElBQUMsQ0FBQSxDQUhiLENBQUE7QUFBQSxJQUlBLElBQUMsQ0FBQSxNQUFNLENBQUMsQ0FBUixHQUFZLElBQUMsQ0FBQSxDQUpiLENBQUE7QUFBQSxJQUtBLElBQUMsQ0FBQSxNQUFELEdBQVUsSUFBQyxDQUFBLFNBTFgsQ0FEVztFQUFBLENBQWI7O0FBQUEsRUFTQSxDQUFDLE1BQUQsRUFBUyxPQUFULEVBQWtCLFFBQWxCLEVBQTRCLFdBQTVCLENBQXdDLENBQUMsT0FBekMsQ0FBaUQsU0FBQyxLQUFELEdBQUE7V0FDL0MsSUFBSSxDQUFDLFFBQUwsQ0FBYyxLQUFkLEVBQ0U7QUFBQSxNQUFBLEdBQUEsRUFBSyxTQUFBLEdBQUE7QUFDSCxlQUFPLElBQUMsQ0FBQSxJQUFLLENBQUEsS0FBQSxDQUFiLENBREc7TUFBQSxDQUFMO0tBREYsRUFEK0M7RUFBQSxDQUFqRCxDQVRBLENBQUE7O0FBQUEsaUJBY0EsU0FBQSxHQUFXLFNBQUEsR0FBQTtBQUNULFFBQUEsS0FBQTtBQUFBLElBQUEsS0FBQSxHQUFZLElBQUEsRUFBRSxDQUFDLFNBQUgsQ0FBYSxJQUFDLENBQUEsS0FBZCxFQUFxQixJQUFDLENBQUEsTUFBdEIsQ0FBWixDQUFBO0FBQ0EsSUFBQSxJQUFHLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBVDtBQUNFLE1BQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxlQUFaLENBQUEsQ0FBQTtBQUFBLE1BQ0EsS0FBSyxDQUFDLGNBQU4sR0FBdUIsZUFBZSxDQUFDLGFBRHZDLENBREY7S0FBQSxNQUFBO0FBSUUsTUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLGVBQVosQ0FBQSxDQUFBO0FBQUEsTUFDQSxLQUFLLENBQUMsY0FBTixHQUF1QixlQUFlLENBQUMsYUFEdkMsQ0FKRjtLQURBO0FBQUEsSUFPQSxLQUFLLENBQUMsYUFBTixHQUFzQixlQUFlLENBQUMsR0FQdEMsQ0FBQTtBQVFBLFdBQU8sS0FBUCxDQVRTO0VBQUEsQ0FkWCxDQUFBOztBQUFBLGlCQXlCQSxVQUFBLEdBQVksU0FBQSxHQUFBO0FBQ1YsUUFBQSxNQUFBO0FBQUEsSUFBQSxNQUFBLEdBQWEsSUFBQSxJQUFJLENBQUMsUUFBTCxDQUFBLENBQWIsQ0FBQTtBQUFBLElBQ0EsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsSUFBQyxDQUFBLElBQUksQ0FBQyxLQUF2QixDQURBLENBQUE7QUFBQSxJQUVBLE1BQU0sQ0FBQyxRQUFQLENBQWdCLENBQUEsR0FBQSxHQUFPLElBQUMsQ0FBQSxLQUF4QixFQUErQixDQUFBLEdBQUEsR0FBTyxJQUFDLENBQUEsTUFBdkMsRUFBK0MsSUFBQyxDQUFBLEtBQWhELEVBQXVELElBQUMsQ0FBQSxNQUF4RCxDQUZBLENBQUE7QUFBQSxJQUdBLE1BQU0sQ0FBQyxPQUFQLENBQUEsQ0FIQSxDQUFBO0FBSUEsV0FBTyxNQUFQLENBTFU7RUFBQSxDQXpCWixDQUFBOztBQUFBLGlCQWdDQSxLQUFBLEdBQU8sU0FBQSxHQUFBO0FBQ0wsV0FBVyxJQUFBLElBQUEsQ0FBSyxJQUFDLENBQUEsQ0FBTixFQUFTLElBQUMsQ0FBQSxDQUFWLEVBQWEsSUFBQyxDQUFBLElBQWQsQ0FBWCxDQURLO0VBQUEsQ0FoQ1AsQ0FBQTs7QUFBQSxpQkFtQ0EsUUFBQSxHQUFVLFNBQUEsR0FBQTtBQUNSLFdBQU8sR0FBQSxHQUFJLElBQUMsQ0FBQSxJQUFMLEdBQVUsT0FBVixHQUFpQixJQUFDLENBQUEsQ0FBbEIsR0FBb0IsR0FBcEIsR0FBdUIsSUFBQyxDQUFBLENBQXhCLEdBQTBCLElBQWpDLENBRFE7RUFBQSxDQW5DVixDQUFBOztjQUFBOztJQU5GLENBQUE7O0FBQUEsSUErQ1UsQ0FBQztBQUNJLEVBQUEsY0FBQyxJQUFELEVBQVEsS0FBUixFQUFrQixNQUFsQixFQUE2QixLQUE3QixFQUE4QyxTQUE5QyxHQUFBO0FBQ1gsSUFEWSxJQUFDLENBQUEsT0FBRCxJQUNaLENBQUE7QUFBQSxJQURtQixJQUFDLENBQUEsd0JBQUQsUUFBTyxDQUMxQixDQUFBO0FBQUEsSUFENkIsSUFBQyxDQUFBLDBCQUFELFNBQVEsQ0FDckMsQ0FBQTtBQUFBLElBRHdDLElBQUMsQ0FBQSx3QkFBRCxRQUFPLFFBQy9DLENBQUE7QUFBQSxJQUR5RCxJQUFDLENBQUEsZ0NBQUQsWUFBVyxHQUNwRSxDQUFBO0FBQUEsNkNBQUEsQ0FBQTtBQUFBLElBQUEsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFDLENBQUEsS0FBRCxHQUFTLElBQUMsQ0FBQSxNQUFsQixDQURXO0VBQUEsQ0FBYjs7QUFBQSxpQkFHQSxRQUFBLEdBQVUsU0FBQSxHQUFBO0FBQ1IsV0FBTyxJQUFDLENBQUEsSUFBUixDQURRO0VBQUEsQ0FIVixDQUFBOztjQUFBOztJQWhERixDQUFBOztBQUFBLE1BdURNLENBQUMsT0FBUCxHQUFpQixJQXZEakIsQ0FBQTs7Ozs7QUNBQSxJQUFBLHVFQUFBO0VBQUE7OzZCQUFBOztBQUFBLFNBQUEsR0FBWSxPQUFBLENBQVEsZ0JBQVIsQ0FBWixDQUFBOztBQUFBLE1BQ0EsR0FBUyxPQUFBLENBQVEsUUFBUixDQURULENBQUE7O0FBQUEsSUFFQSxHQUFPLE9BQUEsQ0FBUSxXQUFSLENBRlAsQ0FBQTs7QUFBQSxFQUdBLEdBQUssT0FBQSxDQUFRLElBQVIsQ0FITCxDQUFBOztBQUFBLElBSUEsR0FBTyxPQUFBLENBQVEsU0FBUixDQUpQLENBQUE7O0FBQUEsY0FLQSxHQUFpQixPQUFBLENBQVEscUJBQVIsQ0FMakIsQ0FBQTs7QUFBQSxRQU1BLEdBQVcsT0FBQSxDQUFRLGVBQVIsQ0FOWCxDQUFBOztBQUFBLElBT0EsR0FBTyxPQUFBLENBQVEsV0FBUixDQVBQLENBQUE7O0FBQUE7QUFXRSxNQUFBLFNBQUE7O0FBQUEsMEJBQUEsQ0FBQTs7QUFBQSxFQUFBLFNBQUEsR0FBWSxHQUFaLENBQUE7O0FBRWEsRUFBQSxjQUFDLFNBQUQsRUFBYSxDQUFiLEVBQW9CLENBQXBCLEdBQUE7QUFDWCxRQUFBLGlCQUFBO0FBQUEsSUFEWSxJQUFDLENBQUEsWUFBRCxTQUNaLENBQUE7O01BRHdCLElBQUk7S0FDNUI7O01BRCtCLElBQUk7S0FDbkM7QUFBQSxxRUFBQSxDQUFBO0FBQUEsbURBQUEsQ0FBQTtBQUFBLHFEQUFBLENBQUE7QUFBQSxxREFBQSxDQUFBO0FBQUEsbURBQUEsQ0FBQTtBQUFBLDZDQUFBLENBQUE7QUFBQSxpREFBQSxDQUFBO0FBQUEsMkNBQUEsQ0FBQTtBQUFBLHFDQUFBLENBQUE7QUFBQSx5Q0FBQSxDQUFBOztNQUFBLElBQUMsQ0FBQSxZQUFpQixJQUFBLFNBQUEsQ0FBQTtLQUFsQjtBQUFBLElBQ0EsSUFBQyxDQUFBLE1BQUQsR0FBYyxJQUFBLElBQUksQ0FBQyxRQUFMLENBQUEsQ0FEZCxDQUFBO0FBQUEsSUFFQSxJQUFDLENBQUEsS0FBRCxHQUFTLE9BRlQsQ0FBQTtBQUFBLElBR0EsSUFBQyxDQUFBLEtBQUQsR0FBUyxFQUhULENBQUE7QUFBQSxJQU1BLElBQUMsQ0FBQSxhQUFELEdBQWlCLEVBTmpCLENBQUE7QUFBQSxJQU9BLElBQUMsQ0FBQSxjQUFELEdBQXNCLElBQUEsY0FBQSxDQUFlLElBQWYsQ0FQdEIsQ0FBQTtBQUFBLElBVUEsSUFBQyxDQUFBLE1BQUQsR0FBVSxDQUFDLENBQUQsRUFBSSxDQUFKLENBVlYsQ0FBQTtBQUFBLElBWUEsSUFBQyxDQUFBLElBQUQsR0FBWSxJQUFBLEVBQUUsQ0FBQyxJQUFILENBQVE7QUFBQSxNQUNsQixRQUFBLEVBQVUsQ0FBQyxDQUFELEVBQUksQ0FBSixDQURRO0FBQUEsTUFFbEIsSUFBQSxFQUFNLFNBRlk7QUFBQSxNQUdsQixjQUFBLEVBQWdCLElBSEU7QUFBQSxNQUlsQixPQUFBLEVBQVMsR0FKUztLQUFSLENBWlosQ0FBQTtBQW1CQTtBQUFBLFNBQUEscUNBQUE7b0JBQUE7QUFDRSxNQUFBLElBQUMsQ0FBQSxPQUFELENBQVMsSUFBSSxDQUFDLEtBQUwsQ0FBQSxDQUFULENBQUEsQ0FERjtBQUFBLEtBcEJXO0VBQUEsQ0FGYjs7QUFBQSxFQXlCQSxJQUFDLENBQUEsUUFBRCxDQUFVLFVBQVYsRUFDRTtBQUFBLElBQUEsR0FBQSxFQUFLLFNBQUEsR0FBQTtBQUNILGFBQU8sSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFiLENBREc7SUFBQSxDQUFMO0dBREYsQ0F6QkEsQ0FBQTs7QUFBQSxpQkE2QkEsTUFBQSxHQUFRLFNBQUEsR0FBQTtBQUNOLFFBQUEsR0FBQTtBQUFBLElBQUEsSUFBQyxDQUFBLE1BQU0sQ0FBQyxLQUFSLENBQUEsQ0FBQSxDQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsTUFBTSxDQUFDLFNBQVIsQ0FBa0IsUUFBbEIsQ0FEQSxDQUFBO0FBQUEsSUFFQSxJQUFDLENBQUEsTUFBTSxDQUFDLFVBQVIsQ0FBbUIsQ0FBQSxJQUFFLENBQUEsTUFBTyxDQUFBLENBQUEsQ0FBNUIsRUFBZ0MsQ0FBQSxJQUFFLENBQUEsTUFBTyxDQUFBLENBQUEsQ0FBekMsRUFBNkMsR0FBN0MsQ0FGQSxDQUFBO0FBQUEsSUFHQSxJQUFDLENBQUEsTUFBTSxDQUFDLE9BQVIsQ0FBQSxDQUhBLENBQUE7QUFBQSxJQUtBLE1BQXlCLElBQUMsQ0FBQSxXQUFELENBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFiLENBQXpCLEVBQUMsSUFBQyxDQUFBLE1BQU0sQ0FBQyxVQUFULEVBQVksSUFBQyxDQUFBLE1BQU0sQ0FBQyxVQUxwQixDQUFBO1dBTUEsSUFBQyxDQUFBLE1BQU0sQ0FBQyxRQUFSLEdBQW1CLElBQUMsQ0FBQSxJQUFJLENBQUMsTUFQbkI7RUFBQSxDQTdCUixDQUFBOztBQUFBLGlCQXNDQSxJQUFBLEdBQU0sU0FBQSxHQUFBO0FBQ0osUUFBQSwwQkFBQTtBQUFBO0FBQUE7U0FBQSxxQ0FBQTtvQkFBQTtBQUNFLG1CQUFBLElBQUksQ0FBQyxJQUFMLENBQVUsSUFBVixFQUFBLENBREY7QUFBQTttQkFESTtFQUFBLENBdENOLENBQUE7O0FBQUEsaUJBMkNBLE9BQUEsR0FBUyxTQUFDLElBQUQsR0FBQTtBQUNQLFFBQUEsb0JBQUE7QUFBQSxJQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsSUFBUCxDQUFZLElBQVosQ0FBQSxDQUFBO0FBQ0EsSUFBQSxJQUFHLGlCQUFIO0FBQ0UsTUFBQSxJQUFDLENBQUEsYUFBYSxDQUFDLElBQWYsQ0FBb0IsSUFBcEIsQ0FBQSxDQURGO0tBREE7QUFBQSxJQUlBLEtBQUEsR0FBVyxzQkFBSCxHQUF3QixJQUFJLENBQUMsRUFBTCxHQUFVLENBQVYsR0FBYyxJQUFJLENBQUMsU0FBM0MsR0FBMEQsQ0FKbEUsQ0FBQTtBQU1BLElBQUEsSUFBRyxtQkFBSDtBQUNFLE1BQUEsSUFBQyxDQUFBLE1BQU0sQ0FBQyxRQUFSLENBQWlCLElBQUksQ0FBQyxNQUF0QixDQUFBLENBQUE7QUFBQSxNQUNBLElBQUMsQ0FBQSxNQUFNLENBQUMsUUFBUixHQUFtQixLQURuQixDQURGO0tBTkE7QUFVQSxJQUFBLElBQUcsa0JBQUg7QUFDRSxNQUFBLGFBQUEsR0FBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBTCxHQUFTLElBQUMsQ0FBQSxNQUFPLENBQUEsQ0FBQSxDQUFsQixFQUFzQixJQUFJLENBQUMsQ0FBTCxHQUFTLElBQUMsQ0FBQSxNQUFPLENBQUEsQ0FBQSxDQUF2QyxDQUFoQixDQUFBO0FBQUEsTUFDQSxJQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBZSxJQUFJLENBQUMsS0FBcEIsRUFBMkIsYUFBM0IsRUFBMEMsS0FBMUMsQ0FEQSxDQUFBO0FBQUEsTUFFQSxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sSUFBYyxJQUFJLENBQUMsSUFGbkIsQ0FBQTtBQUFBLE1BR0EsSUFBQyxDQUFBLFFBQUQsQ0FBQSxDQUhBLENBREY7S0FWQTtBQWdCQSxJQUFBLElBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFiO2FBQ0UsSUFBQyxDQUFBLGNBQWMsQ0FBQyxXQUFoQixDQUE0QixJQUE1QixFQURGO0tBakJPO0VBQUEsQ0EzQ1QsQ0FBQTs7QUFBQSxpQkErREEsVUFBQSxHQUFZLFNBQUMsSUFBRCxHQUFBO0FBQ1YsSUFBQSxJQUFDLENBQUEsS0FBSyxDQUFDLE1BQVAsQ0FBYyxJQUFDLENBQUEsS0FBSyxDQUFDLE9BQVAsQ0FBZSxJQUFmLENBQWQsRUFBb0MsQ0FBcEMsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxJQUFHLGlCQUFIO0FBQ0UsTUFBQSxJQUFDLENBQUEsYUFBYSxDQUFDLE1BQWYsQ0FBc0IsSUFBQyxDQUFBLGFBQWEsQ0FBQyxPQUFmLENBQXVCLElBQXZCLENBQXRCLEVBQW9ELENBQXBELENBQUEsQ0FERjtLQURBO0FBR0EsSUFBQSxJQUFHLG1CQUFIO0FBQ0UsTUFBQSxJQUFDLENBQUEsTUFBTSxDQUFDLFdBQVIsQ0FBb0IsSUFBSSxDQUFDLE1BQXpCLENBQUEsQ0FERjtLQUhBO0FBS0EsSUFBQSxJQUFHLGtCQUFIO0FBQ0UsTUFBQSxJQUFDLENBQUEsSUFBSSxDQUFDLFdBQU4sQ0FBa0IsSUFBSSxDQUFDLEtBQXZCLENBQUEsQ0FERjtLQUxBO0FBT0EsSUFBQSxJQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBYjtBQUNFLE1BQUEsSUFBQyxDQUFBLGNBQWMsQ0FBQyxjQUFoQixDQUErQixJQUEvQixDQUFBLENBREY7S0FQQTtBQUFBLElBU0EsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLElBQWMsSUFBSSxDQUFDLElBVG5CLENBQUE7V0FVQSxJQUFDLENBQUEsUUFBRCxDQUFBLEVBWFU7RUFBQSxDQS9EWixDQUFBOztBQUFBLGlCQTZFQSxRQUFBLEdBQVUsU0FBQSxHQUFBO0FBQ1IsUUFBQSwyQkFBQTtBQUFBLElBQUEsTUFBQSxHQUFTLENBQUMsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFTLENBQUEsQ0FBQSxDQUFoQixFQUFvQixJQUFDLENBQUEsSUFBSSxDQUFDLFFBQVMsQ0FBQSxDQUFBLENBQW5DLENBQVQsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLElBQUksQ0FBQyxrQkFBTixDQUFBLENBREEsQ0FBQTtBQUFBLElBRUEsRUFBQSxHQUFLLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBUyxDQUFBLENBQUEsQ0FBZixHQUFvQixNQUFPLENBQUEsQ0FBQSxDQUZoQyxDQUFBO0FBQUEsSUFHQSxFQUFBLEdBQUssSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFTLENBQUEsQ0FBQSxDQUFmLEdBQW9CLE1BQU8sQ0FBQSxDQUFBLENBSGhDLENBQUE7QUFBQSxJQUlBLFdBQUEsR0FBYyxJQUFDLENBQUEsWUFBRCxDQUFjLE1BQWQsQ0FKZCxDQUFBO0FBQUEsSUFLQSxJQUFDLENBQUEsTUFBTyxDQUFBLENBQUEsQ0FBUixJQUFjLFdBQVksQ0FBQSxDQUFBLENBTDFCLENBQUE7QUFBQSxJQU1BLElBQUMsQ0FBQSxNQUFPLENBQUEsQ0FBQSxDQUFSLElBQWMsV0FBWSxDQUFBLENBQUEsQ0FOMUIsQ0FBQTtXQU9BLE9BQU8sQ0FBQyxHQUFSLENBQVksY0FBQSxHQUFlLFdBQVksQ0FBQSxDQUFBLENBQTNCLEdBQThCLElBQTlCLEdBQWtDLFdBQVksQ0FBQSxDQUFBLENBQTFELEVBUlE7RUFBQSxDQTdFVixDQUFBOztBQUFBLGlCQXdGQSxXQUFBLEdBQWEsU0FBQyxLQUFELEdBQUE7QUFDWCxXQUFPLENBQUMsS0FBTSxDQUFBLENBQUEsQ0FBTixHQUFXLElBQUMsQ0FBQSxNQUFPLENBQUEsQ0FBQSxDQUFwQixFQUF3QixLQUFNLENBQUEsQ0FBQSxDQUFOLEdBQVcsSUFBQyxDQUFBLE1BQU8sQ0FBQSxDQUFBLENBQTNDLENBQVAsQ0FEVztFQUFBLENBeEZiLENBQUE7O0FBQUEsaUJBNEZBLFlBQUEsR0FBYyxTQUFDLEtBQUQsR0FBQTtBQUNaLFFBQUEsS0FBQTtBQUFBLElBQUEsS0FBQSxHQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBUixDQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsSUFBSSxDQUFDLFlBQU4sQ0FBbUIsS0FBbkIsRUFBMEIsS0FBMUIsQ0FEQSxDQUFBO0FBRUEsV0FBTyxLQUFQLENBSFk7RUFBQSxDQTVGZCxDQUFBOztBQUFBLGlCQWtHQSxZQUFBLEdBQWMsU0FBQyxLQUFELEdBQUE7QUFDWixRQUFBLEtBQUE7QUFBQSxJQUFBLEtBQUEsR0FBUSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVIsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLElBQUksQ0FBQyxZQUFOLENBQW1CLEtBQW5CLEVBQTBCLEtBQTFCLENBREEsQ0FBQTtBQUVBLFdBQU8sS0FBUCxDQUhZO0VBQUEsQ0FsR2QsQ0FBQTs7QUFBQSxpQkF3R0EsV0FBQSxHQUFhLFNBQUMsS0FBRCxHQUFBO0FBQ1gsV0FBTyxJQUFDLENBQUEsWUFBRCxDQUFjLElBQUMsQ0FBQSxXQUFELENBQWEsS0FBYixDQUFkLENBQVAsQ0FEVztFQUFBLENBeEdiLENBQUE7O0FBQUEsaUJBNEdBLG9CQUFBLEdBQXNCLFNBQUMsS0FBRCxHQUFBO0FBRXBCLFFBQUEsb0RBQUE7QUFBQSxJQUFBLE1BQVcsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFqQixFQUFDLFdBQUQsRUFBSyxXQUFMLENBQUE7QUFBQSxJQUdBLENBQUEsR0FBSSxLQUFNLENBQUEsQ0FBQSxDQUFOLEdBQVcsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFTLENBQUEsQ0FBQSxDQUg5QixDQUFBO0FBQUEsSUFJQSxDQUFBLEdBQUksS0FBTSxDQUFBLENBQUEsQ0FBTixHQUFXLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBUyxDQUFBLENBQUEsQ0FKOUIsQ0FBQTtBQUFBLElBT0EsS0FBQSxHQUFRLElBQUksQ0FBQyxLQUFMLENBQVcsQ0FBWCxFQUFjLENBQWQsQ0FBQSxHQUFtQixJQUFJLENBQUMsRUFBTCxHQUFVLENBUHJDLENBQUE7QUFBQSxJQVVBLENBQUEsR0FBSSxJQUFJLENBQUMsSUFBTCxDQUFVLENBQUEsR0FBSSxDQUFKLEdBQVEsQ0FBQSxHQUFJLENBQXRCLENBVkosQ0FBQTtBQUFBLElBV0EsZUFBQSxHQUFrQixJQUFDLENBQUEsSUFBSSxDQUFDLGVBQU4sR0FBd0IsQ0FYMUMsQ0FBQTtBQUFBLElBWUEsRUFBQSxHQUFLLElBQUksQ0FBQyxHQUFMLENBQVMsS0FBVCxDQUFBLEdBQWtCLGVBWnZCLENBQUE7QUFBQSxJQWFBLEVBQUEsR0FBSyxJQUFJLENBQUMsR0FBTCxDQUFTLEtBQVQsQ0FBQSxHQUFrQixlQWJ2QixDQUFBO0FBZUEsV0FBTyxDQUFDLEVBQUEsR0FBSyxFQUFOLEVBQVUsRUFBQSxHQUFLLEVBQWYsQ0FBUCxDQWpCb0I7RUFBQSxDQTVHdEIsQ0FBQTs7Y0FBQTs7R0FEaUIsT0FWbkIsQ0FBQTs7QUFBQSxNQTBJTSxDQUFDLE9BQVAsR0FBaUIsSUExSWpCLENBQUE7Ozs7O0FDQUEsSUFBQSxvQkFBQTtFQUFBLGdGQUFBOztBQUFBLElBQUEsR0FBTyxPQUFBLENBQVEsV0FBUixDQUFQLENBQUE7O0FBQUE7QUFJZSxFQUFBLHdCQUFDLElBQUQsR0FBQTtBQUNYLElBRFksSUFBQyxDQUFBLE9BQUQsSUFDWixDQUFBO0FBQUEsMkNBQUEsQ0FBQTtBQUFBLHlEQUFBLENBQUE7QUFBQSxtREFBQSxDQUFBO0FBQUEsSUFBQSxJQUFDLENBQUEsU0FBRCxHQUFhLEVBQWIsQ0FEVztFQUFBLENBQWI7O0FBQUEsMkJBSUEsV0FBQSxHQUFhLFNBQUMsUUFBRCxHQUFBO0FBQ1gsSUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLGdCQUFaLENBQUEsQ0FBQTtXQUNBLElBQUMsQ0FBQSxTQUFTLENBQUMsSUFBWCxDQUFnQixRQUFoQixFQUZXO0VBQUEsQ0FKYixDQUFBOztBQUFBLDJCQVNBLGNBQUEsR0FBZ0IsU0FBQyxRQUFELEdBQUE7V0FDZCxJQUFDLENBQUEsU0FBUyxDQUFDLE1BQVgsQ0FBa0IsSUFBQyxDQUFBLFNBQVMsQ0FBQyxPQUFYLENBQW1CLFFBQW5CLENBQWxCLEVBQWdELENBQWhELEVBRGM7RUFBQSxDQVRoQixDQUFBOztBQUFBLDJCQWFBLE9BQUEsR0FBUyxTQUFDLE9BQUQsRUFBWSxJQUFaLEVBQW9CLElBQXBCLEdBQUE7QUFFUCxRQUFBLDhDQUFBOztNQUZRLFVBQVE7S0FFaEI7O01BRm1CLE9BQUs7S0FFeEI7O01BRjJCLE9BQUs7S0FFaEM7QUFBQTtBQUFBO1NBQUEscUNBQUE7d0JBQUE7QUFDRSxNQUFBLFFBQUEsR0FBVyxDQUFYLENBQUE7QUFBQSxNQUNBLENBQUEsR0FBSSxRQUFRLENBQUMsQ0FBVCxHQUFhLElBQUMsQ0FBQSxJQUFJLENBQUMsTUFBTyxDQUFBLENBQUEsQ0FEOUIsQ0FBQTtBQUFBLE1BRUEsQ0FBQSxHQUFJLFFBQVEsQ0FBQyxDQUFULEdBQWEsSUFBQyxDQUFBLElBQUksQ0FBQyxNQUFPLENBQUEsQ0FBQSxDQUY5QixDQUFBO0FBSUEsY0FBTyxRQUFRLENBQUMsU0FBaEI7QUFBQSxhQUNPLENBRFA7QUFFSSxVQUFBLElBQUcsT0FBQSxHQUFVLENBQWI7QUFDRSxZQUFBLFFBQUEsSUFBWSxPQUFaLENBREY7V0FBQTtBQUVBLFVBQUEsSUFBRyxJQUFBLEdBQU8sQ0FBUCxJQUFhLENBQUEsR0FBSSxDQUFwQjtBQUNFLFlBQUEsUUFBQSxJQUFZLElBQVosQ0FERjtXQUZBO0FBSUEsVUFBQSxJQUFHLElBQUEsR0FBTyxDQUFQLElBQWEsQ0FBQSxHQUFJLENBQXBCO0FBQ0UsWUFBQSxRQUFBLElBQVksQ0FBQSxJQUFaLENBREY7V0FOSjtBQUNPO0FBRFAsYUFRTyxDQVJQO0FBU0ksVUFBQSxJQUFHLElBQUEsR0FBTyxDQUFWO0FBQ0UsWUFBQSxRQUFBLElBQVksSUFBWixDQURGO1dBQUE7QUFFQSxVQUFBLElBQUcsSUFBQSxHQUFPLENBQVAsSUFBYSxDQUFBLEdBQUksQ0FBcEI7QUFDRSxZQUFBLFFBQUEsSUFBWSxJQUFaLENBREY7V0FGQTtBQUlBLFVBQUEsSUFBRyxJQUFBLEdBQU8sQ0FBUCxJQUFhLENBQUEsR0FBSSxDQUFwQjtBQUNFLFlBQUEsUUFBQSxJQUFZLENBQUEsSUFBWixDQURGO1dBYko7QUFRTztBQVJQLGFBZU8sQ0FmUDtBQWdCSSxVQUFBLElBQUcsT0FBQSxHQUFVLENBQWI7QUFDRSxZQUFBLFFBQUEsSUFBWSxDQUFBLE9BQVosQ0FERjtXQUFBO0FBRUEsVUFBQSxJQUFHLElBQUEsR0FBTyxDQUFQLElBQWEsQ0FBQSxHQUFJLENBQXBCO0FBQ0UsWUFBQSxRQUFBLElBQVksSUFBWixDQURGO1dBRkE7QUFJQSxVQUFBLElBQUcsSUFBQSxHQUFPLENBQVAsSUFBYSxDQUFBLEdBQUksQ0FBcEI7QUFDRSxZQUFBLFFBQUEsSUFBWSxDQUFBLElBQVosQ0FERjtXQXBCSjtBQWVPO0FBZlAsYUFzQk8sQ0F0QlA7QUF1QkksVUFBQSxJQUFHLElBQUEsR0FBTyxDQUFWO0FBQ0UsWUFBQSxRQUFBLElBQVksQ0FBQSxJQUFaLENBREY7V0FBQTtBQUVBLFVBQUEsSUFBRyxJQUFBLEdBQU8sQ0FBUCxJQUFhLENBQUEsR0FBSSxDQUFwQjtBQUNFLFlBQUEsUUFBQSxJQUFZLElBQVosQ0FERjtXQUZBO0FBSUEsVUFBQSxJQUFHLElBQUEsR0FBTyxDQUFQLElBQWEsQ0FBQSxHQUFJLENBQXBCO0FBQ0UsWUFBQSxRQUFBLElBQVksQ0FBQSxJQUFaLENBREY7V0EzQko7QUFBQSxPQUpBO0FBQUEsTUFpQ0EsUUFBQSxHQUFXLElBQUksQ0FBQyxLQUFMLENBQVcsUUFBWCxDQWpDWCxDQUFBO0FBQUEsbUJBa0NBLFFBQVEsQ0FBQyxXQUFULENBQXFCLFFBQXJCLEVBbENBLENBREY7QUFBQTttQkFGTztFQUFBLENBYlQsQ0FBQTs7d0JBQUE7O0lBSkYsQ0FBQTs7QUFBQSxNQXdETSxDQUFDLE9BQVAsR0FBaUIsY0F4RGpCLENBQUE7Ozs7O0FDQUEsSUFBQSxvQkFBQTtFQUFBOzs2QkFBQTs7QUFBQSxJQUFBLEdBQU8sT0FBQSxDQUFRLFdBQVIsQ0FBUCxDQUFBOztBQUFBLElBRUEsR0FBVyxJQUFBLElBQUksQ0FBQyxJQUFMLENBQVUsVUFBVixFQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixRQUE1QixDQUZYLENBQUE7O0FBQUEsSUFHSSxDQUFDLFdBQUwsR0FBbUIsSUFIbkIsQ0FBQTs7QUFBQSxJQUlJLENBQUMsUUFBTCxHQUFnQixJQUpoQixDQUFBOztBQUFBO0FBUUUsOEJBQUEsQ0FBQTs7QUFBQSxFQUFBLFFBQUMsQ0FBQSxJQUFELEdBQVEsSUFBUixDQUFBOztBQUVhLEVBQUEsa0JBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxTQUFQLEdBQUE7QUFDWCxJQURrQixJQUFDLENBQUEsZ0NBQUQsWUFBVyxDQUM3QixDQUFBO0FBQUEsdUNBQUEsQ0FBQTtBQUFBLHFDQUFBLENBQUE7QUFBQSxtREFBQSxDQUFBO0FBQUEsaURBQUEsQ0FBQTtBQUFBLElBQUEsMENBQU0sQ0FBTixFQUFTLENBQVQsRUFBWSxJQUFaLENBQUEsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLFFBQUQsR0FBWSxDQURaLENBQUE7QUFBQSxJQUVBLElBQUMsQ0FBQSxTQUFELEdBQWEsR0FGYixDQURXO0VBQUEsQ0FGYjs7QUFBQSxxQkFPQSxVQUFBLEdBQVksU0FBQSxHQUFBO0FBQ1YsUUFBQSxNQUFBO0FBQUEsSUFBQSxNQUFBLEdBQVMsdUNBQUEsQ0FBVCxDQUFBO0FBQUEsSUFDQSxNQUFNLENBQUMsU0FBUCxDQUFpQixJQUFqQixFQUF1QixRQUF2QixDQURBLENBQUE7QUFBQSxJQUVBLE1BQU0sQ0FBQyxNQUFQLENBQWMsQ0FBQSxDQUFkLEVBQWtCLENBQUEsQ0FBbEIsQ0FGQSxDQUFBO0FBQUEsSUFHQSxNQUFNLENBQUMsTUFBUCxDQUFjLENBQWQsRUFBaUIsQ0FBQSxDQUFqQixDQUhBLENBQUE7QUFBQSxJQUlBLE1BQU0sQ0FBQyxRQUFQLEdBQWtCLENBQUMsSUFBQyxDQUFBLFNBQUQsR0FBYSxDQUFkLENBQUEsR0FBbUIsSUFBSSxDQUFDLEVBQXhCLEdBQTZCLENBSi9DLENBQUE7QUFLQSxXQUFPLE1BQVAsQ0FOVTtFQUFBLENBUFosQ0FBQTs7QUFBQSxxQkFlQSxXQUFBLEdBQWEsU0FBQyxLQUFELEdBQUE7V0FDWCxJQUFDLENBQUEsUUFBRCxHQUFZLE1BREQ7RUFBQSxDQWZiLENBQUE7O0FBQUEscUJBa0JBLElBQUEsR0FBTSxTQUFDLElBQUQsR0FBQTtBQUNKLFFBQUEsMEJBQUE7QUFBQSxJQUFBLEtBQUEsR0FBUSxJQUFJLENBQUMsV0FBTCxDQUFpQixDQUFDLElBQUMsQ0FBQSxDQUFGLEVBQUssSUFBQyxDQUFBLENBQU4sQ0FBakIsQ0FBUixDQUFBO0FBQUEsSUFDQSxLQUFBLEdBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFWLEdBQWtCLENBQUMsSUFBQyxDQUFBLFNBQUQsR0FBYSxDQUFkLENBQUEsR0FBbUIsSUFBSSxDQUFDLEVBQXhCLEdBQTZCLENBRHZELENBQUE7QUFBQSxJQUVBLEtBQUEsR0FBUSxJQUFDLENBQUEsUUFBRCxHQUFZLElBQUMsQ0FBQSxTQUZyQixDQUFBO0FBQUEsSUFHQSxLQUFBLEdBQVEsQ0FBQyxJQUFJLENBQUMsR0FBTCxDQUFTLEtBQVQsQ0FBQSxHQUFrQixLQUFuQixFQUEwQixJQUFJLENBQUMsR0FBTCxDQUFTLEtBQVQsQ0FBQSxHQUFrQixLQUE1QyxDQUhSLENBQUE7V0FJQSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVYsQ0FBcUIsS0FBckIsRUFBNEIsS0FBNUIsRUFMSTtFQUFBLENBbEJOLENBQUE7O0FBQUEscUJBeUJBLEtBQUEsR0FBTyxTQUFBLEdBQUE7QUFDTCxXQUFXLElBQUEsUUFBQSxDQUFTLElBQUMsQ0FBQSxDQUFWLEVBQWEsSUFBQyxDQUFBLENBQWQsRUFBaUIsSUFBQyxDQUFBLFNBQWxCLENBQVgsQ0FESztFQUFBLENBekJQLENBQUE7O2tCQUFBOztHQURxQixLQVB2QixDQUFBOztBQUFBLE1Bb0NNLENBQUMsT0FBUCxHQUFpQixRQXBDakIsQ0FBQTs7Ozs7QUNBQSxJQUFBLGtCQUFBO0VBQUE7OzZCQUFBOztBQUFBLE1BQUEsR0FBUyxPQUFBLENBQVEsUUFBUixDQUFULENBQUE7O0FBQUE7QUFJRSxnQ0FBQSxDQUFBOztBQUFhLEVBQUEsb0JBQUEsR0FBQTtBQUNYLHFDQUFBLENBQUE7QUFBQSxJQUFBLElBQUMsQ0FBQSxLQUFELEdBQVMsQ0FBVCxDQUFBO0FBQUEsSUFDQSxJQUFDLENBQUEsUUFBRCxHQUFZLElBQUksQ0FBQyxHQUFMLENBQUEsQ0FEWixDQUFBO0FBQUEsSUFFQSxJQUFDLENBQUEsR0FBRCxHQUFPLEVBRlAsQ0FEVztFQUFBLENBQWI7O0FBQUEsdUJBS0EsSUFBQSxHQUFNLFNBQUEsR0FBQTtBQUNKLFFBQUEsR0FBQTtBQUFBLElBQUEsSUFBQyxDQUFBLEtBQUQsRUFBQSxDQUFBO0FBQUEsSUFDQSxHQUFBLEdBQU0sSUFBSSxDQUFDLEdBQUwsQ0FBQSxDQUROLENBQUE7QUFBQSxJQUVBLElBQUMsQ0FBQSxHQUFELEdBQU8sR0FBQSxHQUFNLElBQUMsQ0FBQSxHQUFQLEdBQWEsR0FBQSxHQUFNLENBQUMsSUFBQSxHQUFPLENBQUMsR0FBQSxHQUFNLElBQUMsQ0FBQSxRQUFSLENBQVIsQ0FGMUIsQ0FBQTtBQUFBLElBR0EsSUFBQyxDQUFBLFFBQUQsR0FBWSxHQUhaLENBQUE7QUFLQSxJQUFBLElBQUcsSUFBQyxDQUFBLEtBQUQsR0FBUyxFQUFULEtBQWUsQ0FBbEI7YUFDRSxPQUFPLENBQUMsR0FBUixDQUFZLElBQUksQ0FBQyxLQUFMLENBQVcsSUFBQyxDQUFBLEdBQVosQ0FBWixFQURGO0tBTkk7RUFBQSxDQUxOLENBQUE7O29CQUFBOztHQUR1QixPQUh6QixDQUFBOztBQUFBLE1Ba0JNLENBQUMsT0FBUCxHQUFpQixVQWxCakIsQ0FBQTs7Ozs7QUNFQSxJQUFBLElBQUE7RUFBQSxnRkFBQTs7QUFBQTtBQUNlLEVBQUEsY0FBQSxHQUFBO0FBQ1gseUNBQUEsQ0FBQTtBQUFBLG1DQUFBLENBQUE7QUFBQSxtQ0FBQSxDQUFBO0FBQUEsSUFBQSxJQUFDLENBQUEsSUFBRCxHQUFRLEVBQVIsQ0FEVztFQUFBLENBQWI7O0FBQUEsaUJBSUEsR0FBQSxHQUFLLFNBQUMsR0FBRCxFQUFTLEtBQVQsR0FBQTtBQUNILFFBQUEsVUFBQTtBQUFBLElBREssWUFBRyxVQUNSLENBQUE7O1VBQU0sQ0FBQSxDQUFBLElBQU07S0FBWjtXQUNBLElBQUMsQ0FBQSxJQUFLLENBQUEsQ0FBQSxDQUFHLENBQUEsQ0FBQSxDQUFULEdBQWMsTUFGWDtFQUFBLENBSkwsQ0FBQTs7QUFBQSxpQkFTQSxHQUFBLEdBQUssU0FBQyxHQUFELEdBQUE7QUFDSCxRQUFBLFVBQUE7QUFBQSxJQURLLFlBQUcsVUFDUixDQUFBOztVQUFNLENBQUEsQ0FBQSxJQUFNO0tBQVo7QUFDQSxXQUFPLElBQUMsQ0FBQSxJQUFLLENBQUEsQ0FBQSxDQUFHLENBQUEsQ0FBQSxDQUFoQixDQUZHO0VBQUEsQ0FUTCxDQUFBOztBQUFBLGlCQWNBLE1BQUEsR0FBUSxTQUFDLEdBQUQsR0FBQTtBQUNOLFFBQUEsVUFBQTtBQUFBLElBRFEsWUFBRyxVQUNYLENBQUE7O1VBQU0sQ0FBQSxDQUFBLElBQU07S0FBWjtXQUNBLE1BQUEsQ0FBQSxJQUFRLENBQUEsSUFBSyxDQUFBLENBQUEsQ0FBRyxDQUFBLENBQUEsRUFGVjtFQUFBLENBZFIsQ0FBQTs7Y0FBQTs7SUFERixDQUFBOztBQUFBLE1Bb0JNLENBQUMsT0FBUCxHQUFpQixJQXBCakIsQ0FBQTs7Ozs7QUNBQSxJQUFBLElBQUE7O0FBQUEsSUFBQSxHQUFPO0FBQUEsRUFDTCxHQUFBLEVBQUssU0FBQyxDQUFELEVBQUksQ0FBSixHQUFBO0FBQ0gsV0FBTyxDQUFDLENBQUMsQ0FBQSxHQUFJLENBQUwsQ0FBQSxHQUFVLENBQVgsQ0FBQSxHQUFnQixDQUF2QixDQURHO0VBQUEsQ0FEQTtBQUFBLEVBSUwsS0FBQSxFQUFPLFNBQUMsS0FBRCxFQUFRLEdBQVIsRUFBZ0IsR0FBaEIsR0FBQTs7TUFBUSxNQUFJLENBQUE7S0FDakI7O01BRHFCLE1BQUk7S0FDekI7QUFBQSxXQUFPLElBQUksQ0FBQyxHQUFMLENBQVMsR0FBVCxFQUFjLElBQUksQ0FBQyxHQUFMLENBQVMsR0FBVCxFQUFjLEtBQWQsQ0FBZCxDQUFQLENBREs7RUFBQSxDQUpGO0NBQVAsQ0FBQTs7QUFBQSxNQVFNLENBQUMsT0FBUCxHQUFpQixJQVJqQixDQUFBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIiMgQWxsb3dzIGRlZmluaW5nIG9mIHByb3BlcnRpZXMgb24gY2xhc3Nlcy5cbiMgSXQgaXMgYSBsaXR0bGUgc2tldGNoeSBhbmQgbWF5IGRpc2FwcGVhciBzb29uLlxuRnVuY3Rpb246OnByb3BlcnR5ID0gKHByb3AsIGRlc2MpIC0+XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGlzLnByb3RvdHlwZSwgcHJvcCwgZGVzY1xuXG5CbHVlcHJpbnQgPSByZXF1aXJlICdzaGlwL0JsdWVwcmludCdcbkJsdWVwcmludEVkaXRvciA9IHJlcXVpcmUgJ0JsdWVwcmludEVkaXRvcidcbkZQU0NvdW50ZXIgPSByZXF1aXJlICd1dGlsL0ZQU0NvdW50ZXInXG5HYW1lID0gcmVxdWlyZSAnR2FtZSdcbkh1bGwgPSByZXF1aXJlICdzaGlwL0h1bGwnXG5QZXJzb24gPSByZXF1aXJlICdQZXJzb24nXG5QbGF5ZXJTaGlwQ29udHJvbGxlciA9IHJlcXVpcmUgJ1BsYXllclNoaXBDb250cm9sbGVyJ1xuUGxheWVyUGVyc29uQ29udHJvbGxlciA9IHJlcXVpcmUgJ1BsYXllclBlcnNvbkNvbnRyb2xsZXInXG5TaGlwID0gcmVxdWlyZSAnc2hpcC9TaGlwJ1xuU2hpcEh1ZCA9IHJlcXVpcmUgJ1NoaXBIdWQnXG5cbndpbmRvdy5vbmxvYWQgPSAtPlxuICBjb25zb2xlLmxvZyBcImxvYWRlZFwiXG4gIHdpbmRvdy5nYW1lID0gZ2FtZSA9IG5ldyBHYW1lKClcbiAgZ2FtZS5zdGFydCgpXG5cbiAgIyBnYW1lLmFkZEVudGl0eShuZXcgRlBTQ291bnRlcigpKVxuXG4gICMgVE9ETzogUmVmYWN0b3IgdGhpcyB0byBnbyBzb21ld2hlcmUgZWxzZS5cbiAgIyBzaGlwID0gbmV3IFNoaXAoKVxuICAjIGdhbWUuYWRkRW50aXR5KHNoaXApXG5cbiAgY2FsbGJhY2sgPSAoYnApIC0+XG4gICAgZ2FtZS5jYW1lcmEueiA9IDIwXG4gICAgd2luZG93LnNoaXAgPSBuZXcgU2hpcChicClcbiAgICBwZXJzb24gPSBuZXcgUGVyc29uKClcbiAgICBwZXJzb24uYm9hcmQoc2hpcClcbiAgICAjIGNvbnRyb2xsZXIgPSBuZXcgUGxheWVyUGVyc29uQ29udHJvbGxlcihwZXJzb24pXG4gICAgY29udHJvbGxlciA9IG5ldyBQbGF5ZXJTaGlwQ29udHJvbGxlcihzaGlwKVxuICAgIGh1ZCA9IG5ldyBTaGlwSHVkKHNoaXApXG4gICAgZ2FtZS5hZGRFbnRpdHkoc2hpcClcbiAgICBnYW1lLmFkZEVudGl0eShwZXJzb24pXG4gICAgZ2FtZS5hZGRFbnRpdHkoY29udHJvbGxlcilcbiAgICBnYW1lLmFkZEVudGl0eShodWQpXG4gICAgZ2FtZS5jYW1lcmEuZm9sbG93KHNoaXApXG5cbiAgZ2FtZS5hZGRFbnRpdHkobmV3IEJsdWVwcmludEVkaXRvcihuZXcgQmx1ZXByaW50LCBjYWxsYmFjaykpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudFF1ZXVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbaV0oKTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG59XG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHF1ZXVlLnB1c2goZnVuKTtcbiAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgU2NhbGFyID0gcmVxdWlyZSgnLi9TY2FsYXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgbGluZS1yZWxhdGVkIGZ1bmN0aW9uc1xuICogQGNsYXNzIExpbmVcbiAqL1xuZnVuY3Rpb24gTGluZSgpe307XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGxpbmVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBsaW5lSW50XG4gKiBAcGFyYW0gIHtBcnJheX0gIGwxICAgICAgICAgIExpbmUgdmVjdG9yIDFcbiAqIEBwYXJhbSAge0FycmF5fSAgbDIgICAgICAgICAgTGluZSB2ZWN0b3IgMlxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBQcmVjaXNpb24gdG8gdXNlIHdoZW4gY2hlY2tpbmcgaWYgdGhlIGxpbmVzIGFyZSBwYXJhbGxlbFxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxuICovXG5MaW5lLmxpbmVJbnQgPSBmdW5jdGlvbihsMSxsMixwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICAgIHZhciBpID0gWzAsMF07IC8vIHBvaW50XG4gICAgdmFyIGExLCBiMSwgYzEsIGEyLCBiMiwgYzIsIGRldDsgLy8gc2NhbGFyc1xuICAgIGExID0gbDFbMV1bMV0gLSBsMVswXVsxXTtcbiAgICBiMSA9IGwxWzBdWzBdIC0gbDFbMV1bMF07XG4gICAgYzEgPSBhMSAqIGwxWzBdWzBdICsgYjEgKiBsMVswXVsxXTtcbiAgICBhMiA9IGwyWzFdWzFdIC0gbDJbMF1bMV07XG4gICAgYjIgPSBsMlswXVswXSAtIGwyWzFdWzBdO1xuICAgIGMyID0gYTIgKiBsMlswXVswXSArIGIyICogbDJbMF1bMV07XG4gICAgZGV0ID0gYTEgKiBiMiAtIGEyKmIxO1xuICAgIGlmICghU2NhbGFyLmVxKGRldCwgMCwgcHJlY2lzaW9uKSkgeyAvLyBsaW5lcyBhcmUgbm90IHBhcmFsbGVsXG4gICAgICAgIGlbMF0gPSAoYjIgKiBjMSAtIGIxICogYzIpIC8gZGV0O1xuICAgICAgICBpWzFdID0gKGExICogYzIgLSBhMiAqIGMxKSAvIGRldDtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RzLlxuICogQG1ldGhvZCBzZWdtZW50c0ludGVyc2VjdFxuICogQHBhcmFtIHtBcnJheX0gcDEgVGhlIHN0YXJ0IHZlcnRleCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcDIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHExIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBxMiBUaGUgZW5kIHZlcnRleCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdFxuICovXG5MaW5lLnNlZ21lbnRzSW50ZXJzZWN0ID0gZnVuY3Rpb24ocDEsIHAyLCBxMSwgcTIpe1xuICAgdmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcbiAgIHZhciBkeSA9IHAyWzFdIC0gcDFbMV07XG4gICB2YXIgZGEgPSBxMlswXSAtIHExWzBdO1xuICAgdmFyIGRiID0gcTJbMV0gLSBxMVsxXTtcblxuICAgLy8gc2VnbWVudHMgYXJlIHBhcmFsbGVsXG4gICBpZihkYSpkeSAtIGRiKmR4ID09IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgIHZhciBzID0gKGR4ICogKHExWzFdIC0gcDFbMV0pICsgZHkgKiAocDFbMF0gLSBxMVswXSkpIC8gKGRhICogZHkgLSBkYiAqIGR4KVxuICAgdmFyIHQgPSAoZGEgKiAocDFbMV0gLSBxMVsxXSkgKyBkYiAqIChxMVswXSAtIHAxWzBdKSkgLyAoZGIgKiBkeCAtIGRhICogZHkpXG5cbiAgIHJldHVybiAocz49MCAmJiBzPD0xICYmIHQ+PTAgJiYgdDw9MSk7XG59O1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG4vKipcbiAqIFBvaW50IHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAY2xhc3MgUG9pbnRcbiAqL1xuZnVuY3Rpb24gUG9pbnQoKXt9O1xuXG4vKipcbiAqIEdldCB0aGUgYXJlYSBvZiBhIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIGdpdmVuIHBvaW50cy4gTm90ZSB0aGF0IHRoZSBhcmVhIHdpbGwgYmUgbmVnYXRpdmUgaWYgdGhlIHBvaW50cyBhcmUgbm90IGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBhcmVhXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblBvaW50LmFyZWEgPSBmdW5jdGlvbihhLGIsYyl7XG4gICAgcmV0dXJuICgoKGJbMF0gLSBhWzBdKSooY1sxXSAtIGFbMV0pKS0oKGNbMF0gLSBhWzBdKSooYlsxXSAtIGFbMV0pKSk7XG59O1xuXG5Qb2ludC5sZWZ0ID0gZnVuY3Rpb24oYSxiLGMpe1xuICAgIHJldHVybiBQb2ludC5hcmVhKGEsYixjKSA+IDA7XG59O1xuXG5Qb2ludC5sZWZ0T24gPSBmdW5jdGlvbihhLGIsYykge1xuICAgIHJldHVybiBQb2ludC5hcmVhKGEsIGIsIGMpID49IDA7XG59O1xuXG5Qb2ludC5yaWdodCA9IGZ1bmN0aW9uKGEsYixjKSB7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPCAwO1xufTtcblxuUG9pbnQucmlnaHRPbiA9IGZ1bmN0aW9uKGEsYixjKSB7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPD0gMDtcbn07XG5cbnZhciB0bXBQb2ludDEgPSBbXSxcbiAgICB0bXBQb2ludDIgPSBbXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxuICogQG1ldGhvZCBjb2xsaW5lYXJcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEBwYXJhbSAge051bWJlcn0gW3RocmVzaG9sZEFuZ2xlPTBdIFRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBjb21wYXJpbmcgdGhlIHZlY3RvcnMuIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSByZXN1bHRpbmcgdmVjdG9ycyBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZS4gVXNlIHplcm8gZm9yIG1heCBwcmVjaXNpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Qb2ludC5jb2xsaW5lYXIgPSBmdW5jdGlvbihhLGIsYyx0aHJlc2hvbGRBbmdsZSkge1xuICAgIGlmKCF0aHJlc2hvbGRBbmdsZSlcbiAgICAgICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPT0gMDtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFiID0gdG1wUG9pbnQxLFxuICAgICAgICAgICAgYmMgPSB0bXBQb2ludDI7XG5cbiAgICAgICAgYWJbMF0gPSBiWzBdLWFbMF07XG4gICAgICAgIGFiWzFdID0gYlsxXS1hWzFdO1xuICAgICAgICBiY1swXSA9IGNbMF0tYlswXTtcbiAgICAgICAgYmNbMV0gPSBjWzFdLWJbMV07XG5cbiAgICAgICAgdmFyIGRvdCA9IGFiWzBdKmJjWzBdICsgYWJbMV0qYmNbMV0sXG4gICAgICAgICAgICBtYWdBID0gTWF0aC5zcXJ0KGFiWzBdKmFiWzBdICsgYWJbMV0qYWJbMV0pLFxuICAgICAgICAgICAgbWFnQiA9IE1hdGguc3FydChiY1swXSpiY1swXSArIGJjWzFdKmJjWzFdKSxcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hY29zKGRvdC8obWFnQSptYWdCKSk7XG4gICAgICAgIHJldHVybiBhbmdsZSA8IHRocmVzaG9sZEFuZ2xlO1xuICAgIH1cbn07XG5cblBvaW50LnNxZGlzdCA9IGZ1bmN0aW9uKGEsYil7XG4gICAgdmFyIGR4ID0gYlswXSAtIGFbMF07XG4gICAgdmFyIGR5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufTtcbiIsInZhciBMaW5lID0gcmVxdWlyZShcIi4vTGluZVwiKVxuLCAgIFBvaW50ID0gcmVxdWlyZShcIi4vUG9pbnRcIilcbiwgICBTY2FsYXIgPSByZXF1aXJlKFwiLi9TY2FsYXJcIilcblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuXG4vKipcbiAqIFBvbHlnb24gY2xhc3MuXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBvbHlnb24oKXtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2VzIHRoYXQgdGhpcyBwb2x5Z29uIGNvbnNpc3RzIG9mLiBBbiBhcnJheSBvZiBhcnJheSBvZiBudW1iZXJzLCBleGFtcGxlOiBbWzAsMF0sWzEsMF0sLi5dXG4gICAgICogQHByb3BlcnR5IHZlcnRpY2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSBbXTtcbn1cblxuLyoqXG4gKiBHZXQgYSB2ZXJ0ZXggYXQgcG9zaXRpb24gaS4gSXQgZG9lcyBub3QgbWF0dGVyIGlmIGkgaXMgb3V0IG9mIGJvdW5kcywgdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgY3ljbGUuXG4gKiBAbWV0aG9kIGF0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKGkpe1xuICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgcyA9IHYubGVuZ3RoO1xuICAgIHJldHVybiB2W2kgPCAwID8gaSAlIHMgKyBzIDogaSAlIHNdO1xufTtcblxuLyoqXG4gKiBHZXQgZmlyc3QgdmVydGV4XG4gKiBAbWV0aG9kIGZpcnN0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzWzBdO1xufTtcblxuLyoqXG4gKiBHZXQgbGFzdCB2ZXJ0ZXhcbiAqIEBtZXRob2QgbGFzdFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzW3RoaXMudmVydGljZXMubGVuZ3RoLTFdO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgcG9seWdvbiBkYXRhXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMudmVydGljZXMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogQXBwZW5kIHBvaW50cyBcImZyb21cIiB0byBcInRvXCItMSBmcm9tIGFuIG90aGVyIHBvbHlnb24gXCJwb2x5XCIgb250byB0aGlzIG9uZS5cbiAqIEBtZXRob2QgYXBwZW5kXG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHkgVGhlIHBvbHlnb24gdG8gZ2V0IHBvaW50cyBmcm9tLlxuICogQHBhcmFtIHtOdW1iZXJ9ICBmcm9tIFRoZSB2ZXJ0ZXggaW5kZXggaW4gXCJwb2x5XCIuXG4gKiBAcGFyYW0ge051bWJlcn0gIHRvIFRoZSBlbmQgdmVydGV4IGluZGV4IGluIFwicG9seVwiLiBOb3RlIHRoYXQgdGhpcyB2ZXJ0ZXggaXMgTk9UIGluY2x1ZGVkIHdoZW4gYXBwZW5kaW5nLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHBvbHksZnJvbSx0byl7XG4gICAgaWYodHlwZW9mKGZyb20pID09IFwidW5kZWZpbmVkXCIpIHRocm93IG5ldyBFcnJvcihcIkZyb20gaXMgbm90IGdpdmVuIVwiKTtcbiAgICBpZih0eXBlb2YodG8pID09IFwidW5kZWZpbmVkXCIpICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gaXMgbm90IGdpdmVuIVwiKTtcblxuICAgIGlmKHRvLTEgPCBmcm9tKSAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9sMVwiKTtcbiAgICBpZih0byA+IHBvbHkudmVydGljZXMubGVuZ3RoKSAgIHRocm93IG5ldyBFcnJvcihcImxvbDJcIik7XG4gICAgaWYoZnJvbSA8IDApICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2wzXCIpO1xuXG4gICAgZm9yKHZhciBpPWZyb207IGk8dG87IGkrKyl7XG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaChwb2x5LnZlcnRpY2VzW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2x5Z29uIHZlcnRpY2VzIGFyZSBvcmRlcmVkIGNvdW50ZXItY2xvY2t3aXNlLlxuICogQG1ldGhvZCBtYWtlQ0NXXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLm1ha2VDQ1cgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiciA9IDAsXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgLy8gZmluZCBib3R0b20gcmlnaHQgcG9pbnRcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHZbaV1bMV0gPCB2W2JyXVsxXSB8fCAodltpXVsxXSA9PSB2W2JyXVsxXSAmJiB2W2ldWzBdID4gdlticl1bMF0pKSB7XG4gICAgICAgICAgICBiciA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXZlcnNlIHBvbHkgaWYgY2xvY2t3aXNlXG4gICAgaWYgKCFQb2ludC5sZWZ0KHRoaXMuYXQoYnIgLSAxKSwgdGhpcy5hdChiciksIHRoaXMuYXQoYnIgKyAxKSkpIHtcbiAgICAgICAgdGhpcy5yZXZlcnNlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXZlcnNlIHRoZSB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvblxuICogQG1ldGhvZCByZXZlcnNlXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICBmb3IodmFyIGk9MCwgTj10aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHRtcC5wdXNoKHRoaXMudmVydGljZXMucG9wKCkpO1xuICAgIH1cbiAgICB0aGlzLnZlcnRpY2VzID0gdG1wO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGluIHRoZSBwb2x5Z29uIGlzIGEgcmVmbGV4IHBvaW50XG4gKiBAbWV0aG9kIGlzUmVmbGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBpXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5pc1JlZmxleCA9IGZ1bmN0aW9uKGkpe1xuICAgIHJldHVybiBQb2ludC5yaWdodCh0aGlzLmF0KGkgLSAxKSwgdGhpcy5hdChpKSwgdGhpcy5hdChpICsgMSkpO1xufTtcblxudmFyIHRtcExpbmUxPVtdLFxuICAgIHRtcExpbmUyPVtdO1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcbiAqIEBtZXRob2QgY2FuU2VlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGEgVmVydGV4IGluZGV4IDFcbiAqIEBwYXJhbSAge051bWJlcn0gYiBWZXJ0ZXggaW5kZXggMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY2FuU2VlID0gZnVuY3Rpb24oYSxiKSB7XG4gICAgdmFyIHAsIGRpc3QsIGwxPXRtcExpbmUxLCBsMj10bXBMaW5lMjtcblxuICAgIGlmIChQb2ludC5sZWZ0T24odGhpcy5hdChhICsgMSksIHRoaXMuYXQoYSksIHRoaXMuYXQoYikpICYmIFBvaW50LnJpZ2h0T24odGhpcy5hdChhIC0gMSksIHRoaXMuYXQoYSksIHRoaXMuYXQoYikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGlzdCA9IFBvaW50LnNxZGlzdCh0aGlzLmF0KGEpLCB0aGlzLmF0KGIpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkgeyAvLyBmb3IgZWFjaCBlZGdlXG4gICAgICAgIGlmICgoaSArIDEpICUgdGhpcy52ZXJ0aWNlcy5sZW5ndGggPT09IGEgfHwgaSA9PT0gYSkgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKFBvaW50LmxlZnRPbih0aGlzLmF0KGEpLCB0aGlzLmF0KGIpLCB0aGlzLmF0KGkgKyAxKSkgJiYgUG9pbnQucmlnaHRPbih0aGlzLmF0KGEpLCB0aGlzLmF0KGIpLCB0aGlzLmF0KGkpKSkgeyAvLyBpZiBkaWFnIGludGVyc2VjdHMgYW4gZWRnZVxuICAgICAgICAgICAgbDFbMF0gPSB0aGlzLmF0KGEpO1xuICAgICAgICAgICAgbDFbMV0gPSB0aGlzLmF0KGIpO1xuICAgICAgICAgICAgbDJbMF0gPSB0aGlzLmF0KGkpO1xuICAgICAgICAgICAgbDJbMV0gPSB0aGlzLmF0KGkgKyAxKTtcbiAgICAgICAgICAgIHAgPSBMaW5lLmxpbmVJbnQobDEsbDIpO1xuICAgICAgICAgICAgaWYgKFBvaW50LnNxZGlzdCh0aGlzLmF0KGEpLCBwKSA8IGRpc3QpIHsgLy8gaWYgZWRnZSBpcyBibG9ja2luZyB2aXNpYmlsaXR5IHRvIGJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgcG9seWdvbiBmcm9tIHZlcnRleCBpIHRvIHZlcnRleCBqLlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtICB7UG9seWdvbn0gW3RhcmdldFBvbHldICAgT3B0aW9uYWwgdGFyZ2V0IHBvbHlnb24gdG8gc2F2ZSBpbi5cbiAqIEByZXR1cm4ge1BvbHlnb259ICAgICAgICAgICAgICAgIFRoZSByZXN1bHRpbmcgY29weS5cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGksaix0YXJnZXRQb2x5KXtcbiAgICB2YXIgcCA9IHRhcmdldFBvbHkgfHwgbmV3IFBvbHlnb24oKTtcbiAgICBwLmNsZWFyKCk7XG4gICAgaWYgKGkgPCBqKSB7XG4gICAgICAgIC8vIEluc2VydCBhbGwgdmVydGljZXMgZnJvbSBpIHRvIGpcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8PWo7IGsrKylcbiAgICAgICAgICAgIHAudmVydGljZXMucHVzaCh0aGlzLnZlcnRpY2VzW2tdKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gSW5zZXJ0IHZlcnRpY2VzIDAgdG8galxuICAgICAgICBmb3IodmFyIGs9MDsgazw9ajsgaysrKVxuICAgICAgICAgICAgcC52ZXJ0aWNlcy5wdXNoKHRoaXMudmVydGljZXNba10pO1xuXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyBpIHRvIGVuZFxuICAgICAgICBmb3IodmFyIGs9aTsgazx0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgcC52ZXJ0aWNlcy5wdXNoKHRoaXMudmVydGljZXNba10pO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLyoqXG4gKiBEZWNvbXBvc2VzIHRoZSBwb2x5Z29uIGludG8gY29udmV4IHBpZWNlcy4gUmV0dXJucyBhIGxpc3Qgb2YgZWRnZXMgW1twMSxwMl0sW3AyLHAzXSwuLi5dIHRoYXQgY3V0cyB0aGUgcG9seWdvbi5cbiAqIE5vdGUgdGhhdCB0aGlzIGFsZ29yaXRobSBoYXMgY29tcGxleGl0eSBPKE5eNCkgYW5kIHdpbGwgYmUgdmVyeSBzbG93IGZvciBwb2x5Z29ucyB3aXRoIG1hbnkgdmVydGljZXMuXG4gKiBAbWV0aG9kIGdldEN1dEVkZ2VzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuZ2V0Q3V0RWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWluPVtdLCB0bXAxPVtdLCB0bXAyPVtdLCB0bXBQb2x5ID0gbmV3IFBvbHlnb24oKTtcbiAgICB2YXIgbkRpYWdzID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5pc1JlZmxleChpKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuU2VlKGksIGopKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcDEgPSB0aGlzLmNvcHkoaSwgaiwgdG1wUG9seSkuZ2V0Q3V0RWRnZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wMiA9IHRoaXMuY29weShqLCBpLCB0bXBQb2x5KS5nZXRDdXRFZGdlcygpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrPHRtcDIubGVuZ3RoOyBrKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAxLnB1c2godG1wMltrXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcDEubGVuZ3RoIDwgbkRpYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB0bXAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbkRpYWdzID0gdG1wMS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4ucHVzaChbdGhpcy5hdChpKSwgdGhpcy5hdChqKV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbjtcbn07XG5cbi8qKlxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIG9uZSBvciBtb3JlIGNvbnZleCBzdWItUG9seWdvbnMuXG4gKiBAbWV0aG9kIGRlY29tcFxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9yIFBvbHlnb24gb2JqZWN0cy5cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuZGVjb21wID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmdldEN1dEVkZ2VzKCk7XG4gICAgaWYoZWRnZXMubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoZWRnZXMpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcbn07XG5cbi8qKlxuICogU2xpY2VzIHRoZSBwb2x5Z29uIGdpdmVuIG9uZSBvciBtb3JlIGN1dCBlZGdlcy4gSWYgZ2l2ZW4gb25lLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHR3byBwb2x5Z29ucyAoZmFsc2Ugb24gZmFpbHVyZSkuIElmIG1hbnksIGFuIGFycmF5IG9mIHBvbHlnb25zLlxuICogQG1ldGhvZCBzbGljZVxuICogQHBhcmFtIHtBcnJheX0gY3V0RWRnZXMgQSBsaXN0IG9mIGVkZ2VzLCBhcyByZXR1cm5lZCBieSAuZ2V0Q3V0RWRnZXMoKVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oY3V0RWRnZXMpe1xuICAgIGlmKGN1dEVkZ2VzLmxlbmd0aCA9PSAwKSByZXR1cm4gW3RoaXNdO1xuICAgIGlmKGN1dEVkZ2VzIGluc3RhbmNlb2YgQXJyYXkgJiYgY3V0RWRnZXMubGVuZ3RoICYmIGN1dEVkZ2VzWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgY3V0RWRnZXNbMF0ubGVuZ3RoPT0yICYmIGN1dEVkZ2VzWzBdWzBdIGluc3RhbmNlb2YgQXJyYXkpe1xuXG4gICAgICAgIHZhciBwb2x5cyA9IFt0aGlzXTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxjdXRFZGdlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgY3V0RWRnZSA9IGN1dEVkZ2VzW2ldO1xuICAgICAgICAgICAgLy8gQ3V0IGFsbCBwb2x5c1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8cG9seXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgIHZhciBwb2x5ID0gcG9seXNbal07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBvbHkuc2xpY2UoY3V0RWRnZSk7XG4gICAgICAgICAgICAgICAgaWYocmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgcG9seSEgQ3V0IGFuZCBxdWl0XG4gICAgICAgICAgICAgICAgICAgIHBvbHlzLnNwbGljZShqLDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5cy5wdXNoKHJlc3VsdFswXSxyZXN1bHRbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seXM7XG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBXYXMgZ2l2ZW4gb25lIGVkZ2VcbiAgICAgICAgdmFyIGN1dEVkZ2UgPSBjdXRFZGdlcztcbiAgICAgICAgdmFyIGkgPSB0aGlzLnZlcnRpY2VzLmluZGV4T2YoY3V0RWRnZVswXSk7XG4gICAgICAgIHZhciBqID0gdGhpcy52ZXJ0aWNlcy5pbmRleE9mKGN1dEVkZ2VbMV0pO1xuXG4gICAgICAgIGlmKGkgIT0gLTEgJiYgaiAhPSAtMSl7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuY29weShpLGopLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHkoaixpKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyB0aGF0IHRoZSBsaW5lIHNlZ21lbnRzIG9mIHRoaXMgcG9seWdvbiBkbyBub3QgaW50ZXJzZWN0IGVhY2ggb3RoZXIuXG4gKiBAbWV0aG9kIGlzU2ltcGxlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiB2ZXJ0aWNlcyBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHRvZG8gU2hvdWxkIGl0IGNoZWNrIGFsbCBzZWdtZW50cyB3aXRoIGFsbCBvdGhlcnM/XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmlzU2ltcGxlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGF0aCA9IHRoaXMudmVydGljZXM7XG4gICAgLy8gQ2hlY2tcbiAgICBmb3IodmFyIGk9MDsgaTxwYXRoLmxlbmd0aC0xOyBpKyspe1xuICAgICAgICBmb3IodmFyIGo9MDsgajxpLTE7IGorKyl7XG4gICAgICAgICAgICBpZihMaW5lLnNlZ21lbnRzSW50ZXJzZWN0KHBhdGhbaV0sIHBhdGhbaSsxXSwgcGF0aFtqXSwgcGF0aFtqKzFdICkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBzZWdtZW50IGJldHdlZW4gdGhlIGxhc3QgYW5kIHRoZSBmaXJzdCBwb2ludCB0byBhbGwgb3RoZXJzXG4gICAgZm9yKHZhciBpPTE7IGk8cGF0aC5sZW5ndGgtMjsgaSsrKXtcbiAgICAgICAgaWYoTGluZS5zZWdtZW50c0ludGVyc2VjdChwYXRoWzBdLCBwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoW2ldLCBwYXRoW2krMV0gKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblBvaW50KHAxLCBwMiwgcTEsIHEyLCBkZWx0YSl7XG4gICAgZGVsdGEgPSBkZWx0YSB8fCAwO1xuICAgdmFyIGExID0gcDJbMV0gLSBwMVsxXTtcbiAgIHZhciBiMSA9IHAxWzBdIC0gcDJbMF07XG4gICB2YXIgYzEgPSAoYTEgKiBwMVswXSkgKyAoYjEgKiBwMVsxXSk7XG4gICB2YXIgYTIgPSBxMlsxXSAtIHExWzFdO1xuICAgdmFyIGIyID0gcTFbMF0gLSBxMlswXTtcbiAgIHZhciBjMiA9IChhMiAqIHExWzBdKSArIChiMiAqIHExWzFdKTtcbiAgIHZhciBkZXQgPSAoYTEgKiBiMikgLSAoYTIgKiBiMSk7XG5cbiAgIGlmKCFTY2FsYXIuZXEoZGV0LDAsZGVsdGEpKVxuICAgICAgcmV0dXJuIFsoKGIyICogYzEpIC0gKGIxICogYzIpKSAvIGRldCwgKChhMSAqIGMyKSAtIChhMiAqIGMxKSkgLyBkZXRdXG4gICBlbHNlXG4gICAgICByZXR1cm4gWzAsMF1cbn1cblxuLyoqXG4gKiBRdWlja2x5IGRlY29tcG9zZSB0aGUgUG9seWdvbiBpbnRvIGNvbnZleCBzdWItcG9seWdvbnMuXG4gKiBAbWV0aG9kIHF1aWNrRGVjb21wXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XG4gKiBAcGFyYW0gIHtBcnJheX0gW3JlZmxleFZlcnRpY2VzXVxuICogQHBhcmFtICB7QXJyYXl9IFtzdGVpbmVyUG9pbnRzXVxuICogQHBhcmFtICB7TnVtYmVyfSBbZGVsdGFdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXhsZXZlbF1cbiAqIEBwYXJhbSAge051bWJlcn0gW2xldmVsXVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnF1aWNrRGVjb21wID0gZnVuY3Rpb24ocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpe1xuICAgIG1heGxldmVsID0gbWF4bGV2ZWwgfHwgMTAwO1xuICAgIGxldmVsID0gbGV2ZWwgfHwgMDtcbiAgICBkZWx0YSA9IGRlbHRhIHx8IDI1O1xuICAgIHJlc3VsdCA9IHR5cGVvZihyZXN1bHQpIT1cInVuZGVmaW5lZFwiID8gcmVzdWx0IDogW107XG4gICAgcmVmbGV4VmVydGljZXMgPSByZWZsZXhWZXJ0aWNlcyB8fCBbXTtcbiAgICBzdGVpbmVyUG9pbnRzID0gc3RlaW5lclBvaW50cyB8fCBbXTtcblxuICAgIHZhciB1cHBlckludD1bMCwwXSwgbG93ZXJJbnQ9WzAsMF0sIHA9WzAsMF07IC8vIFBvaW50c1xuICAgIHZhciB1cHBlckRpc3Q9MCwgbG93ZXJEaXN0PTAsIGQ9MCwgY2xvc2VzdERpc3Q9MDsgLy8gc2NhbGFyc1xuICAgIHZhciB1cHBlckluZGV4PTAsIGxvd2VySW5kZXg9MCwgY2xvc2VzdEluZGV4PTA7IC8vIEludGVnZXJzXG4gICAgdmFyIGxvd2VyUG9seT1uZXcgUG9seWdvbigpLCB1cHBlclBvbHk9bmV3IFBvbHlnb24oKTsgLy8gcG9seWdvbnNcbiAgICB2YXIgcG9seSA9IHRoaXMsXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgaWYodi5sZW5ndGggPCAzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgbGV2ZWwrKztcbiAgICBpZihsZXZlbCA+IG1heGxldmVsKXtcbiAgICAgICAgY29uc29sZS53YXJuKFwicXVpY2tEZWNvbXA6IG1heCBsZXZlbCAoXCIrbWF4bGV2ZWwrXCIpIHJlYWNoZWQuXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAocG9seS5pc1JlZmxleChpKSkge1xuICAgICAgICAgICAgcmVmbGV4VmVydGljZXMucHVzaChwb2x5LnZlcnRpY2VzW2ldKTtcbiAgICAgICAgICAgIHVwcGVyRGlzdCA9IGxvd2VyRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKFBvaW50LmxlZnQocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBQb2ludC5yaWdodE9uKHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGogLSAxKSkpIHsgLy8gaWYgbGluZSBpbnRlcnNlY3RzIHdpdGggYW4gZWRnZVxuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaiksIHBvbHkuYXQoaiAtIDEpKTsgLy8gZmluZCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChQb2ludC5yaWdodChwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcCkpIHsgLy8gbWFrZSBzdXJlIGl0J3MgaW5zaWRlIHRoZSBwb2x5XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gUG9pbnQuc3FkaXN0KHBvbHkudmVydGljZXNbaV0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBsb3dlckRpc3QpIHsgLy8ga2VlcCBvbmx5IHRoZSBjbG9zZXN0IGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyRGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChQb2ludC5sZWZ0KHBvbHkuYXQoaSArIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGogKyAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIFBvaW50LnJpZ2h0T24ocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqKSwgcG9seS5hdChqICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoUG9pbnQubGVmdChwb2x5LmF0KGkgLSAxKSwgcG9seS5hdChpKSwgcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBQb2ludC5zcWRpc3QocG9seS52ZXJ0aWNlc1tpXSwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IHVwcGVyRGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyRGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdmVydGljZXMgdG8gY29ubmVjdCB0bywgY2hvb3NlIGEgcG9pbnQgaW4gdGhlIG1pZGRsZVxuICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggPT0gKHVwcGVySW5kZXggKyAxKSAlIHRoaXMudmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMTogVmVydGV4KFwiK2krXCIpLCBsb3dlckluZGV4KFwiK2xvd2VySW5kZXgrXCIpLCB1cHBlckluZGV4KFwiK3VwcGVySW5kZXgrXCIpLCBwb2x5LnNpemUoXCIrdGhpcy52ZXJ0aWNlcy5sZW5ndGgrXCIpXCIpO1xuICAgICAgICAgICAgICAgIHBbMF0gPSAobG93ZXJJbnRbMF0gKyB1cHBlckludFswXSkgLyAyO1xuICAgICAgICAgICAgICAgIHBbMV0gPSAobG93ZXJJbnRbMV0gKyB1cHBlckludFsxXSkgLyAyO1xuICAgICAgICAgICAgICAgIHN0ZWluZXJQb2ludHMucHVzaChwKTtcblxuICAgICAgICAgICAgICAgIGlmIChpIDwgdXBwZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSwgaSwgdXBwZXJJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnZlcnRpY2VzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGxvd2VySW5kZXgsIHBvbHkuZW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LGxvd2VySW5kZXgscG9seS52ZXJ0aWNlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksMCxpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5lbmQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksaSxwb2x5LnZlcnRpY2VzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpLCBwb2x5LmJlZ2luKCkgKyB1cHBlckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSwwLHVwcGVySW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkudmVydGljZXMucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgLy91cHBlclBvbHkuaW5zZXJ0KHVwcGVyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgbG93ZXJJbmRleCwgcG9seS5iZWdpbigpICsgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksbG93ZXJJbmRleCxpKzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdCB0byB0aGUgY2xvc2VzdCBwb2ludCB3aXRoaW4gdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMjogVmVydGV4KFwiK2krXCIpLCBjbG9zZXN0SW5kZXgoXCIrY2xvc2VzdEluZGV4K1wiKSwgcG9seS5zaXplKFwiK3RoaXMudmVydGljZXMubGVuZ3RoK1wiKVxcblwiKTtcblxuICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID4gdXBwZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ICs9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgICAgICAgICBpZih1cHBlckluZGV4IDwgbG93ZXJJbmRleCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGxvd2VySW5kZXg7IGogPD0gdXBwZXJJbmRleDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChQb2ludC5sZWZ0T24ocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgUG9pbnQucmlnaHRPbihwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBQb2ludC5zcWRpc3QocG9seS5hdChpKSwgcG9seS5hdChqKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGNsb3Nlc3REaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGogJSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpIDwgY2xvc2VzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSxpLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RJbmRleCAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSxjbG9zZXN0SW5kZXgsdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSwwLGkrMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksaSx2Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LDAsY2xvc2VzdEluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksY2xvc2VzdEluZGV4LGkrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzb2x2ZSBzbWFsbGVzdCBwb2x5IGZpcnN0XG4gICAgICAgICAgICBpZiAobG93ZXJQb2x5LnZlcnRpY2VzLmxlbmd0aCA8IHVwcGVyUG9seS52ZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb3dlclBvbHkucXVpY2tEZWNvbXAocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgICAgIHVwcGVyUG9seS5xdWlja0RlY29tcChyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwcGVyUG9seS5xdWlja0RlY29tcChyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICAgICAgbG93ZXJQb2x5LnF1aWNrRGVjb21wKHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQucHVzaCh0aGlzKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBjb2xsaW5lYXIgcG9pbnRzIGluIHRoZSBwb2x5Z29uLlxuICogQG1ldGhvZCByZW1vdmVDb2xsaW5lYXJQb2ludHNcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBlZGdlcyBhcmUgY29sbGluZWFyLiBVc2UgemVybyBmb3IgZmluZXN0IHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlbW92ZWRcbiAqL1xuUG9seWdvbi5wcm90b3R5cGUucmVtb3ZlQ29sbGluZWFyUG9pbnRzID0gZnVuY3Rpb24ocHJlY2lzaW9uKXtcbiAgICB2YXIgbnVtID0gMDtcbiAgICBmb3IodmFyIGk9dGhpcy52ZXJ0aWNlcy5sZW5ndGgtMTsgdGhpcy52ZXJ0aWNlcy5sZW5ndGg+MyAmJiBpPj0wOyAtLWkpe1xuICAgICAgICBpZihQb2ludC5jb2xsaW5lYXIodGhpcy5hdChpLTEpLHRoaXMuYXQoaSksdGhpcy5hdChpKzEpLHByZWNpc2lvbikpe1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBtaWRkbGUgcG9pbnRcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMuc3BsaWNlKGkldGhpcy52ZXJ0aWNlcy5sZW5ndGgsMSk7XG4gICAgICAgICAgICBpLS07IC8vIEp1bXAgb25lIHBvaW50IGZvcndhcmQuIE90aGVyd2lzZSB3ZSBtYXkgZ2V0IGEgY2hhaW4gcmVtb3ZhbFxuICAgICAgICAgICAgbnVtKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFNjYWxhcjtcblxuLyoqXG4gKiBTY2FsYXIgZnVuY3Rpb25zXG4gKiBAY2xhc3MgU2NhbGFyXG4gKi9cbmZ1bmN0aW9uIFNjYWxhcigpe31cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gc2NhbGFycyBhcmUgZXF1YWxcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZXFcbiAqIEBwYXJhbSAge051bWJlcn0gYVxuICogQHBhcmFtICB7TnVtYmVyfSBiXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5TY2FsYXIuZXEgPSBmdW5jdGlvbihhLGIscHJlY2lzaW9uKXtcbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMDtcbiAgICByZXR1cm4gTWF0aC5hYnMoYS1iKSA8IHByZWNpc2lvbjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQb2x5Z29uIDogcmVxdWlyZShcIi4vUG9seWdvblwiKSxcbiAgICBQb2ludCA6IHJlcXVpcmUoXCIuL1BvaW50XCIpLFxufTtcbiIsIm1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwicDJcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMC42LjFcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgSmF2YVNjcmlwdCAyRCBwaHlzaWNzIGVuZ2luZS5cIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIlN0ZWZhbiBIZWRtYW5cIixcbiAgICBcImVtYWlsXCI6IFwic2NodGVwcGVAZ21haWwuY29tXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwOi8vc3RlZmZlLnNlXCJcbiAgfSxcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJwMi5qc1wiLFxuICAgIFwicDJcIixcbiAgICBcInBoeXNpY3NcIixcbiAgICBcImVuZ2luZVwiLFxuICAgIFwiMmRcIlxuICBdLFxuICBcIm1haW5cIjogXCIuL3NyYy9wMi5qc1wiLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIipcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3AyLmpzLmdpdFwiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvcDIuanMvaXNzdWVzXCJcbiAgfSxcbiAgXCJsaWNlbnNlc1wiOiBbXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwiTUlUXCJcbiAgICB9XG4gIF0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImdydW50XCI6IFwifjAuNC4wXCIsXG4gICAgXCJncnVudC1jb250cmliLWpzaGludFwiOiBcIn4wLjkuMlwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1ub2RldW5pdFwiOiBcIn4wLjEuMlwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJ+MC40LjBcIixcbiAgICBcImdydW50LWNvbnRyaWItd2F0Y2hcIjogXCJ+MC41LjBcIixcbiAgICBcImdydW50LWJyb3dzZXJpZnlcIjogXCJ+Mi4wLjFcIixcbiAgICBcImdydW50LWNvbnRyaWItY29uY2F0XCI6IFwiXjAuNC4wXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwicG9seS1kZWNvbXBcIjogXCIwLjEuMFwiXG4gIH0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvcDIuanNcIixcbiAgXCJfaWRcIjogXCJwMkAwLjYuMVwiLFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiYjI2ZmU4YmMzMTllZjBkODljMThmOTc1ZGQ4Y2EyMzk5Zjg3NmI1M1wiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHA6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvcDIvLS9wMi0wLjYuMS50Z3pcIlxuICB9LFxuICBcIl9mcm9tXCI6IFwicDJAPj0wLjYuMSA8MC43LjBcIixcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjEuNC4zXCIsXG4gIFwiX25wbVVzZXJcIjoge1xuICAgIFwibmFtZVwiOiBcInNjaHRlcHBlXCIsXG4gICAgXCJlbWFpbFwiOiBcInNjaHRlcHBlQGdtYWlsLmNvbVwiXG4gIH0sXG4gIFwibWFpbnRhaW5lcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcInNjaHRlcHBlXCIsXG4gICAgICBcImVtYWlsXCI6IFwic2NodGVwcGVAZ21haWwuY29tXCJcbiAgICB9XG4gIF0sXG4gIFwiZGlyZWN0b3JpZXNcIjoge30sXG4gIFwiX3NoYXN1bVwiOiBcImIyNmZlOGJjMzE5ZWYwZDg5YzE4Zjk3NWRkOGNhMjM5OWY4NzZiNTNcIixcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9wMi8tL3AyLTAuNi4xLnRnelwiLFxuICBcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIlxufVxuIiwidmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBQUJCO1xuXG4vKipcbiAqIEF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggY2xhc3MuXG4gKiBAY2xhc3MgQUFCQlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy51cHBlckJvdW5kXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb3dlckJvdW5kXVxuICovXG5mdW5jdGlvbiBBQUJCKG9wdGlvbnMpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHByb3BlcnR5IGxvd2VyQm91bmRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb3dlckJvdW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zICYmIG9wdGlvbnMubG93ZXJCb3VuZCl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmxvd2VyQm91bmQsIG9wdGlvbnMubG93ZXJCb3VuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHByb3BlcnR5IHVwcGVyQm91bmRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy51cHBlckJvdW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICBpZihvcHRpb25zICYmIG9wdGlvbnMudXBwZXJCb3VuZCl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLnVwcGVyQm91bmQsIG9wdGlvbnMudXBwZXJCb3VuZCk7XG4gICAgfVxufVxuXG52YXIgdG1wID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBTZXQgdGhlIEFBQkIgYm91bmRzIGZyb20gYSBzZXQgb2YgcG9pbnRzLlxuICogQG1ldGhvZCBzZXRGcm9tUG9pbnRzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQW4gYXJyYXkgb2YgdmVjMidzLlxuICovXG5BQUJCLnByb3RvdHlwZS5zZXRGcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBwb3NpdGlvbiwgYW5nbGUsIHNraW5TaXplKXtcbiAgICB2YXIgbCA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdSA9IHRoaXMudXBwZXJCb3VuZDtcblxuICAgIGlmKHR5cGVvZihhbmdsZSkgIT09IFwibnVtYmVyXCIpe1xuICAgICAgICBhbmdsZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRvIHRoZSBmaXJzdCBwb2ludFxuICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUobCwgcG9pbnRzWzBdLCBhbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmVjMi5jb3B5KGwsIHBvaW50c1swXSk7XG4gICAgfVxuICAgIHZlYzIuY29weSh1LCBsKTtcblxuICAgIC8vIENvbXB1dGUgY29zaW5lcyBhbmQgc2luZXMganVzdCBvbmNlXG4gICAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBmb3IodmFyIGkgPSAxOyBpPHBvaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgICAgIHZhciB4ID0gcFswXSxcbiAgICAgICAgICAgICAgICB5ID0gcFsxXTtcbiAgICAgICAgICAgIHRtcFswXSA9IGNvc0FuZ2xlICogeCAtc2luQW5nbGUgKiB5O1xuICAgICAgICAgICAgdG1wWzFdID0gc2luQW5nbGUgKiB4ICtjb3NBbmdsZSAqIHk7XG4gICAgICAgICAgICBwID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8MjsgaisrKXtcbiAgICAgICAgICAgIGlmKHBbal0gPiB1W2pdKXtcbiAgICAgICAgICAgICAgICB1W2pdID0gcFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHBbal0gPCBsW2pdKXtcbiAgICAgICAgICAgICAgICBsW2pdID0gcFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBvZmZzZXRcbiAgICBpZihwb3NpdGlvbil7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMubG93ZXJCb3VuZCwgdGhpcy5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMudXBwZXJCb3VuZCwgdGhpcy51cHBlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYoc2tpblNpemUpe1xuICAgICAgICB0aGlzLmxvd2VyQm91bmRbMF0gLT0gc2tpblNpemU7XG4gICAgICAgIHRoaXMubG93ZXJCb3VuZFsxXSAtPSBza2luU2l6ZTtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kWzBdICs9IHNraW5TaXplO1xuICAgICAgICB0aGlzLnVwcGVyQm91bmRbMV0gKz0gc2tpblNpemU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb3B5IGJvdW5kcyBmcm9tIGFuIEFBQkIgdG8gdGhpcyBBQUJCXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuQUFCQi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZlYzIuY29weSh0aGlzLmxvd2VyQm91bmQsIGFhYmIubG93ZXJCb3VuZCk7XG4gICAgdmVjMi5jb3B5KHRoaXMudXBwZXJCb3VuZCwgYWFiYi51cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIHRoaXMgQUFCQiBzbyB0aGF0IGl0IGNvdmVycyB0aGUgZ2l2ZW4gQUFCQiB0b28uXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICovXG5BQUJCLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihhYWJiKXtcbiAgICAvLyBMb29wIG92ZXIgeCBhbmQgeVxuICAgIHZhciBpID0gMjtcbiAgICB3aGlsZShpLS0pe1xuICAgICAgICAvLyBFeHRlbmQgbG93ZXIgYm91bmRcbiAgICAgICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmRbaV07XG4gICAgICAgIGlmKHRoaXMubG93ZXJCb3VuZFtpXSA+IGwpe1xuICAgICAgICAgICAgdGhpcy5sb3dlckJvdW5kW2ldID0gbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwcGVyXG4gICAgICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kW2ldO1xuICAgICAgICBpZih0aGlzLnVwcGVyQm91bmRbaV0gPCB1KXtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZFtpXSA9IHU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBvdmVybGFwcyB0aGlzIEFBQkIuXG4gKiBAbWV0aG9kIG92ZXJsYXBzXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5BQUJCLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdTEgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgIGwyID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcblxuICAgIC8vICAgICAgbDIgICAgICAgIHUyXG4gICAgLy8gICAgICB8LS0tLS0tLS0tfFxuICAgIC8vIHwtLS0tLS0tLXxcbiAgICAvLyBsMSAgICAgICB1MVxuXG4gICAgcmV0dXJuICgobDJbMF0gPD0gdTFbMF0gJiYgdTFbMF0gPD0gdTJbMF0pIHx8IChsMVswXSA8PSB1MlswXSAmJiB1MlswXSA8PSB1MVswXSkpICYmXG4gICAgICAgICAgICgobDJbMV0gPD0gdTFbMV0gJiYgdTFbMV0gPD0gdTJbMV0pIHx8IChsMVsxXSA8PSB1MlsxXSAmJiB1MlsxXSA8PSB1MVsxXSkpO1xufTtcbiIsInZhciB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJyk7XG52YXIgQm9keSA9IHJlcXVpcmUoJy4uL29iamVjdHMvQm9keScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyb2FkcGhhc2U7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAY2xhc3MgQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJyb2FkcGhhc2UodHlwZSl7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyBvdmVybGFwcGluZyBwYWlycy4gV2lsbCBiZSBmaWxsZWQgd2l0aCByZXN1bHRzIGR1cmluZyAuZ2V0Q29sbGlzaW9uUGFpcnMoKS5cbiAgICAgKiBAcHJvcGVydHkgcmVzdWx0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQgdG8gc2VhcmNoIGZvciBjb2xsaXNpb24gcGFpcnMgaW4uIFRvIGNoYW5nZSBpdCwgdXNlIC5zZXRXb3JsZCgpXG4gICAgICogQHByb3BlcnR5IHdvcmxkXG4gICAgICogQHR5cGUge1dvcmxkfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvdW5kaW5nIHZvbHVtZSB0eXBlIHRvIHVzZSBpbiB0aGUgYnJvYWRwaGFzZSBhbGdvcml0aG1zLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBib3VuZGluZ1ZvbHVtZVR5cGVcbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kaW5nVm9sdW1lVHlwZSA9IEJyb2FkcGhhc2UuQUFCQjtcbn1cblxuLyoqXG4gKiBBeGlzIGFsaWduZWQgYm91bmRpbmcgYm94IHR5cGUuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQUFCQlxuICovXG5Ccm9hZHBoYXNlLkFBQkIgPSAxO1xuXG4vKipcbiAqIEJvdW5kaW5nIGNpcmNsZSB0eXBlLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEJPVU5ESU5HX0NJUkNMRVxuICovXG5Ccm9hZHBoYXNlLkJPVU5ESU5HX0NJUkNMRSA9IDI7XG5cbi8qKlxuICogU2V0IHRoZSB3b3JsZCB0aGF0IHdlIGFyZSBzZWFyY2hpbmcgZm9yIGNvbGxpc2lvbiBwYWlycyBpblxuICogQG1ldGhvZCBzZXRXb3JsZFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbn07XG5cbi8qKlxuICogR2V0IGFsbCBwb3RlbnRpYWwgaW50ZXJzZWN0aW5nIGJvZHkgcGFpcnMuXG4gKiBAbWV0aG9kIGdldENvbGxpc2lvblBhaXJzXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGQgVGhlIHdvcmxkIHRvIHNlYXJjaCBpbi5cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgYm9kaWVzLCBvcmRlcmVkIGluIHBhaXJzLiBFeGFtcGxlOiBBIHJlc3VsdCBvZiBbYSxiLGMsZF0gbWVhbnMgdGhhdCB0aGUgcG90ZW50aWFsIHBhaXJzIGFyZTogKGEsYiksIChjLGQpLlxuICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRDb2xsaXNpb25QYWlycyBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgc3ViY2xhc3MhXCIpO1xufTtcblxudmFyIGRpc3QgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0d28gYm9kaWVzIG92ZXJsYXAuXG4gKiBAbWV0aG9kICBib3VuZGluZ1JhZGl1c0NoZWNrXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkJyb2FkcGhhc2UuYm91bmRpbmdSYWRpdXNDaGVjayA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmVjMi5zdWIoZGlzdCwgYm9keUEucG9zaXRpb24sIGJvZHlCLnBvc2l0aW9uKTtcbiAgICB2YXIgZDIgPSB2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCksXG4gICAgICAgIHIgPSBib2R5QS5ib3VuZGluZ1JhZGl1cyArIGJvZHlCLmJvdW5kaW5nUmFkaXVzO1xuICAgIHJldHVybiBkMiA8PSByKnI7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0d28gYm9kaWVzIG92ZXJsYXAuXG4gKiBAbWV0aG9kICBib3VuZGluZ1JhZGl1c0NoZWNrXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkJyb2FkcGhhc2UuYWFiYkNoZWNrID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICByZXR1cm4gYm9keUEuZ2V0QUFCQigpLm92ZXJsYXBzKGJvZHlCLmdldEFBQkIoKSk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0d28gYm9kaWVzIG92ZXJsYXAuXG4gKiBAbWV0aG9kICBib3VuZGluZ1JhZGl1c0NoZWNrXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmJvdW5kaW5nVm9sdW1lQ2hlY2sgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBzd2l0Y2godGhpcy5ib3VuZGluZ1ZvbHVtZVR5cGUpe1xuICAgIGNhc2UgQnJvYWRwaGFzZS5CT1VORElOR19DSVJDTEU6XG4gICAgICAgIHJlc3VsdCA9ICBCcm9hZHBoYXNlLmJvdW5kaW5nUmFkaXVzQ2hlY2soYm9keUEsYm9keUIpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIEJyb2FkcGhhc2UuQUFCQjpcbiAgICAgICAgcmVzdWx0ID0gQnJvYWRwaGFzZS5hYWJiQ2hlY2soYm9keUEsYm9keUIpO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kaW5nIHZvbHVtZSB0eXBlIG5vdCByZWNvZ25pemVkOiAnK3RoaXMuYm91bmRpbmdWb2x1bWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gYm9kaWVzIGFyZSBhbGxvd2VkIHRvIGNvbGxpZGUgYXQgYWxsLlxuICogQG1ldGhvZCAgY2FuQ29sbGlkZVxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLmNhbkNvbGxpZGUgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgc3RhdGljIGJvZGllc1xuICAgIGlmKGJvZHlBLnR5cGUgPT09IEJvZHkuU1RBVElDICYmIGJvZHlCLnR5cGUgPT09IEJvZHkuU1RBVElDKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENhbm5vdCBjb2xsaWRlIHN0YXRpYyB2cyBraW5lbWF0aWMgYm9kaWVzXG4gICAgaWYoIChib2R5QS50eXBlID09PSBCb2R5LktJTkVNQVRJQyAmJiBib2R5Qi50eXBlID09PSBCb2R5LlNUQVRJQykgfHxcbiAgICAgICAgKGJvZHlBLnR5cGUgPT09IEJvZHkuU1RBVElDICAgICYmIGJvZHlCLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBraW5lbWF0aWMgdnMga2luZW1hdGljXG4gICAgaWYoYm9keUEudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMgJiYgYm9keUIudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgYm90aCBzbGVlcGluZyBib2RpZXNcbiAgICBpZihib2R5QS5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HICYmIGJvZHlCLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgaWYgb25lIGlzIHN0YXRpYyBhbmQgdGhlIG90aGVyIGlzIHNsZWVwaW5nXG4gICAgaWYoIChib2R5QS5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HICYmIGJvZHlCLnR5cGUgPT09IEJvZHkuU1RBVElDKSB8fFxuICAgICAgICAoYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBib2R5QS50eXBlID09PSBCb2R5LlNUQVRJQykpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Ccm9hZHBoYXNlLk5BSVZFID0gMTtcbkJyb2FkcGhhc2UuU0FQID0gMjtcbiIsInZhciBDaXJjbGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvQ2lyY2xlJylcbiwgICBQbGFuZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9QbGFuZScpXG4sICAgUGFydGljbGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvUGFydGljbGUnKVxuLCAgIEJyb2FkcGhhc2UgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpXG4sICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXG4sICAgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWRCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEJyb2FkcGhhc2UgdGhhdCB1c2VzIGF4aXMtYWxpZ25lZCBiaW5zLlxuICogQGNsYXNzIEdyaWRCcm9hZHBoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEJyb2FkcGhhc2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy54bWluXSAgIExvd2VyIHggYm91bmQgb2YgdGhlIGdyaWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy54bWF4XSAgIFVwcGVyIHggYm91bmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy55bWluXSAgIExvd2VyIHkgYm91bmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy55bWF4XSAgIFVwcGVyIHkgYm91bmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ueF0gICAgIE51bWJlciBvZiBiaW5zIGFsb25nIHggYXhpc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm55XSAgICAgTnVtYmVyIG9mIGJpbnMgYWxvbmcgeSBheGlzXG4gKiBAdG9kbyBTaG91bGQgaGF2ZSBhbiBvcHRpb24gZm9yIGR5bmFtaWMgc2NlbmUgc2l6ZVxuICovXG5mdW5jdGlvbiBHcmlkQnJvYWRwaGFzZShvcHRpb25zKXtcbiAgICBCcm9hZHBoYXNlLmFwcGx5KHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICB4bWluOiAgIC0xMDAsXG4gICAgICAgIHhtYXg6ICAgMTAwLFxuICAgICAgICB5bWluOiAgIC0xMDAsXG4gICAgICAgIHltYXg6ICAgMTAwLFxuICAgICAgICBueDogICAgIDEwLFxuICAgICAgICBueTogICAgIDEwXG4gICAgfSk7XG5cbiAgICB0aGlzLnhtaW4gPSBvcHRpb25zLnhtaW47XG4gICAgdGhpcy55bWluID0gb3B0aW9ucy55bWluO1xuICAgIHRoaXMueG1heCA9IG9wdGlvbnMueG1heDtcbiAgICB0aGlzLnltYXggPSBvcHRpb25zLnltYXg7XG4gICAgdGhpcy5ueCA9IG9wdGlvbnMubng7XG4gICAgdGhpcy5ueSA9IG9wdGlvbnMubnk7XG5cbiAgICB0aGlzLmJpbnNpemVYID0gKHRoaXMueG1heC10aGlzLnhtaW4pIC8gdGhpcy5ueDtcbiAgICB0aGlzLmJpbnNpemVZID0gKHRoaXMueW1heC10aGlzLnltaW4pIC8gdGhpcy5ueTtcbn1cbkdyaWRCcm9hZHBoYXNlLnByb3RvdHlwZSA9IG5ldyBCcm9hZHBoYXNlKCk7XG5HcmlkQnJvYWRwaGFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmlkQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBHZXQgY29sbGlzaW9uIHBhaXJzLlxuICogQG1ldGhvZCBnZXRDb2xsaXNpb25QYWlyc1xuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQpe1xuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICBOY29sbGlkaW5nID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgYmluc2l6ZVggPSB0aGlzLmJpbnNpemVYLFxuICAgICAgICBiaW5zaXplWSA9IHRoaXMuYmluc2l6ZVksXG4gICAgICAgIG54ID0gdGhpcy5ueCxcbiAgICAgICAgbnkgPSB0aGlzLm55LFxuICAgICAgICB4bWluID0gdGhpcy54bWluLFxuICAgICAgICB5bWluID0gdGhpcy55bWluLFxuICAgICAgICB4bWF4ID0gdGhpcy54bWF4LFxuICAgICAgICB5bWF4ID0gdGhpcy55bWF4O1xuXG4gICAgLy8gVG9kbzogbWFrZSBnYXJiYWdlIGZyZWVcbiAgICB2YXIgYmlucz1bXSwgTmJpbnM9bngqbnk7XG4gICAgZm9yKHZhciBpPTA7IGk8TmJpbnM7IGkrKyl7XG4gICAgICAgIGJpbnMucHVzaChbXSk7XG4gICAgfVxuXG4gICAgdmFyIHhtdWx0ID0gbnggLyAoeG1heC14bWluKTtcbiAgICB2YXIgeW11bHQgPSBueSAvICh5bWF4LXltaW4pO1xuXG4gICAgLy8gUHV0IGFsbCBib2RpZXMgaW50byBiaW5zXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OY29sbGlkaW5nOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG4gICAgICAgIHZhciBhYWJiID0gYmkuYWFiYjtcbiAgICAgICAgdmFyIGxvd2VyWCA9IE1hdGgubWF4KGFhYmIubG93ZXJCb3VuZFswXSwgeG1pbik7XG4gICAgICAgIHZhciBsb3dlclkgPSBNYXRoLm1heChhYWJiLmxvd2VyQm91bmRbMV0sIHltaW4pO1xuICAgICAgICB2YXIgdXBwZXJYID0gTWF0aC5taW4oYWFiYi51cHBlckJvdW5kWzBdLCB4bWF4KTtcbiAgICAgICAgdmFyIHVwcGVyWSA9IE1hdGgubWluKGFhYmIudXBwZXJCb3VuZFsxXSwgeW1heCk7XG4gICAgICAgIHZhciB4aTEgPSBNYXRoLmZsb29yKHhtdWx0ICogKGxvd2VyWCAtIHhtaW4pKTtcbiAgICAgICAgdmFyIHlpMSA9IE1hdGguZmxvb3IoeW11bHQgKiAobG93ZXJZIC0geW1pbikpO1xuICAgICAgICB2YXIgeGkyID0gTWF0aC5mbG9vcih4bXVsdCAqICh1cHBlclggLSB4bWluKSk7XG4gICAgICAgIHZhciB5aTIgPSBNYXRoLmZsb29yKHltdWx0ICogKHVwcGVyWSAtIHltaW4pKTtcblxuICAgICAgICAvLyBQdXQgaW4gYmluXG4gICAgICAgIGZvcih2YXIgaj14aTE7IGo8PXhpMjsgaisrKXtcbiAgICAgICAgICAgIGZvcih2YXIgaz15aTE7IGs8PXlpMjsgaysrKXtcbiAgICAgICAgICAgICAgICB2YXIgeGkgPSBqO1xuICAgICAgICAgICAgICAgIHZhciB5aSA9IGs7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IHhpKihueS0xKSArIHlpO1xuICAgICAgICAgICAgICAgIGlmKGlkeCA+PSAwICYmIGlkeCA8IE5iaW5zKXtcbiAgICAgICAgICAgICAgICAgICAgYmluc1sgaWR4IF0ucHVzaChiaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZWFjaCBiaW5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU5iaW5zOyBpKyspe1xuICAgICAgICB2YXIgYmluID0gYmluc1tpXTtcblxuICAgICAgICBmb3IodmFyIGo9MCwgTmJvZGllc0luQmluPWJpbi5sZW5ndGg7IGohPT1OYm9kaWVzSW5CaW47IGorKyl7XG4gICAgICAgICAgICB2YXIgYmkgPSBiaW5bal07XG4gICAgICAgICAgICBmb3IodmFyIGs9MDsgayE9PWo7IGsrKyl7XG4gICAgICAgICAgICAgICAgdmFyIGJqID0gYmluW2tdO1xuICAgICAgICAgICAgICAgIGlmKEJyb2FkcGhhc2UuY2FuQ29sbGlkZShiaSxiaikgJiYgdGhpcy5ib3VuZGluZ1ZvbHVtZUNoZWNrKGJpLGJqKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpLGJqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgQ2lyY2xlID0gcmVxdWlyZSgnLi4vc2hhcGVzL0NpcmNsZScpLFxuICAgIFBsYW5lID0gcmVxdWlyZSgnLi4vc2hhcGVzL1BsYW5lJyksXG4gICAgU2hhcGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvU2hhcGUnKSxcbiAgICBQYXJ0aWNsZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9QYXJ0aWNsZScpLFxuICAgIEJyb2FkcGhhc2UgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYWl2ZUJyb2FkcGhhc2U7XG5cbi8qKlxuICogTmFpdmUgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbi4gRG9lcyBOXjIgdGVzdHMuXG4gKlxuICogQGNsYXNzIE5haXZlQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXG4gKi9cbmZ1bmN0aW9uIE5haXZlQnJvYWRwaGFzZSgpe1xuICAgIEJyb2FkcGhhc2UuY2FsbCh0aGlzLCBCcm9hZHBoYXNlLk5BSVZFKTtcbn1cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5haXZlQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbGxpZGluZyBwYWlyc1xuICogQG1ldGhvZCBnZXRDb2xsaXNpb25QYWlyc1xuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdDtcblxuICAgIHJlc3VsdC5sZW5ndGggPSAwO1xuXG4gICAgZm9yKHZhciBpPTAsIE5jb2xsaWRpbmc9Ym9kaWVzLmxlbmd0aDsgaSE9PU5jb2xsaWRpbmc7IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcblxuICAgICAgICBmb3IodmFyIGo9MDsgajxpOyBqKyspe1xuICAgICAgICAgICAgdmFyIGJqID0gYm9kaWVzW2pdO1xuXG4gICAgICAgICAgICBpZihCcm9hZHBoYXNlLmNhbkNvbGxpZGUoYmksYmopICYmIHRoaXMuYm91bmRpbmdWb2x1bWVDaGVjayhiaSxiaikpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpLGJqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGJvZGllcyBpbi5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICAgIHZhciBib2RpZXMgPSB3b3JsZC5ib2RpZXM7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGIudXBkYXRlQUFCQigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKXtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07IiwidmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKVxuLCAgIHN1YiA9IHZlYzIuc3ViXG4sICAgYWRkID0gdmVjMi5hZGRcbiwgICBkb3QgPSB2ZWMyLmRvdFxuLCAgIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIFR1cGxlRGljdGlvbmFyeSA9IHJlcXVpcmUoJy4uL3V0aWxzL1R1cGxlRGljdGlvbmFyeScpXG4sICAgRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKVxuLCAgIENvbnRhY3RFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKVxuLCAgIEZyaWN0aW9uRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpXG4sICAgQ2lyY2xlID0gcmVxdWlyZSgnLi4vc2hhcGVzL0NpcmNsZScpXG4sICAgQ29udmV4ID0gcmVxdWlyZSgnLi4vc2hhcGVzL0NvbnZleCcpXG4sICAgU2hhcGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvU2hhcGUnKVxuLCAgIEJvZHkgPSByZXF1aXJlKCcuLi9vYmplY3RzL0JvZHknKVxuLCAgIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9SZWN0YW5nbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYXJyb3dwaGFzZTtcblxuLy8gVGVtcCB0aGluZ3NcbnZhciB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuXG52YXIgdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wNCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wNSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wNiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wNyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wOCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wOSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTAgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDExID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxNSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTYgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE3ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxOCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wQXJyYXkgPSBbXTtcblxuLyoqXG4gKiBOYXJyb3dwaGFzZS4gQ3JlYXRlcyBjb250YWN0cyBhbmQgZnJpY3Rpb24gZ2l2ZW4gc2hhcGVzIGFuZCB0cmFuc2Zvcm1zLlxuICogQGNsYXNzIE5hcnJvd3BoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTmFycm93cGhhc2UoKXtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0RXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uRXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gbWFrZSBmcmljdGlvbiBlcXVhdGlvbnMgaW4gdGhlIHVwY29taW5nIGNvbnRhY3RzLlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVGcmljdGlvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBtYWtlIGVxdWF0aW9ucyBlbmFibGVkIGluIHVwY29taW5nIGNvbnRhY3RzLlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVkRXF1YXRpb25zXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkRXF1YXRpb25zID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmljdGlvbiBzbGlwIGZvcmNlIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGZyaWN0aW9uIGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgc2xpcEZvcmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNsaXBGb3JjZSA9IDEwLjA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJpY3Rpb24gdmFsdWUgdG8gdXNlIGluIHRoZSB1cGNvbWluZyBmcmljdGlvbiBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uQ29lZmZpY2llbnRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25Db2VmZmljaWVudCA9IDAuMztcblxuICAgIC8qKlxuICAgICAqIFdpbGwgYmUgdGhlIC5yZWxhdGl2ZVZlbG9jaXR5IGluIGVhY2ggcHJvZHVjZWQgRnJpY3Rpb25FcXVhdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3VyZmFjZVZlbG9jaXR5XG4gICAgICovXG4gICAgdGhpcy5zdXJmYWNlVmVsb2NpdHkgPSAwO1xuXG4gICAgdGhpcy5yZXVzZU9iamVjdHMgPSB0cnVlO1xuICAgIHRoaXMucmV1c2FibGVDb250YWN0RXF1YXRpb25zID0gW107XG4gICAgdGhpcy5yZXVzYWJsZUZyaWN0aW9uRXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdGl0dXRpb24gdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGNvbnRhY3QgZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0aXR1dGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3RpZmZuZXNzXG4gICAgICovXG4gICAgdGhpcy5zdGlmZm5lc3MgPSBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGlmZm5lc3MgdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGNvbnRhY3QgZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdGlmZm5lc3NcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF4YXRpb24gPSBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBmcmljdGlvbiBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uU3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uU3RpZmZuZXNzID0gRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVsYXhhdGlvbiB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblJlbGF4YXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25SZWxheGF0aW9uID0gRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHJlZHVjdGlvbiBvZiBmcmljdGlvbiBlcXVhdGlvbnMuIElmIGRpc2FibGVkLCBhIGJveCBvbiBhIHBsYW5lIHdpbGwgZ2VuZXJhdGUgMiBjb250YWN0IGVxdWF0aW9ucyBhbmQgMiBmcmljdGlvbiBlcXVhdGlvbnMuIElmIGVuYWJsZWQsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgZnJpY3Rpb24gZXF1YXRpb24uIFNhbWUga2luZCBvZiBzaW1wbGlmaWNhdGlvbnMgYXJlIG1hZGUgIGZvciBhbGwgY29sbGlzaW9uIHR5cGVzLlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVGcmljdGlvblJlZHVjdGlvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgZmxhZyB3aWxsIGJlIHJlbW92ZWQgd2hlbiB0aGUgZmVhdHVyZSBpcyBzdGFibGUgZW5vdWdoLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjb2xsaWRpbmcgYm9kaWVzIGxhc3Qgc3RlcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaWRpbmdCb2RpZXNMYXN0U3RlcFxuICAgICAqIEB0eXBlIHtUdXBsZURpY3Rpb25hcnl9XG4gICAgICovXG4gICAgdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcCA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhY3Qgc2tpbiBzaXplIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29udGFjdFNraW5TaXplXG4gICAgICogQGRlZmF1bHQgMC4wMVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFNraW5TaXplID0gMC4wMTtcbn1cblxudmFyIGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgYm9kaWVzT3ZlcmxhcFxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuYm9kaWVzT3ZlcmxhcCA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmFyIHNoYXBlUG9zaXRpb25BID0gYm9kaWVzT3ZlcmxhcF9zaGFwZVBvc2l0aW9uQTtcbiAgICB2YXIgc2hhcGVQb3NpdGlvbkIgPSBib2RpZXNPdmVybGFwX3NoYXBlUG9zaXRpb25CO1xuXG4gICAgLy8gTG9vcCBvdmVyIGFsbCBzaGFwZXMgb2YgYm9keUFcbiAgICBmb3IodmFyIGs9MCwgTnNoYXBlc2k9Ym9keUEuc2hhcGVzLmxlbmd0aDsgayE9PU5zaGFwZXNpOyBrKyspe1xuICAgICAgICB2YXIgc2hhcGVBID0gYm9keUEuc2hhcGVzW2tdLFxuICAgICAgICAgICAgcG9zaXRpb25BID0gYm9keUEuc2hhcGVPZmZzZXRzW2tdLFxuICAgICAgICAgICAgYW5nbGVBID0gYm9keUEuc2hhcGVBbmdsZXNba107XG5cbiAgICAgICAgYm9keUEudG9Xb3JsZEZyYW1lKHNoYXBlUG9zaXRpb25BLCBwb3NpdGlvbkEpO1xuXG4gICAgICAgIC8vIEFsbCBzaGFwZXMgb2YgYm9keSBqXG4gICAgICAgIGZvcih2YXIgbD0wLCBOc2hhcGVzaj1ib2R5Qi5zaGFwZXMubGVuZ3RoOyBsIT09TnNoYXBlc2o7IGwrKyl7XG4gICAgICAgICAgICB2YXIgc2hhcGVCID0gYm9keUIuc2hhcGVzW2xdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uQiA9IGJvZHlCLnNoYXBlT2Zmc2V0c1tsXSxcbiAgICAgICAgICAgICAgICBhbmdsZUIgPSBib2R5Qi5zaGFwZUFuZ2xlc1tsXTtcblxuICAgICAgICAgICAgYm9keUIudG9Xb3JsZEZyYW1lKHNoYXBlUG9zaXRpb25CLCBwb3NpdGlvbkIpO1xuXG4gICAgICAgICAgICBpZih0aGlzW3NoYXBlQS50eXBlIHwgc2hhcGVCLnR5cGVdKFxuICAgICAgICAgICAgICAgIGJvZHlBLFxuICAgICAgICAgICAgICAgIHNoYXBlQSxcbiAgICAgICAgICAgICAgICBzaGFwZVBvc2l0aW9uQSxcbiAgICAgICAgICAgICAgICBzaGFwZUEuYW5nbGUgKyBib2R5QS5hbmdsZSxcbiAgICAgICAgICAgICAgICBib2R5QixcbiAgICAgICAgICAgICAgICBzaGFwZUIsXG4gICAgICAgICAgICAgICAgc2hhcGVQb3NpdGlvbkIsXG4gICAgICAgICAgICAgICAgc2hhcGVCLmFuZ2xlICsgYm9keUIuYW5nbGUsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBib2RpZXMgd2VyZSBpbiBjb250YWN0IHNpbmNlIHRoZSBsYXN0IHJlc2V0KCkuXG4gKiBAbWV0aG9kIGNvbGxpZGVkTGFzdFN0ZXBcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbGxpZGVkTGFzdFN0ZXAgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZhciBpZDEgPSBib2R5QS5pZHwwLFxuICAgICAgICBpZDIgPSBib2R5Qi5pZHwwO1xuICAgIHJldHVybiAhIXRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAuZ2V0KGlkMSwgaWQyKTtcbn07XG5cbi8qKlxuICogVGhyb3dzIGF3YXkgdGhlIG9sZCBlcXVhdGlvbnMgYW5kIGdldHMgcmVhZHkgdG8gY3JlYXRlIG5ld1xuICogQG1ldGhvZCByZXNldFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAucmVzZXQoKTtcblxuICAgIHZhciBlcXMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvbnM7XG4gICAgdmFyIGwgPSBlcXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tsXSxcbiAgICAgICAgICAgIGlkMSA9IGVxLmJvZHlBLmlkLFxuICAgICAgICAgICAgaWQyID0gZXEuYm9keUIuaWQ7XG4gICAgICAgIHRoaXMuY29sbGlkaW5nQm9kaWVzTGFzdFN0ZXAuc2V0KGlkMSwgaWQyLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZih0aGlzLnJldXNlT2JqZWN0cyl7XG4gICAgICAgIHZhciBjZSA9IHRoaXMuY29udGFjdEVxdWF0aW9ucyxcbiAgICAgICAgICAgIGZlID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucyxcbiAgICAgICAgICAgIHJmZSA9IHRoaXMucmV1c2FibGVGcmljdGlvbkVxdWF0aW9ucyxcbiAgICAgICAgICAgIHJjZSA9IHRoaXMucmV1c2FibGVDb250YWN0RXF1YXRpb25zO1xuICAgICAgICBVdGlscy5hcHBlbmRBcnJheShyY2UsY2UpO1xuICAgICAgICBVdGlscy5hcHBlbmRBcnJheShyZmUsZmUpO1xuICAgIH1cblxuICAgIC8vIFJlc2V0XG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIENvbnRhY3RFcXVhdGlvbiwgZWl0aGVyIGJ5IHJldXNpbmcgYW4gZXhpc3Rpbmcgb2JqZWN0IG9yIGNyZWF0aW5nIGEgbmV3IG9uZS5cbiAqIEBtZXRob2QgY3JlYXRlQ29udGFjdEVxdWF0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbiA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qiwgc2hhcGVBLCBzaGFwZUIpe1xuICAgIHZhciBjID0gdGhpcy5yZXVzYWJsZUNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID8gdGhpcy5yZXVzYWJsZUNvbnRhY3RFcXVhdGlvbnMucG9wKCkgOiBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICBjLmJvZHlBID0gYm9keUE7XG4gICAgYy5ib2R5QiA9IGJvZHlCO1xuICAgIGMuc2hhcGVBID0gc2hhcGVBO1xuICAgIGMuc2hhcGVCID0gc2hhcGVCO1xuICAgIGMucmVzdGl0dXRpb24gPSB0aGlzLnJlc3RpdHV0aW9uO1xuICAgIGMuZmlyc3RJbXBhY3QgPSAhdGhpcy5jb2xsaWRlZExhc3RTdGVwKGJvZHlBLGJvZHlCKTtcbiAgICBjLnN0aWZmbmVzcyA9IHRoaXMuc3RpZmZuZXNzO1xuICAgIGMucmVsYXhhdGlvbiA9IHRoaXMucmVsYXhhdGlvbjtcbiAgICBjLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBjLmVuYWJsZWQgPSB0aGlzLmVuYWJsZWRFcXVhdGlvbnM7XG4gICAgYy5vZmZzZXQgPSB0aGlzLmNvbnRhY3RTa2luU2l6ZTtcblxuICAgIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgRnJpY3Rpb25FcXVhdGlvbiwgZWl0aGVyIGJ5IHJldXNpbmcgYW4gZXhpc3Rpbmcgb2JqZWN0IG9yIGNyZWF0aW5nIGEgbmV3IG9uZS5cbiAqIEBtZXRob2QgY3JlYXRlRnJpY3Rpb25FcXVhdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtGcmljdGlvbkVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbiA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qiwgc2hhcGVBLCBzaGFwZUIpe1xuICAgIHZhciBjID0gdGhpcy5yZXVzYWJsZUZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCA/IHRoaXMucmV1c2FibGVGcmljdGlvbkVxdWF0aW9ucy5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICBjLmJvZHlBID0gYm9keUE7XG4gICAgYy5ib2R5QiA9IGJvZHlCO1xuICAgIGMuc2hhcGVBID0gc2hhcGVBO1xuICAgIGMuc2hhcGVCID0gc2hhcGVCO1xuICAgIGMuc2V0U2xpcEZvcmNlKHRoaXMuc2xpcEZvcmNlKTtcbiAgICBjLmZyaWN0aW9uQ29lZmZpY2llbnQgPSB0aGlzLmZyaWN0aW9uQ29lZmZpY2llbnQ7XG4gICAgYy5yZWxhdGl2ZVZlbG9jaXR5ID0gdGhpcy5zdXJmYWNlVmVsb2NpdHk7XG4gICAgYy5lbmFibGVkID0gdGhpcy5lbmFibGVkRXF1YXRpb25zO1xuICAgIGMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGMuc3RpZmZuZXNzID0gdGhpcy5mcmljdGlvblN0aWZmbmVzcztcbiAgICBjLnJlbGF4YXRpb24gPSB0aGlzLmZyaWN0aW9uUmVsYXhhdGlvbjtcbiAgICBjLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIEZyaWN0aW9uRXF1YXRpb24gZ2l2ZW4gdGhlIGRhdGEgaW4gdGhlIENvbnRhY3RFcXVhdGlvbi4gVXNlcyBzYW1lIG9mZnNldCB2ZWN0b3JzIHJpIGFuZCByaiwgYnV0IHRoZSB0YW5nZW50IHZlY3RvciB3aWxsIGJlIGNvbnN0cnVjdGVkIGZyb20gdGhlIGNvbGxpc2lvbiBub3JtYWwuXG4gKiBAbWV0aG9kIGNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3RcbiAqIEBwYXJhbSAge0NvbnRhY3RFcXVhdGlvbn0gY29udGFjdEVxdWF0aW9uXG4gKiBAcmV0dXJuIHtGcmljdGlvbkVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdCA9IGZ1bmN0aW9uKGMpe1xuICAgIHZhciBlcSA9IHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbihjLmJvZHlBLCBjLmJvZHlCLCBjLnNoYXBlQSwgYy5zaGFwZUIpO1xuICAgIHZlYzIuY29weShlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgIHZlYzIuY29weShlcS5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIpO1xuICAgIHZlYzIucm90YXRlOTBjdyhlcS50LCBjLm5vcm1hbEEpO1xuICAgIGVxLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcbiAgICByZXR1cm4gZXE7XG59O1xuXG4vLyBUYWtlIHRoZSBhdmVyYWdlIE4gbGF0ZXN0IGNvbnRhY3QgcG9pbnQgb24gdGhlIHBsYW5lLlxuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UgPSBmdW5jdGlvbihudW1Db250YWN0cyl7XG4gICAgdmFyIGMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvbnNbdGhpcy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIHZhciBlcSA9IHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbihjLmJvZHlBLCBjLmJvZHlCLCBjLnNoYXBlQSwgYy5zaGFwZUIpO1xuICAgIHZhciBib2R5QSA9IGMuYm9keUE7XG4gICAgdmFyIGJvZHlCID0gYy5ib2R5QjtcbiAgICB2ZWMyLnNldChlcS5jb250YWN0UG9pbnRBLCAwLCAwKTtcbiAgICB2ZWMyLnNldChlcS5jb250YWN0UG9pbnRCLCAwLCAwKTtcbiAgICB2ZWMyLnNldChlcS50LCAwLCAwKTtcbiAgICBmb3IodmFyIGk9MDsgaSE9PW51bUNvbnRhY3RzOyBpKyspe1xuICAgICAgICBjID0gdGhpcy5jb250YWN0RXF1YXRpb25zW3RoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIGlmKGMuYm9keUEgPT09IGJvZHlBKXtcbiAgICAgICAgICAgIHZlYzIuYWRkKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlYzIuc3ViKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEIpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRBKTtcbiAgICAgICAgfVxuICAgICAgICBlcS5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgdmFyIGludk51bUNvbnRhY3RzID0gMS9udW1Db250YWN0cztcbiAgICB2ZWMyLnNjYWxlKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGludk51bUNvbnRhY3RzKTtcbiAgICB2ZWMyLnNjYWxlKGVxLmNvbnRhY3RQb2ludEIsIGVxLmNvbnRhY3RQb2ludEIsIGludk51bUNvbnRhY3RzKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShlcS50LCBlcS50KTtcbiAgICB2ZWMyLnJvdGF0ZTkwY3coZXEudCwgZXEudCk7XG4gICAgcmV0dXJuIGVxO1xufTtcblxuLyoqXG4gKiBDb252ZXgvbGluZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjb252ZXhMaW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjb252ZXhBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBqdXN0VGVzdFxuICogQHRvZG8gSW1wbGVtZW50IG1lIVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuTElORSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleExpbmUgPSBmdW5jdGlvbihcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBsaW5lQm9keSxcbiAgICBsaW5lU2hhcGUsXG4gICAgbGluZU9mZnNldCxcbiAgICBsaW5lQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgLy8gVE9ET1xuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGluZS9yZWN0YW5nbGUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgbGluZVJlY3RhbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICByZWN0YW5nbGVCb2R5XG4gKiBAcGFyYW0gIHtSZWN0YW5nbGV9ICByZWN0YW5nbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVjdGFuZ2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICByZWN0YW5nbGVBbmdsZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICAganVzdFRlc3RcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkxJTkUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5saW5lUmVjdGFuZ2xlID0gZnVuY3Rpb24oXG4gICAgbGluZUJvZHksXG4gICAgbGluZVNoYXBlLFxuICAgIGxpbmVPZmZzZXQsXG4gICAgbGluZUFuZ2xlLFxuICAgIHJlY3RhbmdsZUJvZHksXG4gICAgcmVjdGFuZ2xlU2hhcGUsXG4gICAgcmVjdGFuZ2xlT2Zmc2V0LFxuICAgIHJlY3RhbmdsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIC8vIFRPRE9cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShjb252ZXhTaGFwZSwgY2Fwc3VsZVNoYXBlKXtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1swXSwgLWNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsIC1jYXBzdWxlU2hhcGUucmFkaXVzKTtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1sxXSwgIGNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsIC1jYXBzdWxlU2hhcGUucmFkaXVzKTtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1syXSwgIGNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsICBjYXBzdWxlU2hhcGUucmFkaXVzKTtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1szXSwgLWNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsICBjYXBzdWxlU2hhcGUucmFkaXVzKTtcbn1cblxudmFyIGNvbnZleENhcHN1bGVfdGVtcFJlY3QgPSBuZXcgUmVjdGFuZ2xlKDEsMSksXG4gICAgY29udmV4Q2Fwc3VsZV90ZW1wVmVjID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBDb252ZXgvY2Fwc3VsZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjb252ZXhDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY29udmV4UG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjYXBzdWxlQm9keVxuICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgY2Fwc3VsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBjYXBzdWxlUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNhcHN1bGVBbmdsZVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0FQU1VMRSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhDYXBzdWxlID0gZnVuY3Rpb24oXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhQb3NpdGlvbixcbiAgICBjb252ZXhBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcblxuICAgIC8vIENoZWNrIHRoZSBjaXJjbGVzXG4gICAgLy8gQWRkIG9mZnNldHMhXG4gICAgdmFyIGNpcmNsZVBvcyA9IGNvbnZleENhcHN1bGVfdGVtcFZlYztcbiAgICB2ZWMyLnNldChjaXJjbGVQb3MsIGNhcHN1bGVTaGFwZS5sZW5ndGgvMiwwKTtcbiAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSk7XG4gICAgdmVjMi5hZGQoY2lyY2xlUG9zLGNpcmNsZVBvcyxjYXBzdWxlUG9zaXRpb24pO1xuICAgIHZhciByZXN1bHQxID0gdGhpcy5jaXJjbGVDb252ZXgoY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNpcmNsZVBvcyxjYXBzdWxlQW5nbGUsIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zaXRpb24sY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzKTtcblxuICAgIHZlYzIuc2V0KGNpcmNsZVBvcywtY2Fwc3VsZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSk7XG4gICAgdmVjMi5hZGQoY2lyY2xlUG9zLGNpcmNsZVBvcyxjYXBzdWxlUG9zaXRpb24pO1xuICAgIHZhciByZXN1bHQyID0gdGhpcy5jaXJjbGVDb252ZXgoY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNpcmNsZVBvcyxjYXBzdWxlQW5nbGUsIGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zaXRpb24sY29udmV4QW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzKTtcblxuICAgIGlmKGp1c3RUZXN0ICYmIChyZXN1bHQxIHx8IHJlc3VsdDIpKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY2VudGVyIHJlY3RcbiAgICB2YXIgciA9IGNvbnZleENhcHN1bGVfdGVtcFJlY3Q7XG4gICAgc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUocixjYXBzdWxlU2hhcGUpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnZleENvbnZleChjb252ZXhCb2R5LGNvbnZleFNoYXBlLGNvbnZleFBvc2l0aW9uLGNvbnZleEFuZ2xlLCBjYXBzdWxlQm9keSxyLGNhcHN1bGVQb3NpdGlvbixjYXBzdWxlQW5nbGUsIGp1c3RUZXN0KTtcblxuICAgIHJldHVybiByZXN1bHQgKyByZXN1bHQxICsgcmVzdWx0Mjtcbn07XG5cbi8qKlxuICogQ2Fwc3VsZS9saW5lIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGxpbmVDYXBzdWxlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBsaW5lQm9keVxuICogQHBhcmFtICB7TGluZX0gICAgICAgbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBsaW5lUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGxpbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgY2Fwc3VsZUJvZHlcbiAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIGNhcHN1bGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY2Fwc3VsZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjYXBzdWxlQW5nbGVcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNBUFNVTEUgfCBTaGFwZS5MSU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUNhcHN1bGUgPSBmdW5jdGlvbihcbiAgICBsaW5lQm9keSxcbiAgICBsaW5lU2hhcGUsXG4gICAgbGluZVBvc2l0aW9uLFxuICAgIGxpbmVBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICAvLyBUT0RPXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxudmFyIGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMxID0gdmVjMi5jcmVhdGUoKTtcbnZhciBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgY2Fwc3VsZUNhcHN1bGVfdGVtcFJlY3QxID0gbmV3IFJlY3RhbmdsZSgxLDEpO1xuXG4vKipcbiAqIENhcHN1bGUvY2Fwc3VsZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjYXBzdWxlQ2Fwc3VsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0NhcHN1bGV9ICAgIHNpXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICB4aVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYWlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKiBAcGFyYW0gIHtDYXBzdWxlfSAgICBzalxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgeGpcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DQVBTVUxFIHwgU2hhcGUuQ0FQU1VMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNhcHN1bGVDYXBzdWxlID0gZnVuY3Rpb24oYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCl7XG5cbiAgICB2YXIgZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG5cbiAgICAvLyBDaGVjayB0aGUgY2lyY2xlc1xuICAgIC8vIEFkZCBvZmZzZXRzIVxuICAgIHZhciBjaXJjbGVQb3NpID0gY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzEsXG4gICAgICAgIGNpcmNsZVBvc2ogPSBjYXBzdWxlQ2Fwc3VsZV90ZW1wVmVjMjtcblxuICAgIHZhciBudW1Db250YWN0cyA9IDA7XG5cblxuICAgIC8vIE5lZWQgNCBjaXJjbGUgY2hlY2tzLCBiZXR3ZWVuIGFsbFxuICAgIGZvcih2YXIgaT0wOyBpPDI7IGkrKyl7XG5cbiAgICAgICAgdmVjMi5zZXQoY2lyY2xlUG9zaSwoaT09PTA/LTE6MSkqc2kubGVuZ3RoLzIsMCk7XG4gICAgICAgIHZlYzIucm90YXRlKGNpcmNsZVBvc2ksY2lyY2xlUG9zaSxhaSk7XG4gICAgICAgIHZlYzIuYWRkKGNpcmNsZVBvc2ksY2lyY2xlUG9zaSx4aSk7XG5cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8MjsgaisrKXtcblxuICAgICAgICAgICAgdmVjMi5zZXQoY2lyY2xlUG9zaiwoaj09PTA/LTE6MSkqc2oubGVuZ3RoLzIsIDApO1xuICAgICAgICAgICAgdmVjMi5yb3RhdGUoY2lyY2xlUG9zaixjaXJjbGVQb3NqLGFqKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGNpcmNsZVBvc2osY2lyY2xlUG9zaix4aik7XG5cbiAgICAgICAgICAgIC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jaXJjbGVDaXJjbGUoYmksc2ksY2lyY2xlUG9zaSxhaSwgYmosc2osY2lyY2xlUG9zaixhaiwganVzdFRlc3QsIHNpLnJhZGl1cywgc2oucmFkaXVzKTtcblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCAmJiByZXN1bHQpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBudW1Db250YWN0cyArPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cbiAgICAgICAgZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY2lyY2xlcyBhZ2FpbnN0IHRoZSBjZW50ZXIgcmVjdGFuZ2xlc1xuICAgIHZhciByZWN0ID0gY2Fwc3VsZUNhcHN1bGVfdGVtcFJlY3QxO1xuICAgIHNldENvbnZleFRvQ2Fwc3VsZVNoYXBlTWlkZGxlKHJlY3Qsc2kpO1xuICAgIHZhciByZXN1bHQxID0gdGhpcy5jb252ZXhDYXBzdWxlKGJpLHJlY3QseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0ICYmIHJlc3VsdDEpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbnVtQ29udGFjdHMgKz0gcmVzdWx0MTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxuICAgICAgICB2YXIgZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0Q29udmV4VG9DYXBzdWxlU2hhcGVNaWRkbGUocmVjdCxzaik7XG4gICAgdmFyIHJlc3VsdDIgPSB0aGlzLmNvbnZleENhcHN1bGUoYmoscmVjdCx4aixhaiwgYmksc2kseGksYWksIGp1c3RUZXN0KTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3QgJiYgcmVzdWx0Mil7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBudW1Db250YWN0cyArPSByZXN1bHQyO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGlmKG51bUNvbnRhY3RzICYmIHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTtcblxuLyoqXG4gKiBMaW5lL2xpbmUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgbGluZUxpbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJvZHlBXG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBzaGFwZUFcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBvc2l0aW9uQVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGVBXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBib2R5QlxuICogQHBhcmFtICB7TGluZX0gICAgICAgc2hhcGVCXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBwb3NpdGlvbkJcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlQlxuICogQHRvZG8gSW1wbGVtZW50IG1lIVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuTElORSB8IFNoYXBlLkxJTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5saW5lTGluZSA9IGZ1bmN0aW9uKFxuICAgIGJvZHlBLFxuICAgIHNoYXBlQSxcbiAgICBwb3NpdGlvbkEsXG4gICAgYW5nbGVBLFxuICAgIGJvZHlCLFxuICAgIHNoYXBlQixcbiAgICBwb3NpdGlvbkIsXG4gICAgYW5nbGVCLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIC8vIFRPRE9cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFBsYW5lL2xpbmUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgcGxhbmVMaW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgIHBsYW5lQm9keVxuICogQHBhcmFtICB7UGxhbmV9ICBwbGFuZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBsYW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9ICAgbGluZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gIGxpbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gbGluZUFuZ2xlXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkxJTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUxpbmUgPSBmdW5jdGlvbihwbGFuZUJvZHksIHBsYW5lU2hhcGUsIHBsYW5lT2Zmc2V0LCBwbGFuZUFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVCb2R5LCAgbGluZVNoYXBlLCAgbGluZU9mZnNldCwgIGxpbmVBbmdsZSwganVzdFRlc3Qpe1xuICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLFxuICAgICAgICB3b3JsZFZlcnRleDEgPSB0bXAyLFxuICAgICAgICB3b3JsZFZlcnRleDAxID0gdG1wMyxcbiAgICAgICAgd29ybGRWZXJ0ZXgxMSA9IHRtcDQsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDUsXG4gICAgICAgIHdvcmxkRWRnZVVuaXQgPSB0bXA2LFxuICAgICAgICBkaXN0ID0gdG1wNyxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXA4LFxuICAgICAgICB3b3JsZFRhbmdlbnQgPSB0bXA5LFxuICAgICAgICB2ZXJ0cyA9IHRtcEFycmF5LFxuICAgICAgICBudW1Db250YWN0cyA9IDA7XG5cbiAgICAvLyBHZXQgc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAgICB2ZWMyLnNldCh3b3JsZFZlcnRleDAsIC1saW5lU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIuc2V0KHdvcmxkVmVydGV4MSwgIGxpbmVTaGFwZS5sZW5ndGgvMiwgMCk7XG5cbiAgICAvLyBOb3Qgc3VyZSB3aHkgd2UgaGF2ZSB0byB1c2Ugd29ybGRWZXJ0ZXgqMSBoZXJlLCBidXQgaXQgd29uJ3Qgd29yayBvdGhlcndpc2UuIFRpcmVkLlxuICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MDEsIHdvcmxkVmVydGV4MCwgbGluZUFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDEsIGxpbmVBbmdsZSk7XG5cbiAgICBhZGQod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwMSwgbGluZU9mZnNldCk7XG4gICAgYWRkKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MTEsIGxpbmVPZmZzZXQpO1xuXG4gICAgdmVjMi5jb3B5KHdvcmxkVmVydGV4MCx3b3JsZFZlcnRleDAxKTtcbiAgICB2ZWMyLmNvcHkod29ybGRWZXJ0ZXgxLHdvcmxkVmVydGV4MTEpO1xuXG4gICAgLy8gR2V0IHZlY3RvciBhbG9uZyB0aGUgbGluZVxuICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xuXG4gICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuXG4gICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkVGFuZ2VudCwgd29ybGRFZGdlVW5pdCk7XG5cbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xuXG4gICAgLy8gQ2hlY2sgbGluZSBlbmRzXG4gICAgdmVydHNbMF0gPSB3b3JsZFZlcnRleDA7XG4gICAgdmVydHNbMV0gPSB3b3JsZFZlcnRleDE7XG4gICAgZm9yKHZhciBpPTA7IGk8dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuXG4gICAgICAgIHN1YihkaXN0LCB2LCBwbGFuZU9mZnNldCk7XG5cbiAgICAgICAgdmFyIGQgPSBkb3QoZGlzdCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgaWYoZCA8IDApe1xuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LGxpbmVCb2R5LHBsYW5lU2hhcGUsbGluZVNoYXBlKTtcbiAgICAgICAgICAgIG51bUNvbnRhY3RzKys7XG5cbiAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAvLyBkaXN0YW5jZSB2ZWN0b3IgYWxvbmcgcGxhbmUgbm9ybWFsXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGRpc3QsIHdvcmxkTm9ybWFsLCBkKTtcblxuICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gcGxhbmUgY2VudGVyIHRvIGNvbnRhY3RcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHYsIGRpc3QpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAvLyBGcm9tIGxpbmUgY2VudGVyIHRvIGNvbnRhY3RcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHYsICAgIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGlmKG51bUNvbnRhY3RzICYmIHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTtcblxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuQ0FQU1VMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBhcnRpY2xlQ2Fwc3VsZSA9IGZ1bmN0aW9uKFxuICAgIHBhcnRpY2xlQm9keSxcbiAgICBwYXJ0aWNsZVNoYXBlLFxuICAgIHBhcnRpY2xlUG9zaXRpb24sXG4gICAgcGFydGljbGVBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZVBvc2l0aW9uLFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICByZXR1cm4gdGhpcy5jaXJjbGVMaW5lKHBhcnRpY2xlQm9keSxwYXJ0aWNsZVNoYXBlLHBhcnRpY2xlUG9zaXRpb24scGFydGljbGVBbmdsZSwgY2Fwc3VsZUJvZHksY2Fwc3VsZVNoYXBlLGNhcHN1bGVQb3NpdGlvbixjYXBzdWxlQW5nbGUsIGp1c3RUZXN0LCBjYXBzdWxlU2hhcGUucmFkaXVzLCAwKTtcbn07XG5cbi8qKlxuICogQ2lyY2xlL2xpbmUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2lyY2xlTGluZVxuICogQHBhcmFtICB7Qm9keX0gY2lyY2xlQm9keVxuICogQHBhcmFtICB7Q2lyY2xlfSBjaXJjbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNpcmNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9IGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGxpbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gbGluZUFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0IElmIHNldCB0byB0cnVlLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgKGludGVyc2VjdGlvbiBvciBub3QpIHdpdGhvdXQgYWRkaW5nIGVxdWF0aW9ucy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lUmFkaXVzIFJhZGl1cyB0byBhZGQgdG8gdGhlIGxpbmUuIENhbiBiZSB1c2VkIHRvIHRlc3QgQ2Fwc3VsZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gY2lyY2xlUmFkaXVzIElmIHNldCwgdGhpcyB2YWx1ZSBvdmVycmlkZXMgdGhlIGNpcmNsZSBzaGFwZSByYWRpdXMuXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5MSU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlTGluZSA9IGZ1bmN0aW9uKFxuICAgIGNpcmNsZUJvZHksXG4gICAgY2lyY2xlU2hhcGUsXG4gICAgY2lyY2xlT2Zmc2V0LFxuICAgIGNpcmNsZUFuZ2xlLFxuICAgIGxpbmVCb2R5LFxuICAgIGxpbmVTaGFwZSxcbiAgICBsaW5lT2Zmc2V0LFxuICAgIGxpbmVBbmdsZSxcbiAgICBqdXN0VGVzdCxcbiAgICBsaW5lUmFkaXVzLFxuICAgIGNpcmNsZVJhZGl1c1xuKXtcbiAgICB2YXIgbGluZVJhZGl1cyA9IGxpbmVSYWRpdXMgfHwgMCxcbiAgICAgICAgY2lyY2xlUmFkaXVzID0gdHlwZW9mKGNpcmNsZVJhZGl1cykhPT1cInVuZGVmaW5lZFwiID8gY2lyY2xlUmFkaXVzIDogY2lyY2xlU2hhcGUucmFkaXVzLFxuXG4gICAgICAgIG9ydGhvRGlzdCA9IHRtcDEsXG4gICAgICAgIGxpbmVUb0NpcmNsZU9ydGhvVW5pdCA9IHRtcDIsXG4gICAgICAgIHByb2plY3RlZFBvaW50ID0gdG1wMyxcbiAgICAgICAgY2VudGVyRGlzdCA9IHRtcDQsXG4gICAgICAgIHdvcmxkVGFuZ2VudCA9IHRtcDUsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDYsXG4gICAgICAgIHdvcmxkRWRnZVVuaXQgPSB0bXA3LFxuICAgICAgICB3b3JsZFZlcnRleDAgPSB0bXA4LFxuICAgICAgICB3b3JsZFZlcnRleDEgPSB0bXA5LFxuICAgICAgICB3b3JsZFZlcnRleDAxID0gdG1wMTAsXG4gICAgICAgIHdvcmxkVmVydGV4MTEgPSB0bXAxMSxcbiAgICAgICAgZGlzdCA9IHRtcDEyLFxuICAgICAgICBsaW5lVG9DaXJjbGUgPSB0bXAxMyxcbiAgICAgICAgbGluZUVuZFRvTGluZVJhZGl1cyA9IHRtcDE0LFxuXG4gICAgICAgIHZlcnRzID0gdG1wQXJyYXk7XG5cbiAgICAvLyBHZXQgc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAgICB2ZWMyLnNldCh3b3JsZFZlcnRleDAsIC1saW5lU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIuc2V0KHdvcmxkVmVydGV4MSwgIGxpbmVTaGFwZS5sZW5ndGgvMiwgMCk7XG5cbiAgICAvLyBOb3Qgc3VyZSB3aHkgd2UgaGF2ZSB0byB1c2Ugd29ybGRWZXJ0ZXgqMSBoZXJlLCBidXQgaXQgd29uJ3Qgd29yayBvdGhlcndpc2UuIFRpcmVkLlxuICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MDEsIHdvcmxkVmVydGV4MCwgbGluZUFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDEsIGxpbmVBbmdsZSk7XG5cbiAgICBhZGQod29ybGRWZXJ0ZXgwMSwgd29ybGRWZXJ0ZXgwMSwgbGluZU9mZnNldCk7XG4gICAgYWRkKHdvcmxkVmVydGV4MTEsIHdvcmxkVmVydGV4MTEsIGxpbmVPZmZzZXQpO1xuXG4gICAgdmVjMi5jb3B5KHdvcmxkVmVydGV4MCx3b3JsZFZlcnRleDAxKTtcbiAgICB2ZWMyLmNvcHkod29ybGRWZXJ0ZXgxLHdvcmxkVmVydGV4MTEpO1xuXG4gICAgLy8gR2V0IHZlY3RvciBhbG9uZyB0aGUgbGluZVxuICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xuXG4gICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuXG4gICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkVGFuZ2VudCwgd29ybGRFZGdlVW5pdCk7XG5cbiAgICAvLyBDaGVjayBkaXN0YW5jZSBmcm9tIHRoZSBwbGFuZSBzcGFubmVkIGJ5IHRoZSBlZGdlIHZzIHRoZSBjaXJjbGVcbiAgICBzdWIoZGlzdCwgY2lyY2xlT2Zmc2V0LCB3b3JsZFZlcnRleDApO1xuICAgIHZhciBkID0gZG90KGRpc3QsIHdvcmxkVGFuZ2VudCk7IC8vIERpc3RhbmNlIGZyb20gY2VudGVyIG9mIGxpbmUgdG8gY2lyY2xlIGNlbnRlclxuICAgIHN1YihjZW50ZXJEaXN0LCB3b3JsZFZlcnRleDAsIGxpbmVPZmZzZXQpO1xuXG4gICAgc3ViKGxpbmVUb0NpcmNsZSwgY2lyY2xlT2Zmc2V0LCBsaW5lT2Zmc2V0KTtcblxuICAgIHZhciByYWRpdXNTdW0gPSBjaXJjbGVSYWRpdXMgKyBsaW5lUmFkaXVzO1xuXG4gICAgaWYoTWF0aC5hYnMoZCkgPCByYWRpdXNTdW0pe1xuXG4gICAgICAgIC8vIE5vdyBwcm9qZWN0IHRoZSBjaXJjbGUgb250byB0aGUgZWRnZVxuICAgICAgICB2ZWMyLnNjYWxlKG9ydGhvRGlzdCwgd29ybGRUYW5nZW50LCBkKTtcbiAgICAgICAgc3ViKHByb2plY3RlZFBvaW50LCBjaXJjbGVPZmZzZXQsIG9ydGhvRGlzdCk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBtaXNzaW5nIGxpbmUgcmFkaXVzXG4gICAgICAgIHZlYzIuc2NhbGUobGluZVRvQ2lyY2xlT3J0aG9Vbml0LCB3b3JsZFRhbmdlbnQsIGRvdCh3b3JsZFRhbmdlbnQsIGxpbmVUb0NpcmNsZSkpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShsaW5lVG9DaXJjbGVPcnRob1VuaXQsbGluZVRvQ2lyY2xlT3J0aG9Vbml0KTtcbiAgICAgICAgdmVjMi5zY2FsZShsaW5lVG9DaXJjbGVPcnRob1VuaXQsIGxpbmVUb0NpcmNsZU9ydGhvVW5pdCwgbGluZVJhZGl1cyk7XG4gICAgICAgIGFkZChwcm9qZWN0ZWRQb2ludCxwcm9qZWN0ZWRQb2ludCxsaW5lVG9DaXJjbGVPcnRob1VuaXQpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGVkZ2Ugc3BhblxuICAgICAgICB2YXIgcG9zID0gIGRvdCh3b3JsZEVkZ2VVbml0LCBwcm9qZWN0ZWRQb2ludCk7XG4gICAgICAgIHZhciBwb3MwID0gZG90KHdvcmxkRWRnZVVuaXQsIHdvcmxkVmVydGV4MCk7XG4gICAgICAgIHZhciBwb3MxID0gZG90KHdvcmxkRWRnZVVuaXQsIHdvcmxkVmVydGV4MSk7XG5cbiAgICAgICAgaWYocG9zID4gcG9zMCAmJiBwb3MgPCBwb3MxKXtcbiAgICAgICAgICAgIC8vIFdlIGdvdCBjb250YWN0IVxuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxsaW5lQm9keSxjaXJjbGVTaGFwZSxsaW5lU2hhcGUpO1xuXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGMubm9ybWFsQSwgb3J0aG9EaXN0LCAtMSk7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsIGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgIHZlYzIuc2NhbGUoIGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCAgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHByb2plY3RlZFBvaW50LCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBjb3JuZXJcbiAgICB2ZXJ0c1swXSA9IHdvcmxkVmVydGV4MDtcbiAgICB2ZXJ0c1sxXSA9IHdvcmxkVmVydGV4MTtcblxuICAgIGZvcih2YXIgaT0wOyBpPHZlcnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcblxuICAgICAgICBzdWIoZGlzdCwgdiwgY2lyY2xlT2Zmc2V0KTtcblxuICAgICAgICBpZih2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCkgPCBNYXRoLnBvdyhyYWRpdXNTdW0sIDIpKXtcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksbGluZUJvZHksY2lyY2xlU2hhcGUsbGluZVNoYXBlKTtcblxuICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgZGlzdCk7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gY2lyY2xlIHRvIGNvbnRhY3QgcG9pbnQgaXMgdGhlIG5vcm1hbCB0aW1lcyB0aGUgY2lyY2xlIHJhZGl1c1xuICAgICAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHYsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgdmVjMi5zY2FsZShsaW5lRW5kVG9MaW5lUmFkaXVzLCBjLm5vcm1hbEEsIC1saW5lUmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUVuZFRvTGluZVJhZGl1cyk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQ2lyY2xlL2NhcHN1bGUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2lyY2xlQ2Fwc3VsZVxuICogQHBhcmFtICB7Qm9keX0gICBiaVxuICogQHBhcmFtICB7Q2lyY2xlfSBzaVxuICogQHBhcmFtICB7QXJyYXl9ICB4aVxuICogQHBhcmFtICB7TnVtYmVyfSBhaVxuICogQHBhcmFtICB7Qm9keX0gICBialxuICogQHBhcmFtICB7TGluZX0gICBzalxuICogQHBhcmFtICB7QXJyYXl9ICB4alxuICogQHBhcmFtICB7TnVtYmVyfSBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuQ0FQU1VMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUNhcHN1bGUgPSBmdW5jdGlvbihiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0KXtcbiAgICByZXR1cm4gdGhpcy5jaXJjbGVMaW5lKGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3QsIHNqLnJhZGl1cyk7XG59O1xuXG4vKipcbiAqIENpcmNsZS9jb252ZXggTmFycm93cGhhc2UuXG4gKiBAbWV0aG9kIGNpcmNsZUNvbnZleFxuICogQHBhcmFtICB7Qm9keX0gY2lyY2xlQm9keVxuICogQHBhcmFtICB7Q2lyY2xlfSBjaXJjbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNpcmNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjaXJjbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxuICogQHBhcmFtICB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqIEBwYXJhbSAge051bWJlcn0gY2lyY2xlUmFkaXVzXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVDb252ZXggPSBmdW5jdGlvbihcbiAgICBjaXJjbGVCb2R5LFxuICAgIGNpcmNsZVNoYXBlLFxuICAgIGNpcmNsZU9mZnNldCxcbiAgICBjaXJjbGVBbmdsZSxcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBqdXN0VGVzdCxcbiAgICBjaXJjbGVSYWRpdXNcbil7XG4gICAgdmFyIGNpcmNsZVJhZGl1cyA9IHR5cGVvZihjaXJjbGVSYWRpdXMpPT09XCJudW1iZXJcIiA/IGNpcmNsZVJhZGl1cyA6IGNpcmNsZVNoYXBlLnJhZGl1cztcblxuICAgIHZhciB3b3JsZFZlcnRleDAgPSB0bXAxLFxuICAgICAgICB3b3JsZFZlcnRleDEgPSB0bXAyLFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXAzLFxuICAgICAgICB3b3JsZEVkZ2VVbml0ID0gdG1wNCxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXA1LFxuICAgICAgICBjZW50ZXJEaXN0ID0gdG1wNixcbiAgICAgICAgY29udmV4VG9DaXJjbGUgPSB0bXA3LFxuICAgICAgICBvcnRob0Rpc3QgPSB0bXA4LFxuICAgICAgICBwcm9qZWN0ZWRQb2ludCA9IHRtcDksXG4gICAgICAgIGRpc3QgPSB0bXAxMCxcbiAgICAgICAgd29ybGRWZXJ0ZXggPSB0bXAxMSxcblxuICAgICAgICBjbG9zZXN0RWRnZSA9IC0xLFxuICAgICAgICBjbG9zZXN0RWRnZURpc3RhbmNlID0gbnVsbCxcbiAgICAgICAgY2xvc2VzdEVkZ2VPcnRob0Rpc3QgPSB0bXAxMixcbiAgICAgICAgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCA9IHRtcDEzLFxuICAgICAgICBjYW5kaWRhdGUgPSB0bXAxNCxcbiAgICAgICAgY2FuZGlkYXRlRGlzdCA9IHRtcDE1LFxuICAgICAgICBtaW5DYW5kaWRhdGUgPSB0bXAxNixcblxuICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICB2YXIgbnVtUmVwb3J0ZWQgPSAwO1xuXG4gICAgLy8gTmV3IGFsZ29yaXRobTpcbiAgICAvLyAxLiBDaGVjayBzbyBjZW50ZXIgb2YgY2lyY2xlIGlzIG5vdCBpbnNpZGUgdGhlIHBvbHlnb24uIElmIGl0IGlzLCB0aGlzIHdvbnQgd29yay4uLlxuICAgIC8vIDIuIEZvciBlYWNoIGVkZ2VcbiAgICAvLyAyLiAxLiBHZXQgcG9pbnQgb24gY2lyY2xlIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgZWRnZSAoc2NhbGUgbm9ybWFsIHdpdGggLXJhZGl1cylcbiAgICAvLyAyLiAyLiBDaGVjayBpZiBwb2ludCBpcyBpbnNpZGUuXG5cbiAgICB2YXIgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcztcblxuICAgIC8vIENoZWNrIGFsbCBlZGdlcyBmaXJzdFxuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoKzE7IGkrKyl7XG4gICAgICAgIHZhciB2MCA9IHZlcnRzW2kldmVydHMubGVuZ3RoXSxcbiAgICAgICAgICAgIHYxID0gdmVydHNbKGkrMSkldmVydHMubGVuZ3RoXTtcblxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAsIHYwLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MSwgdjEsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgxLCB3b3JsZFZlcnRleDEsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcblxuICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZEVkZ2VVbml0LCB3b3JsZEVkZ2UpO1xuXG4gICAgICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLiBQb2ludHMgb3V0IG9mIHRoZSBDb252ZXhcbiAgICAgICAgdmVjMi5yb3RhdGU5MGN3KHdvcmxkTm9ybWFsLCB3b3JsZEVkZ2VVbml0KTtcblxuICAgICAgICAvLyBHZXQgcG9pbnQgb24gY2lyY2xlLCBjbG9zZXN0IHRvIHRoZSBwb2x5Z29uXG4gICAgICAgIHZlYzIuc2NhbGUoY2FuZGlkYXRlLHdvcmxkTm9ybWFsLC1jaXJjbGVTaGFwZS5yYWRpdXMpO1xuICAgICAgICBhZGQoY2FuZGlkYXRlLGNhbmRpZGF0ZSxjaXJjbGVPZmZzZXQpO1xuXG4gICAgICAgIGlmKHBvaW50SW5Db252ZXgoY2FuZGlkYXRlLGNvbnZleFNoYXBlLGNvbnZleE9mZnNldCxjb252ZXhBbmdsZSkpe1xuXG4gICAgICAgICAgICB2ZWMyLnN1YihjYW5kaWRhdGVEaXN0LHdvcmxkVmVydGV4MCxjYW5kaWRhdGUpO1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZURpc3RhbmNlID0gTWF0aC5hYnModmVjMi5kb3QoY2FuZGlkYXRlRGlzdCx3b3JsZE5vcm1hbCkpO1xuXG4gICAgICAgICAgICBpZihjYW5kaWRhdGVEaXN0YW5jZSA8IG1pbkNhbmRpZGF0ZURpc3RhbmNlKXtcbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkobWluQ2FuZGlkYXRlLGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgbWluQ2FuZGlkYXRlRGlzdGFuY2UgPSBjYW5kaWRhdGVEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsd29ybGROb3JtYWwsY2FuZGlkYXRlRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIHZlYzIuYWRkKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCxjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGZvdW5kKXtcblxuICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oY2lyY2xlQm9keSxjb252ZXhCb2R5LGNpcmNsZVNoYXBlLGNvbnZleFNoYXBlKTtcbiAgICAgICAgdmVjMi5zdWIoYy5ub3JtYWxBLCBtaW5DYW5kaWRhdGUsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcblxuICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QSwgIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCggdGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBhbGwgdmVydGljZXNcbiAgICBpZihjaXJjbGVSYWRpdXMgPiAwKXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGxvY2FsVmVydGV4ID0gdmVydHNbaV07XG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleCwgbG9jYWxWZXJ0ZXgsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgICAgIGFkZCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA8IE1hdGgucG93KGNpcmNsZVJhZGl1cywgMikpe1xuXG4gICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksY29udmV4Qm9keSxjaXJjbGVTaGFwZSxjb252ZXhTaGFwZSk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcbiAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCBjaXJjbGVSYWRpdXMpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50Qiwgd29ybGRWZXJ0ZXgsIGNvbnZleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4Qm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xufTtcblxudmFyIHBpY193b3JsZFZlcnRleDAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBpY193b3JsZFZlcnRleDEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBpY19yMCA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGljX3IxID0gdmVjMi5jcmVhdGUoKTtcblxuLypcbiAqIENoZWNrIGlmIGEgcG9pbnQgaXMgaW4gYSBwb2x5Z29uXG4gKi9cbmZ1bmN0aW9uIHBvaW50SW5Db252ZXgod29ybGRQb2ludCxjb252ZXhTaGFwZSxjb252ZXhPZmZzZXQsY29udmV4QW5nbGUpe1xuICAgIHZhciB3b3JsZFZlcnRleDAgPSBwaWNfd29ybGRWZXJ0ZXgwLFxuICAgICAgICB3b3JsZFZlcnRleDEgPSBwaWNfd29ybGRWZXJ0ZXgxLFxuICAgICAgICByMCA9IHBpY19yMCxcbiAgICAgICAgcjEgPSBwaWNfcjEsXG4gICAgICAgIHBvaW50ID0gd29ybGRQb2ludCxcbiAgICAgICAgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcyxcbiAgICAgICAgbGFzdENyb3NzID0gbnVsbDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PXZlcnRzLmxlbmd0aCsxOyBpKyspe1xuICAgICAgICB2YXIgdjAgPSB2ZXJ0c1tpJXZlcnRzLmxlbmd0aF0sXG4gICAgICAgICAgICB2MSA9IHZlcnRzWyhpKzEpJXZlcnRzLmxlbmd0aF07XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIHZlcnRpY2VzIHRvIHdvcmxkXG4gICAgICAgIC8vIEB0b2RvIFRoZSBwb2ludCBzaG91bGQgYmUgdHJhbnNmb3JtZWQgdG8gbG9jYWwgY29vcmRpbmF0ZXMgaW4gdGhlIGNvbnZleCwgbm8gbmVlZCB0byB0cmFuc2Zvcm0gZWFjaCB2ZXJ0ZXhcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwLCB2MCwgY29udmV4QW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDEsIHYxLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDAsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgxLCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIHN1YihyMCwgd29ybGRWZXJ0ZXgwLCBwb2ludCk7XG4gICAgICAgIHN1YihyMSwgd29ybGRWZXJ0ZXgxLCBwb2ludCk7XG4gICAgICAgIHZhciBjcm9zcyA9IHZlYzIuY3Jvc3NMZW5ndGgocjAscjEpO1xuXG4gICAgICAgIGlmKGxhc3RDcm9zcz09PW51bGwpe1xuICAgICAgICAgICAgbGFzdENyb3NzID0gY3Jvc3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBnb3QgYSBkaWZmZXJlbnQgc2lnbiBvZiB0aGUgZGlzdGFuY2UgdmVjdG9yLCB0aGUgcG9pbnQgaXMgb3V0IG9mIHRoZSBwb2x5Z29uXG4gICAgICAgIGlmKGNyb3NzKmxhc3RDcm9zcyA8PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Q3Jvc3MgPSBjcm9zcztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUGFydGljbGUvY29udmV4IE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIHBhcnRpY2xlQ29udmV4XG4gKiBAcGFyYW0gIHtCb2R5fSBwYXJ0aWNsZUJvZHlcbiAqIEBwYXJhbSAge1BhcnRpY2xlfSBwYXJ0aWNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGFydGljbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGFydGljbGVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gY29udmV4Qm9keVxuICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxuICogQHRvZG8gdXNlIHBvaW50SW5Db252ZXggYW5kIGNvZGUgbW9yZSBzaW1pbGFyIHRvIGNpcmNsZUNvbnZleFxuICogQHRvZG8gZG9uJ3QgdHJhbnNmb3JtIGVhY2ggdmVydGV4LCBidXQgdHJhbnNmb3JtIHRoZSBwYXJ0aWNsZSBwb3NpdGlvbiB0byBjb252ZXgtbG9jYWwgaW5zdGVhZFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUEFSVElDTEUgfCBTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLlJFQ1RBTkdMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBhcnRpY2xlQ29udmV4ID0gZnVuY3Rpb24oXG4gICAgcGFydGljbGVCb2R5LFxuICAgIHBhcnRpY2xlU2hhcGUsXG4gICAgcGFydGljbGVPZmZzZXQsXG4gICAgcGFydGljbGVBbmdsZSxcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgd29ybGRWZXJ0ZXgwID0gdG1wMSxcbiAgICAgICAgd29ybGRWZXJ0ZXgxID0gdG1wMixcbiAgICAgICAgd29ybGRFZGdlID0gdG1wMyxcbiAgICAgICAgd29ybGRFZGdlVW5pdCA9IHRtcDQsXG4gICAgICAgIHdvcmxkVGFuZ2VudCA9IHRtcDUsXG4gICAgICAgIGNlbnRlckRpc3QgPSB0bXA2LFxuICAgICAgICBjb252ZXhUb3BhcnRpY2xlID0gdG1wNyxcbiAgICAgICAgb3J0aG9EaXN0ID0gdG1wOCxcbiAgICAgICAgcHJvamVjdGVkUG9pbnQgPSB0bXA5LFxuICAgICAgICBkaXN0ID0gdG1wMTAsXG4gICAgICAgIHdvcmxkVmVydGV4ID0gdG1wMTEsXG4gICAgICAgIGNsb3Nlc3RFZGdlID0gLTEsXG4gICAgICAgIGNsb3Nlc3RFZGdlRGlzdGFuY2UgPSBudWxsLFxuICAgICAgICBjbG9zZXN0RWRnZU9ydGhvRGlzdCA9IHRtcDEyLFxuICAgICAgICBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50ID0gdG1wMTMsXG4gICAgICAgIHIwID0gdG1wMTQsIC8vIHZlY3RvciBmcm9tIHBhcnRpY2xlIHRvIHZlcnRleDBcbiAgICAgICAgcjEgPSB0bXAxNSxcbiAgICAgICAgbG9jYWxQb2ludCA9IHRtcDE2LFxuICAgICAgICBjYW5kaWRhdGVEaXN0ID0gdG1wMTcsXG4gICAgICAgIG1pbkVkZ2VOb3JtYWwgPSB0bXAxOCxcbiAgICAgICAgbWluQ2FuZGlkYXRlRGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgdmFyIG51bVJlcG9ydGVkID0gMCxcbiAgICAgICAgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgdmVydHMgPSBjb252ZXhTaGFwZS52ZXJ0aWNlcztcblxuICAgIC8vIENoZWNrIGlmIHRoZSBwYXJ0aWNsZSBpcyBpbiB0aGUgcG9seWdvbiBhdCBhbGxcbiAgICBpZighcG9pbnRJbkNvbnZleChwYXJ0aWNsZU9mZnNldCxjb252ZXhTaGFwZSxjb252ZXhPZmZzZXQsY29udmV4QW5nbGUpKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBlZGdlcyBmaXJzdFxuICAgIHZhciBsYXN0Q3Jvc3MgPSBudWxsO1xuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoKzE7IGkrKyl7XG4gICAgICAgIHZhciB2MCA9IHZlcnRzW2kldmVydHMubGVuZ3RoXSxcbiAgICAgICAgICAgIHYxID0gdmVydHNbKGkrMSkldmVydHMubGVuZ3RoXTtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gdmVydGljZXMgdG8gd29ybGRcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwLCB2MCwgY29udmV4QW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDEsIHYxLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDAsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgxLCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIC8vIEdldCB3b3JsZCBlZGdlXG4gICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgwKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUod29ybGRFZGdlVW5pdCwgd29ybGRFZGdlKTtcblxuICAgICAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS4gUG9pbnRzIG91dCBvZiB0aGUgQ29udmV4XG4gICAgICAgIHZlYzIucm90YXRlOTBjdyh3b3JsZFRhbmdlbnQsIHdvcmxkRWRnZVVuaXQpO1xuXG4gICAgICAgIC8vIENoZWNrIGRpc3RhbmNlIGZyb20gdGhlIGluZmluaXRlIGxpbmUgKHNwYW5uZWQgYnkgdGhlIGVkZ2UpIHRvIHRoZSBwYXJ0aWNsZVxuICAgICAgICBzdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIHdvcmxkVmVydGV4MCk7XG4gICAgICAgIHZhciBkID0gZG90KGRpc3QsIHdvcmxkVGFuZ2VudCk7XG4gICAgICAgIHN1YihjZW50ZXJEaXN0LCB3b3JsZFZlcnRleDAsIGNvbnZleE9mZnNldCk7XG5cbiAgICAgICAgc3ViKGNvbnZleFRvcGFydGljbGUsIHBhcnRpY2xlT2Zmc2V0LCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIHZlYzIuc3ViKGNhbmRpZGF0ZURpc3Qsd29ybGRWZXJ0ZXgwLHBhcnRpY2xlT2Zmc2V0KTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZURpc3RhbmNlID0gTWF0aC5hYnModmVjMi5kb3QoY2FuZGlkYXRlRGlzdCx3b3JsZFRhbmdlbnQpKTtcblxuICAgICAgICBpZihjYW5kaWRhdGVEaXN0YW5jZSA8IG1pbkNhbmRpZGF0ZURpc3RhbmNlKXtcbiAgICAgICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gY2FuZGlkYXRlRGlzdGFuY2U7XG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsd29ybGRUYW5nZW50LGNhbmRpZGF0ZURpc3RhbmNlKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCxwYXJ0aWNsZU9mZnNldCk7XG4gICAgICAgICAgICB2ZWMyLmNvcHkobWluRWRnZU5vcm1hbCx3b3JsZFRhbmdlbnQpO1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZm91bmQpe1xuICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBhcnRpY2xlQm9keSxjb252ZXhCb2R5LHBhcnRpY2xlU2hhcGUsY29udmV4U2hhcGUpO1xuXG4gICAgICAgIHZlYzIuc2NhbGUoYy5ub3JtYWxBLCBtaW5FZGdlTm9ybWFsLCAtMSk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSwgYy5ub3JtYWxBKTtcblxuICAgICAgICAvLyBQYXJ0aWNsZSBoYXMgbm8gZXh0ZW50IHRvIHRoZSBjb250YWN0IHBvaW50XG4gICAgICAgIHZlYzIuc2V0KGMuY29udGFjdFBvaW50QSwgIDAsIDApO1xuICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBhcnRpY2xlT2Zmc2V0KTtcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgIC8vIEZyb20gY29udmV4IGNlbnRlciB0byBwb2ludFxuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4Qm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG5cbiAgICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQ2lyY2xlL2NpcmNsZSBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjaXJjbGVDaXJjbGVcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtDaXJjbGV9IHNoYXBlQVxuICogQHBhcmFtICB7QXJyYXl9IG9mZnNldEFcbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHBhcmFtICB7Q2lyY2xlfSBzaGFwZUJcbiAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRCXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlQlxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXNBXSBPcHRpb25hbCByYWRpdXMgdG8gdXNlIGZvciBzaGFwZUFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzQl0gT3B0aW9uYWwgcmFkaXVzIHRvIHVzZSBmb3Igc2hhcGVCXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVDaXJjbGUgPSBmdW5jdGlvbihcbiAgICBib2R5QSxcbiAgICBzaGFwZUEsXG4gICAgb2Zmc2V0QSxcbiAgICBhbmdsZUEsXG4gICAgYm9keUIsXG4gICAgc2hhcGVCLFxuICAgIG9mZnNldEIsXG4gICAgYW5nbGVCLFxuICAgIGp1c3RUZXN0LFxuICAgIHJhZGl1c0EsXG4gICAgcmFkaXVzQlxuKXtcblxuICAgIHZhciBkaXN0ID0gdG1wMSxcbiAgICAgICAgcmFkaXVzQSA9IHJhZGl1c0EgfHwgc2hhcGVBLnJhZGl1cyxcbiAgICAgICAgcmFkaXVzQiA9IHJhZGl1c0IgfHwgc2hhcGVCLnJhZGl1cztcblxuICAgIHN1YihkaXN0LG9mZnNldEEsb2Zmc2V0Qik7XG4gICAgdmFyIHIgPSByYWRpdXNBICsgcmFkaXVzQjtcbiAgICBpZih2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCkgPiBNYXRoLnBvdyhyLDIpKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCLHNoYXBlQSxzaGFwZUIpO1xuICAgIHN1YihjLm5vcm1hbEEsIG9mZnNldEIsIG9mZnNldEEpO1xuICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgdmVjMi5zY2FsZSggYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsICByYWRpdXNBKTtcbiAgICB2ZWMyLnNjYWxlKCBjLmNvbnRhY3RQb2ludEIsIGMubm9ybWFsQSwgLXJhZGl1c0IpO1xuXG4gICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBvZmZzZXRBKTtcbiAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGJvZHlBLnBvc2l0aW9uKTtcblxuICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50Qiwgb2Zmc2V0Qik7XG4gICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBib2R5Qi5wb3NpdGlvbik7XG5cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIFBsYW5lL0NvbnZleCBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBwbGFuZUNvbnZleFxuICogQHBhcmFtICB7Qm9keX0gcGxhbmVCb2R5XG4gKiBAcGFyYW0gIHtQbGFuZX0gcGxhbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IHBsYW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBsYW5lQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNvbnZleEJvZHlcbiAqIEBwYXJhbSAge0NvbnZleH0gY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjb252ZXhPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY29udmV4QW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuQ09OVkVYXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUNvbnZleCA9IGZ1bmN0aW9uKFxuICAgIHBsYW5lQm9keSxcbiAgICBwbGFuZVNoYXBlLFxuICAgIHBsYW5lT2Zmc2V0LFxuICAgIHBsYW5lQW5nbGUsXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhPZmZzZXQsXG4gICAgY29udmV4QW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgdmFyIHdvcmxkVmVydGV4ID0gdG1wMSxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXAyLFxuICAgICAgICBkaXN0ID0gdG1wMztcblxuICAgIHZhciBudW1SZXBvcnRlZCA9IDA7XG4gICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09Y29udmV4U2hhcGUudmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IGNvbnZleFNoYXBlLnZlcnRpY2VzW2ldO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleCwgdiwgY29udmV4QW5nbGUpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4LCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgcGxhbmVPZmZzZXQpO1xuXG4gICAgICAgIGlmKGRvdChkaXN0LHdvcmxkTm9ybWFsKSA8PSAwKXtcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3VuZCB2ZXJ0ZXhcbiAgICAgICAgICAgIG51bVJlcG9ydGVkKys7XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LGNvbnZleEJvZHkscGxhbmVTaGFwZSxjb252ZXhTaGFwZSk7XG5cbiAgICAgICAgICAgIHN1YihkaXN0LCB3b3JsZFZlcnRleCwgcGxhbmVPZmZzZXQpO1xuXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgICAgIHZhciBkID0gZG90KGRpc3QsIGMubm9ybWFsQSk7XG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGRpc3QsIGMubm9ybWFsQSwgZCk7XG5cbiAgICAgICAgICAgIC8vIHJqIGlzIGZyb20gY29udmV4IGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB3b3JsZFZlcnRleCwgY29udmV4Qm9keS5wb3NpdGlvbik7XG5cblxuICAgICAgICAgICAgLy8gcmkgaXMgZnJvbSBwbGFuZSBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgc3ViKCBjLmNvbnRhY3RQb2ludEEsIHdvcmxkVmVydGV4LCBkaXN0KTtcbiAgICAgICAgICAgIHN1YiggYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uICYmIG51bVJlcG9ydGVkKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtUmVwb3J0ZWQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1SZXBvcnRlZDtcbn07XG5cbi8qKlxuICogTmFycm93cGhhc2UgZm9yIHBhcnRpY2xlIHZzIHBsYW5lXG4gKiBAbWV0aG9kIHBhcnRpY2xlUGxhbmVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHBhcnRpY2xlQm9keVxuICogQHBhcmFtICB7UGFydGljbGV9ICAgcGFydGljbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcGFydGljbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIHBhcnRpY2xlQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHBsYW5lQm9keVxuICogQHBhcmFtICB7UGxhbmV9ICAgICAgcGxhbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcGxhbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIHBsYW5lQW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgIGp1c3RUZXN0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLlBMQU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGFydGljbGVQbGFuZSA9IGZ1bmN0aW9uKFxuICAgIHBhcnRpY2xlQm9keSxcbiAgICBwYXJ0aWNsZVNoYXBlLFxuICAgIHBhcnRpY2xlT2Zmc2V0LFxuICAgIHBhcnRpY2xlQW5nbGUsXG4gICAgcGxhbmVCb2R5LFxuICAgIHBsYW5lU2hhcGUsXG4gICAgcGxhbmVPZmZzZXQsXG4gICAgcGxhbmVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgZGlzdCA9IHRtcDEsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wMjtcblxuICAgIHBsYW5lQW5nbGUgPSBwbGFuZUFuZ2xlIHx8IDA7XG5cbiAgICBzdWIoZGlzdCwgcGFydGljbGVPZmZzZXQsIHBsYW5lT2Zmc2V0KTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgeUF4aXMsIHBsYW5lQW5nbGUpO1xuXG4gICAgdmFyIGQgPSBkb3QoZGlzdCwgd29ybGROb3JtYWwpO1xuXG4gICAgaWYoZCA+IDApe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSxwYXJ0aWNsZUJvZHkscGxhbmVTaGFwZSxwYXJ0aWNsZVNoYXBlKTtcblxuICAgIHZlYzIuY29weShjLm5vcm1hbEEsIHdvcmxkTm9ybWFsKTtcbiAgICB2ZWMyLnNjYWxlKCBkaXN0LCBjLm5vcm1hbEEsIGQgKTtcbiAgICAvLyBkaXN0IGlzIG5vdyB0aGUgZGlzdGFuY2UgdmVjdG9yIGluIHRoZSBub3JtYWwgZGlyZWN0aW9uXG5cbiAgICAvLyByaSBpcyB0aGUgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIGRvd24gb250byB0aGUgcGxhbmUsIGZyb20gdGhlIHBsYW5lIGNlbnRlclxuICAgIHN1YiggYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZU9mZnNldCwgZGlzdCk7XG4gICAgc3ViKCBjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgIC8vIHJqIGlzIGZyb20gdGhlIGJvZHkgY2VudGVyIHRvIHRoZSBwYXJ0aWNsZSBjZW50ZXJcbiAgICBzdWIoIGMuY29udGFjdFBvaW50QiwgcGFydGljbGVPZmZzZXQsIHBhcnRpY2xlQm9keS5wb3NpdGlvbiApO1xuXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvUGFydGljbGUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2lyY2xlUGFydGljbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNpcmNsZUJvZHlcbiAqIEBwYXJhbSAge0NpcmNsZX0gY2lyY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjaXJjbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY2lyY2xlQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IHBhcnRpY2xlQm9keVxuICogQHBhcmFtICB7UGFydGljbGV9IHBhcnRpY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBwYXJ0aWNsZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwYXJ0aWNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb29sZWFufSBqdXN0VGVzdFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuUEFSVElDTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVQYXJ0aWNsZSA9IGZ1bmN0aW9uKFxuICAgIGNpcmNsZUJvZHksXG4gICAgY2lyY2xlU2hhcGUsXG4gICAgY2lyY2xlT2Zmc2V0LFxuICAgIGNpcmNsZUFuZ2xlLFxuICAgIHBhcnRpY2xlQm9keSxcbiAgICBwYXJ0aWNsZVNoYXBlLFxuICAgIHBhcnRpY2xlT2Zmc2V0LFxuICAgIHBhcnRpY2xlQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgdmFyIGRpc3QgPSB0bXAxO1xuXG4gICAgc3ViKGRpc3QsIHBhcnRpY2xlT2Zmc2V0LCBjaXJjbGVPZmZzZXQpO1xuICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA+IE1hdGgucG93KGNpcmNsZVNoYXBlLnJhZGl1cywgMikpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHkscGFydGljbGVCb2R5LGNpcmNsZVNoYXBlLHBhcnRpY2xlU2hhcGUpO1xuICAgIHZlYzIuY29weShjLm5vcm1hbEEsIGRpc3QpO1xuICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgLy8gVmVjdG9yIGZyb20gY2lyY2xlIHRvIGNvbnRhY3QgcG9pbnQgaXMgdGhlIG5vcm1hbCB0aW1lcyB0aGUgY2lyY2xlIHJhZGl1c1xuICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsIGNpcmNsZVNoYXBlLnJhZGl1cyk7XG4gICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVPZmZzZXQpO1xuICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAvLyBWZWN0b3IgZnJvbSBwYXJ0aWNsZSBjZW50ZXIgdG8gY29udGFjdCBwb2ludCBpcyB6ZXJvXG4gICAgc3ViKGMuY29udGFjdFBvaW50QiwgcGFydGljbGVPZmZzZXQsIHBhcnRpY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbn07XG5cbnZhciBwbGFuZUNhcHN1bGVfdG1wQ2lyY2xlID0gbmV3IENpcmNsZSgxKSxcbiAgICBwbGFuZUNhcHN1bGVfdG1wMSA9IHZlYzIuY3JlYXRlKCksXG4gICAgcGxhbmVDYXBzdWxlX3RtcDIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBsYW5lQ2Fwc3VsZV90bXAzID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHBsYW5lQ2Fwc3VsZVxuICogQHBhcmFtICB7Qm9keX0gcGxhbmVCb2R5XG4gKiBAcGFyYW0gIHtDaXJjbGV9IHBsYW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBwbGFuZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwbGFuZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjYXBzdWxlQm9keVxuICogQHBhcmFtICB7UGFydGljbGV9IGNhcHN1bGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNhcHN1bGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY2Fwc3VsZUFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkNBUFNVTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUNhcHN1bGUgPSBmdW5jdGlvbihcbiAgICBwbGFuZUJvZHksXG4gICAgcGxhbmVTaGFwZSxcbiAgICBwbGFuZU9mZnNldCxcbiAgICBwbGFuZUFuZ2xlLFxuICAgIGNhcHN1bGVCb2R5LFxuICAgIGNhcHN1bGVTaGFwZSxcbiAgICBjYXBzdWxlT2Zmc2V0LFxuICAgIGNhcHN1bGVBbmdsZSxcbiAgICBqdXN0VGVzdFxuKXtcbiAgICB2YXIgZW5kMSA9IHBsYW5lQ2Fwc3VsZV90bXAxLFxuICAgICAgICBlbmQyID0gcGxhbmVDYXBzdWxlX3RtcDIsXG4gICAgICAgIGNpcmNsZSA9IHBsYW5lQ2Fwc3VsZV90bXBDaXJjbGUsXG4gICAgICAgIGRzdCA9IHBsYW5lQ2Fwc3VsZV90bXAzO1xuXG4gICAgLy8gQ29tcHV0ZSB3b3JsZCBlbmQgcG9zaXRpb25zXG4gICAgdmVjMi5zZXQoZW5kMSwgLWNhcHN1bGVTaGFwZS5sZW5ndGgvMiwgMCk7XG4gICAgdmVjMi5yb3RhdGUoZW5kMSxlbmQxLGNhcHN1bGVBbmdsZSk7XG4gICAgYWRkKGVuZDEsZW5kMSxjYXBzdWxlT2Zmc2V0KTtcblxuICAgIHZlYzIuc2V0KGVuZDIsICBjYXBzdWxlU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIucm90YXRlKGVuZDIsZW5kMixjYXBzdWxlQW5nbGUpO1xuICAgIGFkZChlbmQyLGVuZDIsY2Fwc3VsZU9mZnNldCk7XG5cbiAgICBjaXJjbGUucmFkaXVzID0gY2Fwc3VsZVNoYXBlLnJhZGl1cztcblxuICAgIHZhciBlbmFibGVGcmljdGlvbkJlZm9yZTtcblxuICAgIC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIERvIE5hcnJvd3BoYXNlIGFzIHR3byBjaXJjbGVzXG4gICAgdmFyIG51bUNvbnRhY3RzMSA9IHRoaXMuY2lyY2xlUGxhbmUoY2Fwc3VsZUJvZHksY2lyY2xlLGVuZDEsMCwgcGxhbmVCb2R5LHBsYW5lU2hhcGUscGxhbmVPZmZzZXQscGxhbmVBbmdsZSwganVzdFRlc3QpLFxuICAgICAgICBudW1Db250YWN0czIgPSB0aGlzLmNpcmNsZVBsYW5lKGNhcHN1bGVCb2R5LGNpcmNsZSxlbmQyLDAsIHBsYW5lQm9keSxwbGFuZVNoYXBlLHBsYW5lT2Zmc2V0LHBsYW5lQW5nbGUsIGp1c3RUZXN0KTtcblxuICAgIC8vIFJlc3RvcmUgZnJpY3Rpb25cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIG51bUNvbnRhY3RzMSB8fCBudW1Db250YWN0czI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG51bVRvdGFsID0gbnVtQ29udGFjdHMxICsgbnVtQ29udGFjdHMyO1xuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgIGlmKG51bVRvdGFsKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bVRvdGFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bVRvdGFsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBDb250YWN0RXF1YXRpb25zIGFuZCBGcmljdGlvbkVxdWF0aW9ucyBmb3IgYSBjb2xsaXNpb24uXG4gKiBAbWV0aG9kIGNpcmNsZVBsYW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgICBiaSAgICAgVGhlIGZpcnN0IGJvZHkgdGhhdCBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBlcXVhdGlvbnMuXG4gKiBAcGFyYW0gIHtDaXJjbGV9ICBzaSAgICAgVGhlIGNpcmNsZSBzaGFwZSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb2xsaXNpb24uXG4gKiBAcGFyYW0gIHtBcnJheX0gICB4aSAgICAgRXh0cmEgb2Zmc2V0IHRvIHRha2UgaW50byBhY2NvdW50IGZvciB0aGUgU2hhcGUsIGluIGFkZGl0aW9uIHRvIHRoZSBvbmUgaW4gY2lyY2xlQm9keS5wb3NpdGlvbi4gV2lsbCAqbm90KiBiZSByb3RhdGVkIGJ5IGNpcmNsZUJvZHkuYW5nbGUgKG1heWJlIGl0IHNob3VsZCwgZm9yIHNha2Ugb2YgaG9tb2dlbml0eT8pLiBTZXQgdG8gbnVsbCBpZiBub25lLlxuICogQHBhcmFtICB7Qm9keX0gICAgYmogICAgIFRoZSBzZWNvbmQgYm9keSB0aGF0IHNob3VsZCBiZSBjb25uZWN0ZWQgdG8gdGhlIGVxdWF0aW9ucy5cbiAqIEBwYXJhbSAge1BsYW5lfSAgIHNqICAgICBUaGUgUGxhbmUgc2hhcGUgdGhhdCBpcyBwYXJ0aWNpcGF0aW5nXG4gKiBAcGFyYW0gIHtBcnJheX0gICB4aiAgICAgRXh0cmEgb2Zmc2V0IGZvciB0aGUgcGxhbmUgc2hhcGUuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBhaiAgICAgRXh0cmEgYW5nbGUgdG8gYXBwbHkgdG8gdGhlIHBsYW5lXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5QTEFORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZVBsYW5lID0gZnVuY3Rpb24oICAgYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCApe1xuICAgIHZhciBjaXJjbGVCb2R5ID0gYmksXG4gICAgICAgIGNpcmNsZVNoYXBlID0gc2ksXG4gICAgICAgIGNpcmNsZU9mZnNldCA9IHhpLCAvLyBPZmZzZXQgZnJvbSBib2R5IGNlbnRlciwgcm90YXRlZCFcbiAgICAgICAgcGxhbmVCb2R5ID0gYmosXG4gICAgICAgIHNoYXBlQiA9IHNqLFxuICAgICAgICBwbGFuZU9mZnNldCA9IHhqLFxuICAgICAgICBwbGFuZUFuZ2xlID0gYWo7XG5cbiAgICBwbGFuZUFuZ2xlID0gcGxhbmVBbmdsZSB8fCAwO1xuXG4gICAgLy8gVmVjdG9yIGZyb20gcGxhbmUgdG8gY2lyY2xlXG4gICAgdmFyIHBsYW5lVG9DaXJjbGUgPSB0bXAxLFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDIsXG4gICAgICAgIHRlbXAgPSB0bXAzO1xuXG4gICAgc3ViKHBsYW5lVG9DaXJjbGUsIGNpcmNsZU9mZnNldCwgcGxhbmVPZmZzZXQpO1xuXG4gICAgLy8gV29ybGQgcGxhbmUgbm9ybWFsXG4gICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcblxuICAgIC8vIE5vcm1hbCBkaXJlY3Rpb24gZGlzdGFuY2VcbiAgICB2YXIgZCA9IGRvdCh3b3JsZE5vcm1hbCwgcGxhbmVUb0NpcmNsZSk7XG5cbiAgICBpZihkID4gY2lyY2xlU2hhcGUucmFkaXVzKXtcbiAgICAgICAgcmV0dXJuIDA7IC8vIE5vIG92ZXJsYXAuIEFib3J0LlxuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGNvbnRhY3RcbiAgICB2YXIgY29udGFjdCA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSxjaXJjbGVCb2R5LHNqLHNpKTtcblxuICAgIC8vIG5pIGlzIHRoZSBwbGFuZSB3b3JsZCBub3JtYWxcbiAgICB2ZWMyLmNvcHkoY29udGFjdC5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XG5cbiAgICAvLyByaiBpcyB0aGUgdmVjdG9yIGZyb20gY2lyY2xlIGNlbnRlciB0byB0aGUgY29udGFjdCBwb2ludFxuICAgIHZlYzIuc2NhbGUoY29udGFjdC5jb250YWN0UG9pbnRCLCBjb250YWN0Lm5vcm1hbEEsIC1jaXJjbGVTaGFwZS5yYWRpdXMpO1xuICAgIGFkZChjb250YWN0LmNvbnRhY3RQb2ludEIsIGNvbnRhY3QuY29udGFjdFBvaW50QiwgY2lyY2xlT2Zmc2V0KTtcbiAgICBzdWIoY29udGFjdC5jb250YWN0UG9pbnRCLCBjb250YWN0LmNvbnRhY3RQb2ludEIsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgLy8gcmkgaXMgdGhlIGRpc3RhbmNlIGZyb20gcGxhbmUgY2VudGVyIHRvIGNvbnRhY3QuXG4gICAgdmVjMi5zY2FsZSh0ZW1wLCBjb250YWN0Lm5vcm1hbEEsIGQpO1xuICAgIHN1Yihjb250YWN0LmNvbnRhY3RQb2ludEEsIHBsYW5lVG9DaXJjbGUsIHRlbXAgKTsgLy8gU3VidHJhY3Qgbm9ybWFsIGRpc3RhbmNlIHZlY3RvciBmcm9tIHRoZSBkaXN0YW5jZSB2ZWN0b3JcbiAgICBhZGQoY29udGFjdC5jb250YWN0UG9pbnRBLCBjb250YWN0LmNvbnRhY3RQb2ludEEsIHBsYW5lT2Zmc2V0KTtcbiAgICBzdWIoY29udGFjdC5jb250YWN0UG9pbnRBLCBjb250YWN0LmNvbnRhY3RQb2ludEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjb250YWN0KTtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjb250YWN0KSApO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBDb252ZXgvY29udmV4IE5hcnJvd3BoYXNlLlNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy5hbHRkZXZibG9nYWRheS5jb20vMjAxMS8wNS8xMy9jb250YWN0LWdlbmVyYXRpb24tYmV0d2Vlbi0zZC1jb252ZXgtbWVzaGVzL1wiPnRoaXMgYXJ0aWNsZTwvYT4gZm9yIG1vcmUgaW5mby5cbiAqIEBtZXRob2QgY29udmV4Q29udmV4XG4gKiBAcGFyYW0gIHtCb2R5fSBiaVxuICogQHBhcmFtICB7Q29udmV4fSBzaVxuICogQHBhcmFtICB7QXJyYXl9IHhpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFpXG4gKiBAcGFyYW0gIHtCb2R5fSBialxuICogQHBhcmFtICB7Q29udmV4fSBzalxuICogQHBhcmFtICB7QXJyYXl9IHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVhdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DT05WRVggfCBTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5SRUNUQU5HTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhDb252ZXggPSBmdW5jdGlvbiggIGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3QsIHByZWNpc2lvbiApe1xuICAgIHZhciBzZXBBeGlzID0gdG1wMSxcbiAgICAgICAgd29ybGRQb2ludCA9IHRtcDIsXG4gICAgICAgIHdvcmxkUG9pbnQwID0gdG1wMyxcbiAgICAgICAgd29ybGRQb2ludDEgPSB0bXA0LFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXA1LFxuICAgICAgICBwcm9qZWN0ZWQgPSB0bXA2LFxuICAgICAgICBwZW5ldHJhdGlvblZlYyA9IHRtcDcsXG4gICAgICAgIGRpc3QgPSB0bXA4LFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDksXG4gICAgICAgIG51bUNvbnRhY3RzID0gMCxcbiAgICAgICAgcHJlY2lzaW9uID0gdHlwZW9mKHByZWNpc2lvbikgPT09ICdudW1iZXInID8gcHJlY2lzaW9uIDogMDtcblxuICAgIHZhciBmb3VuZCA9IE5hcnJvd3BoYXNlLmZpbmRTZXBhcmF0aW5nQXhpcyhzaSx4aSxhaSxzaix4aixhaixzZXBBeGlzKTtcbiAgICBpZighZm91bmQpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIHNlcGFyYXRpbmcgYXhpcyBpcyBkaXJlY3RlZCBmcm9tIHNoYXBlIGkgdG8gc2hhcGUgalxuICAgIHN1YihkaXN0LHhqLHhpKTtcbiAgICBpZihkb3Qoc2VwQXhpcyxkaXN0KSA+IDApe1xuICAgICAgICB2ZWMyLnNjYWxlKHNlcEF4aXMsc2VwQXhpcywtMSk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBlZGdlcyB3aXRoIG5vcm1hbHMgY2xvc2VzdCB0byB0aGUgc2VwYXJhdGluZyBheGlzXG4gICAgdmFyIGNsb3Nlc3RFZGdlMSA9IE5hcnJvd3BoYXNlLmdldENsb3Nlc3RFZGdlKHNpLGFpLHNlcEF4aXMsdHJ1ZSksIC8vIEZsaXBwZWQgYXhpc1xuICAgICAgICBjbG9zZXN0RWRnZTIgPSBOYXJyb3dwaGFzZS5nZXRDbG9zZXN0RWRnZShzaixhaixzZXBBeGlzKTtcblxuICAgIGlmKGNsb3Nlc3RFZGdlMSA9PT0gLTEgfHwgY2xvc2VzdEVkZ2UyID09PSAtMSl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIExvb3Agb3ZlciB0aGUgc2hhcGVzXG4gICAgZm9yKHZhciBrPTA7IGs8MjsgaysrKXtcblxuICAgICAgICB2YXIgY2xvc2VzdEVkZ2VBID0gY2xvc2VzdEVkZ2UxLFxuICAgICAgICAgICAgY2xvc2VzdEVkZ2VCID0gY2xvc2VzdEVkZ2UyLFxuICAgICAgICAgICAgc2hhcGVBID0gIHNpLCBzaGFwZUIgPSAgc2osXG4gICAgICAgICAgICBvZmZzZXRBID0geGksIG9mZnNldEIgPSB4aixcbiAgICAgICAgICAgIGFuZ2xlQSA9IGFpLCBhbmdsZUIgPSBhaixcbiAgICAgICAgICAgIGJvZHlBID0gYmksIGJvZHlCID0gYmo7XG5cbiAgICAgICAgaWYoayA9PT0gMCl7XG4gICAgICAgICAgICAvLyBTd2FwIVxuICAgICAgICAgICAgdmFyIHRtcDtcbiAgICAgICAgICAgIHRtcCA9IGNsb3Nlc3RFZGdlQTtcbiAgICAgICAgICAgIGNsb3Nlc3RFZGdlQSA9IGNsb3Nlc3RFZGdlQjtcbiAgICAgICAgICAgIGNsb3Nlc3RFZGdlQiA9IHRtcDtcblxuICAgICAgICAgICAgdG1wID0gc2hhcGVBO1xuICAgICAgICAgICAgc2hhcGVBID0gc2hhcGVCO1xuICAgICAgICAgICAgc2hhcGVCID0gdG1wO1xuXG4gICAgICAgICAgICB0bXAgPSBvZmZzZXRBO1xuICAgICAgICAgICAgb2Zmc2V0QSA9IG9mZnNldEI7XG4gICAgICAgICAgICBvZmZzZXRCID0gdG1wO1xuXG4gICAgICAgICAgICB0bXAgPSBhbmdsZUE7XG4gICAgICAgICAgICBhbmdsZUEgPSBhbmdsZUI7XG4gICAgICAgICAgICBhbmdsZUIgPSB0bXA7XG5cbiAgICAgICAgICAgIHRtcCA9IGJvZHlBO1xuICAgICAgICAgICAgYm9keUEgPSBib2R5QjtcbiAgICAgICAgICAgIGJvZHlCID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIDIgcG9pbnRzIGluIGNvbnZleCBCXG4gICAgICAgIGZvcih2YXIgaj1jbG9zZXN0RWRnZUI7IGo8Y2xvc2VzdEVkZ2VCKzI7IGorKyl7XG5cbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBwb2ludFxuICAgICAgICAgICAgdmFyIHYgPSBzaGFwZUIudmVydGljZXNbKGorc2hhcGVCLnZlcnRpY2VzLmxlbmd0aCklc2hhcGVCLnZlcnRpY2VzLmxlbmd0aF07XG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50LCB2LCBhbmdsZUIpO1xuICAgICAgICAgICAgYWRkKHdvcmxkUG9pbnQsIHdvcmxkUG9pbnQsIG9mZnNldEIpO1xuXG4gICAgICAgICAgICB2YXIgaW5zaWRlTnVtRWRnZXMgPSAwO1xuXG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgdGhlIDMgY2xvc2VzdCBlZGdlcyBpbiBjb252ZXggQVxuICAgICAgICAgICAgZm9yKHZhciBpPWNsb3Nlc3RFZGdlQS0xOyBpPGNsb3Nlc3RFZGdlQSsyOyBpKyspe1xuXG4gICAgICAgICAgICAgICAgdmFyIHYwID0gc2hhcGVBLnZlcnRpY2VzWyhpICArc2hhcGVBLnZlcnRpY2VzLmxlbmd0aCklc2hhcGVBLnZlcnRpY2VzLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgICAgIHYxID0gc2hhcGVBLnZlcnRpY2VzWyhpKzErc2hhcGVBLnZlcnRpY2VzLmxlbmd0aCklc2hhcGVBLnZlcnRpY2VzLmxlbmd0aF07XG5cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MCwgdjAsIGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDEsIHYxLCBhbmdsZUEpO1xuICAgICAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50MCwgd29ybGRQb2ludDAsIG9mZnNldEEpO1xuICAgICAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50MSwgd29ybGRQb2ludDEsIG9mZnNldEEpO1xuXG4gICAgICAgICAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRQb2ludDEsIHdvcmxkUG9pbnQwKTtcblxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlOTBjdyh3b3JsZE5vcm1hbCwgd29ybGRFZGdlKTsgLy8gTm9ybWFsIHBvaW50cyBvdXQgb2YgY29udmV4IDFcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZE5vcm1hbCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRQb2ludCwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkb3Qod29ybGROb3JtYWwsZGlzdCk7XG5cbiAgICAgICAgICAgICAgICBpZigoaSA9PT0gY2xvc2VzdEVkZ2VBICYmIGQgPD0gcHJlY2lzaW9uKSB8fCAoaSAhPT0gY2xvc2VzdEVkZ2VBICYmIGQgPD0gMCkpe1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGVOdW1FZGdlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoaW5zaWRlTnVtRWRnZXMgPj0gMyl7XG5cbiAgICAgICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHdvcmxkUG9pbnQgd2FzIG9uIHRoZSBcImluc2lkZVwiIHNpZGUgb2YgZWFjaCBvZiB0aGUgMyBjaGVja2VkIGVkZ2VzLlxuICAgICAgICAgICAgICAgIC8vIFByb2plY3QgaXQgdG8gdGhlIGNlbnRlciBlZGdlIGFuZCB1c2UgdGhlIHByb2plY3Rpb24gZGlyZWN0aW9uIGFzIG5vcm1hbFxuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGNvbnRhY3RcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCLHNoYXBlQSxzaGFwZUIpO1xuICAgICAgICAgICAgICAgIG51bUNvbnRhY3RzKys7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY2VudGVyIGVkZ2UgZnJvbSBib2R5IEFcbiAgICAgICAgICAgICAgICB2YXIgdjAgPSBzaGFwZUEudmVydGljZXNbKGNsb3Nlc3RFZGdlQSkgICAlIHNoYXBlQS52ZXJ0aWNlcy5sZW5ndGhdLFxuICAgICAgICAgICAgICAgICAgICB2MSA9IHNoYXBlQS52ZXJ0aWNlc1soY2xvc2VzdEVkZ2VBKzEpICUgc2hhcGVBLnZlcnRpY2VzLmxlbmd0aF07XG5cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MCwgdjAsIGFuZ2xlQSk7XG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDEsIHYxLCBhbmdsZUEpO1xuICAgICAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50MCwgd29ybGRQb2ludDAsIG9mZnNldEEpO1xuICAgICAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50MSwgd29ybGRQb2ludDEsIG9mZnNldEEpO1xuXG4gICAgICAgICAgICAgICAgc3ViKHdvcmxkRWRnZSwgd29ybGRQb2ludDEsIHdvcmxkUG9pbnQwKTtcblxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlOTBjdyhjLm5vcm1hbEEsIHdvcmxkRWRnZSk7IC8vIE5vcm1hbCBwb2ludHMgb3V0IG9mIGNvbnZleCBBXG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRQb2ludCwgd29ybGRQb2ludDApOyAvLyBGcm9tIGVkZ2UgcG9pbnQgdG8gdGhlIHBlbmV0cmF0aW5nIHBvaW50XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkb3QoYy5ub3JtYWxBLGRpc3QpOyAgICAgICAgICAgICAvLyBQZW5ldHJhdGlvblxuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUocGVuZXRyYXRpb25WZWMsIGMubm9ybWFsQSwgZCk7ICAgICAvLyBWZWN0b3IgcGVuZXRyYXRpb25cblxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIHdvcmxkUG9pbnQsIG9mZnNldEEpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGVuZXRyYXRpb25WZWMpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgb2Zmc2V0QSk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBib2R5QS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB3b3JsZFBvaW50LCBvZmZzZXRCKTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIG9mZnNldEIpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgYm9keUIucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgICAgICAvLyBUb2RvIHJlZHVjZSB0byAxIGZyaWN0aW9uIGVxdWF0aW9uIGlmIHdlIGhhdmUgMiBjb250YWN0IHBvaW50c1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uICYmIG51bUNvbnRhY3RzKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1Db250YWN0cztcbn07XG5cbi8vIC5wcm9qZWN0Q29udmV4IGlzIGNhbGxlZCBieSBvdGhlciBmdW5jdGlvbnMsIG5lZWQgbG9jYWwgdG1wIHZlY3RvcnNcbnZhciBwY29hX3RtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBQcm9qZWN0IGEgQ29udmV4IG9udG8gYSB3b3JsZC1vcmllbnRlZCBheGlzXG4gKiBAbWV0aG9kIHByb2plY3RDb252ZXhPbnRvQXhpc1xuICogQHN0YXRpY1xuICogQHBhcmFtICB7Q29udmV4fSBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IGNvbnZleE9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBjb252ZXhBbmdsZVxuICogQHBhcmFtICB7QXJyYXl9IHdvcmxkQXhpc1xuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxuICovXG5OYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMgPSBmdW5jdGlvbihjb252ZXhTaGFwZSwgY29udmV4T2Zmc2V0LCBjb252ZXhBbmdsZSwgd29ybGRBeGlzLCByZXN1bHQpe1xuICAgIHZhciBtYXg9bnVsbCxcbiAgICAgICAgbWluPW51bGwsXG4gICAgICAgIHYsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBsb2NhbEF4aXMgPSBwY29hX3RtcDE7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSBheGlzIHRvIGxvY2FsIGNvb3JkcyBvZiB0aGUgYm9keVxuICAgIHZlYzIucm90YXRlKGxvY2FsQXhpcywgd29ybGRBeGlzLCAtY29udmV4QW5nbGUpO1xuXG4gICAgLy8gR2V0IHByb2plY3RlZCBwb3NpdGlvbiBvZiBhbGwgdmVydGljZXNcbiAgICBmb3IodmFyIGk9MDsgaTxjb252ZXhTaGFwZS52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHYgPSBjb252ZXhTaGFwZS52ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmFsdWUgPSBkb3Qodixsb2NhbEF4aXMpO1xuICAgICAgICBpZihtYXggPT09IG51bGwgfHwgdmFsdWUgPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYobWluID09PSBudWxsIHx8IHZhbHVlIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYobWluID4gbWF4KXtcbiAgICAgICAgdmFyIHQgPSBtaW47XG4gICAgICAgIG1pbiA9IG1heDtcbiAgICAgICAgbWF4ID0gdDtcbiAgICB9XG5cbiAgICAvLyBQcm9qZWN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keSBvbnRvIHRoZSBheGlzIC0gbmVlZCB0byBhZGQgdGhpcyB0byB0aGUgcmVzdWx0XG4gICAgdmFyIG9mZnNldCA9IGRvdChjb252ZXhPZmZzZXQsIHdvcmxkQXhpcyk7XG5cbiAgICB2ZWMyLnNldCggcmVzdWx0LCBtaW4gKyBvZmZzZXQsIG1heCArIG9mZnNldCk7XG59O1xuXG4vLyAuZmluZFNlcGFyYXRpbmdBeGlzIGlzIGNhbGxlZCBieSBvdGhlciBmdW5jdGlvbnMsIG5lZWQgbG9jYWwgdG1wIHZlY3RvcnNcbnZhciBmc2FfdG1wMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXAzID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wNCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDUgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXA2ID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogRmluZCBhIHNlcGFyYXRpbmcgYXhpcyBiZXR3ZWVuIHRoZSBzaGFwZXMsIHRoYXQgbWF4aW1pemVzIHRoZSBzZXBhcmF0aW5nIGRpc3RhbmNlIGJldHdlZW4gdGhlbS5cbiAqIEBtZXRob2QgZmluZFNlcGFyYXRpbmdBeGlzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjMVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgb2Zmc2V0MVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGUxXG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjMlxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgb2Zmc2V0MlxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGUyXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBzZXBBeGlzICAgICBUaGUgcmVzdWx0aW5nIGF4aXNcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgIFdoZXRoZXIgdGhlIGF4aXMgY291bGQgYmUgZm91bmQuXG4gKi9cbk5hcnJvd3BoYXNlLmZpbmRTZXBhcmF0aW5nQXhpcyA9IGZ1bmN0aW9uKGMxLG9mZnNldDEsYW5nbGUxLGMyLG9mZnNldDIsYW5nbGUyLHNlcEF4aXMpe1xuICAgIHZhciBtYXhEaXN0ID0gbnVsbCxcbiAgICAgICAgb3ZlcmxhcCA9IGZhbHNlLFxuICAgICAgICBmb3VuZCA9IGZhbHNlLFxuICAgICAgICBlZGdlID0gZnNhX3RtcDEsXG4gICAgICAgIHdvcmxkUG9pbnQwID0gZnNhX3RtcDIsXG4gICAgICAgIHdvcmxkUG9pbnQxID0gZnNhX3RtcDMsXG4gICAgICAgIG5vcm1hbCA9IGZzYV90bXA0LFxuICAgICAgICBzcGFuMSA9IGZzYV90bXA1LFxuICAgICAgICBzcGFuMiA9IGZzYV90bXA2O1xuXG4gICAgaWYoYzEgaW5zdGFuY2VvZiBSZWN0YW5nbGUgJiYgYzIgaW5zdGFuY2VvZiBSZWN0YW5nbGUpe1xuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09MjsgaisrKXtcbiAgICAgICAgICAgIHZhciBjID0gYzEsXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTE7XG4gICAgICAgICAgICBpZihqPT09MSl7XG4gICAgICAgICAgICAgICAgYyA9IGMyO1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSE9PTI7IGkrKyl7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHdvcmxkIGVkZ2VcbiAgICAgICAgICAgICAgICBpZihpID09PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5zZXQobm9ybWFsLCAwLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLnNldChub3JtYWwsIDEsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihhbmdsZSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKG5vcm1hbCwgbm9ybWFsLCBhbmdsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUHJvamVjdCBodWxscyBvbnRvIHRoYXQgbm9ybWFsXG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMxLG9mZnNldDEsYW5nbGUxLG5vcm1hbCxzcGFuMSk7XG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzKGMyLG9mZnNldDIsYW5nbGUyLG5vcm1hbCxzcGFuMik7XG5cbiAgICAgICAgICAgICAgICAvLyBPcmRlciBieSBzcGFuIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGE9c3BhbjEsXG4gICAgICAgICAgICAgICAgICAgIGI9c3BhbjIsXG4gICAgICAgICAgICAgICAgICAgIHN3YXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZihzcGFuMVswXSA+IHNwYW4yWzBdKXtcbiAgICAgICAgICAgICAgICAgICAgYj1zcGFuMTtcbiAgICAgICAgICAgICAgICAgICAgYT1zcGFuMjtcbiAgICAgICAgICAgICAgICAgICAgc3dhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHNlcGFyYXRpbmcgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGJbMF0gLSBhWzFdO1xuICAgICAgICAgICAgICAgIG92ZXJsYXAgPSAoZGlzdCA8PSAwKTtcblxuICAgICAgICAgICAgICAgIGlmKG1heERpc3Q9PT1udWxsIHx8IGRpc3QgPiBtYXhEaXN0KXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5jb3B5KHNlcEF4aXMsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIG1heERpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09MjsgaisrKXtcbiAgICAgICAgICAgIHZhciBjID0gYzEsXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTE7XG4gICAgICAgICAgICBpZihqPT09MSl7XG4gICAgICAgICAgICAgICAgYyA9IGMyO1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWMudmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgd29ybGQgZWRnZVxuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQwLCBjLnZlcnRpY2VzW2ldLCBhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDEsIGMudmVydGljZXNbKGkrMSklYy52ZXJ0aWNlcy5sZW5ndGhdLCBhbmdsZSk7XG5cbiAgICAgICAgICAgICAgICBzdWIoZWRnZSwgd29ybGRQb2ludDEsIHdvcmxkUG9pbnQwKTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBub3JtYWwgLSBqdXN0IHJvdGF0ZSA5MCBkZWdyZWVzIHNpbmNlIHZlcnRpY2VzIGFyZSBnaXZlbiBpbiBDQ1dcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cobm9ybWFsLCBlZGdlKTtcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTtcblxuICAgICAgICAgICAgICAgIC8vIFByb2plY3QgaHVsbHMgb250byB0aGF0IG5vcm1hbFxuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMSxvZmZzZXQxLGFuZ2xlMSxub3JtYWwsc3BhbjEpO1xuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMixvZmZzZXQyLGFuZ2xlMixub3JtYWwsc3BhbjIpO1xuXG4gICAgICAgICAgICAgICAgLy8gT3JkZXIgYnkgc3BhbiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHZhciBhPXNwYW4xLFxuICAgICAgICAgICAgICAgICAgICBiPXNwYW4yLFxuICAgICAgICAgICAgICAgICAgICBzd2FwcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoc3BhbjFbMF0gPiBzcGFuMlswXSl7XG4gICAgICAgICAgICAgICAgICAgIGI9c3BhbjE7XG4gICAgICAgICAgICAgICAgICAgIGE9c3BhbjI7XG4gICAgICAgICAgICAgICAgICAgIHN3YXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEdldCBzZXBhcmF0aW5nIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBiWzBdIC0gYVsxXTtcbiAgICAgICAgICAgICAgICBvdmVybGFwID0gKGRpc3QgPD0gMCk7XG5cbiAgICAgICAgICAgICAgICBpZihtYXhEaXN0PT09bnVsbCB8fCBkaXN0ID4gbWF4RGlzdCl7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIuY29weShzZXBBeGlzLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICBtYXhEaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLypcbiAgICAvLyBOZWVkcyB0byBiZSB0ZXN0ZWQgc29tZSBtb3JlXG4gICAgZm9yKHZhciBqPTA7IGohPT0yOyBqKyspe1xuICAgICAgICB2YXIgYyA9IGMxLFxuICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTE7XG4gICAgICAgIGlmKGo9PT0xKXtcbiAgICAgICAgICAgIGMgPSBjMjtcbiAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUyO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1jLmF4ZXMubGVuZ3RoOyBpKyspe1xuXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gYy5heGVzW2ldO1xuXG4gICAgICAgICAgICAvLyBQcm9qZWN0IGh1bGxzIG9udG8gdGhhdCBub3JtYWxcbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMSwgb2Zmc2V0MSwgYW5nbGUxLCBub3JtYWwsIHNwYW4xKTtcbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMiwgb2Zmc2V0MiwgYW5nbGUyLCBub3JtYWwsIHNwYW4yKTtcblxuICAgICAgICAgICAgLy8gT3JkZXIgYnkgc3BhbiBwb3NpdGlvblxuICAgICAgICAgICAgdmFyIGE9c3BhbjEsXG4gICAgICAgICAgICAgICAgYj1zcGFuMixcbiAgICAgICAgICAgICAgICBzd2FwcGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZihzcGFuMVswXSA+IHNwYW4yWzBdKXtcbiAgICAgICAgICAgICAgICBiPXNwYW4xO1xuICAgICAgICAgICAgICAgIGE9c3BhbjI7XG4gICAgICAgICAgICAgICAgc3dhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBzZXBhcmF0aW5nIGRpc3RhbmNlXG4gICAgICAgICAgICB2YXIgZGlzdCA9IGJbMF0gLSBhWzFdO1xuICAgICAgICAgICAgb3ZlcmxhcCA9IChkaXN0IDw9IE5hcnJvd3BoYXNlLmNvbnZleFByZWNpc2lvbik7XG5cbiAgICAgICAgICAgIGlmKG1heERpc3Q9PT1udWxsIHx8IGRpc3QgPiBtYXhEaXN0KXtcbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoc2VwQXhpcywgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICBtYXhEaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IG92ZXJsYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgKi9cblxuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8vIC5nZXRDbG9zZXN0RWRnZSBpcyBjYWxsZWQgYnkgb3RoZXIgZnVuY3Rpb25zLCBuZWVkIGxvY2FsIHRtcCB2ZWN0b3JzXG52YXIgZ2NlX3RtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGdjZV90bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBnY2VfdG1wMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIEdldCB0aGUgZWRnZSB0aGF0IGhhcyBhIG5vcm1hbCBjbG9zZXN0IHRvIGFuIGF4aXMuXG4gKiBAbWV0aG9kIGdldENsb3Nlc3RFZGdlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgYXhpc1xuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgZmxpcFxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICBJbmRleCBvZiB0aGUgZWRnZSB0aGF0IGlzIGNsb3Nlc3QuIFRoaXMgaW5kZXggYW5kIHRoZSBuZXh0IHNwYW5zIHRoZSByZXN1bHRpbmcgZWRnZS4gUmV0dXJucyAtMSBpZiBmYWlsZWQuXG4gKi9cbk5hcnJvd3BoYXNlLmdldENsb3Nlc3RFZGdlID0gZnVuY3Rpb24oYyxhbmdsZSxheGlzLGZsaXApe1xuICAgIHZhciBsb2NhbEF4aXMgPSBnY2VfdG1wMSxcbiAgICAgICAgZWRnZSA9IGdjZV90bXAyLFxuICAgICAgICBub3JtYWwgPSBnY2VfdG1wMztcblxuICAgIC8vIENvbnZlcnQgdGhlIGF4aXMgdG8gbG9jYWwgY29vcmRzIG9mIHRoZSBib2R5XG4gICAgdmVjMi5yb3RhdGUobG9jYWxBeGlzLCBheGlzLCAtYW5nbGUpO1xuICAgIGlmKGZsaXApe1xuICAgICAgICB2ZWMyLnNjYWxlKGxvY2FsQXhpcyxsb2NhbEF4aXMsLTEpO1xuICAgIH1cblxuICAgIHZhciBjbG9zZXN0RWRnZSA9IC0xLFxuICAgICAgICBOID0gYy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIG1heERvdCA9IC0xO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgLy8gR2V0IHRoZSBlZGdlXG4gICAgICAgIHN1YihlZGdlLCBjLnZlcnRpY2VzWyhpKzEpJU5dLCBjLnZlcnRpY2VzW2klTl0pO1xuXG4gICAgICAgIC8vIEdldCBub3JtYWwgLSBqdXN0IHJvdGF0ZSA5MCBkZWdyZWVzIHNpbmNlIHZlcnRpY2VzIGFyZSBnaXZlbiBpbiBDQ1dcbiAgICAgICAgdmVjMi5yb3RhdGU5MGN3KG5vcm1hbCwgZWRnZSk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuXG4gICAgICAgIHZhciBkID0gZG90KG5vcm1hbCxsb2NhbEF4aXMpO1xuICAgICAgICBpZihjbG9zZXN0RWRnZSA9PT0gLTEgfHwgZCA+IG1heERvdCl7XG4gICAgICAgICAgICBjbG9zZXN0RWRnZSA9IGkgJSBOO1xuICAgICAgICAgICAgbWF4RG90ID0gZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9zZXN0RWRnZTtcbn07XG5cbnZhciBjaXJjbGVIZWlnaHRmaWVsZF9jYW5kaWRhdGUgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX2Rpc3QgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX3YwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF92MSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF93b3JsZE5vcm1hbCA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlTm9ybWFsID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNpcmNsZUhlaWdodGZpZWxkXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICAgICAgYmlcbiAqIEBwYXJhbSAge0NpcmNsZX0gICAgICAgICBzaVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIHhpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICAgICAgYmpcbiAqIEBwYXJhbSAge0hlaWdodGZpZWxkfSAgICBzalxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgIHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgYWpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkhFSUdIVEZJRUxEXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlSGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiggY2lyY2xlQm9keSxjaXJjbGVTaGFwZSxjaXJjbGVQb3MsY2lyY2xlQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZCb2R5LGhmU2hhcGUsaGZQb3MsaGZBbmdsZSwganVzdFRlc3QsIHJhZGl1cyApe1xuICAgIHZhciBkYXRhID0gaGZTaGFwZS5kYXRhLFxuICAgICAgICByYWRpdXMgPSByYWRpdXMgfHwgY2lyY2xlU2hhcGUucmFkaXVzLFxuICAgICAgICB3ID0gaGZTaGFwZS5lbGVtZW50V2lkdGgsXG4gICAgICAgIGRpc3QgPSBjaXJjbGVIZWlnaHRmaWVsZF9kaXN0LFxuICAgICAgICBjYW5kaWRhdGUgPSBjaXJjbGVIZWlnaHRmaWVsZF9jYW5kaWRhdGUsXG4gICAgICAgIG1pbkNhbmRpZGF0ZSA9IGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZSxcbiAgICAgICAgbWluQ2FuZGlkYXRlTm9ybWFsID0gY2lyY2xlSGVpZ2h0ZmllbGRfbWluQ2FuZGlkYXRlTm9ybWFsLFxuICAgICAgICB3b3JsZE5vcm1hbCA9IGNpcmNsZUhlaWdodGZpZWxkX3dvcmxkTm9ybWFsLFxuICAgICAgICB2MCA9IGNpcmNsZUhlaWdodGZpZWxkX3YwLFxuICAgICAgICB2MSA9IGNpcmNsZUhlaWdodGZpZWxkX3YxO1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxuICAgIHZhciBpZHhBID0gTWF0aC5mbG9vciggKGNpcmNsZVBvc1swXSAtIHJhZGl1cyAtIGhmUG9zWzBdKSAvIHcgKSxcbiAgICAgICAgaWR4QiA9IE1hdGguY2VpbCggIChjaXJjbGVQb3NbMF0gKyByYWRpdXMgLSBoZlBvc1swXSkgLyB3ICk7XG5cbiAgICAvKmlmKGlkeEIgPCAwIHx8IGlkeEEgPj0gZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBqdXN0VGVzdCA/IGZhbHNlIDogMDsqL1xuXG4gICAgaWYoaWR4QSA8IDApe1xuICAgICAgICBpZHhBID0gMDtcbiAgICB9XG4gICAgaWYoaWR4QiA+PSBkYXRhLmxlbmd0aCl7XG4gICAgICAgIGlkeEIgPSBkYXRhLmxlbmd0aC0xO1xuICAgIH1cblxuICAgIC8vIEdldCBtYXggYW5kIG1pblxuICAgIHZhciBtYXggPSBkYXRhW2lkeEFdLFxuICAgICAgICBtaW4gPSBkYXRhW2lkeEJdO1xuICAgIGZvcih2YXIgaT1pZHhBOyBpPGlkeEI7IGkrKyl7XG4gICAgICAgIGlmKGRhdGFbaV0gPCBtaW4pe1xuICAgICAgICAgICAgbWluID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZihkYXRhW2ldID4gbWF4KXtcbiAgICAgICAgICAgIG1heCA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihjaXJjbGVQb3NbMV0tcmFkaXVzID4gbWF4KXtcbiAgICAgICAgcmV0dXJuIGp1c3RUZXN0ID8gZmFsc2UgOiAwO1xuICAgIH1cblxuICAgIC8qXG4gICAgaWYoY2lyY2xlUG9zWzFdK3JhZGl1cyA8IG1pbil7XG4gICAgICAgIC8vIEJlbG93IHRoZSBtaW5pbXVtIHBvaW50Li4uIFdlIGNhbiBqdXN0IGd1ZXNzLlxuICAgICAgICAvLyBUT0RPXG4gICAgfVxuICAgICovXG5cbiAgICAvLyAxLiBDaGVjayBzbyBjZW50ZXIgb2YgY2lyY2xlIGlzIG5vdCBpbnNpZGUgdGhlIGZpZWxkLiBJZiBpdCBpcywgdGhpcyB3b250IHdvcmsuLi5cbiAgICAvLyAyLiBGb3IgZWFjaCBlZGdlXG4gICAgLy8gMi4gMS4gR2V0IHBvaW50IG9uIGNpcmNsZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGVkZ2UgKHNjYWxlIG5vcm1hbCB3aXRoIC1yYWRpdXMpXG4gICAgLy8gMi4gMi4gQ2hlY2sgaWYgcG9pbnQgaXMgaW5zaWRlLlxuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBhbGwgZWRnZXMgZmlyc3RcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCBwb2ludHNcbiAgICAgICAgdmVjMi5zZXQodjAsICAgICBpKncsIGRhdGFbaV0gICk7XG4gICAgICAgIHZlYzIuc2V0KHYxLCAoaSsxKSp3LCBkYXRhW2krMV0pO1xuICAgICAgICB2ZWMyLmFkZCh2MCx2MCxoZlBvcyk7XG4gICAgICAgIHZlYzIuYWRkKHYxLHYxLGhmUG9zKTtcblxuICAgICAgICAvLyBHZXQgbm9ybWFsXG4gICAgICAgIHZlYzIuc3ViKHdvcmxkTm9ybWFsLCB2MSwgdjApO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwsIE1hdGguUEkvMik7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKHdvcmxkTm9ybWFsLHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAvLyBHZXQgcG9pbnQgb24gY2lyY2xlLCBjbG9zZXN0IHRvIHRoZSBlZGdlXG4gICAgICAgIHZlYzIuc2NhbGUoY2FuZGlkYXRlLHdvcmxkTm9ybWFsLC1yYWRpdXMpO1xuICAgICAgICB2ZWMyLmFkZChjYW5kaWRhdGUsY2FuZGlkYXRlLGNpcmNsZVBvcyk7XG5cbiAgICAgICAgLy8gRGlzdGFuY2UgZnJvbSB2MCB0byB0aGUgY2FuZGlkYXRlIHBvaW50XG4gICAgICAgIHZlYzIuc3ViKGRpc3QsY2FuZGlkYXRlLHYwKTtcblxuICAgICAgICAvLyBDaGVjayBpZiBpdCBpcyBpbiB0aGUgZWxlbWVudCBcInN0aWNrXCJcbiAgICAgICAgdmFyIGQgPSB2ZWMyLmRvdChkaXN0LHdvcmxkTm9ybWFsKTtcbiAgICAgICAgaWYoY2FuZGlkYXRlWzBdID49IHYwWzBdICYmIGNhbmRpZGF0ZVswXSA8IHYxWzBdICYmIGQgPD0gMCl7XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgY2FuZGlkYXRlIHBvaW50LCBwcm9qZWN0ZWQgdG8gdGhlIGVkZ2VcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoZGlzdCx3b3JsZE5vcm1hbCwtZCk7XG4gICAgICAgICAgICB2ZWMyLmFkZChtaW5DYW5kaWRhdGUsY2FuZGlkYXRlLGRpc3QpO1xuICAgICAgICAgICAgdmVjMi5jb3B5KG1pbkNhbmRpZGF0ZU5vcm1hbCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oaGZCb2R5LGNpcmNsZUJvZHksaGZTaGFwZSxjaXJjbGVTaGFwZSk7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbCBpcyBvdXQgb2YgdGhlIGhlaWdodGZpZWxkXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBtaW5DYW5kaWRhdGVOb3JtYWwpO1xuXG4gICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gaGVpZ2h0ZmllbGRcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRCLCAgYy5ub3JtYWxBLCAtcmFkaXVzKTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlUG9zKTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHZlYzIuY29weShjLmNvbnRhY3RQb2ludEEsIG1pbkNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB2ZWMyLnN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCggdGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBhbGwgdmVydGljZXNcbiAgICBmb3VuZCA9IGZhbHNlO1xuICAgIGlmKHJhZGl1cyA+IDApe1xuICAgICAgICBmb3IodmFyIGk9aWR4QTsgaTw9aWR4QjsgaSsrKXtcblxuICAgICAgICAgICAgLy8gR2V0IHBvaW50XG4gICAgICAgICAgICB2ZWMyLnNldCh2MCwgaSp3LCBkYXRhW2ldKTtcbiAgICAgICAgICAgIHZlYzIuYWRkKHYwLHYwLGhmUG9zKTtcblxuICAgICAgICAgICAgdmVjMi5zdWIoZGlzdCwgY2lyY2xlUG9zLCB2MCk7XG5cbiAgICAgICAgICAgIGlmKHZlYzIuc3F1YXJlZExlbmd0aChkaXN0KSA8IE1hdGgucG93KHJhZGl1cywgMikpe1xuXG4gICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGhmQm9keSxjaXJjbGVCb2R5LGhmU2hhcGUsY2lyY2xlU2hhcGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IG5vcm1hbCAtIG91dCBvZiBoZWlnaHRmaWVsZFxuICAgICAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIGRpc3QpO1xuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEIsIGMubm9ybWFsQSwgLXJhZGl1cyk7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjaXJjbGVQb3MpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCB2MCwgaGZQb3MpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZQb3MpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgaGZCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGZvdW5kKXtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG5cbn07XG5cbnZhciBjb252ZXhIZWlnaHRmaWVsZF92MCA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29udmV4SGVpZ2h0ZmllbGRfdjEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvbnZleEhlaWdodGZpZWxkX3RpbGVQb3MgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvbnZleEhlaWdodGZpZWxkX3RlbXBDb252ZXhTaGFwZSA9IG5ldyBDb252ZXgoW3ZlYzIuY3JlYXRlKCksdmVjMi5jcmVhdGUoKSx2ZWMyLmNyZWF0ZSgpLHZlYzIuY3JlYXRlKCldKTtcbi8qKlxuICogQG1ldGhvZCBjaXJjbGVIZWlnaHRmaWVsZFxuICogQHBhcmFtICB7Qm9keX0gICAgICAgICAgIGJpXG4gKiBAcGFyYW0gIHtDaXJjbGV9ICAgICAgICAgc2lcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICB4aVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgICAgIGJqXG4gKiBAcGFyYW0gIHtIZWlnaHRmaWVsZH0gICAgc2pcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICB4alxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgIGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5SRUNUQU5HTEUgfCBTaGFwZS5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLkhFSUdIVEZJRUxEXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4SGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiggY29udmV4Qm9keSxjb252ZXhTaGFwZSxjb252ZXhQb3MsY29udmV4QW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZCb2R5LGhmU2hhcGUsaGZQb3MsaGZBbmdsZSwganVzdFRlc3QgKXtcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuZGF0YSxcbiAgICAgICAgdyA9IGhmU2hhcGUuZWxlbWVudFdpZHRoLFxuICAgICAgICB2MCA9IGNvbnZleEhlaWdodGZpZWxkX3YwLFxuICAgICAgICB2MSA9IGNvbnZleEhlaWdodGZpZWxkX3YxLFxuICAgICAgICB0aWxlUG9zID0gY29udmV4SGVpZ2h0ZmllbGRfdGlsZVBvcyxcbiAgICAgICAgdGlsZUNvbnZleCA9IGNvbnZleEhlaWdodGZpZWxkX3RlbXBDb252ZXhTaGFwZTtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcbiAgICB2YXIgaWR4QSA9IE1hdGguZmxvb3IoIChjb252ZXhCb2R5LmFhYmIubG93ZXJCb3VuZFswXSAtIGhmUG9zWzBdKSAvIHcgKSxcbiAgICAgICAgaWR4QiA9IE1hdGguY2VpbCggIChjb252ZXhCb2R5LmFhYmIudXBwZXJCb3VuZFswXSAtIGhmUG9zWzBdKSAvIHcgKTtcblxuICAgIGlmKGlkeEEgPCAwKXtcbiAgICAgICAgaWR4QSA9IDA7XG4gICAgfVxuICAgIGlmKGlkeEIgPj0gZGF0YS5sZW5ndGgpe1xuICAgICAgICBpZHhCID0gZGF0YS5sZW5ndGgtMTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbWF4IGFuZCBtaW5cbiAgICB2YXIgbWF4ID0gZGF0YVtpZHhBXSxcbiAgICAgICAgbWluID0gZGF0YVtpZHhCXTtcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuICAgICAgICBpZihkYXRhW2ldIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYoZGF0YVtpXSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoY29udmV4Qm9keS5hYWJiLmxvd2VyQm91bmRbMV0gPiBtYXgpe1xuICAgICAgICByZXR1cm4ganVzdFRlc3QgPyBmYWxzZSA6IDA7XG4gICAgfVxuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgdmFyIG51bUNvbnRhY3RzID0gMDtcblxuICAgIC8vIExvb3Agb3ZlciBhbGwgZWRnZXNcbiAgICAvLyBUT0RPOiBJZiBwb3NzaWJsZSwgY29uc3RydWN0IGEgY29udmV4IGZyb20gc2V2ZXJhbCBkYXRhIHBvaW50cyAobmVlZCBvIGNoZWNrIGlmIHRoZSBwb2ludHMgbWFrZSBhIGNvbnZleCBzaGFwZSlcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCBwb2ludHNcbiAgICAgICAgdmVjMi5zZXQodjAsICAgICBpKncsIGRhdGFbaV0gICk7XG4gICAgICAgIHZlYzIuc2V0KHYxLCAoaSsxKSp3LCBkYXRhW2krMV0pO1xuICAgICAgICB2ZWMyLmFkZCh2MCx2MCxoZlBvcyk7XG4gICAgICAgIHZlYzIuYWRkKHYxLHYxLGhmUG9zKTtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBjb252ZXhcbiAgICAgICAgdmFyIHRpbGVIZWlnaHQgPSAxMDA7IC8vIHRvZG9cbiAgICAgICAgdmVjMi5zZXQodGlsZVBvcywgKHYxWzBdICsgdjBbMF0pKjAuNSwgKHYxWzFdICsgdjBbMV0gLSB0aWxlSGVpZ2h0KSowLjUpO1xuXG4gICAgICAgIHZlYzIuc3ViKHRpbGVDb252ZXgudmVydGljZXNbMF0sIHYxLCB0aWxlUG9zKTtcbiAgICAgICAgdmVjMi5zdWIodGlsZUNvbnZleC52ZXJ0aWNlc1sxXSwgdjAsIHRpbGVQb3MpO1xuICAgICAgICB2ZWMyLmNvcHkodGlsZUNvbnZleC52ZXJ0aWNlc1syXSwgdGlsZUNvbnZleC52ZXJ0aWNlc1sxXSk7XG4gICAgICAgIHZlYzIuY29weSh0aWxlQ29udmV4LnZlcnRpY2VzWzNdLCB0aWxlQ29udmV4LnZlcnRpY2VzWzBdKTtcbiAgICAgICAgdGlsZUNvbnZleC52ZXJ0aWNlc1syXVsxXSAtPSB0aWxlSGVpZ2h0O1xuICAgICAgICB0aWxlQ29udmV4LnZlcnRpY2VzWzNdWzFdIC09IHRpbGVIZWlnaHQ7XG5cbiAgICAgICAgLy8gRG8gY29udmV4IGNvbGxpc2lvblxuICAgICAgICBudW1Db250YWN0cyArPSB0aGlzLmNvbnZleENvbnZleCggICBjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4UG9zLCBjb252ZXhBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZCb2R5LCB0aWxlQ29udmV4LCB0aWxlUG9zLCAwLCBqdXN0VGVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IFJheTtcblxudmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBSYXljYXN0UmVzdWx0ID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9TaGFwZScpO1xudmFyIEFBQkIgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQUFCQicpO1xuXG4vKipcbiAqIEEgbGluZSB3aXRoIGEgc3RhcnQgYW5kIGVuZCBwb2ludCB0aGF0IGlzIHVzZWQgdG8gaW50ZXJzZWN0IHNoYXBlcy5cbiAqIEBjbGFzcyBSYXlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSYXkob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBmcm9tXG4gICAgICovXG4gICAgdGhpcy5mcm9tID0gb3B0aW9ucy5mcm9tID8gdmVjMi5mcm9tVmFsdWVzKG9wdGlvbnMuZnJvbVswXSwgb3B0aW9ucy5mcm9tWzFdKSA6IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSB0b1xuICAgICAqL1xuICAgIHRoaXMudG8gPSBvcHRpb25zLnRvID8gdmVjMi5mcm9tVmFsdWVzKG9wdGlvbnMudG9bMF0sIG9wdGlvbnMudG9bMV0pIDogdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gX2RpcmVjdGlvblxuICAgICAqL1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlY2lzaW9uIG9mIHRoZSByYXkuIFVzZWQgd2hlbiBjaGVja2luZyBwYXJhbGxlbGl0eSBldGMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHByZWNpc2lvblxuICAgICAqL1xuICAgIHRoaXMucHJlY2lzaW9uID0gMC4wMDAxO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdGhlIFJheSB0byB0YWtlIC5jb2xsaXNpb25SZXNwb25zZSBmbGFncyBpbnRvIGFjY291bnQgb24gYm9kaWVzIGFuZCBzaGFwZXMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjaGVja0NvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG4gICAgdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgcmF5IHNraXBzIGFueSBoaXRzIHdpdGggbm9ybWFsLmRvdChyYXlEaXJlY3Rpb24pIDwgMC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNraXBCYWNrZmFjZXNcbiAgICAgKi9cbiAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25NYXNrXG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvbk1hc2sgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25Hcm91cFxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVyc2VjdGlvbiBtb2RlLiBTaG91bGQgYmUgUmF5LkFOWSwgUmF5LkFMTCBvciBSYXkuQ0xPU0VTVC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW9kZVxuICAgICAqL1xuICAgIHRoaXMubW9kZSA9IFJheS5BTlk7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHJlc3VsdCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGR1cmluZyBpbnRlcnNlY3RXb3JsZCgpIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaGFzSGl0XG4gICAgICovXG4gICAgdGhpcy5oYXNIaXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQsIHVzZXItcHJvdmlkZWQgcmVzdWx0IGNhbGxiYWNrLiBXaWxsIGJlIHVzZWQgaWYgbW9kZSBpcyBSYXkuQUxMLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgdGhpcy5jYWxsYmFjayA9IGZ1bmN0aW9uKHJlc3VsdCl7fTtcbn1cblJheS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYXk7XG5cblJheS5DTE9TRVNUID0gMTtcblJheS5BTlkgPSAyO1xuUmF5LkFMTCA9IDQ7XG5cbnZhciB0bXBBQUJCID0gbmV3IEFBQkIoKTtcbnZhciB0bXBBcnJheSA9IFtdO1xuXG4vKipcbiAqIERvIGl0ZXJzZWN0aW9uIGFnYWluc3QgYWxsIGJvZGllcyBpbiB0aGUgZ2l2ZW4gV29ybGQuXG4gKiBAbWV0aG9kIGludGVyc2VjdFdvcmxkXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmF5IGhpdCBhbnl0aGluZywgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFdvcmxkID0gZnVuY3Rpb24gKHdvcmxkLCBvcHRpb25zKSB7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IFJheS5BTlk7XG4gICAgdGhpcy5yZXN1bHQgPSBvcHRpb25zLnJlc3VsdCB8fCBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuICAgIHRoaXMuc2tpcEJhY2tmYWNlcyA9ICEhb3B0aW9ucy5za2lwQmFja2ZhY2VzO1xuICAgIHRoaXMuY29sbGlzaW9uTWFzayA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbk1hc2spICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uTWFzayA6IC0xO1xuICAgIHRoaXMuY29sbGlzaW9uR3JvdXAgPSB0eXBlb2Yob3B0aW9ucy5jb2xsaXNpb25Hcm91cCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jb2xsaXNpb25Hcm91cCA6IC0xO1xuICAgIGlmKG9wdGlvbnMuZnJvbSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmZyb20sIG9wdGlvbnMuZnJvbSk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMudG8pe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy50bywgb3B0aW9ucy50byk7XG4gICAgfVxuICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCl7fTtcbiAgICB0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG4gICAgdGhpcy5yZXN1bHQucmVzZXQoKTtcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oKTtcblxuICAgIHRoaXMuZ2V0QUFCQih0bXBBQUJCKTtcbiAgICB0bXBBcnJheS5sZW5ndGggPSAwO1xuICAgIHdvcmxkLmJyb2FkcGhhc2UuYWFiYlF1ZXJ5KHdvcmxkLCB0bXBBQUJCLCB0bXBBcnJheSk7XG4gICAgdGhpcy5pbnRlcnNlY3RCb2RpZXModG1wQXJyYXkpO1xuXG4gICAgcmV0dXJuIHRoaXMuaGFzSGl0O1xufTtcblxudmFyIHYxID0gdmVjMi5jcmVhdGUoKSxcbiAgICB2MiA9IHZlYzIuY3JlYXRlKCk7XG5cbnZhciBpbnRlcnNlY3RCb2R5X3dvcmxkUG9zaXRpb24gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFNob290IGEgcmF5IGF0IGEgYm9keSwgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC5cbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9keVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtSYXljYXN0UmVzdWx0fSBbcmVzdWx0XSBEZXByZWNhdGVkIC0gc2V0IHRoZSByZXN1bHQgcHJvcGVydHkgb2YgdGhlIFJheSBpbnN0ZWFkLlxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZHkgPSBmdW5jdGlvbiAoYm9keSwgcmVzdWx0KSB7XG5cbiAgICBpZihyZXN1bHQpe1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgfVxuICAgIHZhciBjaGVja0NvbGxpc2lvblJlc3BvbnNlID0gdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlO1xuXG4gICAgaWYoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhYm9keS5jb2xsaXNpb25SZXNwb25zZSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZigodGhpcy5jb2xsaXNpb25Hcm91cCAmIGJvZHkuY29sbGlzaW9uTWFzayk9PT0wIHx8IChib2R5LmNvbGxpc2lvbkdyb3VwICYgdGhpcy5jb2xsaXNpb25NYXNrKT09PTApe1xuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gfVxuXG4gICAgdmFyIHdvcmxkUG9zaXRpb24gPSBpbnRlcnNlY3RCb2R5X3dvcmxkUG9zaXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMCwgTiA9IGJvZHkuc2hhcGVzLmxlbmd0aDsgaSA8IE47IGkrKykge1xuICAgICAgICB2YXIgc2hhcGUgPSBib2R5LnNoYXBlc1tpXTtcblxuICAgICAgICBpZihjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFzaGFwZS5jb2xsaXNpb25SZXNwb25zZSl7XG4gICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHdvcmxkIGFuZ2xlIGFuZCBwb3NpdGlvbiBvZiB0aGUgc2hhcGVcbiAgICAgICAgdmVjMi5jb3B5KHdvcmxkUG9zaXRpb24sIGJvZHkuc2hhcGVPZmZzZXRzW2ldKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb3NpdGlvbiwgd29ybGRQb3NpdGlvbiwgYm9keS5hbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKHdvcmxkUG9zaXRpb24sIHdvcmxkUG9zaXRpb24sIGJvZHkucG9zaXRpb24pO1xuICAgICAgICB2YXIgd29ybGRBbmdsZSA9IGJvZHkuc2hhcGVBbmdsZXNbaV0gKyBib2R5LmFuZ2xlO1xuXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0U2hhcGUoXG4gICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgIHdvcmxkQW5nbGUsXG4gICAgICAgICAgICB3b3JsZFBvc2l0aW9uLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICApO1xuXG4gICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdEJvZGllc1xuICogQHBhcmFtIHtBcnJheX0gYm9kaWVzIEFuIGFycmF5IG9mIEJvZHkgb2JqZWN0cy5cbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZFxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZGllcyA9IGZ1bmN0aW9uIChib2RpZXMsIHJlc3VsdCkge1xuICAgIGlmKHJlc3VsdCl7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oKTtcbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBib2RpZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuX3Nob3VsZFN0b3AgJiYgaSA8IGw7IGkgKysgKSB7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0Qm9keShib2RpZXNbaV0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgX2RpcmVjdGlvbiB2ZWN0b3IuXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBfdXBkYXRlRGlyZWN0aW9uXG4gKi9cblJheS5wcm90b3R5cGUuX3VwZGF0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGQgPSB0aGlzLl9kaXJlY3Rpb247XG4gICAgdmVjMi5zdWIoZCwgdGhpcy50bywgdGhpcy5mcm9tKTsgLy8gdGhpcy50by52c3ViKHRoaXMuZnJvbSwgdGhpcy5fZGlyZWN0aW9uKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShkLCBkKTsgLy8gdGhpcy5fZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFNoYXBlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIGFuZ2xlLCBwb3NpdGlvbiwgYm9keSl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG5cblxuICAgIC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlXG4gICAgdmFyIGRpc3RhbmNlID0gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKGZyb20sIHRoaXMuX2RpcmVjdGlvbiwgcG9zaXRpb24pO1xuICAgIGlmICggZGlzdGFuY2UgPiBzaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cyApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZXRob2QgPSB0aGlzW3NoYXBlLnR5cGVdO1xuICAgIGlmKG1ldGhvZCl7XG4gICAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIHNoYXBlLCBhbmdsZSwgcG9zaXRpb24sIGJvZHkpO1xuICAgIH1cbn07XG5cbnZhciB2ZWN0b3IgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIG5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UG9pbnQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG52YXIgYSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgYiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgYyA9IHZlYzIuY3JlYXRlKCk7XG52YXIgZCA9IHZlYzIuY3JlYXRlKCk7XG5cbnZhciB0bXBSYXljYXN0UmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTtcbnZhciBpbnRlcnNlY3RSZWN0YW5nbGVfZGlyZWN0aW9uID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RSZWN0YW5nbGVfcmF5U3RhcnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFJlY3RhbmdsZV93b3JsZE5vcm1hbE1pbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX3dvcmxkTm9ybWFsTWF4ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RSZWN0YW5nbGVfaGl0UG9pbnRXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX2JveE1pbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UmVjdGFuZ2xlX2JveE1heCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RSZWN0YW5nbGVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcbiAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFJlY3RhbmdsZSA9IGZ1bmN0aW9uKHNoYXBlLCBhbmdsZSwgcG9zaXRpb24sIGJvZHkpe1xuICAgIHZhciB0bWluID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIHRtYXggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgdmFyIGRpcmVjdGlvbiA9IGludGVyc2VjdFJlY3RhbmdsZV9kaXJlY3Rpb247XG4gICAgdmFyIHJheVN0YXJ0ID0gaW50ZXJzZWN0UmVjdGFuZ2xlX3JheVN0YXJ0O1xuICAgIHZhciB3b3JsZE5vcm1hbE1pbiA9IGludGVyc2VjdFJlY3RhbmdsZV93b3JsZE5vcm1hbE1pbjtcbiAgICB2YXIgd29ybGROb3JtYWxNYXggPSBpbnRlcnNlY3RSZWN0YW5nbGVfd29ybGROb3JtYWxNYXg7XG4gICAgdmFyIGhpdFBvaW50V29ybGQgPSBpbnRlcnNlY3RSZWN0YW5nbGVfaGl0UG9pbnRXb3JsZDtcbiAgICB2YXIgYm94TWluID0gaW50ZXJzZWN0UmVjdGFuZ2xlX2JveE1pbjtcbiAgICB2YXIgYm94TWF4ID0gaW50ZXJzZWN0UmVjdGFuZ2xlX2JveE1heDtcblxuICAgIHZlYzIuc2V0KGJveE1pbiwgLXNoYXBlLndpZHRoICogMC41LCAtc2hhcGUuaGVpZ2h0ICogMC41KTtcbiAgICB2ZWMyLnNldChib3hNYXgsIHNoYXBlLndpZHRoICogMC41LCBzaGFwZS5oZWlnaHQgKiAwLjUpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZSByYXkgZGlyZWN0aW9uIGFuZCBzdGFydCB0byBsb2NhbCBzcGFjZVxuICAgIHZlYzIucm90YXRlKGRpcmVjdGlvbiwgdGhpcy5fZGlyZWN0aW9uLCAtYW5nbGUpO1xuICAgIGJvZHkudG9Mb2NhbEZyYW1lKHJheVN0YXJ0LCB0aGlzLmZyb20pO1xuXG4gICAgaWYgKGRpcmVjdGlvblswXSAhPT0gMCkge1xuICAgICAgICB2YXIgdHgxID0gKGJveE1pblswXSAtIHJheVN0YXJ0WzBdKSAvIGRpcmVjdGlvblswXTtcbiAgICAgICAgdmFyIHR4MiA9IChib3hNYXhbMF0gLSByYXlTdGFydFswXSkgLyBkaXJlY3Rpb25bMF07XG5cbiAgICAgICAgdmFyIHRtaW5PbGQgPSB0bWluO1xuICAgICAgICB0bWluID0gTWF0aC5tYXgodG1pbiwgTWF0aC5taW4odHgxLCB0eDIpKTtcbiAgICAgICAgaWYodG1pbiAhPT0gdG1pbk9sZCl7XG4gICAgICAgICAgICB2ZWMyLnNldCh3b3JsZE5vcm1hbE1pbiwgdHgxID4gdHgyID8gMSA6IC0xLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bWF4T2xkID0gdG1heDtcbiAgICAgICAgdG1heCA9IE1hdGgubWluKHRtYXgsIE1hdGgubWF4KHR4MSwgdHgyKSk7XG4gICAgICAgIGlmKHRtYXggIT09IHRtYXhPbGQpe1xuICAgICAgICAgICAgdmVjMi5zZXQod29ybGROb3JtYWxNYXgsIHR4MSA8IHR4MiA/IDEgOiAtMSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uWzFdICE9PSAwKSB7XG4gICAgICAgIHZhciB0eTEgPSAoYm94TWluWzFdIC0gcmF5U3RhcnRbMV0pIC8gZGlyZWN0aW9uWzFdO1xuICAgICAgICB2YXIgdHkyID0gKGJveE1heFsxXSAtIHJheVN0YXJ0WzFdKSAvIGRpcmVjdGlvblsxXTtcblxuICAgICAgICB2YXIgdG1pbk9sZCA9IHRtaW47XG4gICAgICAgIHRtaW4gPSBNYXRoLm1heCh0bWluLCBNYXRoLm1pbih0eTEsIHR5MikpO1xuICAgICAgICBpZih0bWluICE9PSB0bWluT2xkKXtcbiAgICAgICAgICAgIHZlYzIuc2V0KHdvcmxkTm9ybWFsTWluLCAwLCB0eTEgPiB0eTIgPyAxIDogLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtYXhPbGQgPSB0bWF4O1xuICAgICAgICB0bWF4ID0gTWF0aC5taW4odG1heCwgTWF0aC5tYXgodHkxLCB0eTIpKTtcbiAgICAgICAgaWYodG1heCAhPT0gdG1heE9sZCl7XG4gICAgICAgICAgICB2ZWMyLnNldCh3b3JsZE5vcm1hbE1heCwgMCwgdHkxIDwgdHkyID8gMSA6IC0xKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRtYXggPj0gdG1pbil7XG4gICAgICAgIC8vIEhpdCBwb2ludFxuICAgICAgICB2ZWMyLnNldChcbiAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICByYXlTdGFydFswXSArIGRpcmVjdGlvblswXSAqIHRtaW4sXG4gICAgICAgICAgICByYXlTdGFydFsxXSArIGRpcmVjdGlvblsxXSAqIHRtaW5cbiAgICAgICAgKTtcblxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbE1pbiwgd29ybGROb3JtYWxNaW4sIGFuZ2xlKTtcblxuICAgICAgICBib2R5LnRvV29ybGRGcmFtZShoaXRQb2ludFdvcmxkLCBoaXRQb2ludFdvcmxkKTtcblxuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbih3b3JsZE5vcm1hbE1pbiwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIC0xKTtcbiAgICAgICAgaWYodGhpcy5fc2hvdWxkU3RvcCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbE1heCwgd29ybGROb3JtYWxNYXgsIGFuZ2xlKTtcblxuICAgICAgICAvLyBIaXQgcG9pbnRcbiAgICAgICAgdmVjMi5zZXQoXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgcmF5U3RhcnRbMF0gKyBkaXJlY3Rpb25bMF0gKiB0bWF4LFxuICAgICAgICAgICAgcmF5U3RhcnRbMV0gKyBkaXJlY3Rpb25bMV0gKiB0bWF4XG4gICAgICAgICk7XG4gICAgICAgIGJvZHkudG9Xb3JsZEZyYW1lKGhpdFBvaW50V29ybGQsIGhpdFBvaW50V29ybGQpO1xuXG4gICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsTWF4LCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgLTEpO1xuICAgIH1cbn07XG5SYXkucHJvdG90eXBlW1NoYXBlLlJFQ1RBTkdMRV0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdFJlY3RhbmdsZTtcblxudmFyIGludGVyc2VjdFBsYW5lX3BsYW5lUG9pbnRUb0Zyb20gPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBsYW5lX2Rpcl9zY2FsZWRfd2l0aF90ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RQbGFuZV9oaXRQb2ludFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RQbGFuZV93b3JsZE5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UGxhbmVfbGVuID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFBsYW5lXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXG4gKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RQbGFuZSA9IGZ1bmN0aW9uKHNoYXBlLCBhbmdsZSwgcG9zaXRpb24sIGJvZHkpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHZhciB0byA9IHRoaXMudG87XG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbjtcblxuICAgIHZhciBwbGFuZVBvaW50VG9Gcm9tID0gaW50ZXJzZWN0UGxhbmVfcGxhbmVQb2ludFRvRnJvbTtcbiAgICB2YXIgZGlyX3NjYWxlZF93aXRoX3QgPSBpbnRlcnNlY3RQbGFuZV9kaXJfc2NhbGVkX3dpdGhfdDtcbiAgICB2YXIgaGl0UG9pbnRXb3JsZCA9IGludGVyc2VjdFBsYW5lX2hpdFBvaW50V29ybGQ7XG4gICAgdmFyIHdvcmxkTm9ybWFsID0gaW50ZXJzZWN0UGxhbmVfd29ybGROb3JtYWw7XG4gICAgdmFyIGxlbiA9IGludGVyc2VjdFBsYW5lX2xlbjtcblxuICAgIC8vIEdldCBwbGFuZSBub3JtYWxcbiAgICB2ZWMyLnNldCh3b3JsZE5vcm1hbCwgMCwgMSk7XG4gICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsLCBhbmdsZSk7XG5cbiAgICB2ZWMyLnN1YihsZW4sIGZyb20sIHBvc2l0aW9uKTsgLy9mcm9tLnZzdWIocG9zaXRpb24sIGxlbik7XG4gICAgdmFyIHBsYW5lVG9Gcm9tID0gdmVjMi5kb3QobGVuLCB3b3JsZE5vcm1hbCk7IC8vIGxlbi5kb3Qod29ybGROb3JtYWwpO1xuICAgIHZlYzIuc3ViKGxlbiwgdG8sIHBvc2l0aW9uKTsgLy8gdG8udnN1Yihwb3NpdGlvbiwgbGVuKTtcbiAgICB2YXIgcGxhbmVUb1RvID0gdmVjMi5kb3QobGVuLCB3b3JsZE5vcm1hbCk7IC8vIGxlbi5kb3Qod29ybGROb3JtYWwpO1xuXG4gICAgaWYocGxhbmVUb0Zyb20gKiBwbGFuZVRvVG8gPiAwKXtcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBhcmUgb24gdGhlIHNhbWUgc2lkZSBvZiB0aGUgcGxhbmUuLi4gYmFpbCBvdXRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKHZlYzIuZGlzdGFuY2UoZnJvbSwgdG8pIC8qIGZyb20uZGlzdGFuY2VUbyh0bykgKi8gPCBwbGFuZVRvRnJvbSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbl9kb3RfZGlyID0gdmVjMi5kb3Qod29ybGROb3JtYWwsIGRpcmVjdGlvbik7IC8vIHdvcmxkTm9ybWFsLmRvdChkaXJlY3Rpb24pO1xuXG4gICAgLy8gaWYgKE1hdGguYWJzKG5fZG90X2RpcikgPCB0aGlzLnByZWNpc2lvbikge1xuICAgIC8vICAgICAvLyBObyBpbnRlcnNlY3Rpb25cbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vIH1cblxuICAgIHZlYzIuc3ViKHBsYW5lUG9pbnRUb0Zyb20sIGZyb20sIHBvc2l0aW9uKTsgLy8gZnJvbS52c3ViKHBvc2l0aW9uLCBwbGFuZVBvaW50VG9Gcm9tKTtcbiAgICB2YXIgdCA9IC12ZWMyLmRvdCh3b3JsZE5vcm1hbCwgcGxhbmVQb2ludFRvRnJvbSkgLyBuX2RvdF9kaXI7IC8vIC0gd29ybGROb3JtYWwuZG90KHBsYW5lUG9pbnRUb0Zyb20pIC8gbl9kb3RfZGlyO1xuICAgIHZlYzIuc2NhbGUoZGlyX3NjYWxlZF93aXRoX3QsIGRpcmVjdGlvbiwgdCk7IC8vIGRpcmVjdGlvbi5zY2FsZSh0LCBkaXJfc2NhbGVkX3dpdGhfdCk7XG4gICAgdmVjMi5hZGQoaGl0UG9pbnRXb3JsZCwgZnJvbSwgZGlyX3NjYWxlZF93aXRoX3QpOyAvLyBmcm9tLnZhZGQoZGlyX3NjYWxlZF93aXRoX3QsIGhpdFBvaW50V29ybGQpO1xuXG4gICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24od29ybGROb3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCAtMSk7XG59O1xuUmF5LnByb3RvdHlwZVtTaGFwZS5QTEFORV0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdFBsYW5lO1xuXG52YXIgUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RDaXJjbGUgPSBmdW5jdGlvbihzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbSxcbiAgICAgICAgdG8gPSB0aGlzLnRvLFxuICAgICAgICByID0gc2hhcGUucmFkaXVzO1xuXG4gICAgdmFyIGEgPSBNYXRoLnBvdyh0b1swXSAtIGZyb21bMF0sIDIpICsgTWF0aC5wb3codG9bMV0gLSBmcm9tWzFdLCAyKTtcbiAgICB2YXIgYiA9IDIgKiAoKHRvWzBdIC0gZnJvbVswXSkgKiAoZnJvbVswXSAtIHBvc2l0aW9uWzBdKSArICh0b1sxXSAtIGZyb21bMV0pICogKGZyb21bMV0gLSBwb3NpdGlvblsxXSkpO1xuICAgIHZhciBjID0gTWF0aC5wb3coZnJvbVswXSAtIHBvc2l0aW9uWzBdLCAyKSArIE1hdGgucG93KGZyb21bMV0gLSBwb3NpdGlvblsxXSwgMikgLSBNYXRoLnBvdyhyLCAyKTtcblxuICAgIHZhciBkZWx0YSA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGEgKiBjO1xuXG4gICAgdmFyIGludGVyc2VjdGlvblBvaW50ID0gUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludDtcbiAgICB2YXIgbm9ybWFsID0gUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWw7XG5cbiAgICBpZihkZWx0YSA8IDApe1xuICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb25cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgfSBlbHNlIGlmKGRlbHRhID09PSAwKXtcbiAgICAgICAgLy8gc2luZ2xlIGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgICB2ZWMyLmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkZWx0YSk7IC8vIGZyb20ubGVycCh0bywgZGVsdGEsIGludGVyc2VjdGlvblBvaW50KTtcblxuICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7IC8vIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpOyAvL25vcm1hbC5ub3JtYWxpemUoKTtcblxuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBzaGFwZSwgYm9keSwgLTEpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGQxID0gKC0gYiAtIE1hdGguc3FydChkZWx0YSkpIC8gKDIgKiBhKTtcbiAgICAgICAgdmFyIGQyID0gKC0gYiArIE1hdGguc3FydChkZWx0YSkpIC8gKDIgKiBhKTtcblxuICAgICAgICB2ZWMyLmxlcnAoaW50ZXJzZWN0aW9uUG9pbnQsIGZyb20sIHRvLCBkMSk7IC8vIGZyb20ubGVycCh0bywgZDEsIGludGVyc2VjdGlvblBvaW50KTtcblxuICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7IC8vIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpOyAvL25vcm1hbC5ub3JtYWxpemUoKTtcblxuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBzaGFwZSwgYm9keSwgLTEpO1xuXG4gICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzIubGVycChpbnRlcnNlY3Rpb25Qb2ludCwgZnJvbSwgdG8sIGQyKTsgLy8gZnJvbS5sZXJwKHRvLCBkMiwgaW50ZXJzZWN0aW9uUG9pbnQpO1xuXG4gICAgICAgIHZlYzIuc3ViKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHBvc2l0aW9uKTsgLy8gaW50ZXJzZWN0aW9uUG9pbnQudnN1Yihwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7IC8vbm9ybWFsLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHNoYXBlLCBib2R5LCAtMSk7XG4gICAgfVxufTtcblJheS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0Q2lyY2xlO1xuXG4vKipcbiAqIEdldCB0aGUgQUFCQiBvZiB0aGUgcmF5LlxuICogQG1ldGhvZCBnZXRBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKi9cblJheS5wcm90b3R5cGUuZ2V0QUFCQiA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICByZXN1bHQubG93ZXJCb3VuZFswXSA9IE1hdGgubWluKHRvWzBdLCBmcm9tWzBdKTtcbiAgICByZXN1bHQubG93ZXJCb3VuZFsxXSA9IE1hdGgubWluKHRvWzFdLCBmcm9tWzFdKTtcbiAgICByZXN1bHQudXBwZXJCb3VuZFswXSA9IE1hdGgubWF4KHRvWzBdLCBmcm9tWzBdKTtcbiAgICByZXN1bHQudXBwZXJCb3VuZFsxXSA9IE1hdGgubWF4KHRvWzFdLCBmcm9tWzFdKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCByZXBvcnRJbnRlcnNlY3Rpb25cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHthcnJheX0gbm9ybWFsXG4gKiBAcGFyYW0gIHthcnJheX0gaGl0UG9pbnRXb3JsZFxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBpbnRlcnNlY3Rpb25zIHNob3VsZCBjb250aW51ZVxuICovXG5SYXkucHJvdG90eXBlLnJlcG9ydEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKG5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIGhpdEZhY2VJbmRleCl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgZGlzdGFuY2UgPSB2ZWMyLmRpc3RhbmNlKGZyb20sIGhpdFBvaW50V29ybGQpOyAvLyBmcm9tLmRpc3RhbmNlVG8oaGl0UG9pbnRXb3JsZCk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0O1xuXG4gICAgLy8gU2tpcCBiYWNrIGZhY2VzP1xuICAgIGlmKHRoaXMuc2tpcEJhY2tmYWNlcyAmJiAvKiBub3JtYWwuZG90KHRoaXMuX2RpcmVjdGlvbikgKi8gdmVjMi5kb3Qobm9ybWFsLCB0aGlzLl9kaXJlY3Rpb24pID4gMCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXN1bHQuaGl0RmFjZUluZGV4ID0gdHlwZW9mKGhpdEZhY2VJbmRleCkgIT09ICd1bmRlZmluZWQnID8gaGl0RmFjZUluZGV4IDogLTE7XG5cbiAgICBzd2l0Y2godGhpcy5tb2RlKXtcbiAgICBjYXNlIFJheS5BTEw6XG4gICAgICAgIHRoaXMuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIG5vcm1hbCxcbiAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICApO1xuICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgUmF5LkNMT1NFU1Q6XG5cbiAgICAgICAgLy8gU3RvcmUgaWYgY2xvc2VyIHRoYW4gY3VycmVudCBjbG9zZXN0XG4gICAgICAgIGlmKGRpc3RhbmNlIDwgcmVzdWx0LmRpc3RhbmNlIHx8ICFyZXN1bHQuaGFzSGl0KXtcbiAgICAgICAgICAgIHRoaXMuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdC5oYXNIaXQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIG5vcm1hbCxcbiAgICAgICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFJheS5BTlk6XG5cbiAgICAgICAgLy8gUmVwb3J0IGFuZCBzdG9wLlxuICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5oYXNIaXQgPSB0cnVlO1xuICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIGRpc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdC5fc2hvdWxkU3RvcCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbnZhciB2MCA9IHZlYzIuY3JlYXRlKCksXG4gICAgaW50ZXJzZWN0ID0gdmVjMi5jcmVhdGUoKTtcbmZ1bmN0aW9uIGRpc3RhbmNlRnJvbUludGVyc2VjdGlvbihmcm9tLCBkaXJlY3Rpb24sIHBvc2l0aW9uKSB7XG5cbiAgICAvLyB2MCBpcyB2ZWN0b3IgZnJvbSBmcm9tIHRvIHBvc2l0aW9uXG4gICAgdmVjMi5zdWIodjAsIHBvc2l0aW9uLCBmcm9tKTsgLy8gcG9zaXRpb24udnN1Yihmcm9tLHYwKTtcbiAgICB2YXIgZG90ID0gdmVjMi5kb3QodjAsIGRpcmVjdGlvbik7IC8vIHYwLmRvdChkaXJlY3Rpb24pO1xuXG4gICAgLy8gaW50ZXJzZWN0ID0gZGlyZWN0aW9uKmRvdCArIGZyb21cbiAgICB2ZWMyLnNjYWxlKGludGVyc2VjdCwgZGlyZWN0aW9uLCBkb3QpOyAvL2RpcmVjdGlvbi5tdWx0KGRvdCxpbnRlcnNlY3QpO1xuICAgIHZlYzIuYWRkKGludGVyc2VjdCwgaW50ZXJzZWN0LCBmcm9tKTsgLy8gaW50ZXJzZWN0LnZhZGQoZnJvbSwgaW50ZXJzZWN0KTtcblxuICAgIHZhciBkaXN0YW5jZSA9IHZlYzIuZGlzdGFuY2UocG9zaXRpb24sIGludGVyc2VjdCk7IC8vIHBvc2l0aW9uLmRpc3RhbmNlVG8oaW50ZXJzZWN0KTtcblxuICAgIHJldHVybiBkaXN0YW5jZTtcbn1cblxuIiwidmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXljYXN0UmVzdWx0O1xuXG4vKipcbiAqIFN0b3JhZ2UgZm9yIFJheSBjYXN0aW5nIGRhdGEuXG4gKiBAY2xhc3MgUmF5Y2FzdFJlc3VsdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJheWNhc3RSZXN1bHQoKXtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHthcnJheX0gcmF5RnJvbVdvcmxkXG5cdCAqL1xuXHR0aGlzLnJheUZyb21Xb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7YXJyYXl9IHJheVRvV29ybGRcblx0ICovXG5cdHRoaXMucmF5VG9Xb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7YXJyYXl9IGhpdE5vcm1hbFdvcmxkXG5cdCAqL1xuXHR0aGlzLmhpdE5vcm1hbFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHthcnJheX0gaGl0UG9pbnRXb3JsZFxuXHQgKi9cblx0dGhpcy5oaXRQb2ludFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBoYXNIaXRcblx0ICovXG5cdHRoaXMuaGFzSGl0ID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFRoZSBoaXQgc2hhcGUsIG9yIG51bGwuXG5cdCAqIEBwcm9wZXJ0eSB7U2hhcGV9IHNoYXBlXG5cdCAqL1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblxuXHQvKipcblx0ICogVGhlIGhpdCBib2R5LCBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlcblx0ICovXG5cdHRoaXMuYm9keSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBpbmRleCBvZiB0aGUgaGl0IHRyaWFuZ2xlLCBpZiB0aGUgaGl0IHNoYXBlIHdhcyBhIHRyaW1lc2guXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaXRGYWNlSW5kZXhcblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuaGl0RmFjZUluZGV4ID0gLTE7XG5cblx0LyoqXG5cdCAqIERpc3RhbmNlIHRvIHRoZSBoaXQuIFdpbGwgYmUgc2V0IHRvIC0xIGlmIHRoZXJlIHdhcyBubyBoaXQuXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaXN0YW5jZVxuXHQgKiBAZGVmYXVsdCAtMVxuXHQgKi9cblx0dGhpcy5kaXN0YW5jZSA9IC0xO1xuXG5cdC8qKlxuXHQgKiBJZiB0aGUgcmF5IHNob3VsZCBzdG9wIHRyYXZlcnNpbmcgdGhlIGJvZGllcy5cblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtCb29sZWFufSBfc2hvdWxkU3RvcFxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKi9cblx0dGhpcy5fc2hvdWxkU3RvcCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlc2V0IGFsbCByZXN1bHQgZGF0YS5cbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cdHZlYzIuc2V0KHRoaXMucmF5RnJvbVdvcmxkLCAwLCAwKTtcblx0dmVjMi5zZXQodGhpcy5yYXlUb1dvcmxkLCAwLCAwKTtcblx0dmVjMi5zZXQodGhpcy5oaXROb3JtYWxXb3JsZCwgMCwgMCk7XG5cdHZlYzIuc2V0KHRoaXMuaGl0UG9pbnRXb3JsZCwgMCwgMCk7XG5cdHRoaXMuaGFzSGl0ID0gZmFsc2U7XG5cdHRoaXMuc2hhcGUgPSBudWxsO1xuXHR0aGlzLmJvZHkgPSBudWxsO1xuXHR0aGlzLmhpdEZhY2VJbmRleCA9IC0xO1xuXHR0aGlzLmRpc3RhbmNlID0gLTE7XG5cdHRoaXMuX3Nob3VsZFN0b3AgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBhYm9ydFxuICovXG5SYXljYXN0UmVzdWx0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuX3Nob3VsZFN0b3AgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHthcnJheX0gcmF5RnJvbVdvcmxkXG4gKiBAcGFyYW0ge2FycmF5fSByYXlUb1dvcmxkXG4gKiBAcGFyYW0ge2FycmF5fSBoaXROb3JtYWxXb3JsZFxuICogQHBhcmFtIHthcnJheX0gaGl0UG9pbnRXb3JsZFxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKFxuXHRyYXlGcm9tV29ybGQsXG5cdHJheVRvV29ybGQsXG5cdGhpdE5vcm1hbFdvcmxkLFxuXHRoaXRQb2ludFdvcmxkLFxuXHRzaGFwZSxcblx0Ym9keSxcblx0ZGlzdGFuY2Vcbil7XG5cdHZlYzIuY29weSh0aGlzLnJheUZyb21Xb3JsZCwgcmF5RnJvbVdvcmxkKTtcblx0dmVjMi5jb3B5KHRoaXMucmF5VG9Xb3JsZCwgcmF5VG9Xb3JsZCk7XG5cdHZlYzIuY29weSh0aGlzLmhpdE5vcm1hbFdvcmxkLCBoaXROb3JtYWxXb3JsZCk7XG5cdHZlYzIuY29weSh0aGlzLmhpdFBvaW50V29ybGQsIGhpdFBvaW50V29ybGQpO1xuXHR0aGlzLnNoYXBlID0gc2hhcGU7XG5cdHRoaXMuYm9keSA9IGJvZHk7XG5cdHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbn07IiwidmFyIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIEJyb2FkcGhhc2UgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNBUEJyb2FkcGhhc2U7XG5cbi8qKlxuICogU3dlZXAgYW5kIHBydW5lIGJyb2FkcGhhc2UgYWxvbmcgb25lIGF4aXMuXG4gKlxuICogQGNsYXNzIFNBUEJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICovXG5mdW5jdGlvbiBTQVBCcm9hZHBoYXNlKCl7XG4gICAgQnJvYWRwaGFzZS5jYWxsKHRoaXMsQnJvYWRwaGFzZS5TQVApO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBib2RpZXMgY3VycmVudGx5IGluIHRoZSBicm9hZHBoYXNlLlxuICAgICAqIEBwcm9wZXJ0eSBheGlzTGlzdFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmF4aXNMaXN0ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXhpcyB0byBzb3J0IGFsb25nLiAwIG1lYW5zIHgtYXhpcyBhbmQgMSB5LWF4aXMuIElmIHlvdXIgYm9kaWVzIGFyZSBtb3JlIHNwcmVhZCBvdXQgb3ZlciB0aGUgWCBheGlzLCBzZXQgYXhpc0luZGV4IHRvIDAsIGFuZCB5b3Ugd2lsbCBnYWluIHNvbWUgcGVyZm9ybWFuY2UuXG4gICAgICogQHByb3BlcnR5IGF4aXNJbmRleFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5heGlzSW5kZXggPSAwO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMuX2FkZEJvZHlIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHRoYXQuYXhpc0xpc3QucHVzaChlLmJvZHkpO1xuICAgIH07XG5cbiAgICB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSBsaXN0XG4gICAgICAgIHZhciBpZHggPSB0aGF0LmF4aXNMaXN0LmluZGV4T2YoZS5ib2R5KTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICB0aGF0LmF4aXNMaXN0LnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTQVBCcm9hZHBoYXNlO1xuXG4vKipcbiAqIENoYW5nZSB0aGUgd29ybGRcbiAqIEBtZXRob2Qgc2V0V29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xuICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxuICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDtcblxuICAgIC8vIEFkZCBhbGwgYm9kaWVzIGZyb20gdGhlIG5ldyB3b3JsZFxuICAgIFV0aWxzLmFwcGVuZEFycmF5KHRoaXMuYXhpc0xpc3QsIHdvcmxkLmJvZGllcyk7XG5cbiAgICAvLyBSZW1vdmUgb2xkIGhhbmRsZXJzLCBpZiBhbnlcbiAgICB3b3JsZFxuICAgICAgICAub2ZmKFwiYWRkQm9keVwiLHRoaXMuX2FkZEJvZHlIYW5kbGVyKVxuICAgICAgICAub2ZmKFwicmVtb3ZlQm9keVwiLHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTtcblxuICAgIC8vIEFkZCBoYW5kbGVycyB0byB1cGRhdGUgdGhlIGxpc3Qgb2YgYm9kaWVzLlxuICAgIHdvcmxkLm9uKFwiYWRkQm9keVwiLHRoaXMuX2FkZEJvZHlIYW5kbGVyKS5vbihcInJlbW92ZUJvZHlcIix0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7XG5cbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG59O1xuXG4vKipcbiAqIFNvcnRzIGJvZGllcyBhbG9uZyBhbiBheGlzLlxuICogQG1ldGhvZCBzb3J0QXhpc0xpc3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzSW5kZXhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLnNvcnRBeGlzTGlzdCA9IGZ1bmN0aW9uKGEsIGF4aXNJbmRleCl7XG4gICAgYXhpc0luZGV4ID0gYXhpc0luZGV4fDA7XG4gICAgZm9yKHZhciBpPTEsbD1hLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgdmFyIHYgPSBhW2ldO1xuICAgICAgICBmb3IodmFyIGo9aSAtIDE7aj49MDtqLS0pIHtcbiAgICAgICAgICAgIGlmKGFbal0uYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0gPD0gdi5hYWJiLmxvd2VyQm91bmRbYXhpc0luZGV4XSl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhW2orMV0gPSBhW2pdO1xuICAgICAgICB9XG4gICAgICAgIGFbaisxXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcblxuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuc29ydExpc3QgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib2RpZXMgPSB0aGlzLmF4aXNMaXN0LFxuICAgIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuXG4gICAgLy8gU29ydCB0aGUgbGlzdHNcbiAgICBTQVBCcm9hZHBoYXNlLnNvcnRBeGlzTGlzdChib2RpZXMsIGF4aXNJbmRleCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29sbGlkaW5nIHBhaXJzXG4gKiBAbWV0aG9kIGdldENvbGxpc2lvblBhaXJzXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCxcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHQsXG4gICAgICAgIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IDA7XG5cbiAgICAvLyBVcGRhdGUgYWxsIEFBQkJzIGlmIG5lZWRlZFxuICAgIHZhciBsID0gYm9kaWVzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tsXTtcbiAgICAgICAgaWYoYi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgYi51cGRhdGVBQUJCKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb3J0IHRoZSBsaXN0c1xuICAgIHRoaXMuc29ydExpc3QoKTtcblxuICAgIC8vIExvb2sgdGhyb3VnaCB0aGUgWCBsaXN0XG4gICAgZm9yKHZhciBpPTAsIE49Ym9kaWVzLmxlbmd0aHwwOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIGZvcih2YXIgaj1pKzE7IGo8TjsgaisrKXtcbiAgICAgICAgICAgIHZhciBiaiA9IGJvZGllc1tqXTtcblxuICAgICAgICAgICAgLy8gQm91bmRzIG92ZXJsYXA/XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSAoYmouYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0gPD0gYmkuYWFiYi51cHBlckJvdW5kW2F4aXNJbmRleF0pO1xuICAgICAgICAgICAgaWYoIW92ZXJsYXBzKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoQnJvYWRwaGFzZS5jYW5Db2xsaWRlKGJpLGJqKSAmJiB0aGlzLmJvdW5kaW5nVm9sdW1lQ2hlY2soYmksYmopKXtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaSxiaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxuICogQG1ldGhvZCBhYWJiUXVlcnlcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24od29ybGQsIGFhYmIsIHJlc3VsdCl7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gICAgdGhpcy5zb3J0TGlzdCgpO1xuXG4gICAgdmFyIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuICAgIHZhciBheGlzID0gJ3gnO1xuICAgIGlmKGF4aXNJbmRleCA9PT0gMSl7IGF4aXMgPSAneSc7IH1cbiAgICBpZihheGlzSW5kZXggPT09IDIpeyBheGlzID0gJ3onOyB9XG5cbiAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xuICAgIHZhciBsb3dlciA9IGFhYmIubG93ZXJCb3VuZFtheGlzXTtcbiAgICB2YXIgdXBwZXIgPSBhYWJiLnVwcGVyQm91bmRbYXhpc107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGF4aXNMaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBheGlzTGlzdFtpXTtcblxuICAgICAgICBpZihiLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiLnVwZGF0ZUFBQkIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGIuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gQ29uc3RyYWludDtcblxudmFyIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKTtcblxuLyoqXG4gKiBCYXNlIGNvbnN0cmFpbnQgY2xhc3MuXG4gKlxuICogQGNsYXNzIENvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkPXRydWVdXG4gKi9cbmZ1bmN0aW9uIENvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB0eXBlLCBvcHRpb25zKXtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIGNvbnN0cmFpbnQuIE1heSBiZSBvbmUgb2YgQ29uc3RyYWludC5ESVNUQU5DRSwgQ29uc3RyYWludC5HRUFSLCBDb25zdHJhaW50LkxPQ0ssIENvbnN0cmFpbnQuUFJJU01BVElDIG9yIENvbnN0cmFpbnQuUkVWT0xVVEUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICBjb2xsaWRlQ29ubmVjdGVkIDogdHJ1ZSxcbiAgICAgICAgd2FrZVVwQm9kaWVzIDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEVxdWF0aW9ucyB0byBiZSBzb2x2ZWQgaW4gdGhpcyBjb25zdHJhaW50XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbnN0cmFpbnQuXG4gICAgICogQHByb3BlcnR5IGJvZHlBXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuXG4gICAgLyoqXG4gICAgICogU2Vjb25kIGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgY29uc3RyYWludC5cbiAgICAgKiBAcHJvcGVydHkgYm9keUJcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgY29ubmVjdGVkIGJvZGllcyB0byBjb2xsaWRlLlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaWRlQ29ubmVjdGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9IG9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZDtcblxuICAgIC8vIFdha2UgdXAgYm9kaWVzIHdoZW4gY29ubmVjdGVkXG4gICAgaWYob3B0aW9ucy53YWtlVXBCb2RpZXMpe1xuICAgICAgICBpZihib2R5QSl7XG4gICAgICAgICAgICBib2R5QS53YWtlVXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZihib2R5Qil7XG4gICAgICAgICAgICBib2R5Qi53YWtlVXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBjb25zdHJhaW50IHBhcmFtZXRlcnMgYmVmb3JlIHNvbHZlLlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXRob2QgdXBkYXRlKCkgbm90IGltcGxtZW1lbnRlZCBpbiB0aGlzIENvbnN0cmFpbnQgc3ViY2xhc3MhXCIpO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gRElTVEFOQ0VcbiAqL1xuQ29uc3RyYWludC5ESVNUQU5DRSA9IDE7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IEdFQVJcbiAqL1xuQ29uc3RyYWludC5HRUFSID0gMjtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gTE9DS1xuICovXG5Db25zdHJhaW50LkxPQ0sgPSAzO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBQUklTTUFUSUNcbiAqL1xuQ29uc3RyYWludC5QUklTTUFUSUMgPSA0O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSRVZPTFVURVxuICovXG5Db25zdHJhaW50LlJFVk9MVVRFID0gNTtcblxuLyoqXG4gKiBTZXQgc3RpZmZuZXNzIGZvciB0aGlzIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIHNldFN0aWZmbmVzc1xuICogQHBhcmFtIHtOdW1iZXJ9IHN0aWZmbmVzc1xuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS5zZXRTdGlmZm5lc3MgPSBmdW5jdGlvbihzdGlmZm5lc3Mpe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gZXFzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xuICAgICAgICBlcS5zdGlmZm5lc3MgPSBzdGlmZm5lc3M7XG4gICAgICAgIGVxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCByZWxheGF0aW9uIGZvciB0aGlzIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIHNldFJlbGF4YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByZWxheGF0aW9uXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnNldFJlbGF4YXRpb24gPSBmdW5jdGlvbihyZWxheGF0aW9uKXtcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGVxcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tpXTtcbiAgICAgICAgZXEucmVsYXhhdGlvbiA9IHJlbGF4YXRpb247XG4gICAgICAgIGVxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG59O1xuIiwidmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKVxuLCAgIEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0VxdWF0aW9uJylcbiwgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcbiwgICBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VDb25zdHJhaW50O1xuXG4vKipcbiAqIENvbnN0cmFpbnQgdGhhdCB0cmllcyB0byBrZWVwIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBib2RpZXMgY29uc3RhbnQuXG4gKlxuICogQGNsYXNzIERpc3RhbmNlQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGlzdGFuY2VdIFRoZSBkaXN0YW5jZSB0byBrZWVwIGJldHdlZW4gdGhlIGFuY2hvciBwb2ludHMuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvZGllcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gVGhlIGFuY2hvciBwb2ludCBmb3IgYm9keUEsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QSBmcmFtZS4gRGVmYXVsdHMgdG8gWzAsMF0uXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEFuY2hvckJdIFRoZSBhbmNob3IgcG9pbnQgZm9yIGJvZHlCLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUIgZnJhbWUuIERlZmF1bHRzIHRvIFswLDBdLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1heEZvcmNlPU51bWJlci5NQVhfVkFMVUVdIE1heGltdW0gZm9yY2UgdG8gYXBwbHkuXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBJZiBkaXN0YW5jZSBpcyBub3QgZ2l2ZW4gYXMgYW4gb3B0aW9uLCB0aGVuIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvZGllcyBpcyB1c2VkLlxuICogICAgIC8vIEluIHRoaXMgZXhhbXBsZSwgdGhlIGJvZGllcyB3aWxsIGJlIGNvbnN0cmFpbmVkIHRvIGhhdmUgYSBkaXN0YW5jZSBvZiAyIGJldHdlZW4gdGhlaXIgY2VudGVycy5cbiAqICAgICB2YXIgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbLTEsIDBdIH0pO1xuICogICAgIHZhciBib2R5QiA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFsxLCAwXSB9KTtcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IERpc3RhbmNlQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcbiAqICAgICAgICAgZGlzdGFuY2U6IDEsICAgICAgICAgIC8vIERpc3RhbmNlIHRvIGtlZXAgYmV0d2VlbiB0aGUgcG9pbnRzXG4gKiAgICAgICAgIGxvY2FsQW5jaG9yQTogWzEsIDBdLCAvLyBQb2ludCBvbiBib2R5QVxuICogICAgICAgICBsb2NhbEFuY2hvckI6IFstMSwgMF0gLy8gUG9pbnQgb24gYm9keUJcbiAqICAgICB9KTtcbiAqL1xuZnVuY3Rpb24gRGlzdGFuY2VDb25zdHJhaW50KGJvZHlBLGJvZHlCLG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcbiAgICAgICAgbG9jYWxBbmNob3JBOlswLDBdLFxuICAgICAgICBsb2NhbEFuY2hvckI6WzAsMF1cbiAgICB9KTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuRElTVEFOQ0Usb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCBhbmNob3IgaW4gYm9keSBBLlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSB2ZWMyLmZyb21WYWx1ZXMob3B0aW9ucy5sb2NhbEFuY2hvckFbMF0sIG9wdGlvbnMubG9jYWxBbmNob3JBWzFdKTtcblxuICAgIC8qKlxuICAgICAqIExvY2FsIGFuY2hvciBpbiBib2R5IEIuXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLmxvY2FsQW5jaG9yQlswXSwgb3B0aW9ucy5sb2NhbEFuY2hvckJbMV0pO1xuXG4gICAgdmFyIGxvY2FsQW5jaG9yQSA9IHRoaXMubG9jYWxBbmNob3JBO1xuICAgIHZhciBsb2NhbEFuY2hvckIgPSB0aGlzLmxvY2FsQW5jaG9yQjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSB0byBrZWVwLlxuICAgICAqIEBwcm9wZXJ0eSBkaXN0YW5jZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kaXN0YW5jZSA9IDA7XG5cbiAgICBpZih0eXBlb2Yob3B0aW9ucy5kaXN0YW5jZSkgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIHRoZSBjdXJyZW50IHdvcmxkIGRpc3RhbmNlIGJldHdlZW4gdGhlIHdvcmxkIGFuY2hvciBwb2ludHMuXG4gICAgICAgIHZhciB3b3JsZEFuY2hvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICAgICAgd29ybGRBbmNob3JCID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgICAgIHIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSBsb2NhbCBhbmNob3JzIHRvIHdvcmxkXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkQW5jaG9yQSwgbG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkQW5jaG9yQiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAgICAgdmVjMi5hZGQociwgYm9keUIucG9zaXRpb24sIHdvcmxkQW5jaG9yQik7XG4gICAgICAgIHZlYzIuc3ViKHIsIHIsIHdvcmxkQW5jaG9yQSk7XG4gICAgICAgIHZlYzIuc3ViKHIsIHIsIGJvZHlBLnBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gdmVjMi5sZW5ndGgocik7XG4gICAgfVxuXG4gICAgdmFyIG1heEZvcmNlO1xuICAgIGlmKHR5cGVvZihvcHRpb25zLm1heEZvcmNlKT09PVwidW5kZWZpbmVkXCIgKXtcbiAgICAgICAgbWF4Rm9yY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1heEZvcmNlID0gb3B0aW9ucy5tYXhGb3JjZTtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsID0gbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7IC8vIEp1c3QgaW4gdGhlIG5vcm1hbCBkaXJlY3Rpb25cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFsgbm9ybWFsIF07XG5cbiAgICAvKipcbiAgICAgKiBNYXggZm9yY2UgdG8gYXBwbHkuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heEZvcmNlXG4gICAgICovXG4gICAgdGhpcy5tYXhGb3JjZSA9IG1heEZvcmNlO1xuXG4gICAgLy8gZyA9ICh4aSAtIHhqKS5kb3QobilcbiAgICAvLyBkZy9kdCA9ICh2aSAtIHZqKS5kb3QobikgPSBHKlcgPSBbbiAwIC1uIDBdICogW3ZpIHdpIHZqIHdqXSdcblxuICAgIC8vIC4uLmFuZCBpZiB3ZSB3ZXJlIHRvIGluY2x1ZGUgb2Zmc2V0IHBvaW50cyAoVE9ETyBmb3Igbm93KTpcbiAgICAvLyBnID1cbiAgICAvLyAgICAgICh4aiArIHJqIC0geGkgLSByaSkuZG90KG4pIC0gZGlzdGFuY2VcbiAgICAvL1xuICAgIC8vIGRnL2R0ID1cbiAgICAvLyAgICAgICh2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmkpLmRvdChuKSA9XG4gICAgLy8gICAgICB7IHRlcm0gMiBpcyBuZWFyIHplcm8gfSA9XG4gICAgLy8gICAgICBbLW4gICAtcmkgeCBuICAgbiAgIHJqIHggbl0gKiBbdmkgd2kgdmogd2pdJyA9XG4gICAgLy8gICAgICBHICogV1xuICAgIC8vXG4gICAgLy8gPT4gRyA9IFstbiAtcml4biBuIHJqeG5dXG5cbiAgICB2YXIgciA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdmFyIHJpID0gdmVjMi5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JBXG4gICAgdmFyIHJqID0gdmVjMi5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JCXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIG5vcm1hbC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICAgICAgeGkgPSBib2R5QS5wb3NpdGlvbixcbiAgICAgICAgICAgIHhqID0gYm9keUIucG9zaXRpb247XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcbiAgICAgICAgdmVjMi5yb3RhdGUocmksIGxvY2FsQW5jaG9yQSwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZShyaiwgbG9jYWxBbmNob3JCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAgICAgdmVjMi5hZGQociwgeGosIHJqKTtcbiAgICAgICAgdmVjMi5zdWIociwgciwgcmkpO1xuICAgICAgICB2ZWMyLnN1YihyLCByLCB4aSk7XG5cbiAgICAgICAgLy92ZWMyLnN1YihyLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdmVjMi5sZW5ndGgocikgLSB0aGF0LmRpc3RhbmNlO1xuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSBjb250YWN0IGNvbnN0cmFpbnQgYmlsYXRlcmFsXG4gICAgdGhpcy5zZXRNYXhGb3JjZShtYXhGb3JjZSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdXBwZXIgbGltaXQgaXMgZW5hYmxlZCBvciBub3QuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1cHBlckxpbWl0RW5hYmxlZFxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cHBlciBjb25zdHJhaW50IGxpbWl0LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1cHBlckxpbWl0XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0ID0gMTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBsb3dlciBsaW1pdCBpcyBlbmFibGVkIG9yIG5vdC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGxvd2VyTGltaXRFbmFibGVkXG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGNvbnN0cmFpbnQgbGltaXQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxvd2VyTGltaXRcbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBjb25zdHJhaW50IHBvc2l0aW9uLiBUaGlzIGlzIGVxdWFsIHRvIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gdGhlIHdvcmxkIGFuY2hvciBwb2ludHMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG59XG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXN0YW5jZUNvbnN0cmFpbnQ7XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25zdHJhaW50IGVxdWF0aW9ucy4gU2hvdWxkIGJlIGRvbmUgaWYgYW55IG9mIHRoZSBib2RpZXMgY2hhbmdlZCBwb3NpdGlvbiwgYmVmb3JlIHNvbHZpbmcuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG52YXIgbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgcmkgPSB2ZWMyLmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckFcbnZhciByaiA9IHZlYzIuY3JlYXRlKCk7IC8vIHdvcmxkQW5jaG9yQlxuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBub3JtYWwgPSB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSxcbiAgICAgICAgeGkgPSBib2R5QS5wb3NpdGlvbixcbiAgICAgICAgeGogPSBib2R5Qi5wb3NpdGlvbixcbiAgICAgICAgbm9ybWFsRXF1YXRpb24gPSB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgRyA9IG5vcm1hbC5HO1xuXG4gICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcbiAgICB2ZWMyLnJvdGF0ZShyaSwgdGhpcy5sb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZShyaiwgdGhpcy5sb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcblxuICAgIC8vIEdldCB3b3JsZCBhbmNob3IgcG9pbnRzIGFuZCBub3JtYWxcbiAgICB2ZWMyLmFkZChuLCB4aiwgcmopO1xuICAgIHZlYzIuc3ViKG4sIG4sIHJpKTtcbiAgICB2ZWMyLnN1YihuLCBuLCB4aSk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHZlYzIubGVuZ3RoKG4pO1xuXG4gICAgdmFyIHZpb2xhdGluZyA9IGZhbHNlO1xuICAgIGlmKHRoaXMudXBwZXJMaW1pdEVuYWJsZWQpe1xuICAgICAgICBpZih0aGlzLnBvc2l0aW9uID4gdGhpcy51cHBlckxpbWl0KXtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1heEZvcmNlID0gMDtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1pbkZvcmNlID0gLXRoaXMubWF4Rm9yY2U7XG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gdGhpcy51cHBlckxpbWl0O1xuICAgICAgICAgICAgdmlvbGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQpe1xuICAgICAgICBpZih0aGlzLnBvc2l0aW9uIDwgdGhpcy5sb3dlckxpbWl0KXtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1heEZvcmNlID0gdGhpcy5tYXhGb3JjZTtcbiAgICAgICAgICAgIG5vcm1hbEVxdWF0aW9uLm1pbkZvcmNlID0gMDtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLmxvd2VyTGltaXQ7XG4gICAgICAgICAgICB2aW9sYXRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgfHwgdGhpcy51cHBlckxpbWl0RW5hYmxlZCkgJiYgIXZpb2xhdGluZyl7XG4gICAgICAgIC8vIE5vIGNvbnN0cmFpbnQgbmVlZGVkLlxuICAgICAgICBub3JtYWxFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBub3JtYWxFcXVhdGlvbi5lbmFibGVkID0gdHJ1ZTtcblxuICAgIHZlYzIubm9ybWFsaXplKG4sbik7XG5cbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICB2YXIgcml4biA9IHZlYzIuY3Jvc3NMZW5ndGgocmksIG4pLFxuICAgICAgICByanhuID0gdmVjMi5jcm9zc0xlbmd0aChyaiwgbik7XG5cbiAgICAvLyBHID0gWy1uIC1yaXhuIG4gcmp4bl1cbiAgICBHWzBdID0gLW5bMF07XG4gICAgR1sxXSA9IC1uWzFdO1xuICAgIEdbMl0gPSAtcml4bjtcbiAgICBHWzNdID0gblswXTtcbiAgICBHWzRdID0gblsxXTtcbiAgICBHWzVdID0gcmp4bjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggZm9yY2UgdG8gYmUgdXNlZFxuICogQG1ldGhvZCBzZXRNYXhGb3JjZVxuICogQHBhcmFtIHtOdW1iZXJ9IGZcbiAqL1xuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKGYpe1xuICAgIHZhciBub3JtYWwgPSB0aGlzLmVxdWF0aW9uc1swXTtcbiAgICBub3JtYWwubWluRm9yY2UgPSAtZjtcbiAgICBub3JtYWwubWF4Rm9yY2UgPSAgZjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXggZm9yY2VcbiAqIEBtZXRob2QgZ2V0TWF4Rm9yY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKGYpe1xuICAgIHZhciBub3JtYWwgPSB0aGlzLmVxdWF0aW9uc1swXTtcbiAgICByZXR1cm4gbm9ybWFsLm1heEZvcmNlO1xufTtcbiIsInZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50JylcbiwgICBFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgQW5nbGVMb2NrRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvQW5nbGVMb2NrRXF1YXRpb24nKVxuLCAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZWFyQ29uc3RyYWludDtcblxuLyoqXG4gKiBDb25uZWN0cyB0d28gYm9kaWVzIGF0IGdpdmVuIG9mZnNldCBwb2ludHMsIGxldHRpbmcgdGhlbSByb3RhdGUgcmVsYXRpdmUgdG8gZWFjaCBvdGhlciBhcm91bmQgdGhpcyBwb2ludC5cbiAqIEBjbGFzcyBHZWFyQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9ICAgICAgICAgICAgYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gICAgICAgICAgICBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLmFuZ2xlPTBdIFJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdGhlIGJvZGllcy4gV2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzICh0aGUgZ2VhciByYXRpbyBpcyBhY2NvdW50ZWQgZm9yKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICBbb3B0aW9ucy5yYXRpbz0xXSBHZWFyIHJhdGlvLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLm1heFRvcnF1ZV0gTWF4aW11bSB0b3JxdWUgdG8gYXBwbHkuXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKiBAdG9kbyBBYmlsaXR5IHRvIHNwZWNpZnkgd29ybGQgcG9pbnRzXG4gKi9cbmZ1bmN0aW9uIEdlYXJDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBDb25zdHJhaW50LkdFQVIsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdlYXIgcmF0aW8uXG4gICAgICogQHByb3BlcnR5IHJhdGlvXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJhdGlvID0gdHlwZW9mKG9wdGlvbnMucmF0aW8pID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5yYXRpbyA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVsYXRpdmUgYW5nbGVcbiAgICAgKiBAcHJvcGVydHkgYW5nbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSB0eXBlb2Yob3B0aW9ucy5hbmdsZSkgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLmFuZ2xlIDogYm9keUIuYW5nbGUgLSB0aGlzLnJhdGlvICogYm9keUEuYW5nbGU7XG5cbiAgICAvLyBTZW5kIHNhbWUgcGFyYW1ldGVycyB0byB0aGUgZXF1YXRpb25cbiAgICBvcHRpb25zLmFuZ2xlID0gdGhpcy5hbmdsZTtcbiAgICBvcHRpb25zLnJhdGlvID0gdGhpcy5yYXRpbztcblxuICAgIHRoaXMuZXF1YXRpb25zID0gW1xuICAgICAgICBuZXcgQW5nbGVMb2NrRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyksXG4gICAgXTtcblxuICAgIC8vIFNldCBtYXggdG9ycXVlXG4gICAgaWYodHlwZW9mKG9wdGlvbnMubWF4VG9ycXVlKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICAgIHRoaXMuc2V0TWF4VG9ycXVlKG9wdGlvbnMubWF4VG9ycXVlKTtcbiAgICB9XG59XG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VhckNvbnN0cmFpbnQ7XG5cbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlcSA9IHRoaXMuZXF1YXRpb25zWzBdO1xuICAgIGlmKGVxLnJhdGlvICE9PSB0aGlzLnJhdGlvKXtcbiAgICAgICAgZXEuc2V0UmF0aW8odGhpcy5yYXRpbyk7XG4gICAgfVxuICAgIGVxLmFuZ2xlID0gdGhpcy5hbmdsZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggdG9ycXVlIGZvciB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2Qgc2V0TWF4VG9ycXVlXG4gKiBAcGFyYW0ge051bWJlcn0gdG9ycXVlXG4gKi9cbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNYXhUb3JxdWUgPSBmdW5jdGlvbih0b3JxdWUpe1xuICAgIHRoaXMuZXF1YXRpb25zWzBdLnNldE1heFRvcnF1ZSh0b3JxdWUpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1heCB0b3JxdWUgZm9yIHRoZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBnZXRNYXhUb3JxdWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLmdldE1heFRvcnF1ZSA9IGZ1bmN0aW9uKHRvcnF1ZSl7XG4gICAgcmV0dXJuIHRoaXMuZXF1YXRpb25zWzBdLm1heEZvcmNlO1xufTsiLCJ2YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4vQ29uc3RyYWludCcpXG4sICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXG4sICAgRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NrQ29uc3RyYWludDtcblxuLyoqXG4gKiBMb2NrcyB0aGUgcmVsYXRpdmUgcG9zaXRpb24gYmV0d2VlbiB0d28gYm9kaWVzLlxuICpcbiAqIEBjbGFzcyBMb2NrQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxPZmZzZXRCXSBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuIElmIG5vdCBnaXZlbiB0aGUgb2Zmc2V0IGlzIGNvbXB1dGVkIGZyb20gY3VycmVudCBwb3NpdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9jYWxBbmdsZUJdIFRoZSBhbmdsZSBvZiBib2R5QiBpbiBib2R5QSdzIGZyYW1lLiBJZiBub3QgZ2l2ZW4sIHRoZSBhbmdsZSBpcyBjb21wdXRlZCBmcm9tIGN1cnJlbnQgYW5nbGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlXVxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICovXG5mdW5jdGlvbiBMb2NrQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIsQ29uc3RyYWludC5MT0NLLG9wdGlvbnMpO1xuXG4gICAgdmFyIG1heEZvcmNlID0gKCB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSk9PT1cInVuZGVmaW5lZFwiID8gTnVtYmVyLk1BWF9WQUxVRSA6IG9wdGlvbnMubWF4Rm9yY2UgKTtcblxuICAgIHZhciBsb2NhbEFuZ2xlQiA9IG9wdGlvbnMubG9jYWxBbmdsZUIgfHwgMDtcblxuICAgIC8vIFVzZSAzIGVxdWF0aW9uczpcbiAgICAvLyBneCA9ICAgKHhqIC0geGkgLSBsKSAqIHhoYXQgPSAwXG4gICAgLy8gZ3kgPSAgICh4aiAtIHhpIC0gbCkgKiB5aGF0ID0gMFxuICAgIC8vIGdyID0gICAoeGkgLSB4aiArIHIpICogdGhhdCA9IDBcbiAgICAvL1xuICAgIC8vIC4uLndoZXJlOlxuICAgIC8vICAgbCBpcyB0aGUgbG9jYWxPZmZzZXRCIHZlY3RvciByb3RhdGVkIHRvIHdvcmxkIGluIGJvZHlBIGZyYW1lXG4gICAgLy8gICByIGlzIHRoZSBzYW1lIHZlY3RvciBidXQgcmV2ZXJzZWQgYW5kIHJvdGF0ZWQgZnJvbSBib2R5QiBmcmFtZVxuICAgIC8vICAgeGhhdCwgeWhhdCBhcmUgd29ybGQgYXhpcyB2ZWN0b3JzXG4gICAgLy8gICB0aGF0IGlzIHRoZSB0YW5nZW50IG9mIHJcbiAgICAvL1xuICAgIC8vIEZvciB0aGUgZmlyc3QgdHdvIGNvbnN0cmFpbnRzLCB3ZSBnZXRcbiAgICAvLyBHKlcgPSAodmogLSB2aSAtIGxkb3QgICkgKiB4aGF0XG4gICAgLy8gICAgID0gKHZqIC0gdmkgLSB3aSB4IGwpICogeGhhdFxuICAgIC8vXG4gICAgLy8gU2luY2UgKHdpIHggbCkgKiB4aGF0ID0gKGwgeCB4aGF0KSAqIHdpLCB3ZSBnZXRcbiAgICAvLyBHKlcgPSBbIC0xICAgMCAgICgtbCB4IHhoYXQpICAxICAgMCAgIDBdICogW3ZpIHdpIHZqIHdqXVxuICAgIC8vXG4gICAgLy8gVGhlIGxhc3QgY29uc3RyYWludCBnaXZlc1xuICAgIC8vIEdXID0gKHZpIC0gdmogKyB3aiB4IHIpICogdGhhdFxuICAgIC8vICAgID0gWyAgdGhhdCAgIDAgIC10aGF0ICAociB4IHQpIF1cblxuICAgIHZhciB4ID0gICAgIG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpLFxuICAgICAgICB5ID0gICAgIG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpLFxuICAgICAgICByb3QgPSAgIG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpO1xuXG4gICAgdmFyIGwgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICBnID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgeC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZShsLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnN1YihnLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBsKTtcbiAgICAgICAgcmV0dXJuIGdbMF07XG4gICAgfTtcbiAgICB5LmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZlYzIucm90YXRlKGwsIHRoYXQubG9jYWxPZmZzZXRCLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIuc3ViKGcsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIGwpO1xuICAgICAgICByZXR1cm4gZ1sxXTtcbiAgICB9O1xuICAgIHZhciByID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgdCA9IHZlYzIuY3JlYXRlKCk7XG4gICAgcm90LmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZlYzIucm90YXRlKHIsIHRoYXQubG9jYWxPZmZzZXRCLCBib2R5Qi5hbmdsZSAtIHRoYXQubG9jYWxBbmdsZUIpO1xuICAgICAgICB2ZWMyLnNjYWxlKHIsciwtMSk7XG4gICAgICAgIHZlYzIuc3ViKGcsYm9keUEucG9zaXRpb24sYm9keUIucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLmFkZChnLGcscik7XG4gICAgICAgIHZlYzIucm90YXRlKHQsciwtTWF0aC5QSS8yKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUodCx0KTtcbiAgICAgICAgcmV0dXJuIHZlYzIuZG90KGcsdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvZmZzZXQgb2YgYm9keUIgaW4gYm9keUEncyBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBsb2NhbE9mZnNldEJcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsT2Zmc2V0QiA9IHZlYzIuY3JlYXRlKCk7XG4gICAgaWYob3B0aW9ucy5sb2NhbE9mZnNldEIpe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5sb2NhbE9mZnNldEIsIG9wdGlvbnMubG9jYWxPZmZzZXRCKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgZnJvbSBjdXJyZW50IHBvc2l0aW9uc1xuICAgICAgICB2ZWMyLnN1Yih0aGlzLmxvY2FsT2Zmc2V0QiwgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5yb3RhdGUodGhpcy5sb2NhbE9mZnNldEIsIHRoaXMubG9jYWxPZmZzZXRCLCAtYm9keUEuYW5nbGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvZmZzZXQgYW5nbGUgb2YgYm9keUIgaW4gYm9keUEncyBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbG9jYWxBbmdsZUJcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5nbGVCID0gMDtcbiAgICBpZih0eXBlb2Yob3B0aW9ucy5sb2NhbEFuZ2xlQikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy5sb2NhbEFuZ2xlQiA9IG9wdGlvbnMubG9jYWxBbmdsZUI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0XG4gICAgICAgIHRoaXMubG9jYWxBbmdsZUIgPSBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlO1xuICAgIH1cblxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2goeCwgeSwgcm90KTtcbiAgICB0aGlzLnNldE1heEZvcmNlKG1heEZvcmNlKTtcbn1cbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5Mb2NrQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2NrQ29uc3RyYWludDtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZm9yY2UgdG8gYmUgYXBwbGllZC5cbiAqIEBtZXRob2Qgc2V0TWF4Rm9yY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBmb3JjZVxuICovXG5Mb2NrQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TWF4Rm9yY2UgPSBmdW5jdGlvbihmb3JjZSl7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuZXF1YXRpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZXFzW2ldLm1heEZvcmNlID0gIGZvcmNlO1xuICAgICAgICBlcXNbaV0ubWluRm9yY2UgPSAtZm9yY2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1heCBmb3JjZS5cbiAqIEBtZXRob2QgZ2V0TWF4Rm9yY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLmdldE1heEZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5lcXVhdGlvbnNbMF0ubWF4Rm9yY2U7XG59O1xuXG52YXIgbCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgciA9IHZlYzIuY3JlYXRlKCk7XG52YXIgdCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgeEF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMSwwKTtcbnZhciB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHggPSAgIHRoaXMuZXF1YXRpb25zWzBdLFxuICAgICAgICB5ID0gICB0aGlzLmVxdWF0aW9uc1sxXSxcbiAgICAgICAgcm90ID0gdGhpcy5lcXVhdGlvbnNbMl0sXG4gICAgICAgIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCO1xuXG4gICAgdmVjMi5yb3RhdGUobCx0aGlzLmxvY2FsT2Zmc2V0Qixib2R5QS5hbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUocix0aGlzLmxvY2FsT2Zmc2V0Qixib2R5Qi5hbmdsZSAtIHRoaXMubG9jYWxBbmdsZUIpO1xuICAgIHZlYzIuc2NhbGUocixyLC0xKTtcblxuICAgIHZlYzIucm90YXRlKHQscixNYXRoLlBJLzIpO1xuICAgIHZlYzIubm9ybWFsaXplKHQsdCk7XG5cbiAgICB4LkdbMF0gPSAtMTtcbiAgICB4LkdbMV0gPSAgMDtcbiAgICB4LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChsLHhBeGlzKTtcbiAgICB4LkdbM10gPSAgMTtcblxuICAgIHkuR1swXSA9ICAwO1xuICAgIHkuR1sxXSA9IC0xO1xuICAgIHkuR1syXSA9IC12ZWMyLmNyb3NzTGVuZ3RoKGwseUF4aXMpO1xuICAgIHkuR1s0XSA9ICAxO1xuXG4gICAgcm90LkdbMF0gPSAgLXRbMF07XG4gICAgcm90LkdbMV0gPSAgLXRbMV07XG4gICAgcm90LkdbM10gPSAgdFswXTtcbiAgICByb3QuR1s0XSA9ICB0WzFdO1xuICAgIHJvdC5HWzVdID0gIHZlYzIuY3Jvc3NMZW5ndGgocix0KTtcbn07XG4iLCJ2YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4vQ29uc3RyYWludCcpXG4sICAgQ29udGFjdEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpXG4sICAgRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKVxuLCAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFJvdGF0aW9uYWxMb2NrRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbExvY2tFcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByaXNtYXRpY0NvbnN0cmFpbnQ7XG5cbi8qKlxuICogQ29uc3RyYWludCB0aGF0IG9ubHkgYWxsb3dzIGJvZGllcyB0byBtb3ZlIGFsb25nIGEgbGluZSwgcmVsYXRpdmUgdG8gZWFjaCBvdGhlci4gU2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmlmb3JjZTJkLm5ldC9iMmR0dXQvam9pbnRzLXByaXNtYXRpY1wiPnRoaXMgdHV0b3JpYWw8L2E+LlxuICpcbiAqIEBjbGFzcyBQcmlzbWF0aWNDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gICAgYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gICAgYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLm1heEZvcmNlXSAgICAgICAgICAgICAgICBNYXggZm9yY2UgdG8gYmUgYXBwbGllZCBieSB0aGUgY29uc3RyYWludFxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbEFuY2hvckFdICAgICAgICAgICAgQm9keSBBJ3MgYW5jaG9yIHBvaW50LCBkZWZpbmVkIGluIGl0cyBvd24gbG9jYWwgZnJhbWUuXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsQW5jaG9yQl0gICAgICAgICAgICBCb2R5IEIncyBhbmNob3IgcG9pbnQsIGRlZmluZWQgaW4gaXRzIG93biBsb2NhbCBmcmFtZS5cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxBeGlzQV0gICAgICAgICAgICAgIEFuIGF4aXMsIGRlZmluZWQgaW4gYm9keSBBIGZyYW1lLCB0aGF0IGJvZHkgQidzIGFuY2hvciBwb2ludCBtYXkgc2xpZGUgYWxvbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRpc2FibGVSb3RhdGlvbmFsTG9ja10gICBJZiBzZXQgdG8gdHJ1ZSwgYm9keUIgd2lsbCBiZSBmcmVlIHRvIHJvdGF0ZSBhcm91bmQgaXRzIGFuY2hvciBwb2ludC5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgW29wdGlvbnMudXBwZXJMaW1pdF1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgW29wdGlvbnMubG93ZXJMaW1pdF1cbiAqIEB0b2RvIEFiaWxpdHkgdG8gY3JlYXRlIHVzaW5nIG9ubHkgYSBwb2ludCBhbmQgYSB3b3JsZEF4aXNcbiAqL1xuZnVuY3Rpb24gUHJpc21hdGljQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuUFJJU01BVElDLG9wdGlvbnMpO1xuXG4gICAgLy8gR2V0IGFuY2hvcnNcbiAgICB2YXIgbG9jYWxBbmNob3JBID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgICAgIGxvY2FsQXhpc0EgPSB2ZWMyLmZyb21WYWx1ZXMoMSwwKSxcbiAgICAgICAgbG9jYWxBbmNob3JCID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckEpeyB2ZWMyLmNvcHkobG9jYWxBbmNob3JBLCBvcHRpb25zLmxvY2FsQW5jaG9yQSk7IH1cbiAgICBpZihvcHRpb25zLmxvY2FsQXhpc0EpeyB2ZWMyLmNvcHkobG9jYWxBeGlzQSwgICBvcHRpb25zLmxvY2FsQXhpc0EpOyB9XG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckIpeyB2ZWMyLmNvcHkobG9jYWxBbmNob3JCLCBvcHRpb25zLmxvY2FsQW5jaG9yQik7IH1cblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSBsb2NhbEFuY2hvckE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JCID0gbG9jYWxBbmNob3JCO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxvY2FsQXhpc0FcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEF4aXNBID0gbG9jYWxBeGlzQTtcblxuICAgIC8qXG5cbiAgICBUaGUgY29uc3RyYWludCB2aW9sYXRpb24gZm9yIHRoZSBjb21tb24gYXhpcyBwb2ludCBpc1xuXG4gICAgICAgIGcgPSAoIHhqICsgcmogLSB4aSAtIHJpICkgKiB0ICAgOj0gIGdnKnRcblxuICAgIHdoZXJlIHIgYXJlIGJvZHktbG9jYWwgYW5jaG9yIHBvaW50cywgYW5kIHQgaXMgYSB0YW5nZW50IHRvIHRoZSBjb25zdHJhaW50IGF4aXMgZGVmaW5lZCBpbiBib2R5IGkgZnJhbWUuXG5cbiAgICAgICAgZ2RvdCA9ICAoIHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaSApICogdCArICggeGogKyByaiAtIHhpIC0gcmkgKSAqICggd2kgeCB0IClcblxuICAgIE5vdGUgdGhlIHVzZSBvZiB0aGUgY2hhaW4gcnVsZS4gTm93IHdlIGlkZW50aWZ5IHRoZSBqYWNvYmlhblxuXG4gICAgICAgIEcqVyA9IFsgLXQgICAgICAtcmkgeCB0ICsgdCB4IGdnICAgICB0ICAgIHJqIHggdCBdICogW3ZpIHdpIHZqIHdqXVxuXG4gICAgVGhlIHJvdGF0aW9uYWwgcGFydCBpcyBqdXN0IGEgcm90YXRpb24gbG9jay5cblxuICAgICAqL1xuXG4gICAgdmFyIG1heEZvcmNlID0gdGhpcy5tYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSE9PVwidW5kZWZpbmVkXCIgPyBvcHRpb25zLm1heEZvcmNlIDogTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIC8vIFRyYW5zbGF0aW9uYWwgcGFydFxuICAgIHZhciB0cmFucyA9IG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpO1xuICAgIHZhciByaSA9IG5ldyB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICByaiA9IG5ldyB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICBnZyA9IG5ldyB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICB0ID0gIG5ldyB2ZWMyLmNyZWF0ZSgpO1xuICAgIHRyYW5zLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIGcgPSAoIHhqICsgcmogLSB4aSAtIHJpICkgKiB0XG4gICAgICAgIHJldHVybiB2ZWMyLmRvdChnZyx0KTtcbiAgICB9O1xuICAgIHRyYW5zLnVwZGF0ZUphY29iaWFuID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIEcgPSB0aGlzLkcsXG4gICAgICAgICAgICB4aSA9IGJvZHlBLnBvc2l0aW9uLFxuICAgICAgICAgICAgeGogPSBib2R5Qi5wb3NpdGlvbjtcbiAgICAgICAgdmVjMi5yb3RhdGUocmksbG9jYWxBbmNob3JBLGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUocmosbG9jYWxBbmNob3JCLGJvZHlCLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQoZ2cseGoscmopO1xuICAgICAgICB2ZWMyLnN1YihnZyxnZyx4aSk7XG4gICAgICAgIHZlYzIuc3ViKGdnLGdnLHJpKTtcbiAgICAgICAgdmVjMi5yb3RhdGUodCxsb2NhbEF4aXNBLGJvZHlBLmFuZ2xlK01hdGguUEkvMik7XG5cbiAgICAgICAgR1swXSA9IC10WzBdO1xuICAgICAgICBHWzFdID0gLXRbMV07XG4gICAgICAgIEdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChyaSx0KSArIHZlYzIuY3Jvc3NMZW5ndGgodCxnZyk7XG4gICAgICAgIEdbM10gPSB0WzBdO1xuICAgICAgICBHWzRdID0gdFsxXTtcbiAgICAgICAgR1s1XSA9IHZlYzIuY3Jvc3NMZW5ndGgocmosdCk7XG4gICAgfTtcbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHRyYW5zKTtcblxuICAgIC8vIFJvdGF0aW9uYWwgcGFydFxuICAgIGlmKCFvcHRpb25zLmRpc2FibGVSb3RhdGlvbmFsTG9jayl7XG4gICAgICAgIHZhciByb3QgPSBuZXcgUm90YXRpb25hbExvY2tFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpO1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHJvdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIGFuY2hvciBBIHJlbGF0aXZlIHRvIGFuY2hvciBCLCBhbG9uZyB0aGUgY29uc3RyYWludCBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG5cbiAgICAvLyBJcyB0aGlzIG9uZSB1c2VkIGF0IGFsbD9cbiAgICB0aGlzLnZlbG9jaXR5ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSBsb3dlciBsaW1pdC5cbiAgICAgKiBAcHJvcGVydHkgbG93ZXJMaW1pdEVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gdHlwZW9mKG9wdGlvbnMubG93ZXJMaW1pdCkhPT1cInVuZGVmaW5lZFwiID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIHVwcGVyIGxpbWl0LlxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckxpbWl0RW5hYmxlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSB0eXBlb2Yob3B0aW9ucy51cHBlckxpbWl0KSE9PVwidW5kZWZpbmVkXCIgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBMb3dlciBjb25zdHJhaW50IGxpbWl0LiBUaGUgY29uc3RyYWludCBwb3NpdGlvbiBpcyBmb3JjZWQgdG8gYmUgbGFyZ2VyIHRoYW4gdGhpcyB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkgbG93ZXJMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0ID0gdHlwZW9mKG9wdGlvbnMubG93ZXJMaW1pdCkhPT1cInVuZGVmaW5lZFwiID8gb3B0aW9ucy5sb3dlckxpbWl0IDogMDtcblxuICAgIC8qKlxuICAgICAqIFVwcGVyIGNvbnN0cmFpbnQgbGltaXQuIFRoZSBjb25zdHJhaW50IHBvc2l0aW9uIGlzIGZvcmNlZCB0byBiZSBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0ID0gdHlwZW9mKG9wdGlvbnMudXBwZXJMaW1pdCkhPT1cInVuZGVmaW5lZFwiID8gb3B0aW9ucy51cHBlckxpbWl0IDogMTtcblxuICAgIC8vIEVxdWF0aW9ucyB1c2VkIGZvciBsaW1pdHNcbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbiA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIpO1xuICAgIHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvLyBTZXQgbWF4L21pbiBmb3JjZXNcbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbi5taW5Gb3JjZSA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uLm1pbkZvcmNlID0gMDtcbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbi5tYXhGb3JjZSA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uLm1heEZvcmNlID0gbWF4Rm9yY2U7XG5cbiAgICAvKipcbiAgICAgKiBFcXVhdGlvbiB1c2VkIGZvciB0aGUgbW90b3IuXG4gICAgICogQHByb3BlcnR5IG1vdG9yRXF1YXRpb25cbiAgICAgKiBAdHlwZSB7RXF1YXRpb259XG4gICAgICovXG4gICAgdGhpcy5tb3RvckVxdWF0aW9uID0gbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IG1vdG9yIHN0YXRlLiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgbW90b3IgdXNpbmcgLmVuYWJsZU1vdG9yXG4gICAgICogQHByb3BlcnR5IG1vdG9yRW5hYmxlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRhcmdldCBzcGVlZCBmb3IgdGhlIG1vdG9yLlxuICAgICAqIEBwcm9wZXJ0eSBtb3RvclNwZWVkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1vdG9yU3BlZWQgPSAwO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBtb3RvckVxdWF0aW9uID0gdGhpcy5tb3RvckVxdWF0aW9uO1xuICAgIHZhciBvbGQgPSBtb3RvckVxdWF0aW9uLmNvbXB1dGVHVztcbiAgICBtb3RvckVxdWF0aW9uLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7IHJldHVybiAwOyB9O1xuICAgIG1vdG9yRXF1YXRpb24uY29tcHV0ZUdXID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIEcgPSB0aGlzLkcsXG4gICAgICAgICAgICBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgICAgICB2aSA9IGJpLnZlbG9jaXR5LFxuICAgICAgICAgICAgdmogPSBiai52ZWxvY2l0eSxcbiAgICAgICAgICAgIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICAgICAgd2ogPSBiai5hbmd1bGFyVmVsb2NpdHk7XG4gICAgICAgIHJldHVybiB0aGlzLmdtdWx0KEcsdmksd2ksdmosd2opICsgdGhhdC5tb3RvclNwZWVkO1xuICAgIH07XG59XG5cblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJpc21hdGljQ29uc3RyYWludDtcblxudmFyIHdvcmxkQXhpc0EgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHdvcmxkQW5jaG9yQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgd29ybGRBbmNob3JCID0gdmVjMi5jcmVhdGUoKSxcbiAgICBvcmllbnRlZEFuY2hvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIG9yaWVudGVkQW5jaG9yQiA9IHZlYzIuY3JlYXRlKCksXG4gICAgdG1wID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbnN0cmFpbnQgZXF1YXRpb25zLiBTaG91bGQgYmUgZG9uZSBpZiBhbnkgb2YgdGhlIGJvZGllcyBjaGFuZ2VkIHBvc2l0aW9uLCBiZWZvcmUgc29sdmluZy5cbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zLFxuICAgICAgICB0cmFucyA9IGVxc1swXSxcbiAgICAgICAgdXBwZXJMaW1pdCA9IHRoaXMudXBwZXJMaW1pdCxcbiAgICAgICAgbG93ZXJMaW1pdCA9IHRoaXMubG93ZXJMaW1pdCxcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uID0gdGhpcy51cHBlckxpbWl0RXF1YXRpb24sXG4gICAgICAgIGxvd2VyTGltaXRFcXVhdGlvbiA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgbG9jYWxBeGlzQSA9IHRoaXMubG9jYWxBeGlzQSxcbiAgICAgICAgbG9jYWxBbmNob3JBID0gdGhpcy5sb2NhbEFuY2hvckEsXG4gICAgICAgIGxvY2FsQW5jaG9yQiA9IHRoaXMubG9jYWxBbmNob3JCO1xuXG4gICAgdHJhbnMudXBkYXRlSmFjb2JpYW4oKTtcblxuICAgIC8vIFRyYW5zZm9ybSBsb2NhbCB0aGluZ3MgdG8gd29ybGRcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZEF4aXNBLCAgICAgIGxvY2FsQXhpc0EsICAgICAgYm9keUEuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKG9yaWVudGVkQW5jaG9yQSwgbG9jYWxBbmNob3JBLCAgICBib2R5QS5hbmdsZSk7XG4gICAgdmVjMi5hZGQod29ybGRBbmNob3JBLCAgICAgICBvcmllbnRlZEFuY2hvckEsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICB2ZWMyLnJvdGF0ZShvcmllbnRlZEFuY2hvckIsIGxvY2FsQW5jaG9yQiwgICAgYm9keUIuYW5nbGUpO1xuICAgIHZlYzIuYWRkKHdvcmxkQW5jaG9yQiwgICAgICAgb3JpZW50ZWRBbmNob3JCLCBib2R5Qi5wb3NpdGlvbik7XG5cbiAgICB2YXIgcmVsUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uID0gdmVjMi5kb3Qod29ybGRBbmNob3JCLHdvcmxkQXhpc0EpIC0gdmVjMi5kb3Qod29ybGRBbmNob3JBLHdvcmxkQXhpc0EpO1xuXG4gICAgLy8gTW90b3JcbiAgICBpZih0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIC8vIEcgPSBbIGEgICAgIGEgeCByaSAgIC1hICAgLWEgeCByaiBdXG4gICAgICAgIHZhciBHID0gdGhpcy5tb3RvckVxdWF0aW9uLkc7XG4gICAgICAgIEdbMF0gPSB3b3JsZEF4aXNBWzBdO1xuICAgICAgICBHWzFdID0gd29ybGRBeGlzQVsxXTtcbiAgICAgICAgR1syXSA9IHZlYzIuY3Jvc3NMZW5ndGgod29ybGRBeGlzQSxvcmllbnRlZEFuY2hvckIpO1xuICAgICAgICBHWzNdID0gLXdvcmxkQXhpc0FbMF07XG4gICAgICAgIEdbNF0gPSAtd29ybGRBeGlzQVsxXTtcbiAgICAgICAgR1s1XSA9IC12ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkQXhpc0Esb3JpZW50ZWRBbmNob3JBKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAgICBMaW1pdHMgc3RyYXRlZ3k6XG4gICAgICAgIEFkZCBjb250YWN0IGVxdWF0aW9uLCB3aXRoIG5vcm1hbCBhbG9uZyB0aGUgY29uc3RyYWludCBheGlzLlxuICAgICAgICBtaW4vbWF4Rm9yY2UgaXMgc2V0IHNvIHRoZSBjb25zdHJhaW50IGlzIHJlcHVsc2l2ZSBpbiB0aGUgY29ycmVjdCBkaXJlY3Rpb24uXG4gICAgICAgIFNvbWUgb2Zmc2V0IGlzIGFkZGVkIHRvIGVpdGhlciBlcXVhdGlvbi5jb250YWN0UG9pbnRBIG9yIC5jb250YWN0UG9pbnRCIHRvIGdldCB0aGUgY29ycmVjdCB1cHBlci9sb3dlciBsaW1pdC5cblxuICAgICAgICAgICAgICAgICBeXG4gICAgICAgICAgICAgICAgIHxcbiAgICAgIHVwcGVyTGltaXQgeFxuICAgICAgICAgICAgICAgICB8ICAgIC0tLS0tLVxuICAgICAgICAgYW5jaG9yQiB4PC0tLXwgIEIgfFxuICAgICAgICAgICAgICAgICB8ICAgIHwgICAgfFxuICAgICAgICAtLS0tLS0gICB8ICAgIC0tLS0tLVxuICAgICAgICB8ICAgIHwgICB8XG4gICAgICAgIHwgIEEgfC0tPnggYW5jaG9yQVxuICAgICAgICAtLS0tLS0gICB8XG4gICAgICAgICAgICAgICAgIHggbG93ZXJMaW1pdFxuICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgYXhpc1xuICAgICAqL1xuXG5cbiAgICBpZih0aGlzLnVwcGVyTGltaXRFbmFibGVkICYmIHJlbFBvc2l0aW9uID4gdXBwZXJMaW1pdCl7XG4gICAgICAgIC8vIFVwZGF0ZSBjb250YWN0IGNvbnN0cmFpbnQgbm9ybWFsLCBldGNcbiAgICAgICAgdmVjMi5zY2FsZSh1cHBlckxpbWl0RXF1YXRpb24ubm9ybWFsQSwgd29ybGRBeGlzQSwgLTEpO1xuICAgICAgICB2ZWMyLnN1Yih1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSwgd29ybGRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLCB3b3JsZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zY2FsZSh0bXAsd29ybGRBeGlzQSx1cHBlckxpbWl0KTtcbiAgICAgICAgdmVjMi5hZGQodXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsdXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsdG1wKTtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YodXBwZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpe1xuICAgICAgICAgICAgZXFzLnB1c2godXBwZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZih1cHBlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5sb3dlckxpbWl0RW5hYmxlZCAmJiByZWxQb3NpdGlvbiA8IGxvd2VyTGltaXQpe1xuICAgICAgICAvLyBVcGRhdGUgY29udGFjdCBjb25zdHJhaW50IG5vcm1hbCwgZXRjXG4gICAgICAgIHZlYzIuc2NhbGUobG93ZXJMaW1pdEVxdWF0aW9uLm5vcm1hbEEsIHdvcmxkQXhpc0EsIDEpO1xuICAgICAgICB2ZWMyLnN1Yihsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSwgd29ybGRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRCLCB3b3JsZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zY2FsZSh0bXAsd29ybGRBeGlzQSxsb3dlckxpbWl0KTtcbiAgICAgICAgdmVjMi5zdWIobG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsbG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsdG1wKTtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpe1xuICAgICAgICAgICAgZXFzLnB1c2gobG93ZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgdGhlIG1vdG9yXG4gKiBAbWV0aG9kIGVuYWJsZU1vdG9yXG4gKi9cblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLmVuYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaCh0aGlzLm1vdG9yRXF1YXRpb24pO1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRGlzYWJsZSB0aGUgcm90YXRpb25hbCBtb3RvclxuICogQG1ldGhvZCBkaXNhYmxlTW90b3JcbiAqL1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICBpZighdGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5lcXVhdGlvbnMuaW5kZXhPZih0aGlzLm1vdG9yRXF1YXRpb24pO1xuICAgIHRoaXMuZXF1YXRpb25zLnNwbGljZShpLDEpO1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29uc3RyYWludCBsaW1pdHMuXG4gKiBAbWV0aG9kIHNldExpbWl0c1xuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIExvd2VyIGxpbWl0LlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFVwcGVyIGxpbWl0LlxuICovXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5zZXRMaW1pdHMgPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyKSB7XG4gICAgaWYodHlwZW9mKGxvd2VyKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXI7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZih0eXBlb2YodXBwZXIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xuICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbiIsInZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50JylcbiwgICBFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24nKVxuLCAgIFJvdGF0aW9uYWxMb2NrRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbExvY2tFcXVhdGlvbicpXG4sICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJldm9sdXRlQ29uc3RyYWludDtcblxudmFyIHdvcmxkUGl2b3RBID0gdmVjMi5jcmVhdGUoKSxcbiAgICB3b3JsZFBpdm90QiA9IHZlYzIuY3JlYXRlKCksXG4gICAgeEF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMSwwKSxcbiAgICB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpLFxuICAgIGcgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIENvbm5lY3RzIHR3byBib2RpZXMgYXQgZ2l2ZW4gb2Zmc2V0IHBvaW50cywgbGV0dGluZyB0aGVtIHJvdGF0ZSByZWxhdGl2ZSB0byBlYWNoIG90aGVyIGFyb3VuZCB0aGlzIHBvaW50LlxuICogQGNsYXNzIFJldm9sdXRlQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9ICAgIGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy53b3JsZFBpdm90XSBBIHBpdm90IHBvaW50IGdpdmVuIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBJZiBzcGVjaWZpZWQsIGxvY2FsUGl2b3RBIGFuZCBsb2NhbFBpdm90QiBhcmUgYXV0b21hdGljYWxseSBjb21wdXRlZCBmcm9tIHRoaXMgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsUGl2b3RBXSBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzIG9mIGJvZHlBIHdoaWNoIGJvZHlBIGlzIGNvbnN0cmFpbmVkIHRvLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbFBpdm90Ql0gU2VlIGxvY2FsUGl2b3RBLlxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy5tYXhGb3JjZV0gVGhlIG1heGltdW0gZm9yY2UgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBjb25zdHJhaW4gdGhlIGJvZGllcy5cbiAqIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIFRoaXMgd2lsbCBjcmVhdGUgYSByZXZvbHV0ZSBjb25zdHJhaW50IGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIHBpdm90IHBvaW50IGluIGJldHdlZW4gdGhlbS5cbiAqICAgICB2YXIgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbLTEsIDBdIH0pO1xuICogICAgIHZhciBib2R5QiA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFsxLCAwXSB9KTtcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBSZXZvbHV0ZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCB7XG4gKiAgICAgICAgIHdvcmxkUGl2b3Q6IFswLCAwXVxuICogICAgIH0pO1xuICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG4gKlxuICogICAgIC8vIFVzaW5nIGJvZHktbG9jYWwgcGl2b3QgcG9pbnRzLCB0aGUgY29uc3RyYWludCBjb3VsZCBoYXZlIGJlZW4gY29uc3RydWN0ZWQgbGlrZSB0aGlzOlxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFJldm9sdXRlQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcbiAqICAgICAgICAgbG9jYWxQaXZvdEE6IFsxLCAwXSxcbiAqICAgICAgICAgbG9jYWxQaXZvdEI6IFstMSwgMF1cbiAqICAgICB9KTtcbiAqL1xuZnVuY3Rpb24gUmV2b2x1dGVDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIsQ29uc3RyYWludC5SRVZPTFVURSxvcHRpb25zKTtcblxuICAgIHZhciBtYXhGb3JjZSA9IHRoaXMubWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLm1heEZvcmNlIDogTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHBpdm90QVxuICAgICAqL1xuICAgIHRoaXMucGl2b3RBID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHBpdm90QlxuICAgICAqL1xuICAgIHRoaXMucGl2b3RCID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIGlmKG9wdGlvbnMud29ybGRQaXZvdCl7XG4gICAgICAgIC8vIENvbXB1dGUgcGl2b3RBIGFuZCBwaXZvdEJcbiAgICAgICAgdmVjMi5zdWIodGhpcy5waXZvdEEsIG9wdGlvbnMud29ybGRQaXZvdCwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1Yih0aGlzLnBpdm90Qiwgb3B0aW9ucy53b3JsZFBpdm90LCBib2R5Qi5wb3NpdGlvbik7XG4gICAgICAgIC8vIFJvdGF0ZSB0byBsb2NhbCBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICB2ZWMyLnJvdGF0ZSh0aGlzLnBpdm90QSwgdGhpcy5waXZvdEEsIC1ib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHRoaXMucGl2b3RCLCB0aGlzLnBpdm90QiwgLWJvZHlCLmFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgcGl2b3RBIGFuZCBwaXZvdEJcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucGl2b3RBLCBvcHRpb25zLmxvY2FsUGl2b3RBKTtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucGl2b3RCLCBvcHRpb25zLmxvY2FsUGl2b3RCKTtcbiAgICB9XG5cbiAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnMgPSBbXG4gICAgICAgIG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpLFxuICAgICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICBdO1xuXG4gICAgdmFyIHggPSBlcXNbMF07XG4gICAgdmFyIHkgPSBlcXNbMV07XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgeC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QSwgdGhhdC5waXZvdEEsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEIsIHRoYXQucGl2b3RCLCBib2R5Qi5hbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKGcsIGJvZHlCLnBvc2l0aW9uLCB3b3JsZFBpdm90Qik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgd29ybGRQaXZvdEEpO1xuICAgICAgICByZXR1cm4gdmVjMi5kb3QoZyx4QXhpcyk7XG4gICAgfTtcblxuICAgIHkuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEEsIHRoYXQucGl2b3RBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RCLCB0aGF0LnBpdm90QiwgYm9keUIuYW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZChnLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRQaXZvdEIpO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIHdvcmxkUGl2b3RBKTtcbiAgICAgICAgcmV0dXJuIHZlYzIuZG90KGcseUF4aXMpO1xuICAgIH07XG5cbiAgICB5Lm1pbkZvcmNlID0geC5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcbiAgICB5Lm1heEZvcmNlID0geC5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcblxuICAgIHRoaXMubW90b3JFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbW90b3IgaXMgZW5hYmxlZC4gVXNlIC5lbmFibGVNb3RvcigpIHRvIGVuYWJsZSB0aGUgY29uc3RyYWludCBtb3Rvci5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG1vdG9yRW5hYmxlZFxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RyYWludCBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgYW5nbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIGxvd2VyIGxpbWl0XG4gICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIHVwcGVyIGxpbWl0XG4gICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGxpbWl0IG9uIHRoZSBjb25zdHJhaW50IGFuZ2xlLlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb3dlckxpbWl0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cHBlciBsaW1pdCBvbiB0aGUgY29uc3RyYWludCBhbmdsZS5cbiAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJMaW1pdCA9IDA7XG5cbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCKTtcbiAgICB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbi5taW5Gb3JjZSA9IDA7XG4gICAgdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWF4Rm9yY2UgPSAwO1xufVxuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmV2b2x1dGVDb25zdHJhaW50O1xuXG4vKipcbiAqIFNldCB0aGUgY29uc3RyYWludCBhbmdsZSBsaW1pdHMuXG4gKiBAbWV0aG9kIHNldExpbWl0c1xuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIExvd2VyIGFuZ2xlIGxpbWl0LlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFVwcGVyIGFuZ2xlIGxpbWl0LlxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcbiAgICBpZih0eXBlb2YobG93ZXIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdCA9IGxvd2VyO1xuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZih1cHBlcikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xuICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib2R5QSA9ICB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9ICB0aGlzLmJvZHlCLFxuICAgICAgICBwaXZvdEEgPSB0aGlzLnBpdm90QSxcbiAgICAgICAgcGl2b3RCID0gdGhpcy5waXZvdEIsXG4gICAgICAgIGVxcyA9ICAgIHRoaXMuZXF1YXRpb25zLFxuICAgICAgICBub3JtYWwgPSBlcXNbMF0sXG4gICAgICAgIHRhbmdlbnQ9IGVxc1sxXSxcbiAgICAgICAgeCA9IGVxc1swXSxcbiAgICAgICAgeSA9IGVxc1sxXSxcbiAgICAgICAgdXBwZXJMaW1pdCA9IHRoaXMudXBwZXJMaW1pdCxcbiAgICAgICAgbG93ZXJMaW1pdCA9IHRoaXMubG93ZXJMaW1pdCxcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uID0gdGhpcy51cHBlckxpbWl0RXF1YXRpb24sXG4gICAgICAgIGxvd2VyTGltaXRFcXVhdGlvbiA9IHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uO1xuXG4gICAgdmFyIHJlbEFuZ2xlID0gdGhpcy5hbmdsZSA9IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XG5cbiAgICBpZih0aGlzLnVwcGVyTGltaXRFbmFibGVkICYmIHJlbEFuZ2xlID4gdXBwZXJMaW1pdCl7XG4gICAgICAgIHVwcGVyTGltaXRFcXVhdGlvbi5hbmdsZSA9IHVwcGVyTGltaXQ7XG4gICAgICAgIGlmKGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbikgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKHVwcGVyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gZXFzLmluZGV4T2YodXBwZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgICAgICBlcXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgJiYgcmVsQW5nbGUgPCBsb3dlckxpbWl0KXtcbiAgICAgICAgbG93ZXJMaW1pdEVxdWF0aW9uLmFuZ2xlID0gbG93ZXJMaW1pdDtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YobG93ZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpe1xuICAgICAgICAgICAgZXFzLnB1c2gobG93ZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcblxuICAgIFRoZSBjb25zdHJhaW50IHZpb2xhdGlvbiBpc1xuXG4gICAgICAgIGcgPSB4aiArIHJqIC0geGkgLSByaVxuXG4gICAgLi4ud2hlcmUgeGkgYW5kIHhqIGFyZSB0aGUgYm9keSBwb3NpdGlvbnMgYW5kIHJpIGFuZCByaiB3b3JsZC1vcmllbnRlZCBvZmZzZXQgdmVjdG9ycy4gRGlmZmVyZW50aWF0ZTpcblxuICAgICAgICBnZG90ID0gdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpXG5cbiAgICBXZSBzcGxpdCB0aGlzIGludG8geCBhbmQgeSBkaXJlY3Rpb25zLiAobGV0IHggYW5kIHkgYmUgdW5pdCB2ZWN0b3JzIGFsb25nIHRoZSByZXNwZWN0aXZlIGF4ZXMpXG5cbiAgICAgICAgZ2RvdCAqIHggPSAoIHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaSApICogeFxuICAgICAgICAgICAgICAgICA9ICggdmoqeCArICh3aiB4IHJqKSp4IC12aSp4IC0od2kgeCByaSkqeFxuICAgICAgICAgICAgICAgICA9ICggdmoqeCArIChyaiB4IHgpKndqIC12aSp4IC0ocmkgeCB4KSp3aVxuICAgICAgICAgICAgICAgICA9IFsgLXggICAtKHJpIHggeCkgICB4ICAgKHJqIHggeCldICogW3ZpIHdpIHZqIHdqXVxuICAgICAgICAgICAgICAgICA9IEcqV1xuXG4gICAgLi4uYW5kIHNpbWlsYXIgZm9yIHkuIFdlIGhhdmUgdGhlbiBpZGVudGlmaWVkIHRoZSBqYWNvYmlhbiBlbnRyaWVzIGZvciB4IGFuZCB5IGRpcmVjdGlvbnM6XG5cbiAgICAgICAgR3ggPSBbIHggICAocmogeCB4KSAgIC14ICAgLShyaSB4IHgpXVxuICAgICAgICBHeSA9IFsgeSAgIChyaiB4IHkpICAgLXkgICAtKHJpIHggeSldXG5cbiAgICAgKi9cblxuICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RBLCBwaXZvdEEsIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QiwgcGl2b3RCLCBib2R5Qi5hbmdsZSk7XG5cbiAgICAvLyB0b2RvOiB0aGVzZSBhcmUgYSBiaXQgc3BhcnNlLiBXZSBjb3VsZCBzYXZlIHNvbWUgY29tcHV0YXRpb25zIG9uIG1ha2luZyBjdXN0b20gZXEuY29tcHV0ZUdXIGZ1bmN0aW9ucywgZXRjXG5cbiAgICB4LkdbMF0gPSAtMTtcbiAgICB4LkdbMV0gPSAgMDtcbiAgICB4LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aCh3b3JsZFBpdm90QSx4QXhpcyk7XG4gICAgeC5HWzNdID0gIDE7XG4gICAgeC5HWzRdID0gIDA7XG4gICAgeC5HWzVdID0gIHZlYzIuY3Jvc3NMZW5ndGgod29ybGRQaXZvdEIseEF4aXMpO1xuXG4gICAgeS5HWzBdID0gIDA7XG4gICAgeS5HWzFdID0gLTE7XG4gICAgeS5HWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgod29ybGRQaXZvdEEseUF4aXMpO1xuICAgIHkuR1szXSA9ICAwO1xuICAgIHkuR1s0XSA9ICAxO1xuICAgIHkuR1s1XSA9ICB2ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RCLHlBeGlzKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIHRoZSByb3RhdGlvbmFsIG1vdG9yXG4gKiBAbWV0aG9kIGVuYWJsZU1vdG9yXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuZW5hYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIHRoZSByb3RhdGlvbmFsIG1vdG9yXG4gKiBAbWV0aG9kIGRpc2FibGVNb3RvclxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLmRpc2FibGVNb3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLmVxdWF0aW9ucy5zcGxpY2UoaSwxKTtcbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgbW90b3IgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2QgbW90b3JJc0VuYWJsZWRcbiAqIEBkZXByZWNhdGVkIHVzZSBwcm9wZXJ0eSBtb3RvckVuYWJsZWQgaW5zdGVhZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUubW90b3JJc0VuYWJsZWQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIXRoaXMubW90b3JFbmFibGVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNwZWVkIG9mIHRoZSByb3RhdGlvbmFsIGNvbnN0cmFpbnQgbW90b3JcbiAqIEBtZXRob2Qgc2V0TW90b3JTcGVlZFxuICogQHBhcmFtICB7TnVtYmVyfSBzcGVlZFxuICovXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbihzcGVlZCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YodGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLmVxdWF0aW9uc1tpXS5yZWxhdGl2ZVZlbG9jaXR5ID0gc3BlZWQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3BlZWQgb2YgdGhlIHJvdGF0aW9uYWwgY29uc3RyYWludCBtb3RvclxuICogQG1ldGhvZCBnZXRNb3RvclNwZWVkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHNwZWVkLCBvciBmYWxzZSBpZiB0aGUgbW90b3IgaXMgbm90IGVuYWJsZWQuXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuZ2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIXRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tb3RvckVxdWF0aW9uLnJlbGF0aXZlVmVsb2NpdHk7XG59O1xuIiwidmFyIEVxdWF0aW9uID0gcmVxdWlyZShcIi4vRXF1YXRpb25cIiksXG4gICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuZ2xlTG9ja0VxdWF0aW9uO1xuXG4vKipcbiAqIExvY2tzIHRoZSByZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHR3byBib2RpZXMuIFRoZSBjb25zdHJhaW50IHRyaWVzIHRvIGtlZXAgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdHdvIHZlY3RvcnMsIGxvY2FsIGluIGVhY2ggYm9keSwgdG8gemVyby4gVGhlIGxvY2FsIGFuZ2xlIGluIGJvZHkgaSBpcyBhIHBhcmFtZXRlci5cbiAqXG4gKiBAY2xhc3MgQW5nbGVMb2NrRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZV0gQW5nbGUgdG8gYWRkIHRvIHRoZSBsb2NhbCB2ZWN0b3IgaW4gYm9keSBBLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhdGlvXSBHZWFyIHJhdGlvXG4gKi9cbmZ1bmN0aW9uIEFuZ2xlTG9ja0VxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLGJvZHlBLGJvZHlCLC1OdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUpO1xuICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmFuZ2xlIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ2VhciByYXRpby5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmF0aW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUgc2V0UmF0aW9cbiAgICAgKi9cbiAgICB0aGlzLnJhdGlvID0gdHlwZW9mKG9wdGlvbnMucmF0aW8pPT09XCJudW1iZXJcIiA/IG9wdGlvbnMucmF0aW8gOiAxO1xuXG4gICAgdGhpcy5zZXRSYXRpbyh0aGlzLnJhdGlvKTtcbn1cbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQW5nbGVMb2NrRXF1YXRpb247XG5cbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnJhdGlvICogdGhpcy5ib2R5QS5hbmdsZSAtIHRoaXMuYm9keUIuYW5nbGUgKyB0aGlzLmFuZ2xlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGdlYXIgcmF0aW8gZm9yIHRoaXMgZXF1YXRpb25cbiAqIEBtZXRob2Qgc2V0UmF0aW9cbiAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xuICovXG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUuc2V0UmF0aW8gPSBmdW5jdGlvbihyYXRpbyl7XG4gICAgdmFyIEcgPSB0aGlzLkc7XG4gICAgR1syXSA9ICByYXRpbztcbiAgICBHWzVdID0gLTE7XG4gICAgdGhpcy5yYXRpbyA9IHJhdGlvO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCBmb3JjZSBmb3IgdGhlIGVxdWF0aW9uLlxuICogQG1ldGhvZCBzZXRNYXhUb3JxdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3JxdWVcbiAqL1xuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLnNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uKHRvcnF1ZSl7XG4gICAgdGhpcy5tYXhGb3JjZSA9ICB0b3JxdWU7XG4gICAgdGhpcy5taW5Gb3JjZSA9IC10b3JxdWU7XG59O1xuIiwidmFyIEVxdWF0aW9uID0gcmVxdWlyZShcIi4vRXF1YXRpb25cIiksXG4gICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RFcXVhdGlvbjtcblxuLyoqXG4gKiBOb24tcGVuZXRyYXRpb24gY29uc3RyYWludCBlcXVhdGlvbi4gVHJpZXMgdG8gbWFrZSB0aGUgY29udGFjdFBvaW50QSBhbmQgY29udGFjdFBvaW50QiB2ZWN0b3JzIGNvaW5jaWRlLCB3aGlsZSBrZWVwaW5nIHRoZSBhcHBsaWVkIGZvcmNlIHJlcHVsc2l2ZS5cbiAqXG4gKiBAY2xhc3MgQ29udGFjdEVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbmZ1bmN0aW9uIENvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIpe1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAwLCBOdW1iZXIuTUFYX1ZBTFVFKTtcblxuICAgIC8qKlxuICAgICAqIFZlY3RvciBmcm9tIGJvZHkgaSBjZW50ZXIgb2YgbWFzcyB0byB0aGUgY29udGFjdCBwb2ludC5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RQb2ludEEgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHRoaXMucGVuZXRyYXRpb25WZWMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogV29ybGQtb3JpZW50ZWQgdmVjdG9yIGZyb20gYm9keSBBIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBjb250YWN0IHBvaW50LlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRCXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFBvaW50QiA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbm9ybWFsIHZlY3RvciwgcG9pbnRpbmcgb3V0IG9mIGJvZHkgaVxuICAgICAqIEBwcm9wZXJ0eSBub3JtYWxBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubm9ybWFsQSA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdGl0dXRpb24gdG8gdXNlICgwPW5vIGJvdW5jaW5lc3MsIDE9bWF4IGJvdW5jaW5lc3MpLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0aXR1dGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHNldCB0byB0cnVlIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGltcGFjdCBiZXR3ZWVuIHRoZSBib2RpZXMgKG5vdCBwZXJzaXN0YW50IGNvbnRhY3QpLlxuICAgICAqIEBwcm9wZXJ0eSBmaXJzdEltcGFjdFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuZmlyc3RJbXBhY3QgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBpbiBib2R5IGkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjb250YWN0LlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUFcbiAgICAgKiBAdHlwZSB7U2hhcGV9XG4gICAgICovXG4gICAgdGhpcy5zaGFwZUEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlIGluIGJvZHkgaiB0aGF0IHRyaWdnZXJlZCB0aGlzIGNvbnRhY3QuXG4gICAgICogQHByb3BlcnR5IHNoYXBlQlxuICAgICAqIEB0eXBlIHtTaGFwZX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQiA9IG51bGw7XG59XG5Db250YWN0RXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Db250YWN0RXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udGFjdEVxdWF0aW9uO1xuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHJpID0gdGhpcy5jb250YWN0UG9pbnRBLFxuICAgICAgICByaiA9IHRoaXMuY29udGFjdFBvaW50QixcbiAgICAgICAgeGkgPSBiaS5wb3NpdGlvbixcbiAgICAgICAgeGogPSBiai5wb3NpdGlvbjtcblxuICAgIHZhciBwZW5ldHJhdGlvblZlYyA9IHRoaXMucGVuZXRyYXRpb25WZWMsXG4gICAgICAgIG4gPSB0aGlzLm5vcm1hbEEsXG4gICAgICAgIEcgPSB0aGlzLkc7XG5cbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICB2YXIgcml4biA9IHZlYzIuY3Jvc3NMZW5ndGgocmksbiksXG4gICAgICAgIHJqeG4gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJqLG4pO1xuXG4gICAgLy8gRyA9IFstbiAtcml4biBuIHJqeG5dXG4gICAgR1swXSA9IC1uWzBdO1xuICAgIEdbMV0gPSAtblsxXTtcbiAgICBHWzJdID0gLXJpeG47XG4gICAgR1szXSA9IG5bMF07XG4gICAgR1s0XSA9IG5bMV07XG4gICAgR1s1XSA9IHJqeG47XG5cbiAgICAvLyBDYWxjdWxhdGUgcSA9IHhqK3JqIC0oeGkrcmkpIGkuZS4gdGhlIHBlbmV0cmF0aW9uIHZlY3RvclxuICAgIHZlYzIuYWRkKHBlbmV0cmF0aW9uVmVjLHhqLHJqKTtcbiAgICB2ZWMyLnN1YihwZW5ldHJhdGlvblZlYyxwZW5ldHJhdGlvblZlYyx4aSk7XG4gICAgdmVjMi5zdWIocGVuZXRyYXRpb25WZWMscGVuZXRyYXRpb25WZWMscmkpO1xuXG4gICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cbiAgICB2YXIgR1csIEdxO1xuICAgIGlmKHRoaXMuZmlyc3RJbXBhY3QgJiYgdGhpcy5yZXN0aXR1dGlvbiAhPT0gMCl7XG4gICAgICAgIEdxID0gMDtcbiAgICAgICAgR1cgPSAoMS9iKSooMSt0aGlzLnJlc3RpdHV0aW9uKSAqIHRoaXMuY29tcHV0ZUdXKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgR3EgPSB2ZWMyLmRvdChuLHBlbmV0cmF0aW9uVmVjKSArIHRoaXMub2Zmc2V0O1xuICAgICAgICBHVyA9IHRoaXMuY29tcHV0ZUdXKCk7XG4gICAgfVxuXG4gICAgdmFyIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG4gICAgdmFyIEIgPSAtIEdxICogYSAtIEdXICogYiAtIGgqR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gRXF1YXRpb247XG5cbnZhciB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJyksXG4gICAgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpLFxuICAgIEJvZHkgPSByZXF1aXJlKCcuLi9vYmplY3RzL0JvZHknKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBjb25zdHJhaW50IGVxdWF0aW9ucy5cbiAqIEBjbGFzcyBFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBIEZpcnN0IGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgZXF1YXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUIgU2Vjb25kIGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgZXF1YXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5Gb3JjZSBNaW5pbXVtIGZvcmNlIHRvIGFwcGx5LiBEZWZhdWx0OiAtTnVtYmVyLk1BWF9WQUxVRVxuICogQHBhcmFtIHtudW1iZXJ9IG1heEZvcmNlIE1heGltdW0gZm9yY2UgdG8gYXBwbHkuIERlZmF1bHQ6IE51bWJlci5NQVhfVkFMVUVcbiAqL1xuZnVuY3Rpb24gRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtaW5Gb3JjZSwgbWF4Rm9yY2Upe1xuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBmb3JjZSB0byBhcHBseSB3aGVuIHNvbHZpbmcuXG4gICAgICogQHByb3BlcnR5IG1pbkZvcmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pbkZvcmNlID0gdHlwZW9mKG1pbkZvcmNlKT09PVwidW5kZWZpbmVkXCIgPyAtTnVtYmVyLk1BWF9WQUxVRSA6IG1pbkZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogTWF4IGZvcmNlIHRvIGFwcGx5IHdoZW4gc29sdmluZy5cbiAgICAgKiBAcHJvcGVydHkgbWF4Rm9yY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4Rm9yY2UgPSB0eXBlb2YobWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IE51bWJlci5NQVhfVkFMVUUgOiBtYXhGb3JjZTtcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgY29uc3RyYWludFxuICAgICAqIEBwcm9wZXJ0eSBib2R5QVxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcblxuICAgIC8qKlxuICAgICAqIFNlY29uZCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbnN0cmFpbnRcbiAgICAgKiBAcHJvcGVydHkgYm9keUJcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIG9mIHRoaXMgZXF1YXRpb24uIFR5cGljYWxseSBjaG9zZW4gdG8gYSBsYXJnZSBudW1iZXIgKH4xZTcpLCBidXQgY2FuIGJlIGNob3NlbiBzb21ld2hhdCBmcmVlbHkgdG8gZ2V0IGEgc3RhYmxlIHNpbXVsYXRpb24uXG4gICAgICogQHByb3BlcnR5IHN0aWZmbmVzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdGlmZm5lc3MgPSBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgdGltZSBzdGVwcyBuZWVkZWQgdG8gc3RhYmlsaXplIHRoZSBjb25zdHJhaW50IGVxdWF0aW9uLiBUeXBpY2FsbHkgYmV0d2VlbiAzIGFuZCA1IHRpbWUgc3RlcHMuXG4gICAgICogQHByb3BlcnR5IHJlbGF4YXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVsYXhhdGlvbiA9IEVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBKYWNvYmlhbiBlbnRyeSBvZiB0aGlzIGVxdWF0aW9uLiA2IG51bWJlcnMsIDMgcGVyIGJvZHkgKHgseSxhbmdsZSkuXG4gICAgICogQHByb3BlcnR5IEdcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5HID0gbmV3IFV0aWxzLkFSUkFZX1RZUEUoNik7XG4gICAgZm9yKHZhciBpPTA7IGk8NjsgaSsrKXtcbiAgICAgICAgdGhpcy5HW2ldPTA7XG4gICAgfVxuXG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5hID0gMDtcbiAgICB0aGlzLmIgPSAwO1xuICAgIHRoaXMuZXBzaWxvbiA9IDA7XG4gICAgdGhpcy50aW1lU3RlcCA9IDEvNjA7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgc3RpZmZuZXNzIG9yIHJlbGF4YXRpb24gd2FzIGNoYW5nZWQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBuZWVkc1VwZGF0ZVxuICAgICAqL1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyBjb25zdHJhaW50IG11bHRpcGxpZXIgZnJvbSB0aGUgbGFzdCBzb2x2ZS4gVGhpcyBpcyBtb3N0bHkgZXF1aXZhbGVudCB0byB0aGUgZm9yY2UgcHJvZHVjZWQgYnkgdGhlIGNvbnN0cmFpbnQuXG4gICAgICogQHByb3BlcnR5IG11bHRpcGxpZXJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubXVsdGlwbGllciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSB2ZWxvY2l0eS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmVsYXRpdmVWZWxvY2l0eVxuICAgICAqL1xuICAgIHRoaXMucmVsYXRpdmVWZWxvY2l0eSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZXF1YXRpb24gaXMgZW5hYmxlZCBvciBub3QuIElmIHRydWUsIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNvbHZlci5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xufVxuRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXF1YXRpb247XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc3RpZmZuZXNzIHdoZW4gY3JlYXRpbmcgYSBuZXcgRXF1YXRpb24uXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gREVGQVVMVF9TVElGRk5FU1NcbiAqIEBkZWZhdWx0IDFlNlxuICovXG5FcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUyA9IDFlNjtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCByZWxheGF0aW9uIHdoZW4gY3JlYXRpbmcgYSBuZXcgRXF1YXRpb24uXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gREVGQVVMVF9SRUxBWEFUSU9OXG4gKiBAZGVmYXVsdCA0XG4gKi9cbkVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTiA9IDQ7XG5cbi8qKlxuICogQ29tcHV0ZSBTUE9PSyBwYXJhbWV0ZXJzIC5hLCAuYiBhbmQgLmVwc2lsb24gYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhcmFtZXRlcnMuIFNlZSBlcXVhdGlvbnMgOSwgMTAgYW5kIDExIGluIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci81RFYwNTgvVlQwOS9sZWN0dXJlcy9zcG9va25vdGVzLnBkZlwiPlNQT09LIG5vdGVzPC9hPi5cbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MsXG4gICAgICAgIGQgPSB0aGlzLnJlbGF4YXRpb24sXG4gICAgICAgIGggPSB0aGlzLnRpbWVTdGVwO1xuXG4gICAgdGhpcy5hID0gNC4wIC8gKGggKiAoMSArIDQgKiBkKSk7XG4gICAgdGhpcy5iID0gKDQuMCAqIGQpIC8gKDEgKyA0ICogZCk7XG4gICAgdGhpcy5lcHNpbG9uID0gNC4wIC8gKGggKiBoICogayAqICgxICsgNCAqIGQpKTtcblxuICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgYSBqYWNvYmlhbiBlbnRyeSB3aXRoIGNvcnJlc3BvbmRpbmcgcG9zaXRpb25zIG9yIHZlbG9jaXRpZXNcbiAqIEBtZXRob2QgZ211bHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmdtdWx0ID0gZnVuY3Rpb24oRyx2aSx3aSx2aix3ail7XG4gICAgcmV0dXJuICBHWzBdICogdmlbMF0gK1xuICAgICAgICAgICAgR1sxXSAqIHZpWzFdICtcbiAgICAgICAgICAgIEdbMl0gKiB3aSArXG4gICAgICAgICAgICBHWzNdICogdmpbMF0gK1xuICAgICAgICAgICAgR1s0XSAqIHZqWzFdICtcbiAgICAgICAgICAgIEdbNV0gKiB3ajtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFJIUyBvZiB0aGUgU1BPT0sgZXF1YXRpb25cbiAqIEBtZXRob2QgY29tcHV0ZUJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oYSxiLGgpe1xuICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCk7XG4gICAgdmFyIEdxID0gdGhpcy5jb21wdXRlR3EoKTtcbiAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICByZXR1cm4gLSBHcSAqIGEgLSBHVyAqIGIgLSBHaU1mKmg7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCpxLCB3aGVyZSBxIGFyZSB0aGUgZ2VuZXJhbGl6ZWQgYm9keSBjb29yZGluYXRlc1xuICogQG1ldGhvZCBjb21wdXRlR3FcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIHFpID0gdmVjMi5jcmVhdGUoKSxcbiAgICBxaiA9IHZlYzIuY3JlYXRlKCk7XG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHhpID0gYmkucG9zaXRpb24sXG4gICAgICAgIHhqID0gYmoucG9zaXRpb24sXG4gICAgICAgIGFpID0gYmkuYW5nbGUsXG4gICAgICAgIGFqID0gYmouYW5nbGU7XG5cbiAgICByZXR1cm4gdGhpcy5nbXVsdChHLCBxaSwgYWksIHFqLCBhaikgKyB0aGlzLm9mZnNldDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgR1xcKlcsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdXXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1cgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgdmkgPSBiaS52ZWxvY2l0eSxcbiAgICAgICAgdmogPSBiai52ZWxvY2l0eSxcbiAgICAgICAgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHksXG4gICAgICAgIHdqID0gYmouYW5ndWxhclZlbG9jaXR5O1xuICAgIHJldHVybiB0aGlzLmdtdWx0KEcsdmksd2ksdmosd2opICsgdGhpcy5yZWxhdGl2ZVZlbG9jaXR5O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqV2xhbWJkYSwgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllc1xuICogQG1ldGhvZCBjb21wdXRlR1dsYW1iZGFcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHV2xhbWJkYSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEcgPSB0aGlzLkcsXG4gICAgICAgIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICB2aSA9IGJpLnZsYW1iZGEsXG4gICAgICAgIHZqID0gYmoudmxhbWJkYSxcbiAgICAgICAgd2kgPSBiaS53bGFtYmRhLFxuICAgICAgICB3aiA9IGJqLndsYW1iZGE7XG4gICAgcmV0dXJuIHRoaXMuZ211bHQoRyx2aSx3aSx2aix3aik7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCppbnYoTSlcXCpmLCB3aGVyZSBNIGlzIHRoZSBtYXNzIG1hdHJpeCB3aXRoIGRpYWdvbmFsIGJsb2NrcyBmb3IgZWFjaCBib2R5LCBhbmQgZiBhcmUgdGhlIGZvcmNlcyBvbiB0aGUgYm9kaWVzLlxuICogQG1ldGhvZCBjb21wdXRlR2lNZlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52YXIgaU1maSA9IHZlYzIuY3JlYXRlKCksXG4gICAgaU1maiA9IHZlYzIuY3JlYXRlKCk7XG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdpTWYgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgZmkgPSBiaS5mb3JjZSxcbiAgICAgICAgdGkgPSBiaS5hbmd1bGFyRm9yY2UsXG4gICAgICAgIGZqID0gYmouZm9yY2UsXG4gICAgICAgIHRqID0gYmouYW5ndWxhckZvcmNlLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBpbnZJaiA9IGJqLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIHZlYzIuc2NhbGUoaU1maSwgZmksaW52TWFzc2kpO1xuICAgIHZlYzIuc2NhbGUoaU1maiwgZmosaW52TWFzc2opO1xuXG4gICAgcmV0dXJuIHRoaXMuZ211bHQoRyxpTWZpLHRpKmludklpLGlNZmosdGoqaW52SWopO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqaW52KE0pXFwqRydcbiAqIEBtZXRob2QgY29tcHV0ZUdpTUd0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNR3QgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZJaSA9IGJpLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIEcgPSB0aGlzLkc7XG5cbiAgICByZXR1cm4gIEdbMF0gKiBHWzBdICogaW52TWFzc2kgK1xuICAgICAgICAgICAgR1sxXSAqIEdbMV0gKiBpbnZNYXNzaSArXG4gICAgICAgICAgICBHWzJdICogR1syXSAqICAgIGludklpICtcbiAgICAgICAgICAgIEdbM10gKiBHWzNdICogaW52TWFzc2ogK1xuICAgICAgICAgICAgR1s0XSAqIEdbNF0gKiBpbnZNYXNzaiArXG4gICAgICAgICAgICBHWzVdICogR1s1XSAqICAgIGludklqO1xufTtcblxudmFyIGFkZFRvV2xhbWJkYV90ZW1wID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfR2kgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9HaiA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX3JpID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfcmogPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9NZGlhZyA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQWRkIGNvbnN0cmFpbnQgdmVsb2NpdHkgdG8gdGhlIGJvZGllcy5cbiAqIEBtZXRob2QgYWRkVG9XbGFtYmRhXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFsYW1iZGFcbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmFkZFRvV2xhbWJkYSA9IGZ1bmN0aW9uKGRlbHRhbGFtYmRhKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHRlbXAgPSBhZGRUb1dsYW1iZGFfdGVtcCxcbiAgICAgICAgR2kgPSBhZGRUb1dsYW1iZGFfR2ksXG4gICAgICAgIEdqID0gYWRkVG9XbGFtYmRhX0dqLFxuICAgICAgICByaSA9IGFkZFRvV2xhbWJkYV9yaSxcbiAgICAgICAgcmogPSBhZGRUb1dsYW1iZGFfcmosXG4gICAgICAgIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52SWkgPSBiaS5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIGludklqID0gYmouaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBNZGlhZyA9IGFkZFRvV2xhbWJkYV9NZGlhZyxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIEdpWzBdID0gR1swXTtcbiAgICBHaVsxXSA9IEdbMV07XG4gICAgR2pbMF0gPSBHWzNdO1xuICAgIEdqWzFdID0gR1s0XTtcblxuICAgIC8vIEFkZCB0byBsaW5lYXIgdmVsb2NpdHlcbiAgICAvLyB2X2xhbWJkYSArPSBpbnYoTSkgKiBkZWx0YV9sYW1iYSAqIEdcbiAgICB2ZWMyLnNjYWxlKHRlbXAsIEdpLCBpbnZNYXNzaSpkZWx0YWxhbWJkYSk7XG4gICAgdmVjMi5hZGQoIGJpLnZsYW1iZGEsIGJpLnZsYW1iZGEsIHRlbXApO1xuICAgIC8vIFRoaXMgaW1wdWxzZSBpcyBpbiB0aGUgb2Zmc2V0IGZyYW1lXG4gICAgLy8gQWxzbyBhZGQgY29udHJpYnV0aW9uIHRvIGFuZ3VsYXJcbiAgICAvL2JpLndsYW1iZGEgLT0gdmVjMi5jcm9zc0xlbmd0aCh0ZW1wLHJpKTtcbiAgICBiaS53bGFtYmRhICs9IGludklpICogR1syXSAqIGRlbHRhbGFtYmRhO1xuXG5cbiAgICB2ZWMyLnNjYWxlKHRlbXAsIEdqLCBpbnZNYXNzaipkZWx0YWxhbWJkYSk7XG4gICAgdmVjMi5hZGQoIGJqLnZsYW1iZGEsIGJqLnZsYW1iZGEsIHRlbXApO1xuICAgIC8vYmoud2xhbWJkYSAtPSB2ZWMyLmNyb3NzTGVuZ3RoKHRlbXAscmopO1xuICAgIGJqLndsYW1iZGEgKz0gaW52SWogKiBHWzVdICogZGVsdGFsYW1iZGE7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGRlbm9taW5hdG9yIHBhcnQgb2YgdGhlIFNQT09LIGVxdWF0aW9uOiBDID0gR1xcKmludihNKVxcKkcnICsgZXBzXG4gKiBAbWV0aG9kIGNvbXB1dGVJbnZDXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVwc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUludkMgPSBmdW5jdGlvbihlcHMpe1xuICAgIHJldHVybiAxLjAgLyAodGhpcy5jb21wdXRlR2lNR3QoKSArIGVwcyk7XG59O1xuIiwidmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKVxuLCAgIEVxdWF0aW9uID0gcmVxdWlyZSgnLi9FcXVhdGlvbicpXG4sICAgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyaWN0aW9uRXF1YXRpb247XG5cbi8qKlxuICogQ29uc3RyYWlucyB0aGUgc2xpcHBpbmcgaW4gYSBjb250YWN0IGFsb25nIGEgdGFuZ2VudFxuICpcbiAqIEBjbGFzcyBGcmljdGlvbkVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzbGlwRm9yY2VcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKi9cbmZ1bmN0aW9uIEZyaWN0aW9uRXF1YXRpb24oYm9keUEsIGJvZHlCLCBzbGlwRm9yY2Upe1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtc2xpcEZvcmNlLCBzbGlwRm9yY2UpO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgdmVjdG9yIGZyb20gY2VudGVyIG9mIGJvZHkgQSB0byB0aGUgY29udGFjdCBwb2ludCwgd29ybGQgb3JpZW50ZWQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRBID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHZlY3RvciBmcm9tIGNlbnRlciBvZiBib2R5IEIgdG8gdGhlIGNvbnRhY3QgcG9pbnQsIHdvcmxkIG9yaWVudGVkLlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRCXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFBvaW50QiA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUYW5nZW50IHZlY3RvciB0aGF0IHRoZSBmcmljdGlvbiBmb3JjZSB3aWxsIGFjdCBhbG9uZy4gV29ybGQgb3JpZW50ZWQuXG4gICAgICogQHByb3BlcnR5IHRcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy50ID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEEgQ29udGFjdEVxdWF0aW9uIGNvbm5lY3RlZCB0byB0aGlzIGZyaWN0aW9uLiBUaGUgY29udGFjdCBlcXVhdGlvbnMgY2FuIGJlIHVzZWQgdG8gcmVzY2FsZSB0aGUgbWF4IGZvcmNlIGZvciB0aGUgZnJpY3Rpb24uIElmIG1vcmUgdGhhbiBvbmUgY29udGFjdCBlcXVhdGlvbiBpcyBnaXZlbiwgdGhlbiB0aGUgbWF4IGZvcmNlIGNhbiBiZSBzZXQgdG8gdGhlIGF2ZXJhZ2UuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RFcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7Q29udGFjdEVxdWF0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlIGluIGJvZHkgaSB0aGF0IHRyaWdnZXJlZCB0aGlzIGZyaWN0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUFcbiAgICAgKiBAdHlwZSB7U2hhcGV9XG4gICAgICogQHRvZG8gTmVlZGVkPyBUaGUgc2hhcGUgY2FuIGJlIGxvb2tlZCB1cCB2aWEgY29udGFjdEVxdWF0aW9uLnNoYXBlQS4uLlxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVBID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBpbiBib2R5IGogdGhhdCB0cmlnZ2VyZWQgdGhpcyBmcmljdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVCXG4gICAgICogQHR5cGUge1NoYXBlfVxuICAgICAqIEB0b2RvIE5lZWRlZD8gVGhlIHNoYXBlIGNhbiBiZSBsb29rZWQgdXAgdmlhIGNvbnRhY3RFcXVhdGlvbi5zaGFwZUIuLi5cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQiA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJpY3Rpb24gY29lZmZpY2llbnQgdG8gdXNlLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkNvZWZmaWNpZW50XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uQ29lZmZpY2llbnQgPSAwLjM7XG59XG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcmljdGlvbkVxdWF0aW9uO1xuXG4vKipcbiAqIFNldCB0aGUgc2xpcHBpbmcgY29uZGl0aW9uIGZvciB0aGUgY29uc3RyYWludC4gVGhlIGZyaWN0aW9uIGZvcmNlIGNhbm5vdCBiZVxuICogbGFyZ2VyIHRoYW4gdGhpcyB2YWx1ZS5cbiAqIEBtZXRob2Qgc2V0U2xpcEZvcmNlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHNsaXBGb3JjZVxuICovXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5zZXRTbGlwRm9yY2UgPSBmdW5jdGlvbihzbGlwRm9yY2Upe1xuICAgIHRoaXMubWF4Rm9yY2UgPSBzbGlwRm9yY2U7XG4gICAgdGhpcy5taW5Gb3JjZSA9IC1zbGlwRm9yY2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IGZvcmNlIGZvciB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2QgZ2V0U2xpcEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmdldFNsaXBGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubWF4Rm9yY2U7XG59O1xuXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHJpID0gdGhpcy5jb250YWN0UG9pbnRBLFxuICAgICAgICByaiA9IHRoaXMuY29udGFjdFBvaW50QixcbiAgICAgICAgdCA9IHRoaXMudCxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIC8vIEcgPSBbLXQgLXJpeHQgdCByanh0XVxuICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyFcbiAgICBHWzBdID0gLXRbMF07XG4gICAgR1sxXSA9IC10WzFdO1xuICAgIEdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChyaSx0KTtcbiAgICBHWzNdID0gdFswXTtcbiAgICBHWzRdID0gdFsxXTtcbiAgICBHWzVdID0gdmVjMi5jcm9zc0xlbmd0aChyaix0KTtcblxuICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICB2YXIgQiA9IC8qIC0gZyAqIGEgICovIC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuIiwidmFyIEVxdWF0aW9uID0gcmVxdWlyZShcIi4vRXF1YXRpb25cIiksXG4gICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxMb2NrRXF1YXRpb247XG5cbi8qKlxuICogTG9ja3MgdGhlIHJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdHdvIGJvZGllcy4gVGhlIGNvbnN0cmFpbnQgdHJpZXMgdG8ga2VlcCB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0d28gdmVjdG9ycywgbG9jYWwgaW4gZWFjaCBib2R5LCB0byB6ZXJvLiBUaGUgbG9jYWwgYW5nbGUgaW4gYm9keSBpIGlzIGEgcGFyYW1ldGVyLlxuICpcbiAqIEBjbGFzcyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5nbGVdIEFuZ2xlIHRvIGFkZCB0byB0aGUgbG9jYWwgdmVjdG9yIGluIGJvZHlBLlxuICovXG5mdW5jdGlvbiBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhbmdsZVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmFuZ2xlIHx8IDA7XG5cbiAgICB2YXIgRyA9IHRoaXMuRztcbiAgICBHWzJdID0gIDE7XG4gICAgR1s1XSA9IC0xO1xufVxuUm90YXRpb25hbExvY2tFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcblJvdGF0aW9uYWxMb2NrRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbExvY2tFcXVhdGlvbjtcblxudmFyIHdvcmxkVmVjdG9yQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgd29ybGRWZWN0b3JCID0gdmVjMi5jcmVhdGUoKSxcbiAgICB4QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygxLDApLFxuICAgIHlBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDAsMSk7XG5Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgIHZlYzIucm90YXRlKHdvcmxkVmVjdG9yQSx4QXhpcyx0aGlzLmJvZHlBLmFuZ2xlK3RoaXMuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkVmVjdG9yQix5QXhpcyx0aGlzLmJvZHlCLmFuZ2xlKTtcbiAgICByZXR1cm4gdmVjMi5kb3Qod29ybGRWZWN0b3JBLHdvcmxkVmVjdG9yQik7XG59O1xuIiwidmFyIEVxdWF0aW9uID0gcmVxdWlyZShcIi4vRXF1YXRpb25cIiksXG4gICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uO1xuXG4vKipcbiAqIFN5bmNzIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdHdvIGJvZGllcywgb3Igc2V0cyBhIHJlbGF0aXZlIHZlbG9jaXR5IChtb3RvcikuXG4gKlxuICogQGNsYXNzIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbmZ1bmN0aW9uIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB0aGlzLnJlbGF0aXZlVmVsb2NpdHkgPSAxO1xuICAgIHRoaXMucmF0aW8gPSAxO1xufVxuUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbjtcblJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgRyA9IHRoaXMuRztcbiAgICBHWzJdID0gLTE7XG4gICAgR1s1XSA9IHRoaXMucmF0aW87XG5cbiAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xuICAgIHZhciBCID0gLSBHVyAqIGIgLSBoKkdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG4iLCIvKipcbiAqIEJhc2UgY2xhc3MgZm9yIG9iamVjdHMgdGhhdCBkaXNwYXRjaGVzIGV2ZW50cy5cbiAqIEBjbGFzcyBFdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24gKCkge307XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBFdmVudEVtaXR0ZXIsXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAbWV0aG9kIG9uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIsIGNvbnRleHQgKSB7XG4gICAgICAgIGxpc3RlbmVyLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBldmVudCBsaXN0ZW5lciBpcyBhZGRlZFxuICAgICAqIEBtZXRob2QgaGFzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXM6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICBpZihsaXN0ZW5lcil7XG4gICAgICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKTtcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0uc3BsaWNlKCBpbmRleCwgMSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbWl0IGFuIGV2ZW50LlxuICAgICAqIEBtZXRob2QgZW1pdFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50LnR5cGVcbiAgICAgKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICB2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuICAgICAgICBpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBcnJheVsgaSBdO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoIGxpc3RlbmVyLmNvbnRleHQsIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcbiIsInZhciBNYXRlcmlhbCA9IHJlcXVpcmUoJy4vTWF0ZXJpYWwnKTtcbnZhciBFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RNYXRlcmlhbDtcblxuLyoqXG4gKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldCwgc3VjaCBhcyB3aGF0IGZyaWN0aW9uIGNvZWZmaWNpZW50IHRvIHVzZS4gWW91IGNhbiBhbHNvIHNldCBvdGhlciB0aGluZ3Mgc3VjaCBhcyByZXN0aXR1dGlvbiwgc3VyZmFjZSB2ZWxvY2l0eSBhbmQgY29uc3RyYWludCBwYXJhbWV0ZXJzLlxuICogQGNsYXNzIENvbnRhY3RNYXRlcmlhbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEFcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQlxuICogQHBhcmFtIHtPYmplY3R9ICAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5mcmljdGlvbj0wLjNdICAgICAgIEZyaWN0aW9uIGNvZWZmaWNpZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMucmVzdGl0dXRpb249MF0gICAgICBSZXN0aXR1dGlvbiBjb2VmZmljaWVudCBha2EgXCJib3VuY2luZXNzXCIuXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5zdGlmZm5lc3NdICAgICAgICAgIENvbnRhY3RFcXVhdGlvbiBzdGlmZm5lc3MuXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5yZWxheGF0aW9uXSAgICAgICAgIENvbnRhY3RFcXVhdGlvbiByZWxheGF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuZnJpY3Rpb25TdGlmZm5lc3NdICBGcmljdGlvbkVxdWF0aW9uIHN0aWZmbmVzcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbl0gRnJpY3Rpb25FcXVhdGlvbiByZWxheGF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuc3VyZmFjZVZlbG9jaXR5PTBdICBTdXJmYWNlIHZlbG9jaXR5LlxuICogQGF1dGhvciBzY2h0ZXBwZVxuICovXG5mdW5jdGlvbiBDb250YWN0TWF0ZXJpYWwobWF0ZXJpYWxBLCBtYXRlcmlhbEIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYoIShtYXRlcmlhbEEgaW5zdGFuY2VvZiBNYXRlcmlhbCkgfHwgIShtYXRlcmlhbEIgaW5zdGFuY2VvZiBNYXRlcmlhbCkpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCB0d28gYXJndW1lbnRzIG11c3QgYmUgTWF0ZXJpYWwgaW5zdGFuY2VzLlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGFjdCBtYXRlcmlhbCBpZGVudGlmaWVyXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gQ29udGFjdE1hdGVyaWFsLmlkQ291bnRlcisrO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QgbWF0ZXJpYWwgcGFydGljaXBhdGluZyBpbiB0aGUgY29udGFjdCBtYXRlcmlhbFxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbEFcbiAgICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbEEgPSBtYXRlcmlhbEE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgbWF0ZXJpYWwgcGFydGljaXBhdGluZyBpbiB0aGUgY29udGFjdCBtYXRlcmlhbFxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbEJcbiAgICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbEIgPSBtYXRlcmlhbEI7XG5cbiAgICAvKipcbiAgICAgKiBGcmljdGlvbiB0byB1c2UgaW4gdGhlIGNvbnRhY3Qgb2YgdGhlc2UgdHdvIG1hdGVyaWFsc1xuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbiAgICA9ICB0eXBlb2Yob3B0aW9ucy5mcmljdGlvbikgICAgIT09IFwidW5kZWZpbmVkXCIgPyAgIE51bWJlcihvcHRpb25zLmZyaWN0aW9uKSAgICA6IDAuMztcblxuICAgIC8qKlxuICAgICAqIFJlc3RpdHV0aW9uIHRvIHVzZSBpbiB0aGUgY29udGFjdCBvZiB0aGVzZSB0d28gbWF0ZXJpYWxzXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gIHR5cGVvZihvcHRpb25zLnJlc3RpdHV0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMucmVzdGl0dXRpb24pIDogMC4wO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSByZXN1bHRpbmcgQ29udGFjdEVxdWF0aW9uIHRoYXQgdGhpcyBDb250YWN0TWF0ZXJpYWwgZ2VuZXJhdGVcbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9ICAgICAgICAgICAgdHlwZW9mKG9wdGlvbnMuc3RpZmZuZXNzKSAgICAgICAgICAgIT09IFwidW5kZWZpbmVkXCIgPyAgIE51bWJlcihvcHRpb25zLnN0aWZmbmVzcykgICA6IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXhhdGlvbiBvZiB0aGUgcmVzdWx0aW5nIENvbnRhY3RFcXVhdGlvbiB0aGF0IHRoaXMgQ29udGFjdE1hdGVyaWFsIGdlbmVyYXRlXG4gICAgICogQHByb3BlcnR5IHJlbGF4YXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVsYXhhdGlvbiA9ICAgICAgICAgICB0eXBlb2Yob3B0aW9ucy5yZWxheGF0aW9uKSAgICAgICAgICAhPT0gXCJ1bmRlZmluZWRcIiA/ICAgTnVtYmVyKG9wdGlvbnMucmVsYXhhdGlvbikgIDogRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSByZXN1bHRpbmcgRnJpY3Rpb25FcXVhdGlvbiB0aGF0IHRoaXMgQ29udGFjdE1hdGVyaWFsIGdlbmVyYXRlXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uU3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uU3RpZmZuZXNzID0gICAgdHlwZW9mKG9wdGlvbnMuZnJpY3Rpb25TdGlmZm5lc3MpICAgIT09IFwidW5kZWZpbmVkXCIgPyAgIE51bWJlcihvcHRpb25zLmZyaWN0aW9uU3RpZmZuZXNzKSAgIDogRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBSZWxheGF0aW9uIG9mIHRoZSByZXN1bHRpbmcgRnJpY3Rpb25FcXVhdGlvbiB0aGF0IHRoaXMgQ29udGFjdE1hdGVyaWFsIGdlbmVyYXRlXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uUmVsYXhhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblJlbGF4YXRpb24gPSAgIHR5cGVvZihvcHRpb25zLmZyaWN0aW9uUmVsYXhhdGlvbikgICE9PSBcInVuZGVmaW5lZFwiID8gICBOdW1iZXIob3B0aW9ucy5mcmljdGlvblJlbGF4YXRpb24pICA6IEVxdWF0aW9uLkRFRkFVTFRfUkVMQVhBVElPTjtcblxuICAgIC8qKlxuICAgICAqIFdpbGwgYWRkIHN1cmZhY2UgdmVsb2NpdHkgdG8gdGhpcyBtYXRlcmlhbC4gSWYgYm9keUEgcmVzdHMgb24gdG9wIGlmIGJvZHlCLCBhbmQgdGhlIHN1cmZhY2UgdmVsb2NpdHkgaXMgcG9zaXRpdmUsIGJvZHlBIHdpbGwgc2xpZGUgdG8gdGhlIHJpZ2h0LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdXJmYWNlVmVsb2NpdHlcbiAgICAgKi9cbiAgICB0aGlzLnN1cmZhY2VWZWxvY2l0eSA9IHR5cGVvZihvcHRpb25zLnN1cmZhY2VWZWxvY2l0eSkgICAgIT09IFwidW5kZWZpbmVkXCIgPyAgIE51bWJlcihvcHRpb25zLnN1cmZhY2VWZWxvY2l0eSkgICAgOiAwO1xuXG4gICAgLyoqXG4gICAgICogT2Zmc2V0IHRvIGJlIHNldCBvbiBDb250YWN0RXF1YXRpb25zLiBBIHBvc2l0aXZlIHZhbHVlIHdpbGwgbWFrZSB0aGUgYm9kaWVzIHBlbmV0cmF0ZSBtb3JlIGludG8gZWFjaCBvdGhlci4gQ2FuIGJlIHVzZWZ1bCBpbiBzY2VuZXMgd2hlcmUgY29udGFjdHMgbmVlZCB0byBiZSBtb3JlIHBlcnNpc3RlbnQsIGZvciBleGFtcGxlIHdoZW4gc3RhY2tpbmcuIEFrYSBcImN1cmUgZm9yIG5lcnZvdXMgY29udGFjdHNcIi5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFNraW5TaXplXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RTa2luU2l6ZSA9IDAuMDA1O1xufVxuXG5Db250YWN0TWF0ZXJpYWwuaWRDb3VudGVyID0gMDtcbiIsIm1vZHVsZS5leHBvcnRzID0gTWF0ZXJpYWw7XG5cbi8qKlxuICogRGVmaW5lcyBhIHBoeXNpY3MgbWF0ZXJpYWwuXG4gKiBAY2xhc3MgTWF0ZXJpYWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGlkIE1hdGVyaWFsIGlkZW50aWZpZXJcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gTWF0ZXJpYWwoaWQpe1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXRlcmlhbCBpZGVudGlmaWVyXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gaWQgfHwgTWF0ZXJpYWwuaWRDb3VudGVyKys7XG59XG5cbk1hdGVyaWFsLmlkQ291bnRlciA9IDA7XG4iLCJcbiAgICAvKlxuICAgICAgICBQb2x5SyBsaWJyYXJ5XG4gICAgICAgIHVybDogaHR0cDovL3BvbHlrLml2YW5rLm5ldFxuICAgICAgICBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5jZS5cblxuICAgICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgSXZhbiBLdWNraXJcblxuICAgICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgICAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICAgICAgICBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAgICAgICAgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gICAgICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICAgICAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICAgICAgICBjb25kaXRpb25zOlxuXG4gICAgICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICAgICAgICBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgICAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICAgICAgICBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAgICAgICAgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gICAgICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAgICAgICAgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgICovXG5cbiAgICB2YXIgUG9seUsgPSB7fTtcblxuICAgIC8qXG4gICAgICAgIElzIFBvbHlnb24gc2VsZi1pbnRlcnNlY3Rpbmc/XG5cbiAgICAgICAgTyhuXjIpXG4gICAgKi9cbiAgICAvKlxuICAgIFBvbHlLLklzU2ltcGxlID0gZnVuY3Rpb24ocClcbiAgICB7XG4gICAgICAgIHZhciBuID0gcC5sZW5ndGg+PjE7XG4gICAgICAgIGlmKG48NCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBhMSA9IG5ldyBQb2x5Sy5fUCgpLCBhMiA9IG5ldyBQb2x5Sy5fUCgpO1xuICAgICAgICB2YXIgYjEgPSBuZXcgUG9seUsuX1AoKSwgYjIgPSBuZXcgUG9seUsuX1AoKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgUG9seUsuX1AoKTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGExLnggPSBwWzIqaSAgXTtcbiAgICAgICAgICAgIGExLnkgPSBwWzIqaSsxXTtcbiAgICAgICAgICAgIGlmKGk9PW4tMSkgIHsgYTIueCA9IHBbMCAgICBdOyAgYTIueSA9IHBbMSAgICBdOyB9XG4gICAgICAgICAgICBlbHNlICAgICAgICB7IGEyLnggPSBwWzIqaSsyXTsgIGEyLnkgPSBwWzIqaSszXTsgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGo9MDsgajxuOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoaS1qKSA8IDIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmKGo9PW4tMSAmJiBpPT0wKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZihpPT1uLTEgJiYgaj09MCkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBiMS54ID0gcFsyKmogIF07XG4gICAgICAgICAgICAgICAgYjEueSA9IHBbMipqKzFdO1xuICAgICAgICAgICAgICAgIGlmKGo9PW4tMSkgIHsgYjIueCA9IHBbMCAgICBdOyAgYjIueSA9IHBbMSAgICBdOyB9XG4gICAgICAgICAgICAgICAgZWxzZSAgICAgICAgeyBiMi54ID0gcFsyKmorMl07ICBiMi55ID0gcFsyKmorM107IH1cblxuICAgICAgICAgICAgICAgIGlmKFBvbHlLLl9HZXRMaW5lSW50ZXJzZWN0aW9uKGExLGEyLGIxLGIyLGMpICE9IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBQb2x5Sy5Jc0NvbnZleCA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICBpZihwLmxlbmd0aDw2KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDQ7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgICAgICBpZighUG9seUsuX2NvbnZleChwW2ldLCBwW2krMV0sIHBbaSsyXSwgcFtpKzNdLCBwW2krNF0sIHBbaSs1XSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYoIVBvbHlLLl9jb252ZXgocFtsICBdLCBwW2wrMV0sIHBbbCsyXSwgcFtsKzNdLCBwWzBdLCBwWzFdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZighUG9seUsuX2NvbnZleChwW2wrMl0sIHBbbCszXSwgcFswICBdLCBwWzEgIF0sIHBbMl0sIHBbM10pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAqL1xuICAgIFBvbHlLLkdldEFyZWEgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgaWYocC5sZW5ndGggPDYpIHJldHVybiAwO1xuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgICAgICBzdW0gKz0gKHBbaSsyXS1wW2ldKSAqIChwW2krMV0rcFtpKzNdKTtcbiAgICAgICAgc3VtICs9IChwWzBdLXBbbF0pICogKHBbbCsxXStwWzFdKTtcbiAgICAgICAgcmV0dXJuIC0gc3VtICogMC41O1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLkdldEFBQkIgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgdmFyIG1pbnggPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1pbnkgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1heHggPSAtbWlueDtcbiAgICAgICAgdmFyIG1heHkgPSAtbWlueTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1pbnggPSBNYXRoLm1pbihtaW54LCBwW2kgIF0pO1xuICAgICAgICAgICAgbWF4eCA9IE1hdGgubWF4KG1heHgsIHBbaSAgXSk7XG4gICAgICAgICAgICBtaW55ID0gTWF0aC5taW4obWlueSwgcFtpKzFdKTtcbiAgICAgICAgICAgIG1heHkgPSBNYXRoLm1heChtYXh5LCBwW2krMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eDptaW54LCB5Om1pbnksIHdpZHRoOm1heHgtbWlueCwgaGVpZ2h0Om1heHktbWlueX07XG4gICAgfVxuICAgICovXG5cbiAgICBQb2x5Sy5Ucmlhbmd1bGF0ZSA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xuICAgICAgICBpZihuPDMpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIHRncyA9IFtdO1xuICAgICAgICB2YXIgYXZsID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKykgYXZsLnB1c2goaSk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgYWwgPSBuO1xuICAgICAgICB3aGlsZShhbCA+IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpMCA9IGF2bFsoaSswKSVhbF07XG4gICAgICAgICAgICB2YXIgaTEgPSBhdmxbKGkrMSklYWxdO1xuICAgICAgICAgICAgdmFyIGkyID0gYXZsWyhpKzIpJWFsXTtcblxuICAgICAgICAgICAgdmFyIGF4ID0gcFsyKmkwXSwgIGF5ID0gcFsyKmkwKzFdO1xuICAgICAgICAgICAgdmFyIGJ4ID0gcFsyKmkxXSwgIGJ5ID0gcFsyKmkxKzFdO1xuICAgICAgICAgICAgdmFyIGN4ID0gcFsyKmkyXSwgIGN5ID0gcFsyKmkyKzFdO1xuXG4gICAgICAgICAgICB2YXIgZWFyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKFBvbHlLLl9jb252ZXgoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWFyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPGFsOyBqKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmkgPSBhdmxbal07XG4gICAgICAgICAgICAgICAgICAgIGlmKHZpPT1pMCB8fCB2aT09aTEgfHwgdmk9PWkyKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYoUG9seUsuX1BvaW50SW5UcmlhbmdsZShwWzIqdmldLCBwWzIqdmkrMV0sIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKSB7ZWFyRm91bmQgPSBmYWxzZTsgYnJlYWs7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGVhckZvdW5kKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRncy5wdXNoKGkwLCBpMSwgaTIpO1xuICAgICAgICAgICAgICAgIGF2bC5zcGxpY2UoKGkrMSklYWwsIDEpO1xuICAgICAgICAgICAgICAgIGFsLS07XG4gICAgICAgICAgICAgICAgaT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaSsrID4gMyphbCkgYnJlYWs7ICAgICAgLy8gbm8gY29udmV4IGFuZ2xlcyA6KFxuICAgICAgICB9XG4gICAgICAgIHRncy5wdXNoKGF2bFswXSwgYXZsWzFdLCBhdmxbMl0pO1xuICAgICAgICByZXR1cm4gdGdzO1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLkNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbihwLCBweCwgcHkpXG4gICAge1xuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xuICAgICAgICB2YXIgYXgsIGF5LCBieCA9IHBbMipuLTJdLXB4LCBieSA9IHBbMipuLTFdLXB5O1xuICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF4ID0gYng7ICBheSA9IGJ5O1xuICAgICAgICAgICAgYnggPSBwWzIqaSAgXSAtIHB4O1xuICAgICAgICAgICAgYnkgPSBwWzIqaSsxXSAtIHB5O1xuICAgICAgICAgICAgaWYoYXk8IDAgJiYgYnk8IDApIGNvbnRpbnVlOyAgICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG9ud1wiXG4gICAgICAgICAgICBpZihheT49MCAmJiBieT49MCkgY29udGludWU7ICAgIC8vIGJvdGggXCJ1cFwiIG9yIGJvdGggXCJkb253XCJcbiAgICAgICAgICAgIGlmKGF4PCAwICYmIGJ4PCAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGx4ID0gYXggKyAoYngtYXgpKigtYXkpLyhieS1heSk7XG4gICAgICAgICAgICBpZihseD4wKSBkZXB0aCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZGVwdGggJiAxKSA9PSAxO1xuICAgIH1cblxuICAgIFBvbHlLLlNsaWNlID0gZnVuY3Rpb24ocCwgYXgsIGF5LCBieCwgYnkpXG4gICAge1xuICAgICAgICBpZihQb2x5Sy5Db250YWluc1BvaW50KHAsIGF4LCBheSkgfHwgUG9seUsuQ29udGFpbnNQb2ludChwLCBieCwgYnkpKSByZXR1cm4gW3Auc2xpY2UoMCldO1xuXG4gICAgICAgIHZhciBhID0gbmV3IFBvbHlLLl9QKGF4LCBheSk7XG4gICAgICAgIHZhciBiID0gbmV3IFBvbHlLLl9QKGJ4LCBieSk7XG4gICAgICAgIHZhciBpc2NzID0gW107ICAvLyBpbnRlcnNlY3Rpb25zXG4gICAgICAgIHZhciBwcyA9IFtdOyAgICAvLyBwb2ludHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpIHBzLnB1c2gobmV3IFBvbHlLLl9QKHBbaV0sIHBbaSsxXSkpO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaXNjID0gbmV3IFBvbHlLLl9QKDAsMCk7XG4gICAgICAgICAgICBpc2MgPSBQb2x5Sy5fR2V0TGluZUludGVyc2VjdGlvbihhLCBiLCBwc1tpXSwgcHNbKGkrMSklcHMubGVuZ3RoXSwgaXNjKTtcblxuICAgICAgICAgICAgaWYoaXNjKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlzYy5mbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpc2NzLnB1c2goaXNjKTtcbiAgICAgICAgICAgICAgICBwcy5zcGxpY2UoaSsxLDAsaXNjKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNjcy5sZW5ndGggPT0gMCkgcmV0dXJuIFtwLnNsaWNlKDApXTtcbiAgICAgICAgdmFyIGNvbXAgPSBmdW5jdGlvbih1LHYpIHtyZXR1cm4gUG9seUsuX1AuZGlzdChhLHUpIC0gUG9seUsuX1AuZGlzdChhLHYpOyB9XG4gICAgICAgIGlzY3Muc29ydChjb21wKTtcblxuICAgICAgICB2YXIgcGdzID0gW107XG4gICAgICAgIHZhciBkaXIgPSAwO1xuICAgICAgICB3aGlsZShpc2NzLmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGkwID0gaXNjc1swXTtcbiAgICAgICAgICAgIHZhciBpMSA9IGlzY3NbMV07XG4gICAgICAgICAgICB2YXIgaW5kMCA9IHBzLmluZGV4T2YoaTApO1xuICAgICAgICAgICAgdmFyIGluZDEgPSBwcy5pbmRleE9mKGkxKTtcbiAgICAgICAgICAgIHZhciBzb2x2ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYoUG9seUsuX2ZpcnN0V2l0aEZsYWcocHMsIGluZDApID09IGluZDEpIHNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaTAgPSBpc2NzWzFdO1xuICAgICAgICAgICAgICAgIGkxID0gaXNjc1swXTtcbiAgICAgICAgICAgICAgICBpbmQwID0gcHMuaW5kZXhPZihpMCk7XG4gICAgICAgICAgICAgICAgaW5kMSA9IHBzLmluZGV4T2YoaTEpO1xuICAgICAgICAgICAgICAgIGlmKFBvbHlLLl9maXJzdFdpdGhGbGFnKHBzLCBpbmQwKSA9PSBpbmQxKSBzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc29sdmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpci0tO1xuICAgICAgICAgICAgICAgIHZhciBwZ24gPSBQb2x5Sy5fZ2V0UG9pbnRzKHBzLCBpbmQwLCBpbmQxKTtcbiAgICAgICAgICAgICAgICBwZ3MucHVzaChwZ24pO1xuICAgICAgICAgICAgICAgIHBzID0gUG9seUsuX2dldFBvaW50cyhwcywgaW5kMSwgaW5kMCk7XG4gICAgICAgICAgICAgICAgaTAuZmxhZyA9IGkxLmZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc2NzLnNwbGljZSgwLDIpO1xuICAgICAgICAgICAgICAgIGlmKGlzY3MubGVuZ3RoID09IDApIHBncy5wdXNoKHBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyBkaXIrKzsgaXNjcy5yZXZlcnNlKCk7IH1cbiAgICAgICAgICAgIGlmKGRpcj4xKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBncy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBnID0gcGdzW2ldO1xuICAgICAgICAgICAgdmFyIG5wZyA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8cGcubGVuZ3RoOyBqKyspIG5wZy5wdXNoKHBnW2pdLngsIHBnW2pdLnkpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnBnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIFBvbHlLLlJheWNhc3QgPSBmdW5jdGlvbihwLCB4LCB5LCBkeCwgZHksIGlzYylcbiAgICB7XG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICAgICAgICB2YXIgdHAgPSBQb2x5Sy5fdHA7XG4gICAgICAgIHZhciBhMSA9IHRwWzBdLCBhMiA9IHRwWzFdLFxuICAgICAgICBiMSA9IHRwWzJdLCBiMiA9IHRwWzNdLCBjID0gdHBbNF07XG4gICAgICAgIGExLnggPSB4OyBhMS55ID0geTtcbiAgICAgICAgYTIueCA9IHgrZHg7IGEyLnkgPSB5K2R5O1xuXG4gICAgICAgIGlmKGlzYz09bnVsbCkgaXNjID0ge2Rpc3Q6MCwgZWRnZTowLCBub3JtOnt4OjAsIHk6MH0sIHJlZmw6e3g6MCwgeTowfX07XG4gICAgICAgIGlzYy5kaXN0ID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bDsgaSs9MilcbiAgICAgICAge1xuICAgICAgICAgICAgYjEueCA9IHBbaSAgXTsgIGIxLnkgPSBwW2krMV07XG4gICAgICAgICAgICBiMi54ID0gcFtpKzJdOyAgYjIueSA9IHBbaSszXTtcbiAgICAgICAgICAgIHZhciBuaXNjID0gUG9seUsuX1JheUxpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpO1xuICAgICAgICAgICAgaWYobmlzYykgUG9seUsuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIGkvMiwgaXNjKTtcbiAgICAgICAgfVxuICAgICAgICBiMS54ID0gYjIueDsgIGIxLnkgPSBiMi55O1xuICAgICAgICBiMi54ID0gcFswXTsgIGIyLnkgPSBwWzFdO1xuICAgICAgICB2YXIgbmlzYyA9IFBvbHlLLl9SYXlMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKTtcbiAgICAgICAgaWYobmlzYykgUG9seUsuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIHAubGVuZ3RoLzIsIGlzYyk7XG5cbiAgICAgICAgcmV0dXJuIChpc2MuZGlzdCAhPSBJbmZpbml0eSkgPyBpc2MgOiBudWxsO1xuICAgIH1cblxuICAgIFBvbHlLLkNsb3Nlc3RFZGdlID0gZnVuY3Rpb24ocCwgeCwgeSwgaXNjKVxuICAgIHtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gICAgICAgIHZhciB0cCA9IFBvbHlLLl90cDtcbiAgICAgICAgdmFyIGExID0gdHBbMF0sXG4gICAgICAgIGIxID0gdHBbMl0sIGIyID0gdHBbM10sIGMgPSB0cFs0XTtcbiAgICAgICAgYTEueCA9IHg7IGExLnkgPSB5O1xuXG4gICAgICAgIGlmKGlzYz09bnVsbCkgaXNjID0ge2Rpc3Q6MCwgZWRnZTowLCBwb2ludDp7eDowLCB5OjB9LCBub3JtOnt4OjAsIHk6MH19O1xuICAgICAgICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGIxLnggPSBwW2kgIF07ICBiMS55ID0gcFtpKzFdO1xuICAgICAgICAgICAgYjIueCA9IHBbaSsyXTsgIGIyLnkgPSBwW2krM107XG4gICAgICAgICAgICBQb2x5Sy5fcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBpPj4xLCBpc2MpO1xuICAgICAgICB9XG4gICAgICAgIGIxLnggPSBiMi54OyAgYjEueSA9IGIyLnk7XG4gICAgICAgIGIyLnggPSBwWzBdOyAgYjIueSA9IHBbMV07XG4gICAgICAgIFBvbHlLLl9wb2ludExpbmVEaXN0KGExLCBiMSwgYjIsIGw+PjEsIGlzYyk7XG5cbiAgICAgICAgdmFyIGlkc3QgPSAxL2lzYy5kaXN0O1xuICAgICAgICBpc2Mubm9ybS54ID0gKHgtaXNjLnBvaW50LngpKmlkc3Q7XG4gICAgICAgIGlzYy5ub3JtLnkgPSAoeS1pc2MucG9pbnQueSkqaWRzdDtcbiAgICAgICAgcmV0dXJuIGlzYztcbiAgICB9XG5cbiAgICBQb2x5Sy5fcG9pbnRMaW5lRGlzdCA9IGZ1bmN0aW9uKHAsIGEsIGIsIGVkZ2UsIGlzYylcbiAgICB7XG4gICAgICAgIHZhciB4ID0gcC54LCB5ID0gcC55LCB4MSA9IGEueCwgeTEgPSBhLnksIHgyID0gYi54LCB5MiA9IGIueTtcblxuICAgICAgICB2YXIgQSA9IHggLSB4MTtcbiAgICAgICAgdmFyIEIgPSB5IC0geTE7XG4gICAgICAgIHZhciBDID0geDIgLSB4MTtcbiAgICAgICAgdmFyIEQgPSB5MiAtIHkxO1xuXG4gICAgICAgIHZhciBkb3QgPSBBICogQyArIEIgKiBEO1xuICAgICAgICB2YXIgbGVuX3NxID0gQyAqIEMgKyBEICogRDtcbiAgICAgICAgdmFyIHBhcmFtID0gZG90IC8gbGVuX3NxO1xuXG4gICAgICAgIHZhciB4eCwgeXk7XG5cbiAgICAgICAgaWYgKHBhcmFtIDwgMCB8fCAoeDEgPT0geDIgJiYgeTEgPT0geTIpKSB7XG4gICAgICAgICAgICB4eCA9IHgxO1xuICAgICAgICAgICAgeXkgPSB5MTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbSA+IDEpIHtcbiAgICAgICAgICAgIHh4ID0geDI7XG4gICAgICAgICAgICB5eSA9IHkyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeHggPSB4MSArIHBhcmFtICogQztcbiAgICAgICAgICAgIHl5ID0geTEgKyBwYXJhbSAqIEQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSB4IC0geHg7XG4gICAgICAgIHZhciBkeSA9IHkgLSB5eTtcbiAgICAgICAgdmFyIGRzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGlmKGRzdDxpc2MuZGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgaXNjLmRpc3QgPSBkc3Q7XG4gICAgICAgICAgICBpc2MuZWRnZSA9IGVkZ2U7XG4gICAgICAgICAgICBpc2MucG9pbnQueCA9IHh4O1xuICAgICAgICAgICAgaXNjLnBvaW50LnkgPSB5eTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFBvbHlLLl91cGRhdGVJU0MgPSBmdW5jdGlvbihkeCwgZHksIGExLCBiMSwgYjIsIGMsIGVkZ2UsIGlzYylcbiAgICB7XG4gICAgICAgIHZhciBucmwgPSBQb2x5Sy5fUC5kaXN0KGExLCBjKTtcbiAgICAgICAgaWYobnJsPGlzYy5kaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaWJsID0gMS9Qb2x5Sy5fUC5kaXN0KGIxLCBiMik7XG4gICAgICAgICAgICB2YXIgbnggPSAtKGIyLnktYjEueSkqaWJsO1xuICAgICAgICAgICAgdmFyIG55ID0gIChiMi54LWIxLngpKmlibDtcbiAgICAgICAgICAgIHZhciBkZG90ID0gMiooZHgqbngrZHkqbnkpO1xuICAgICAgICAgICAgaXNjLmRpc3QgPSBucmw7XG4gICAgICAgICAgICBpc2Mubm9ybS54ID0gbng7XG4gICAgICAgICAgICBpc2Mubm9ybS55ID0gbnk7XG4gICAgICAgICAgICBpc2MucmVmbC54ID0gLWRkb3QqbngrZHg7XG4gICAgICAgICAgICBpc2MucmVmbC55ID0gLWRkb3QqbnkrZHk7XG4gICAgICAgICAgICBpc2MuZWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBQb2x5Sy5fZ2V0UG9pbnRzID0gZnVuY3Rpb24ocHMsIGluZDAsIGluZDEpXG4gICAge1xuICAgICAgICB2YXIgbiA9IHBzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5wcyA9IFtdO1xuICAgICAgICBpZihpbmQxPGluZDApIGluZDEgKz0gbjtcbiAgICAgICAgZm9yKHZhciBpPWluZDA7IGk8PSBpbmQxOyBpKyspIG5wcy5wdXNoKHBzW2klbl0pO1xuICAgICAgICByZXR1cm4gbnBzO1xuICAgIH1cblxuICAgIFBvbHlLLl9maXJzdFdpdGhGbGFnID0gZnVuY3Rpb24ocHMsIGluZClcbiAgICB7XG4gICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSh0cnVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbmQgPSAoaW5kKzEpJW47XG4gICAgICAgICAgICBpZihwc1tpbmRdLmZsYWcpIHJldHVybiBpbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKi9cbiAgICBQb2x5Sy5fUG9pbnRJblRyaWFuZ2xlID0gZnVuY3Rpb24ocHgsIHB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KVxuICAgIHtcbiAgICAgICAgdmFyIHYweCA9IGN4LWF4O1xuICAgICAgICB2YXIgdjB5ID0gY3ktYXk7XG4gICAgICAgIHZhciB2MXggPSBieC1heDtcbiAgICAgICAgdmFyIHYxeSA9IGJ5LWF5O1xuICAgICAgICB2YXIgdjJ4ID0gcHgtYXg7XG4gICAgICAgIHZhciB2MnkgPSBweS1heTtcblxuICAgICAgICB2YXIgZG90MDAgPSB2MHgqdjB4K3YweSp2MHk7XG4gICAgICAgIHZhciBkb3QwMSA9IHYweCp2MXgrdjB5KnYxeTtcbiAgICAgICAgdmFyIGRvdDAyID0gdjB4KnYyeCt2MHkqdjJ5O1xuICAgICAgICB2YXIgZG90MTEgPSB2MXgqdjF4K3YxeSp2MXk7XG4gICAgICAgIHZhciBkb3QxMiA9IHYxeCp2MngrdjF5KnYyeTtcblxuICAgICAgICB2YXIgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKTtcbiAgICAgICAgdmFyIHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gICAgICAgIHZhciB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHBvaW50IGlzIGluIHRyaWFuZ2xlXG4gICAgICAgIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKTtcbiAgICB9XG4gICAgLypcbiAgICBQb2x5Sy5fUmF5TGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKVxuICAgIHtcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcbiAgICAgICAgdmFyIGRheSA9IChhMS55LWEyLnkpLCBkYnkgPSAoYjEueS1iMi55KTtcblxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XG4gICAgICAgIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGw7ICAvLyBwYXJhbGxlbFxuXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xuICAgICAgICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcblxuICAgICAgICB2YXIgSSA9IGM7XG4gICAgICAgIHZhciBpRGVuID0gMS9EZW47XG4gICAgICAgIEkueCA9ICggQSpkYnggLSBkYXgqQiApICogaURlbjtcbiAgICAgICAgSS55ID0gKCBBKmRieSAtIGRheSpCICkgKiBpRGVuO1xuXG4gICAgICAgIGlmKCFQb2x5Sy5fSW5SZWN0KEksIGIxLCBiMikpIHJldHVybiBudWxsO1xuICAgICAgICBpZigoZGF5PjAgJiYgSS55PmExLnkpIHx8IChkYXk8MCAmJiBJLnk8YTEueSkpIHJldHVybiBudWxsO1xuICAgICAgICBpZigoZGF4PjAgJiYgSS54PmExLngpIHx8IChkYXg8MCAmJiBJLng8YTEueCkpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gSTtcbiAgICB9XG5cbiAgICBQb2x5Sy5fR2V0TGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKVxuICAgIHtcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcbiAgICAgICAgdmFyIGRheSA9IChhMS55LWEyLnkpLCBkYnkgPSAoYjEueS1iMi55KTtcblxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XG4gICAgICAgIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGw7ICAvLyBwYXJhbGxlbFxuXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xuICAgICAgICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcblxuICAgICAgICB2YXIgSSA9IGM7XG4gICAgICAgIEkueCA9ICggQSpkYnggLSBkYXgqQiApIC8gRGVuO1xuICAgICAgICBJLnkgPSAoIEEqZGJ5IC0gZGF5KkIgKSAvIERlbjtcblxuICAgICAgICBpZihQb2x5Sy5fSW5SZWN0KEksIGExLCBhMikgJiYgUG9seUsuX0luUmVjdChJLCBiMSwgYjIpKSByZXR1cm4gSTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgUG9seUsuX0luUmVjdCA9IGZ1bmN0aW9uKGEsIGIsIGMpXG4gICAge1xuICAgICAgICBpZiAgKGIueCA9PSBjLngpIHJldHVybiAoYS55Pj1NYXRoLm1pbihiLnksIGMueSkgJiYgYS55PD1NYXRoLm1heChiLnksIGMueSkpO1xuICAgICAgICBpZiAgKGIueSA9PSBjLnkpIHJldHVybiAoYS54Pj1NYXRoLm1pbihiLngsIGMueCkgJiYgYS54PD1NYXRoLm1heChiLngsIGMueCkpO1xuXG4gICAgICAgIGlmKGEueCA+PSBNYXRoLm1pbihiLngsIGMueCkgJiYgYS54IDw9IE1hdGgubWF4KGIueCwgYy54KVxuICAgICAgICAmJiBhLnkgPj0gTWF0aC5taW4oYi55LCBjLnkpICYmIGEueSA8PSBNYXRoLm1heChiLnksIGMueSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgICovXG4gICAgUG9seUsuX2NvbnZleCA9IGZ1bmN0aW9uKGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpXG4gICAge1xuICAgICAgICByZXR1cm4gKGF5LWJ5KSooY3gtYngpICsgKGJ4LWF4KSooY3ktYnkpID49IDA7XG4gICAgfVxuICAgIC8qXG4gICAgUG9seUsuX1AgPSBmdW5jdGlvbih4LHkpXG4gICAge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLmZsYWcgPSBmYWxzZTtcbiAgICB9XG4gICAgUG9seUsuX1AucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFwiUG9pbnQgW1wiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiXVwiO1xuICAgIH1cbiAgICBQb2x5Sy5fUC5kaXN0ID0gZnVuY3Rpb24oYSxiKVxuICAgIHtcbiAgICAgICAgdmFyIGR4ID0gYi54LWEueDtcbiAgICAgICAgdmFyIGR5ID0gYi55LWEueTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcbiAgICB9XG5cbiAgICBQb2x5Sy5fdHAgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTwxMDsgaSsrKSBQb2x5Sy5fdHAucHVzaChuZXcgUG9seUsuX1AoMCwwKSk7XG4gICAgICAgICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9seUs7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBUaGUgdmVjMiBvYmplY3QgZnJvbSBnbE1hdHJpeCwgd2l0aCBzb21lIGV4dGVuc2lvbnMgYW5kIHNvbWUgcmVtb3ZlZCBtZXRob2RzLiBTZWUgaHR0cDovL2dsbWF0cml4Lm5ldC5cbiAqIEBjbGFzcyB2ZWMyXG4gKi9cblxudmFyIHZlYzIgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpO1xuXG4vKipcbiAqIE1ha2UgYSBjcm9zcyBwcm9kdWN0IGFuZCBvbmx5IHJldHVybiB0aGUgeiBjb21wb25lbnRcbiAqIEBtZXRob2QgY3Jvc3NMZW5ndGhcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52ZWMyLmNyb3NzTGVuZ3RoID0gZnVuY3Rpb24oYSxiKXtcbiAgICByZXR1cm4gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbn07XG5cbi8qKlxuICogQ3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIGEgdmVjdG9yIGFuZCB0aGUgWiBjb21wb25lbnQgb2YgYSB2ZWN0b3JcbiAqIEBtZXRob2QgY3Jvc3NWWlxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IHZlY1xuICogQHBhcmFtICB7TnVtYmVyfSB6Y29tcFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52ZWMyLmNyb3NzVlogPSBmdW5jdGlvbihvdXQsIHZlYywgemNvbXApe1xuICAgIHZlYzIucm90YXRlKG91dCx2ZWMsLU1hdGguUEkvMik7Ly8gUm90YXRlIGFjY29yZGluZyB0byB0aGUgcmlnaHQgaGFuZCBydWxlXG4gICAgdmVjMi5zY2FsZShvdXQsb3V0LHpjb21wKTsgICAgICAvLyBTY2FsZSB3aXRoIHpcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcm9zcyBwcm9kdWN0IGJldHdlZW4gYSB2ZWN0b3IgYW5kIHRoZSBaIGNvbXBvbmVudCBvZiBhIHZlY3RvclxuICogQG1ldGhvZCBjcm9zc1pWXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHpjb21wXG4gKiBAcGFyYW0gIHtBcnJheX0gdmVjXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZlYzIuY3Jvc3NaViA9IGZ1bmN0aW9uKG91dCwgemNvbXAsIHZlYyl7XG4gICAgdmVjMi5yb3RhdGUob3V0LHZlYyxNYXRoLlBJLzIpOyAvLyBSb3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByaWdodCBoYW5kIHJ1bGVcbiAgICB2ZWMyLnNjYWxlKG91dCxvdXQsemNvbXApOyAgICAgIC8vIFNjYWxlIHdpdGggelxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSBhbiBhbmdsZVxuICogQG1ldGhvZCByb3RhdGVcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbnZlYzIucm90YXRlID0gZnVuY3Rpb24ob3V0LGEsYW5nbGUpe1xuICAgIGlmKGFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBzID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgeCA9IGFbMF0sXG4gICAgICAgICAgICB5ID0gYVsxXTtcbiAgICAgICAgb3V0WzBdID0gYyp4IC1zKnk7XG4gICAgICAgIG91dFsxXSA9IHMqeCArYyp5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMV07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgOTAgZGVncmVlcyBjbG9ja3dpc2VcbiAqIEBtZXRob2Qgcm90YXRlOTBjd1xuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xudmVjMi5yb3RhdGU5MGN3ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdO1xuICAgIHZhciB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSB5O1xuICAgIG91dFsxXSA9IC14O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBwb2ludCBwb3NpdGlvbiB0byBsb2NhbCBmcmFtZS5cbiAqIEBtZXRob2QgdG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gd29ybGRQb2ludFxuICogQHBhcmFtICB7QXJyYXl9IGZyYW1lUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gZnJhbWVBbmdsZVxuICovXG52ZWMyLnRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uKG91dCwgd29ybGRQb2ludCwgZnJhbWVQb3NpdGlvbiwgZnJhbWVBbmdsZSl7XG4gICAgdmVjMi5jb3B5KG91dCwgd29ybGRQb2ludCk7XG4gICAgdmVjMi5zdWIob3V0LCBvdXQsIGZyYW1lUG9zaXRpb24pO1xuICAgIHZlYzIucm90YXRlKG91dCwgb3V0LCAtZnJhbWVBbmdsZSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHBvaW50IHBvc2l0aW9uIHRvIGdsb2JhbCBmcmFtZS5cbiAqIEBtZXRob2QgdG9HbG9iYWxGcmFtZVxuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IGxvY2FsUG9pbnRcbiAqIEBwYXJhbSAge0FycmF5fSBmcmFtZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGZyYW1lQW5nbGVcbiAqL1xudmVjMi50b0dsb2JhbEZyYW1lID0gZnVuY3Rpb24ob3V0LCBsb2NhbFBvaW50LCBmcmFtZVBvc2l0aW9uLCBmcmFtZUFuZ2xlKXtcbiAgICB2ZWMyLmNvcHkob3V0LCBsb2NhbFBvaW50KTtcbiAgICB2ZWMyLnJvdGF0ZShvdXQsIG91dCwgZnJhbWVBbmdsZSk7XG4gICAgdmVjMi5hZGQob3V0LCBvdXQsIGZyYW1lUG9zaXRpb24pO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIGNlbnRyb2lkIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB2ZWN0b3JzIGEsYixjLiBTZWUgaHR0cDovL2Vhc3ljYWxjdWxhdGlvbi5jb20vYW5hbHl0aWNhbC9sZWFybi1jZW50cm9pZC5waHBcbiAqIEBtZXRob2QgY2VudHJvaWRcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEByZXR1cm4gIHtBcnJheX0gVGhlIG91dCBvYmplY3RcbiAqL1xudmVjMi5jZW50cm9pZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gICAgdmVjMi5hZGQob3V0LCBhLCBiKTtcbiAgICB2ZWMyLmFkZChvdXQsIG91dCwgYyk7XG4gICAgdmVjMi5zY2FsZShvdXQsIG91dCwgMS8zKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNyZWF0ZVxuICogQHJldHVybiB7QXJyYXl9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybiB7QXJyYXl9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tVmFsdWVzXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBvdXQgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBzdWJ0cmFjdFxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuc3VidHJhY3RcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3ViXG4gKi9cbnZlYzIuc3ViID0gdmVjMi5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbXVsdGlwbHlcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLm11bHRpcGx5XG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG11bFxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRpdmlkZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLmRpdmlkZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXZcbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzY2FsZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRpc3RhbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5kaXN0YW5jZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXN0XG4gKi9cbnZlYzIuZGlzdCA9IHZlYzIuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHNxdWFyZWREaXN0YW5jZVxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLnNxdWFyZWREaXN0YW5jZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXJEaXN0XG4gKi9cbnZlYzIuc3FyRGlzdCA9IHZlYzIuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbGVuZ3RoXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIubGVuZ3RoXG4gKiBAbWV0aG9kIGxlblxuICogQHN0YXRpY1xuICovXG52ZWMyLmxlbiA9IHZlYzIubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXVhcmVkTGVuZ3RoXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm4ge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMyLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuc3F1YXJlZExlbmd0aFxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXJMZW5cbiAqL1xudmVjMi5zcXJMZW4gPSB2ZWMyLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbmVnYXRlXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZG90XG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzIuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzdHJcbiAqIEBwYXJhbSB7QXJyYXl9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcpJztcbn07XG5cbnZlYzIubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG4iLCJ2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXG4sICAgZGVjb21wID0gcmVxdWlyZSgncG9seS1kZWNvbXAnKVxuLCAgIENvbnZleCA9IHJlcXVpcmUoJy4uL3NoYXBlcy9Db252ZXgnKVxuLCAgIEFBQkIgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQUFCQicpXG4sICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RW1pdHRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJvZHk7XG5cbi8qKlxuICogQSByaWdpZCBib2R5LiBIYXMgZ290IGEgY2VudGVyIG9mIG1hc3MsIHBvc2l0aW9uLCB2ZWxvY2l0eSBhbmQgYSBudW1iZXIgb2ZcbiAqIHNoYXBlcyB0aGF0IGFyZSB1c2VkIGZvciBjb2xsaXNpb25zLlxuICpcbiAqIEBjbGFzcyBCb2R5XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMubWFzcz0wXSAgICBBIG51bWJlciA+PSAwLiBJZiB6ZXJvLCB0aGUgLnR5cGUgd2lsbCBiZSBzZXQgdG8gQm9keS5TVEFUSUMuXG4gKiBAcGFyYW0ge0FycmF5fSAgICAgICAgICAgICAgIFtvcHRpb25zLnBvc2l0aW9uXVxuICogQHBhcmFtIHtBcnJheX0gICAgICAgICAgICAgICBbb3B0aW9ucy52ZWxvY2l0eV1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMuYW5nbGU9MF1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMuYW5ndWxhclZlbG9jaXR5PTBdXG4gKiBAcGFyYW0ge0FycmF5fSAgICAgICAgICAgICAgIFtvcHRpb25zLmZvcmNlXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgICAgICBbb3B0aW9ucy5hbmd1bGFyRm9yY2U9MF1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMuZml4ZWRSb3RhdGlvbj1mYWxzZV1cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICAgICAgW29wdGlvbnMuY2NkU3BlZWRUaHJlc2hvbGQ9LTFdXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICAgICAgICAgIFtvcHRpb25zLmNjZEl0ZXJhdGlvbnM9MTBdXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgdHlwaWNhbCBkeW5hbWljIGJvZHlcbiAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHtcbiAqICAgICAgICAgbWFzczogMSxcbiAqICAgICAgICAgcG9zaXRpb246IFswLCAwXSxcbiAqICAgICAgICAgYW5nbGU6IDAsXG4gKiAgICAgICAgIHZlbG9jaXR5OiBbMCwgMF0sXG4gKiAgICAgICAgIGFuZ3VsYXJWZWxvY2l0eTogMFxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBBZGQgYSBjaXJjdWxhciBzaGFwZSB0byB0aGUgYm9keVxuICogICAgIGJvZHkuYWRkU2hhcGUobmV3IENpcmNsZSgxKSk7XG4gKlxuICogICAgIC8vIEFkZCB0aGUgYm9keSB0byB0aGUgd29ybGRcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHkpO1xuICovXG5mdW5jdGlvbiBCb2R5KG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm9keSBpZGVudGlmeWVyXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gKytCb2R5Ll9pZENvdW50ZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQgdGhhdCB0aGlzIGJvZHkgaXMgYWRkZWQgdG8uIFRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIE5VTEwgaWYgdGhlIGJvZHkgaXMgbm90IGFkZGVkIHRvIGFueSB3b3JsZC5cbiAgICAgKiBAcHJvcGVydHkgd29ybGRcbiAgICAgKiBAdHlwZSB7V29ybGR9XG4gICAgICovXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGVzIG9mIHRoZSBib2R5LiBUaGUgbG9jYWwgdHJhbnNmb3JtIG9mIHRoZSBzaGFwZSBpbiAuc2hhcGVzW2ldIGlzXG4gICAgICogZGVmaW5lZCBieSAuc2hhcGVPZmZzZXRzW2ldIGFuZCAuc2hhcGVBbmdsZXNbaV0uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc2hhcGVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWwgc2hhcGUgb2Zmc2V0cywgcmVsYXRpdmUgdG8gdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MuIFRoaXMgaXMgYW5cbiAgICAgKiBhcnJheSBvZiBBcnJheS5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVPZmZzZXRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVPZmZzZXRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm9keS1sb2NhbCBzaGFwZSBhbmdsZSB0cmFuc2Zvcm1zLiBUaGlzIGlzIGFuIGFycmF5IG9mIG51bWJlcnMgKGFuZ2xlcykuXG4gICAgICogQHByb3BlcnR5IHNoYXBlQW5nbGVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVBbmdsZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXNzIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBtYXNzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1hc3MgPSBvcHRpb25zLm1hc3MgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG1hc3Mgb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGludk1hc3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW52TWFzcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5lcnRpYSBvZiB0aGUgYm9keSBhcm91bmQgdGhlIFogYXhpcy5cbiAgICAgKiBAcHJvcGVydHkgaW5lcnRpYVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmVydGlhID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIGluZXJ0aWEgb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGludkluZXJ0aWFcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYSA9IDA7XG5cbiAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7XG4gICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gZml4IHRoZSByb3RhdGlvbiBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgZml4ZWRSb3RhdGlvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZml4ZWRSb3RhdGlvbiA9ICEhb3B0aW9ucy5maXhlZFJvdGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5XG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICBpZihvcHRpb25zLnBvc2l0aW9uKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucG9zaXRpb24sIG9wdGlvbnMucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnBvbGF0ZWQgcG9zaXRpb24gb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGludGVycG9sYXRlZFBvc2l0aW9uXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnBvbGF0ZWQgYW5nbGUgb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGludGVycG9sYXRlZEFuZ2xlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludGVycG9sYXRlZEFuZ2xlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyBwb3NpdGlvbiBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgcHJldmlvdXNQb3NpdGlvblxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyBhbmdsZSBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgcHJldmlvdXNBbmdsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wcmV2aW91c0FuZ2xlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZWxvY2l0eSBvZiB0aGUgYm9keVxuICAgICAqIEBwcm9wZXJ0eSB2ZWxvY2l0eVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlbG9jaXR5ID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG4gICAgaWYob3B0aW9ucy52ZWxvY2l0eSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLnZlbG9jaXR5LCBvcHRpb25zLnZlbG9jaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJhaW50IHZlbG9jaXR5IHRoYXQgd2FzIGFkZGVkIHRvIHRoZSBib2R5IGR1cmluZyB0aGUgbGFzdCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSB2bGFtYmRhXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmxhbWJkYSA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBjb25zdHJhaW50IHZlbG9jaXR5IHRoYXQgd2FzIGFkZGVkIHRvIHRoZSBib2R5IGR1cmluZyBsYXN0IHN0ZXAuXG4gICAgICogQHByb3BlcnR5IHdsYW1iZGFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy53bGFtYmRhID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmdsZSBvZiB0aGUgYm9keSwgaW4gcmFkaWFucy5cbiAgICAgKiBAcHJvcGVydHkgYW5nbGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIFRoZSBhbmdsZSBwcm9wZXJ0eSBpcyBub3Qgbm9ybWFsaXplZCB0byB0aGUgaW50ZXJ2YWwgMCB0byAyKnBpLCBpdCBjYW4gYmUgYW55IHZhbHVlLlxuICAgICAqICAgICAvLyBJZiB5b3UgbmVlZCBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMipwaSwgdXNlIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gdG8gbm9ybWFsaXplIGl0LlxuICAgICAqICAgICBmdW5jdGlvbiBub3JtYWxpemVBbmdsZShhbmdsZSl7XG4gICAgICogICAgICAgICBhbmdsZSA9IGFuZ2xlICUgKDIqTWF0aC5QSSk7XG4gICAgICogICAgICAgICBpZihhbmdsZSA8IDApe1xuICAgICAqICAgICAgICAgICAgIGFuZ2xlICs9ICgyKk1hdGguUEkpO1xuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGUgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSBib2R5LCBpbiByYWRpYW5zIHBlciBzZWNvbmQuXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJWZWxvY2l0eVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSBvcHRpb25zLmFuZ3VsYXJWZWxvY2l0eSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2luY2UgdGhlIGJvZHkgZm9yY2UgKGFuZCB7eyNjcm9zc0xpbmsgXCJCb2R5L2FuZ3VsYXJGb3JjZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSkgd2lsbCBiZSB6ZXJvZWQgYWZ0ZXIgZWFjaCBzdGVwLCBzbyB5b3UgbmVlZCB0byBzZXQgdGhlIGZvcmNlIGJlZm9yZSBlYWNoIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IGZvcmNlXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gVGhpcyBwcm9kdWNlcyBhIGZvcmNlZmllbGQgb2YgMSBOZXd0b24gaW4gdGhlIHBvc2l0aXZlIHggZGlyZWN0aW9uLlxuICAgICAqICAgICBmb3IodmFyIGk9MDsgaTxudW1TdGVwczsgaSsrKXtcbiAgICAgKiAgICAgICAgIGJvZHkuZm9yY2VbMF0gPSAxO1xuICAgICAqICAgICAgICAgd29ybGQuc3RlcCgxLzYwKTtcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gVGhpcyB3aWxsIGFwcGx5IGEgcm90YXRpb25hbCBmb3JjZSBvbiB0aGUgYm9keVxuICAgICAqICAgICBmb3IodmFyIGk9MDsgaTxudW1TdGVwczsgaSsrKXtcbiAgICAgKiAgICAgICAgIGJvZHkuYW5ndWxhckZvcmNlID0gLTM7XG4gICAgICogICAgICAgICB3b3JsZC5zdGVwKDEvNjApO1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgdGhpcy5mb3JjZSA9IHZlYzIuY3JlYXRlKCk7XG4gICAgaWYob3B0aW9ucy5mb3JjZSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmZvcmNlLCBvcHRpb25zLmZvcmNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5ndWxhciBmb3JjZSBhY3Rpbmcgb24gdGhlIGJvZHkuIFNlZSB7eyNjcm9zc0xpbmsgXCJCb2R5L2ZvcmNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyRm9yY2VcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYW5ndWxhckZvcmNlID0gb3B0aW9ucy5hbmd1bGFyRm9yY2UgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lYXIgZGFtcGluZyBhY3Rpbmcgb24gdGhlIGJvZHkgaW4gdGhlIHZlbG9jaXR5IGRpcmVjdGlvbi4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwcm9wZXJ0eSBkYW1waW5nXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjFcbiAgICAgKi9cbiAgICB0aGlzLmRhbXBpbmcgPSB0eXBlb2Yob3B0aW9ucy5kYW1waW5nKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMuZGFtcGluZyA6IDAuMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmd1bGFyIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyRGFtcGluZ1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4xXG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmFuZ3VsYXJEYW1waW5nKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMuYW5ndWxhckRhbXBpbmcgOiAwLjE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBtb3Rpb24gdGhpcyBib2R5IGhhcy4gU2hvdWxkIGJlIG9uZSBvZjoge3sjY3Jvc3NMaW5rIFwiQm9keS9TVEFUSUM6cHJvcGVydHlcIn19Qm9keS5TVEFUSUN7ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQm9keS9EWU5BTUlDOnByb3BlcnR5XCJ9fUJvZHkuRFlOQU1JQ3t7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJCb2R5L0tJTkVNQVRJQzpwcm9wZXJ0eVwifX1Cb2R5LktJTkVNQVRJQ3t7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogKiBTdGF0aWMgYm9kaWVzIGRvIG5vdCBtb3ZlLCBhbmQgdGhleSBkbyBub3QgcmVzcG9uZCB0byBmb3JjZXMgb3IgY29sbGlzaW9uLlxuICAgICAqICogRHluYW1pYyBib2RpZXMgYm9keSBjYW4gbW92ZSBhbmQgcmVzcG9uZCB0byBjb2xsaXNpb25zIGFuZCBmb3JjZXMuXG4gICAgICogKiBLaW5lbWF0aWMgYm9kaWVzIG9ubHkgbW92ZXMgYWNjb3JkaW5nIHRvIGl0cyAudmVsb2NpdHksIGFuZCBkb2VzIG5vdCByZXNwb25kIHRvIGNvbGxpc2lvbnMgb3IgZm9yY2UuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBCb2RpZXMgYXJlIHN0YXRpYyBieSBkZWZhdWx0LiBTdGF0aWMgYm9kaWVzIHdpbGwgbmV2ZXIgbW92ZS5cbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSgpO1xuICAgICAqICAgICBjb25zb2xlLmxvZyhib2R5LnR5cGUgPT0gQm9keS5TVEFUSUMpOyAvLyB0cnVlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBCeSBzZXR0aW5nIHRoZSBtYXNzIG9mIGEgYm9keSB0byBhIG5vbnplcm8gbnVtYmVyLCB0aGUgYm9keVxuICAgICAqICAgICAvLyB3aWxsIGJlY29tZSBkeW5hbWljIGFuZCB3aWxsIG1vdmUgYW5kIGludGVyYWN0IHdpdGggb3RoZXIgYm9kaWVzLlxuICAgICAqICAgICB2YXIgZHluYW1pY0JvZHkgPSBuZXcgQm9keSh7XG4gICAgICogICAgICAgICBtYXNzIDogMVxuICAgICAqICAgICB9KTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZHluYW1pY0JvZHkudHlwZSA9PSBCb2R5LkRZTkFNSUMpOyAvLyB0cnVlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBLaW5lbWF0aWMgYm9kaWVzIHdpbGwgb25seSBtb3ZlIGlmIHlvdSBjaGFuZ2UgdGhlaXIgdmVsb2NpdHkuXG4gICAgICogICAgIHZhciBraW5lbWF0aWNCb2R5ID0gbmV3IEJvZHkoe1xuICAgICAqICAgICAgICAgdHlwZTogQm9keS5LSU5FTUFUSUMgLy8gVHlwZSBjYW4gYmUgc2V0IHZpYSB0aGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogICAgIH0pO1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IEJvZHkuU1RBVElDO1xuXG4gICAgaWYodHlwZW9mKG9wdGlvbnMudHlwZSkgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIH0gZWxzZSBpZighb3B0aW9ucy5tYXNzKXtcbiAgICAgICAgdGhpcy50eXBlID0gQm9keS5TVEFUSUM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50eXBlID0gQm9keS5EWU5BTUlDO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJvdW5kaW5nIGNpcmNsZSByYWRpdXMuXG4gICAgICogQHByb3BlcnR5IGJvdW5kaW5nUmFkaXVzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gMDtcblxuICAgIC8qKlxuICAgICAqIEJvdW5kaW5nIGJveCBvZiB0aGlzIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGFhYmJcbiAgICAgKiBAdHlwZSB7QUFCQn1cbiAgICAgKi9cbiAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBBQUJCIG5lZWRzIHVwZGF0ZS4gVXBkYXRlIGl0IHdpdGgge3sjY3Jvc3NMaW5rIFwiQm9keS91cGRhdGVBQUJCOm1ldGhvZFwifX0udXBkYXRlQUFCQigpe3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IGFhYmJOZWVkc1VwZGF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBzZWUgdXBkYXRlQUFCQlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gRm9yY2UgdXBkYXRlIHRoZSBBQUJCXG4gICAgICogICAgIGJvZHkuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgKiAgICAgYm9keS51cGRhdGVBQUJCKCk7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkuYWFiYk5lZWRzVXBkYXRlKTsgLy8gZmFsc2VcbiAgICAgKi9cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYm9keSB3aWxsIGF1dG9tYXRpY2FsbHkgZmFsbCB0byBzbGVlcC4gTm90ZSB0aGF0IHlvdSBuZWVkIHRvIGVuYWJsZSBzbGVlcGluZyBpbiB0aGUge3sjY3Jvc3NMaW5rIFwiV29ybGRcIn19e3svY3Jvc3NMaW5rfX0gYmVmb3JlIGFueXRoaW5nIHdpbGwgaGFwcGVuLlxuICAgICAqIEBwcm9wZXJ0eSBhbGxvd1NsZWVwXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuYWxsb3dTbGVlcCA9IHRydWU7XG5cbiAgICB0aGlzLndhbnRzVG9TbGVlcCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogT25lIG9mIHt7I2Nyb3NzTGluayBcIkJvZHkvQVdBS0U6cHJvcGVydHlcIn19Qm9keS5BV0FLRXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJCb2R5L1NMRUVQWTpwcm9wZXJ0eVwifX1Cb2R5LlNMRUVQWXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJCb2R5L1NMRUVQSU5HOnByb3BlcnR5XCJ9fUJvZHkuU0xFRVBJTkd7ey9jcm9zc0xpbmt9fS5cbiAgICAgKlxuICAgICAqIFRoZSBib2R5IGlzIGluaXRpYWxseSBCb2R5LkFXQUtFLiBJZiBpdHMgdmVsb2NpdHkgbm9ybSBpcyBiZWxvdyAuc2xlZXBTcGVlZExpbWl0LCB0aGUgc2xlZXBTdGF0ZSB3aWxsIGJlY29tZSBCb2R5LlNMRUVQWS4gSWYgdGhlIGJvZHkgY29udGludWVzIHRvIGJlIEJvZHkuU0xFRVBZIGZvciAuc2xlZXBUaW1lTGltaXQgc2Vjb25kcywgaXQgd2lsbCBmYWxsIGFzbGVlcCAoQm9keS5TTEVFUFkpLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNsZWVwU3RhdGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IEJvZHkuQVdBS0VcbiAgICAgKi9cbiAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LkFXQUtFO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHNwZWVkICh0aGUgbm9ybSBvZiB0aGUgdmVsb2NpdHkpIGlzIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLCB0aGUgYm9keSBpcyBjb25zaWRlcmVkIHNsZWVweS5cbiAgICAgKiBAcHJvcGVydHkgc2xlZXBTcGVlZExpbWl0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjJcbiAgICAgKi9cbiAgICB0aGlzLnNsZWVwU3BlZWRMaW1pdCA9IDAuMjtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVweSBmb3IgdGhpcyBzbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCBpcyBjb25zaWRlcmVkIHNsZWVwaW5nLlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFRpbWVMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBUaW1lTGltaXQgPSAxO1xuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSBzY2FsaW5nIGZhY3Rvci4gSWYgeW91IHdhbnQgdGhlIGJvZHkgdG8gaWdub3JlIGdyYXZpdHksIHNldCB0aGlzIHRvIHplcm8uIElmIHlvdSB3YW50IHRvIHJldmVyc2UgZ3Jhdml0eSwgc2V0IGl0IHRvIC0xLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBncmF2aXR5U2NhbGVcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5ncmF2aXR5U2NhbGUgPSAxO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBwcm9kdWNlIGNvbnRhY3QgZm9yY2VzIHdoZW4gaW4gY29udGFjdCB3aXRoIG90aGVyIGJvZGllcy4gTm90ZSB0aGF0IGNvbnRhY3RzIHdpbGwgYmUgZ2VuZXJhdGVkLCBidXQgdGhleSB3aWxsIGJlIGRpc2FibGVkLiBUaGF0IG1lYW5zIHRoYXQgdGhpcyBib2R5IHdpbGwgbW92ZSB0aHJvdWdoIG90aGVyIGJvZGllcywgYnV0IGl0IHdpbGwgc3RpbGwgdHJpZ2dlciBjb250YWN0IGV2ZW50cywgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29sbGlzaW9uUmVzcG9uc2VcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvblJlc3BvbnNlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEhvdyBsb25nIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVwaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZGxlVGltZVxuICAgICAqL1xuICAgIHRoaXMuaWRsZVRpbWUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhc3QgdGltZSB3aGVuIHRoZSBib2R5IHdlbnQgdG8gU0xFRVBZIHN0YXRlLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0aW1lTGFzdFNsZWVweVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50aW1lTGFzdFNsZWVweSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYm9keSBzcGVlZCBleGNlZWRzIHRoaXMgdGhyZXNob2xkLCBDQ0QgKGNvbnRpbnVvdXMgY29sbGlzaW9uIGRldGVjdGlvbikgd2lsbCBiZSBlbmFibGVkLiBTZXQgaXQgdG8gYSBuZWdhdGl2ZSBudW1iZXIgdG8gZGlzYWJsZSBDQ0QgY29tcGxldGVseSBmb3IgdGhpcyBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjY2RTcGVlZFRocmVzaG9sZFxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jY2RTcGVlZFRocmVzaG9sZCA9IG9wdGlvbnMuY2NkU3BlZWRUaHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2NkU3BlZWRUaHJlc2hvbGQgOiAtMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gc2VhcmNoaW5nIGZvciB0aGUgdGltZSBvZiBpbXBhY3QgZHVyaW5nIENDRC4gQSBsYXJnZXIgbnVtYmVyIHdpbGwgYXNzdXJlIHRoYXQgdGhlcmUncyBhIHNtYWxsIHBlbmV0cmF0aW9uIG9uIENDRCBjb2xsaXNpb24sIGJ1dCBhIHNtYWxsIG51bWJlciB3aWxsIGdpdmUgbW9yZSBwZXJmb3JtYW5jZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY2NkSXRlcmF0aW9uc1xuICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICovXG4gICAgdGhpcy5jY2RJdGVyYXRpb25zID0gb3B0aW9ucy5jY2RJdGVyYXRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNjZEl0ZXJhdGlvbnMgOiAxMDtcblxuICAgIHRoaXMuY29uY2F2ZVBhdGggPSBudWxsO1xuXG4gICAgdGhpcy5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IGZhbHNlO1xuXG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xufVxuQm9keS5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5Cb2R5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJvZHk7XG5cbkJvZHkuX2lkQ291bnRlciA9IDA7XG5cbkJvZHkucHJvdG90eXBlLnVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXMgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyB8fCB0aGlzLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKXtcbiAgICAgICAgdGhpcy5pbnZNYXNzU29sdmUgPSAwO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFTb2x2ZSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnZNYXNzU29sdmUgPSB0aGlzLmludk1hc3M7XG4gICAgICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlID0gdGhpcy5pbnZJbmVydGlhO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IHRoZSB0b3RhbCBkZW5zaXR5IG9mIHRoZSBib2R5XG4gKiBAbWV0aG9kIHNldERlbnNpdHlcbiAqL1xuQm9keS5wcm90b3R5cGUuc2V0RGVuc2l0eSA9IGZ1bmN0aW9uKGRlbnNpdHkpIHtcbiAgICB2YXIgdG90YWxBcmVhID0gdGhpcy5nZXRBcmVhKCk7XG4gICAgdGhpcy5tYXNzID0gdG90YWxBcmVhICogZGVuc2l0eTtcbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdG90YWwgYXJlYSBvZiBhbGwgc2hhcGVzIGluIHRoZSBib2R5XG4gKiBAbWV0aG9kIGdldEFyZWFcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b3RhbEFyZWEgPSAwO1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdG90YWxBcmVhICs9IHRoaXMuc2hhcGVzW2ldLmFyZWE7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbEFyZWE7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgQUFCQiBmcm9tIHRoZSBib2R5LiBUaGUgQUFCQiBpcyB1cGRhdGVkIGlmIG5lY2Vzc2FyeS5cbiAqIEBtZXRob2QgZ2V0QUFCQlxuICovXG5Cb2R5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgIHRoaXMudXBkYXRlQUFCQigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hYWJiO1xufTtcblxudmFyIHNoYXBlQUFCQiA9IG5ldyBBQUJCKCksXG4gICAgdG1wID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBBQUJCIG9mIHRoZSBCb2R5XG4gKiBAbWV0aG9kIHVwZGF0ZUFBQkJcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlQUFCQiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgc2hhcGVPZmZzZXRzID0gdGhpcy5zaGFwZU9mZnNldHMsXG4gICAgICAgIHNoYXBlQW5nbGVzID0gdGhpcy5zaGFwZUFuZ2xlcyxcbiAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IHRtcCxcbiAgICAgICAgYm9keUFuZ2xlID0gdGhpcy5hbmdsZTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2ldLFxuICAgICAgICAgICAgYW5nbGUgPSBzaGFwZUFuZ2xlc1tpXSArIGJvZHlBbmdsZTtcblxuICAgICAgICAvLyBHZXQgc2hhcGUgd29ybGQgb2Zmc2V0XG4gICAgICAgIHZlYzIucm90YXRlKG9mZnNldCwgc2hhcGVPZmZzZXRzW2ldLCBib2R5QW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZChvZmZzZXQsIG9mZnNldCwgdGhpcy5wb3NpdGlvbik7XG5cbiAgICAgICAgLy8gR2V0IHNoYXBlIEFBQkJcbiAgICAgICAgc2hhcGUuY29tcHV0ZUFBQkIoc2hhcGVBQUJCLCBvZmZzZXQsIGFuZ2xlKTtcblxuICAgICAgICBpZihpPT09MCl7XG4gICAgICAgICAgICB0aGlzLmFhYmIuY29weShzaGFwZUFBQkIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hYWJiLmV4dGVuZChzaGFwZUFBQkIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdGhlIGJvZHkuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgc2hhcGVzXG4gKiBhcmUgY2hhbmdlZC5cbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgc2hhcGVPZmZzZXRzID0gdGhpcy5zaGFwZU9mZnNldHMsXG4gICAgICAgIE4gPSBzaGFwZXMubGVuZ3RoLFxuICAgICAgICByYWRpdXMgPSAwO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sXG4gICAgICAgICAgICBvZmZzZXQgPSB2ZWMyLmxlbmd0aChzaGFwZU9mZnNldHNbaV0pLFxuICAgICAgICAgICAgciA9IHNoYXBlLmJvdW5kaW5nUmFkaXVzO1xuICAgICAgICBpZihvZmZzZXQgKyByID4gcmFkaXVzKXtcbiAgICAgICAgICAgIHJhZGl1cyA9IG9mZnNldCArIHI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gcmFkaXVzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzaGFwZSB0byB0aGUgYm9keS4gWW91IGNhbiBwYXNzIGEgbG9jYWwgdHJhbnNmb3JtIHdoZW4gYWRkaW5nIGEgc2hhcGUsXG4gKiBzbyB0aGF0IHRoZSBzaGFwZSBnZXRzIGFuIG9mZnNldCBhbmQgYW5nbGUgcmVsYXRpdmUgdG8gdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MuXG4gKiBXaWxsIGF1dG9tYXRpY2FsbHkgdXBkYXRlIHRoZSBtYXNzIHByb3BlcnRpZXMgYW5kIGJvdW5kaW5nIHJhZGl1cy5cbiAqXG4gKiBAbWV0aG9kIGFkZFNoYXBlXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICAgICAgICAgIHNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gW29mZnNldF0gTG9jYWwgYm9keSBvZmZzZXQgb2YgdGhlIHNoYXBlLlxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgICAgICBbYW5nbGVdICBMb2NhbCBib2R5IGFuZ2xlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSgpLFxuICogICAgICAgICBzaGFwZSA9IG5ldyBDaXJjbGUoKTtcbiAqXG4gKiAgICAgLy8gQWRkIHRoZSBzaGFwZSB0byB0aGUgYm9keSwgcG9zaXRpb25lZCBpbiB0aGUgY2VudGVyXG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XG4gKlxuICogICAgIC8vIEFkZCBhbm90aGVyIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIDEgdW5pdCBsZW5ndGggZnJvbSB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcyBhbG9uZyB0aGUgbG9jYWwgeC1heGlzLlxuICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUsWzEsMF0pO1xuICpcbiAqICAgICAvLyBBZGQgYW5vdGhlciBzaGFwZSB0byB0aGUgYm9keSwgcG9zaXRpb25lZCAxIHVuaXQgbGVuZ3RoIGZyb20gdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MgYWxvbmcgdGhlIGxvY2FsIHktYXhpcywgYW5kIHJvdGF0ZWQgOTAgZGVncmVlcyBDQ1cuXG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSxbMCwxXSxNYXRoLlBJLzIpO1xuICovXG5Cb2R5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlLG9mZnNldCxhbmdsZSl7XG4gICAgYW5nbGUgPSBhbmdsZSB8fCAwLjA7XG5cbiAgICAvLyBDb3B5IHRoZSBvZmZzZXQgdmVjdG9yXG4gICAgaWYob2Zmc2V0KXtcbiAgICAgICAgb2Zmc2V0ID0gdmVjMi5mcm9tVmFsdWVzKG9mZnNldFswXSxvZmZzZXRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuICAgIH1cblxuICAgIHRoaXMuc2hhcGVzICAgICAgLnB1c2goc2hhcGUpO1xuICAgIHRoaXMuc2hhcGVPZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICB0aGlzLnNoYXBlQW5nbGVzIC5wdXNoKGFuZ2xlKTtcbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBzaGFwZVxuICogQG1ldGhvZCByZW1vdmVTaGFwZVxuICogQHBhcmFtICB7U2hhcGV9ICBzaGFwZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgVHJ1ZSBpZiB0aGUgc2hhcGUgd2FzIGZvdW5kIGFuZCByZW1vdmVkLCBlbHNlIGZhbHNlLlxuICovXG5Cb2R5LnByb3RvdHlwZS5yZW1vdmVTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlKXtcbiAgICB2YXIgaWR4ID0gdGhpcy5zaGFwZXMuaW5kZXhPZihzaGFwZSk7XG5cbiAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgdGhpcy5zaGFwZXMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgdGhpcy5zaGFwZU9mZnNldHMuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgdGhpcy5zaGFwZUFuZ2xlcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgLmluZXJ0aWEsIC5pbnZNYXNzLCAuaW52SW5lcnRpYSBmb3IgdGhpcyBCb2R5LiBTaG91bGQgYmUgY2FsbGVkIHdoZW5cbiAqIGNoYW5naW5nIHRoZSBzdHJ1Y3R1cmUgb3IgbWFzcyBvZiB0aGUgQm9keS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZU1hc3NQcm9wZXJ0aWVzXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICBib2R5Lm1hc3MgKz0gMTtcbiAqICAgICBib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gKi9cbkJvZHkucHJvdG90eXBlLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLnR5cGUgPT09IEJvZHkuU1RBVElDIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuXG4gICAgICAgIHRoaXMubWFzcyA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHRoaXMuaW52TWFzcyA9IDA7XG4gICAgICAgIHRoaXMuaW5lcnRpYSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgICAgIE4gPSBzaGFwZXMubGVuZ3RoLFxuICAgICAgICAgICAgbSA9IHRoaXMubWFzcyAvIE4sXG4gICAgICAgICAgICBJID0gMDtcblxuICAgICAgICBpZighdGhpcy5maXhlZFJvdGF0aW9uKXtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPE47IGkrKyl7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2ldLFxuICAgICAgICAgICAgICAgICAgICByMiA9IHZlYzIuc3F1YXJlZExlbmd0aCh0aGlzLnNoYXBlT2Zmc2V0c1tpXSksXG4gICAgICAgICAgICAgICAgICAgIEljbSA9IHNoYXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEobSk7XG4gICAgICAgICAgICAgICAgSSArPSBJY20gKyBtKnIyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmVydGlhID0gSTtcbiAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IEk+MCA/IDEvSSA6IDA7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB0aGlzLmludkluZXJ0aWEgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW52ZXJzZSBtYXNzIHByb3BlcnRpZXMgYXJlIGVhc3lcbiAgICAgICAgdGhpcy5pbnZNYXNzID0gMS90aGlzLm1hc3M7Ly8gPiAwID8gMS90aGlzLm1hc3MgOiAwO1xuICAgIH1cbn07XG5cbnZhciBCb2R5X2FwcGx5Rm9yY2VfciA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQXBwbHkgZm9yY2UgdG8gYSB3b3JsZCBwb2ludC4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBSaWdpZEJvZHkgc3VyZmFjZS4gQXBwbHlpbmcgZm9yY2UgdGhpcyB3YXkgd2lsbCBhZGQgdG8gQm9keS5mb3JjZSBhbmQgQm9keS5hbmd1bGFyRm9yY2UuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGZvcmNlIFRoZSBmb3JjZSB0byBhZGQuXG4gKiBAcGFyYW0ge0FycmF5fSB3b3JsZFBvaW50IEEgd29ybGQgcG9pbnQgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLlxuICovXG5Cb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oZm9yY2Usd29ybGRQb2ludCl7XG4gICAgLy8gQ29tcHV0ZSBwb2ludCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXJcbiAgICB2YXIgciA9IEJvZHlfYXBwbHlGb3JjZV9yO1xuICAgIHZlYzIuc3ViKHIsd29ybGRQb2ludCx0aGlzLnBvc2l0aW9uKTtcblxuICAgIC8vIEFkZCBsaW5lYXIgZm9yY2VcbiAgICB2ZWMyLmFkZCh0aGlzLmZvcmNlLHRoaXMuZm9yY2UsZm9yY2UpO1xuXG4gICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCByb3RhdGlvbmFsIGZvcmNlXG4gICAgdmFyIHJvdEZvcmNlID0gdmVjMi5jcm9zc0xlbmd0aChyLGZvcmNlKTtcblxuICAgIC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlXG4gICAgdGhpcy5hbmd1bGFyRm9yY2UgKz0gcm90Rm9yY2U7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHdvcmxkIHBvaW50IHRvIGxvY2FsIGJvZHkgZnJhbWUuXG4gKiBAbWV0aG9kIHRvTG9jYWxGcmFtZVxuICogQHBhcmFtICB7QXJyYXl9IG91dCAgICAgICAgICBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cbiAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFBvaW50ICAgVGhlIGlucHV0IHdvcmxkIHZlY3RvclxuICovXG5Cb2R5LnByb3RvdHlwZS50b0xvY2FsRnJhbWUgPSBmdW5jdGlvbihvdXQsIHdvcmxkUG9pbnQpe1xuICAgIHZlYzIudG9Mb2NhbEZyYW1lKG91dCwgd29ybGRQb2ludCwgdGhpcy5wb3NpdGlvbiwgdGhpcy5hbmdsZSk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGxvY2FsIHBvaW50IHRvIHdvcmxkIGZyYW1lLlxuICogQG1ldGhvZCB0b1dvcmxkRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXQgICAgICAgICAgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gKiBAcGFyYW0gIHtBcnJheX0gbG9jYWxQb2ludCAgIFRoZSBpbnB1dCBsb2NhbCB2ZWN0b3JcbiAqL1xuQm9keS5wcm90b3R5cGUudG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24ob3V0LCBsb2NhbFBvaW50KXtcbiAgICB2ZWMyLnRvR2xvYmFsRnJhbWUob3V0LCBsb2NhbFBvaW50LCB0aGlzLnBvc2l0aW9uLCB0aGlzLmFuZ2xlKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBwb2x5Z29uIHNoYXBlIHBhdGgsIGFuZCBhc3NlbWJsZXMgY29udmV4IHNoYXBlcyBmcm9tIHRoYXQgYW5kIHB1dHMgdGhlbSBhdCBwcm9wZXIgb2Zmc2V0IHBvaW50cy5cbiAqIEBtZXRob2QgZnJvbVBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggQW4gYXJyYXkgb2YgMmQgdmVjdG9ycywgZS5nLiBbWzAsMF0sWzAsMV0sLi4uXSB0aGF0IHJlc2VtYmxlcyBhIGNvbmNhdmUgb3IgY29udmV4IHBvbHlnb24uIFRoZSBzaGFwZSBtdXN0IGJlIHNpbXBsZSBhbmQgd2l0aG91dCBob2xlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3B0aW1hbERlY29tcD1mYWxzZV0gICBTZXQgdG8gdHJ1ZSBpZiB5b3UgbmVlZCBvcHRpbWFsIGRlY29tcG9zaXRpb24uIFdhcm5pbmc6IHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtb3JlIHRoYW4gMTAgdmVydGljZXMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBTaW1wbGVDaGVjaz1mYWxzZV0gU2V0IHRvIHRydWUgaWYgeW91IGFscmVhZHkga25vdyB0aGF0IHRoZSBwYXRoIGlzIG5vdCBpbnRlcnNlY3RpbmcgaXRzZWxmLlxuICogQHBhcmFtIHtCb29sZWFufE51bWJlcn0gW29wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzPWZhbHNlXSBTZXQgdG8gYSBudW1iZXIgKGFuZ2xlIHRocmVzaG9sZCB2YWx1ZSkgdG8gcmVtb3ZlIGNvbGxpbmVhciBwb2ludHMsIG9yIGZhbHNlIHRvIGtlZXAgYWxsIHBvaW50cy5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgb24gc3VjY2VzcywgZWxzZSBmYWxzZS5cbiAqL1xuQm9keS5wcm90b3R5cGUuZnJvbVBvbHlnb24gPSBmdW5jdGlvbihwYXRoLG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gUmVtb3ZlIGFsbCBzaGFwZXNcbiAgICBmb3IodmFyIGk9dGhpcy5zaGFwZXMubGVuZ3RoOyBpPj0wOyAtLWkpe1xuICAgICAgICB0aGlzLnJlbW92ZVNoYXBlKHRoaXMuc2hhcGVzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBkZWNvbXAuUG9seWdvbigpO1xuICAgIHAudmVydGljZXMgPSBwYXRoO1xuXG4gICAgLy8gTWFrZSBpdCBjb3VudGVyLWNsb2Nrd2lzZVxuICAgIHAubWFrZUNDVygpO1xuXG4gICAgaWYodHlwZW9mKG9wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICAgIHAucmVtb3ZlQ29sbGluZWFyUG9pbnRzKG9wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhbnkgbGluZSBzZWdtZW50IGludGVyc2VjdHMgdGhlIHBhdGggaXRzZWxmXG4gICAgaWYodHlwZW9mKG9wdGlvbnMuc2tpcFNpbXBsZUNoZWNrKSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIGlmKCFwLmlzU2ltcGxlKCkpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2F2ZSB0aGlzIHBhdGggZm9yIGxhdGVyXG4gICAgdGhpcy5jb25jYXZlUGF0aCA9IHAudmVydGljZXMuc2xpY2UoMCk7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5jb25jYXZlUGF0aC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gWzAsMF07XG4gICAgICAgIHZlYzIuY29weSh2LHRoaXMuY29uY2F2ZVBhdGhbaV0pO1xuICAgICAgICB0aGlzLmNvbmNhdmVQYXRoW2ldID0gdjtcbiAgICB9XG5cbiAgICAvLyBTbG93IG9yIGZhc3QgZGVjb21wP1xuICAgIHZhciBjb252ZXhlcztcbiAgICBpZihvcHRpb25zLm9wdGltYWxEZWNvbXApe1xuICAgICAgICBjb252ZXhlcyA9IHAuZGVjb21wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29udmV4ZXMgPSBwLnF1aWNrRGVjb21wKCk7XG4gICAgfVxuXG4gICAgdmFyIGNtID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8vIEFkZCBjb252ZXhlc1xuICAgIGZvcih2YXIgaT0wOyBpIT09Y29udmV4ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAvLyBDcmVhdGUgY29udmV4XG4gICAgICAgIHZhciBjID0gbmV3IENvbnZleChjb252ZXhlc1tpXS52ZXJ0aWNlcyk7XG5cbiAgICAgICAgLy8gTW92ZSBhbGwgdmVydGljZXMgc28gaXRzIGNlbnRlciBvZiBtYXNzIGlzIGluIHRoZSBsb2NhbCBjZW50ZXIgb2YgdGhlIGNvbnZleFxuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PWMudmVydGljZXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgdmFyIHYgPSBjLnZlcnRpY2VzW2pdO1xuICAgICAgICAgICAgdmVjMi5zdWIodix2LGMuY2VudGVyT2ZNYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzIuc2NhbGUoY20sYy5jZW50ZXJPZk1hc3MsMSk7XG4gICAgICAgIGMudXBkYXRlVHJpYW5nbGVzKCk7XG4gICAgICAgIGMudXBkYXRlQ2VudGVyT2ZNYXNzKCk7XG4gICAgICAgIGMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcblxuICAgICAgICAvLyBBZGQgdGhlIHNoYXBlXG4gICAgICAgIHRoaXMuYWRkU2hhcGUoYyxjbSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGp1c3RDZW50ZXJPZk1hc3MoKTtcblxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxudmFyIGFkanVzdENlbnRlck9mTWFzc190bXAxID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIGFkanVzdENlbnRlck9mTWFzc190bXA0ID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogTW92ZXMgdGhlIHNoYXBlIG9mZnNldHMgc28gdGhlaXIgY2VudGVyIG9mIG1hc3MgYmVjb21lcyB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcy5cbiAqIEBtZXRob2QgYWRqdXN0Q2VudGVyT2ZNYXNzXG4gKi9cbkJvZHkucHJvdG90eXBlLmFkanVzdENlbnRlck9mTWFzcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG9mZnNldF90aW1lc19hcmVhID0gYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDIsXG4gICAgICAgIHN1bSA9ICAgICAgICAgICAgICAgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDMsXG4gICAgICAgIGNtID0gICAgICAgICAgICAgICAgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDQsXG4gICAgICAgIHRvdGFsQXJlYSA9ICAgICAgICAgMDtcbiAgICB2ZWMyLnNldChzdW0sMCwwKTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09dGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2hhcGVzW2ldLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5zaGFwZU9mZnNldHNbaV07XG4gICAgICAgIHZlYzIuc2NhbGUob2Zmc2V0X3RpbWVzX2FyZWEsb2Zmc2V0LHMuYXJlYSk7XG4gICAgICAgIHZlYzIuYWRkKHN1bSxzdW0sb2Zmc2V0X3RpbWVzX2FyZWEpO1xuICAgICAgICB0b3RhbEFyZWEgKz0gcy5hcmVhO1xuICAgIH1cblxuICAgIHZlYzIuc2NhbGUoY20sc3VtLDEvdG90YWxBcmVhKTtcblxuICAgIC8vIE5vdyBtb3ZlIGFsbCBzaGFwZXNcbiAgICBmb3IodmFyIGk9MDsgaSE9PXRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNoYXBlc1tpXSxcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2hhcGVPZmZzZXRzW2ldO1xuXG4gICAgICAgIC8vIE9mZnNldCBtYXkgYmUgdW5kZWZpbmVkLiBGaXggdGhhdC5cbiAgICAgICAgaWYoIW9mZnNldCl7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNoYXBlT2Zmc2V0c1tpXSA9IHZlYzIuY3JlYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2ZWMyLnN1YihvZmZzZXQsb2Zmc2V0LGNtKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIHRoZSBib2R5IHBvc2l0aW9uIHRvb1xuICAgIHZlYzIuYWRkKHRoaXMucG9zaXRpb24sdGhpcy5wb3NpdGlvbixjbSk7XG5cbiAgICAvLyBBbmQgY29uY2F2ZSBwYXRoXG4gICAgZm9yKHZhciBpPTA7IHRoaXMuY29uY2F2ZVBhdGggJiYgaTx0aGlzLmNvbmNhdmVQYXRoLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmVjMi5zdWIodGhpcy5jb25jYXZlUGF0aFtpXSwgdGhpcy5jb25jYXZlUGF0aFtpXSwgY20pO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGZvcmNlIG9uIHRoZSBib2R5IHRvIHplcm8uXG4gKiBAbWV0aG9kIHNldFplcm9Gb3JjZVxuICovXG5Cb2R5LnByb3RvdHlwZS5zZXRaZXJvRm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZlYzIuc2V0KHRoaXMuZm9yY2UsMC4wLDAuMCk7XG4gICAgdGhpcy5hbmd1bGFyRm9yY2UgPSAwLjA7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICB2bGFtYmRhID0gYi52bGFtYmRhO1xuICAgIHZlYzIuc2V0KHZsYW1iZGEsMCwwKTtcbiAgICBiLndsYW1iZGEgPSAwO1xufTtcblxuQm9keS5wcm90b3R5cGUuYWRkQ29uc3RyYWludFZlbG9jaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgIHYgPSBiLnZlbG9jaXR5O1xuICAgIHZlYzIuYWRkKCB2LCB2LCBiLnZsYW1iZGEpO1xuICAgIGIuYW5ndWxhclZlbG9jaXR5ICs9IGIud2xhbWJkYTtcbn07XG5cbi8qKlxuICogQXBwbHkgZGFtcGluZywgc2VlIDxhIGhyZWY9XCJodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYnVsbGV0L2lzc3Vlcy9kZXRhaWw/aWQ9NzRcIj50aGlzPC9hPiBmb3IgZGV0YWlscy5cbiAqIEBtZXRob2QgYXBwbHlEYW1waW5nXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGR0IEN1cnJlbnQgdGltZSBzdGVwXG4gKi9cbkJvZHkucHJvdG90eXBlLmFwcGx5RGFtcGluZyA9IGZ1bmN0aW9uKGR0KXtcbiAgICBpZih0aGlzLnR5cGUgPT09IEJvZHkuRFlOQU1JQyl7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXG4gICAgICAgIHZhciB2ID0gdGhpcy52ZWxvY2l0eTtcbiAgICAgICAgdmVjMi5zY2FsZSh2LCB2LCBNYXRoLnBvdygxLjAgLSB0aGlzLmRhbXBpbmcsZHQpKTtcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKj0gTWF0aC5wb3coMS4wIC0gdGhpcy5hbmd1bGFyRGFtcGluZyxkdCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBXYWtlIHRoZSBib2R5IHVwLiBOb3JtYWxseSB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRoaXMsIGFzIHRoZSBib2R5IGlzIGF1dG9tYXRpY2FsbHkgYXdva2VuIGF0IGV2ZW50cyBzdWNoIGFzIGNvbGxpc2lvbnMuXG4gKiBTZXRzIHRoZSBzbGVlcFN0YXRlIHRvIHt7I2Nyb3NzTGluayBcIkJvZHkvQVdBS0U6cHJvcGVydHlcIn19Qm9keS5BV0FLRXt7L2Nyb3NzTGlua319IGFuZCBlbWl0cyB0aGUgd2FrZVVwIGV2ZW50IGlmIHRoZSBib2R5IHdhc24ndCBhd2FrZSBiZWZvcmUuXG4gKiBAbWV0aG9kIHdha2VVcFxuICovXG5Cb2R5LnByb3RvdHlwZS53YWtlVXAgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzID0gdGhpcy5zbGVlcFN0YXRlO1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuQVdBS0U7XG4gICAgdGhpcy5pZGxlVGltZSA9IDA7XG4gICAgaWYocyAhPT0gQm9keS5BV0FLRSl7XG4gICAgICAgIHRoaXMuZW1pdChCb2R5Lndha2VVcEV2ZW50KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZvcmNlIGJvZHkgc2xlZXBcbiAqIEBtZXRob2Qgc2xlZXBcbiAqL1xuQm9keS5wcm90b3R5cGUuc2xlZXAgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuU0xFRVBJTkc7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSAwO1xuICAgIHRoaXMuYW5ndWxhckZvcmNlID0gMDtcbiAgICB2ZWMyLnNldCh0aGlzLnZlbG9jaXR5LDAsMCk7XG4gICAgdmVjMi5zZXQodGhpcy5mb3JjZSwwLDApO1xuICAgIHRoaXMuZW1pdChCb2R5LnNsZWVwRXZlbnQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgZXZlcnkgdGltZXN0ZXAgdG8gdXBkYXRlIGludGVybmFsIHNsZWVwIHRpbWVyIGFuZCBjaGFuZ2Ugc2xlZXAgc3RhdGUgaWYgbmVlZGVkLlxuICogQG1ldGhvZCBzbGVlcFRpY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSB3b3JsZCB0aW1lIGluIHNlY29uZHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udFNsZWVwXG4gKiBAcGFyYW0ge251bWJlcn0gZHRcbiAqL1xuQm9keS5wcm90b3R5cGUuc2xlZXBUaWNrID0gZnVuY3Rpb24odGltZSwgZG9udFNsZWVwLCBkdCl7XG4gICAgaWYoIXRoaXMuYWxsb3dTbGVlcCB8fCB0aGlzLnR5cGUgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53YW50c1RvU2xlZXAgPSBmYWxzZTtcblxuICAgIHZhciBzbGVlcFN0YXRlID0gdGhpcy5zbGVlcFN0YXRlLFxuICAgICAgICBzcGVlZFNxdWFyZWQgPSB2ZWMyLnNxdWFyZWRMZW5ndGgodGhpcy52ZWxvY2l0eSkgKyBNYXRoLnBvdyh0aGlzLmFuZ3VsYXJWZWxvY2l0eSwyKSxcbiAgICAgICAgc3BlZWRMaW1pdFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnNsZWVwU3BlZWRMaW1pdCwyKTtcblxuICAgIC8vIEFkZCB0byBpZGxlIHRpbWVcbiAgICBpZihzcGVlZFNxdWFyZWQgPj0gc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICB0aGlzLmlkbGVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5BV0FLRTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlkbGVUaW1lICs9IGR0O1xuICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQWTtcbiAgICB9XG4gICAgaWYodGhpcy5pZGxlVGltZSA+IHRoaXMuc2xlZXBUaW1lTGltaXQpe1xuICAgICAgICBpZighZG9udFNsZWVwKXtcbiAgICAgICAgICAgIHRoaXMuc2xlZXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2FudHNUb1NsZWVwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgaWYoc2xlZXBTdGF0ZT09PUJvZHkuQVdBS0UgJiYgc3BlZWRTcXVhcmVkIDwgc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQWTsgLy8gU2xlZXB5XG4gICAgICAgIHRoaXMudGltZUxhc3RTbGVlcHkgPSB0aW1lO1xuICAgICAgICB0aGlzLmVtaXQoQm9keS5zbGVlcHlFdmVudCk7XG4gICAgfSBlbHNlIGlmKHNsZWVwU3RhdGU9PT1Cb2R5LlNMRUVQWSAmJiBzcGVlZFNxdWFyZWQgPj0gc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICB0aGlzLndha2VVcCgpOyAvLyBXYWtlIHVwXG4gICAgfSBlbHNlIGlmKHNsZWVwU3RhdGU9PT1Cb2R5LlNMRUVQWSAmJiAodGltZSAtIHRoaXMudGltZUxhc3RTbGVlcHkgKSA+IHRoaXMuc2xlZXBUaW1lTGltaXQpe1xuICAgICAgICB0aGlzLndhbnRzVG9TbGVlcCA9IHRydWU7XG4gICAgICAgIGlmKCFkb250U2xlZXApe1xuICAgICAgICAgICAgdGhpcy5zbGVlcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICovXG59O1xuXG5Cb2R5LnByb3RvdHlwZS5nZXRWZWxvY2l0eUZyb21Qb3NpdGlvbiA9IGZ1bmN0aW9uKHN0b3JlLCB0aW1lU3RlcCl7XG4gICAgc3RvcmUgPSBzdG9yZSB8fCB2ZWMyLmNyZWF0ZSgpO1xuICAgIHZlYzIuc3ViKHN0b3JlLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnByZXZpb3VzUG9zaXRpb24pO1xuICAgIHZlYzIuc2NhbGUoc3RvcmUsIHN0b3JlLCAxL3RpbWVTdGVwKTtcbiAgICByZXR1cm4gc3RvcmU7XG59O1xuXG5Cb2R5LnByb3RvdHlwZS5nZXRBbmd1bGFyVmVsb2NpdHlGcm9tUG9zaXRpb24gPSBmdW5jdGlvbih0aW1lU3RlcCl7XG4gICAgcmV0dXJuICh0aGlzLmFuZ2xlIC0gdGhpcy5wcmV2aW91c0FuZ2xlKSAvIHRpbWVTdGVwO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm9keSBpcyBvdmVybGFwcGluZyBhbm90aGVyIGJvZHkuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBvbmx5IHdvcmtzIGlmIHRoZSBib2R5IHdhcyBhZGRlZCB0byBhIFdvcmxkIGFuZCBpZiBhdCBsZWFzdCBvbmUgc3RlcCB3YXMgdGFrZW4uXG4gKiBAbWV0aG9kIG92ZXJsYXBzXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5Cb2R5LnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uKGJvZHkpe1xuICAgIHJldHVybiB0aGlzLndvcmxkLm92ZXJsYXBLZWVwZXIuYm9kaWVzQXJlT3ZlcmxhcHBpbmcodGhpcywgYm9keSk7XG59O1xuXG52YXIgaW50ZWdyYXRlX2ZoTWludiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZWdyYXRlX3ZlbG9kdCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogTW92ZSB0aGUgYm9keSBmb3J3YXJkIGluIHRpbWUgZ2l2ZW4gaXRzIGN1cnJlbnQgdmVsb2NpdHkuXG4gKiBAbWV0aG9kIGludGVncmF0ZVxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICovXG5Cb2R5LnByb3RvdHlwZS5pbnRlZ3JhdGUgPSBmdW5jdGlvbihkdCl7XG4gICAgdmFyIG1pbnYgPSB0aGlzLmludk1hc3MsXG4gICAgICAgIGYgPSB0aGlzLmZvcmNlLFxuICAgICAgICBwb3MgPSB0aGlzLnBvc2l0aW9uLFxuICAgICAgICB2ZWxvID0gdGhpcy52ZWxvY2l0eTtcblxuICAgIC8vIFNhdmUgb2xkIHBvc2l0aW9uXG4gICAgdmVjMi5jb3B5KHRoaXMucHJldmlvdXNQb3NpdGlvbiwgdGhpcy5wb3NpdGlvbik7XG4gICAgdGhpcy5wcmV2aW91c0FuZ2xlID0gdGhpcy5hbmdsZTtcblxuICAgIC8vIFZlbG9jaXR5IHVwZGF0ZVxuICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSArPSB0aGlzLmFuZ3VsYXJGb3JjZSAqIHRoaXMuaW52SW5lcnRpYSAqIGR0O1xuICAgIH1cbiAgICB2ZWMyLnNjYWxlKGludGVncmF0ZV9maE1pbnYsIGYsIGR0ICogbWludik7XG4gICAgdmVjMi5hZGQodmVsbywgaW50ZWdyYXRlX2ZoTWludiwgdmVsbyk7XG5cbiAgICAvLyBDQ0RcbiAgICBpZighdGhpcy5pbnRlZ3JhdGVUb1RpbWVPZkltcGFjdChkdCkpe1xuXG4gICAgICAgIC8vIFJlZ3VsYXIgcG9zaXRpb24gdXBkYXRlXG4gICAgICAgIHZlYzIuc2NhbGUoaW50ZWdyYXRlX3ZlbG9kdCwgdmVsbywgZHQpO1xuICAgICAgICB2ZWMyLmFkZChwb3MsIHBvcywgaW50ZWdyYXRlX3ZlbG9kdCk7XG4gICAgICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICAgICAgdGhpcy5hbmdsZSArPSB0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGR0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xufTtcblxudmFyIGRpcmVjdGlvbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbnZhciBzdGFydFRvRW5kID0gdmVjMi5jcmVhdGUoKTtcbnZhciByZW1lbWJlclBvc2l0aW9uID0gdmVjMi5jcmVhdGUoKTtcbkJvZHkucHJvdG90eXBlLmludGVncmF0ZVRvVGltZU9mSW1wYWN0ID0gZnVuY3Rpb24oZHQpe1xuXG4gICAgaWYodGhpcy5jY2RTcGVlZFRocmVzaG9sZCA8IDAgfHwgdmVjMi5zcXVhcmVkTGVuZ3RoKHRoaXMudmVsb2NpdHkpIDwgTWF0aC5wb3codGhpcy5jY2RTcGVlZFRocmVzaG9sZCwgMikpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmVjMi5ub3JtYWxpemUoZGlyZWN0aW9uLCB0aGlzLnZlbG9jaXR5KTtcblxuICAgIHZlYzIuc2NhbGUoZW5kLCB0aGlzLnZlbG9jaXR5LCBkdCk7XG4gICAgdmVjMi5hZGQoZW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xuXG4gICAgdmVjMi5zdWIoc3RhcnRUb0VuZCwgZW5kLCB0aGlzLnBvc2l0aW9uKTtcbiAgICB2YXIgc3RhcnRUb0VuZEFuZ2xlID0gdGhpcy5hbmd1bGFyVmVsb2NpdHkgKiBkdDtcbiAgICB2YXIgbGVuID0gdmVjMi5sZW5ndGgoc3RhcnRUb0VuZCk7XG5cbiAgICB2YXIgdGltZU9mSW1wYWN0ID0gMTtcblxuICAgIHZhciBoaXQ7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMud29ybGQucmF5Y2FzdEFsbCh0aGlzLnBvc2l0aW9uLCBlbmQsIHt9LCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmKHJlc3VsdC5ib2R5ID09PSB0aGF0KXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoaXQgPSByZXN1bHQuYm9keTtcbiAgICAgICAgdmVjMi5jb3B5KGVuZCwgcmVzdWx0LmhpdFBvaW50V29ybGQpO1xuICAgICAgICB2ZWMyLnN1YihzdGFydFRvRW5kLCByZXN1bHQuaGl0UG9pbnRXb3JsZCwgdGhhdC5wb3NpdGlvbik7XG4gICAgICAgIHRpbWVPZkltcGFjdCA9IHZlYzIubGVuZ3RoKHN0YXJ0VG9FbmQpIC8gbGVuO1xuICAgICAgICByZXN1bHQuYWJvcnQoKTtcbiAgICB9KTtcblxuICAgIGlmKCFoaXQpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHJlbWVtYmVyQW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgIHZlYzIuY29weShyZW1lbWJlclBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uKTtcblxuICAgIC8vIEdvdCBhIHN0YXJ0IGFuZCBlbmQgcG9pbnQuIEFwcHJveGltYXRlIHRpbWUgb2YgaW1wYWN0IHVzaW5nIGJpbmFyeSBzZWFyY2hcbiAgICB2YXIgaXRlciA9IDA7XG4gICAgdmFyIHRtaW4gPSAwO1xuICAgIHZhciB0bWlkID0gMDtcbiAgICB2YXIgdG1heCA9IHRpbWVPZkltcGFjdDtcbiAgICB3aGlsZSAodG1heCA+PSB0bWluICYmIGl0ZXIgPCB0aGlzLmNjZEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgaXRlcisrO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbWlkcG9pbnRcbiAgICAgICAgdG1pZCA9ICh0bWF4IC0gdG1pbikgLyAyO1xuXG4gICAgICAgIC8vIE1vdmUgdGhlIGJvZHkgdG8gdGhhdCBwb2ludFxuICAgICAgICB2ZWMyLnNjYWxlKGludGVncmF0ZV92ZWxvZHQsIHN0YXJ0VG9FbmQsIHRpbWVPZkltcGFjdCk7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMucG9zaXRpb24sIHJlbWVtYmVyUG9zaXRpb24sIGludGVncmF0ZV92ZWxvZHQpO1xuICAgICAgICB0aGlzLmFuZ2xlID0gcmVtZW1iZXJBbmdsZSArIHN0YXJ0VG9FbmRBbmdsZSAqIHRpbWVPZkltcGFjdDtcbiAgICAgICAgdGhpcy51cGRhdGVBQUJCKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgb3ZlcmxhcFxuICAgICAgICB2YXIgb3ZlcmxhcHMgPSB0aGlzLmFhYmIub3ZlcmxhcHMoaGl0LmFhYmIpICYmIHRoaXMud29ybGQubmFycm93cGhhc2UuYm9kaWVzT3ZlcmxhcCh0aGlzLCBoaXQpO1xuXG4gICAgICAgIGlmIChvdmVybGFwcykge1xuICAgICAgICAgICAgLy8gY2hhbmdlIG1pbiB0byBzZWFyY2ggdXBwZXIgaW50ZXJ2YWxcbiAgICAgICAgICAgIHRtaW4gPSB0bWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2hhbmdlIG1heCB0byBzZWFyY2ggbG93ZXIgaW50ZXJ2YWxcbiAgICAgICAgICAgIHRtYXggPSB0bWlkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGltZU9mSW1wYWN0ID0gdG1pZDtcblxuICAgIHZlYzIuY29weSh0aGlzLnBvc2l0aW9uLCByZW1lbWJlclBvc2l0aW9uKTtcbiAgICB0aGlzLmFuZ2xlID0gcmVtZW1iZXJBbmdsZTtcblxuICAgIC8vIG1vdmUgdG8gVE9JXG4gICAgdmVjMi5zY2FsZShpbnRlZ3JhdGVfdmVsb2R0LCBzdGFydFRvRW5kLCB0aW1lT2ZJbXBhY3QpO1xuICAgIHZlYzIuYWRkKHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb24sIGludGVncmF0ZV92ZWxvZHQpO1xuICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICB0aGlzLmFuZ2xlICs9IHN0YXJ0VG9FbmRBbmdsZSAqIHRpbWVPZkltcGFjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQGV2ZW50IHNsZWVweVxuICovXG5Cb2R5LnNsZWVweUV2ZW50ID0ge1xuICAgIHR5cGU6IFwic2xlZXB5XCJcbn07XG5cbi8qKlxuICogQGV2ZW50IHNsZWVwXG4gKi9cbkJvZHkuc2xlZXBFdmVudCA9IHtcbiAgICB0eXBlOiBcInNsZWVwXCJcbn07XG5cbi8qKlxuICogQGV2ZW50IHdha2V1cFxuICovXG5Cb2R5Lndha2VVcEV2ZW50ID0ge1xuICAgIHR5cGU6IFwid2FrZXVwXCJcbn07XG5cbi8qKlxuICogRHluYW1pYyBib2R5LlxuICogQHByb3BlcnR5IERZTkFNSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkJvZHkuRFlOQU1JQyA9IDE7XG5cbi8qKlxuICogU3RhdGljIGJvZHkuXG4gKiBAcHJvcGVydHkgU1RBVElDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LlNUQVRJQyA9IDI7XG5cbi8qKlxuICogS2luZW1hdGljIGJvZHkuXG4gKiBAcHJvcGVydHkgS0lORU1BVElDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LktJTkVNQVRJQyA9IDQ7XG5cbi8qKlxuICogQHByb3BlcnR5IEFXQUtFXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LkFXQUtFID0gMDtcblxuLyoqXG4gKiBAcHJvcGVydHkgU0xFRVBZXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LlNMRUVQWSA9IDE7XG5cbi8qKlxuICogQHByb3BlcnR5IFNMRUVQSU5HXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LlNMRUVQSU5HID0gMjtcblxuIiwidmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBTcHJpbmcgPSByZXF1aXJlKCcuL1NwcmluZycpO1xudmFyIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lYXJTcHJpbmc7XG5cbi8qKlxuICogQSBzcHJpbmcsIGNvbm5lY3RpbmcgdHdvIGJvZGllcy5cbiAqXG4gKiBUaGUgU3ByaW5nIGV4cGxpY2l0bHkgYWRkcyBmb3JjZSBhbmQgYW5ndWxhckZvcmNlIHRvIHRoZSBib2RpZXMuXG4gKlxuICogQGNsYXNzIExpbmVhclNwcmluZ1xuICogQGV4dGVuZHMgU3ByaW5nXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXN0TGVuZ3RoXSAgIEEgbnVtYmVyID4gMC4gRGVmYXVsdCBpcyB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB3b3JsZCBhbmNob3IgcG9pbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdICBTcHJpbmcgY29uc3RhbnQgKHNlZSBIb29rZXMgTGF3KS4gQSBudW1iZXIgPj0gMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nPTFdICAgICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMVxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy4gT3ZlcnJpZGVzIHRoZSBvcHRpb24gXCJsb2NhbEFuY2hvckFcIiBpZiBnaXZlbi5cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckJdXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuIERlZmF1bHRzIHRvIHRoZSBib2R5IGNlbnRlci5cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdXG4gKi9cbmZ1bmN0aW9uIExpbmVhclNwcmluZyhib2R5QSxib2R5QixvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIFNwcmluZy5jYWxsKHRoaXMsIGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBBbmNob3IgZm9yIGJvZHlBIGluIGxvY2FsIGJvZHlBIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIEFuY2hvciBmb3IgYm9keUIgaW4gbG9jYWwgYm9keUIgY29vcmRpbmF0ZXMuXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckEpeyB2ZWMyLmNvcHkodGhpcy5sb2NhbEFuY2hvckEsIG9wdGlvbnMubG9jYWxBbmNob3JBKTsgfVxuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JCKXsgdmVjMi5jb3B5KHRoaXMubG9jYWxBbmNob3JCLCBvcHRpb25zLmxvY2FsQW5jaG9yQik7IH1cbiAgICBpZihvcHRpb25zLndvcmxkQW5jaG9yQSl7IHRoaXMuc2V0V29ybGRBbmNob3JBKG9wdGlvbnMud29ybGRBbmNob3JBKTsgfVxuICAgIGlmKG9wdGlvbnMud29ybGRBbmNob3JCKXsgdGhpcy5zZXRXb3JsZEFuY2hvckIob3B0aW9ucy53b3JsZEFuY2hvckIpOyB9XG5cbiAgICB2YXIgd29ybGRBbmNob3JBID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgd29ybGRBbmNob3JCID0gdmVjMi5jcmVhdGUoKTtcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQSh3b3JsZEFuY2hvckEpO1xuICAgIHRoaXMuZ2V0V29ybGRBbmNob3JCKHdvcmxkQW5jaG9yQik7XG4gICAgdmFyIHdvcmxkRGlzdGFuY2UgPSB2ZWMyLmRpc3RhbmNlKHdvcmxkQW5jaG9yQSwgd29ybGRBbmNob3JCKTtcblxuICAgIC8qKlxuICAgICAqIFJlc3QgbGVuZ3RoIG9mIHRoZSBzcHJpbmcuXG4gICAgICogQHByb3BlcnR5IHJlc3RMZW5ndGhcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdExlbmd0aCA9IHR5cGVvZihvcHRpb25zLnJlc3RMZW5ndGgpID09PSBcIm51bWJlclwiID8gb3B0aW9ucy5yZXN0TGVuZ3RoIDogd29ybGREaXN0YW5jZTtcbn1cbkxpbmVhclNwcmluZy5wcm90b3R5cGUgPSBuZXcgU3ByaW5nKCk7XG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZWFyU3ByaW5nO1xuXG4vKipcbiAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQSwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQVxuICogQHBhcmFtIHtBcnJheX0gd29ybGRBbmNob3JBXG4gKi9cbkxpbmVhclNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24od29ybGRBbmNob3JBKXtcbiAgICB0aGlzLmJvZHlBLnRvTG9jYWxGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQSwgd29ybGRBbmNob3JBKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCB1c2luZyB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2Qgc2V0V29ybGRBbmNob3JCXG4gKiBAcGFyYW0ge0FycmF5fSB3b3JsZEFuY2hvckJcbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbih3b3JsZEFuY2hvckIpe1xuICAgIHRoaXMuYm9keUIudG9Mb2NhbEZyYW1lKHRoaXMubG9jYWxBbmNob3JCLCB3b3JsZEFuY2hvckIpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBnZXRXb3JsZEFuY2hvckFcbiAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXG4gKi9cbkxpbmVhclNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLmJvZHlBLnRvV29ybGRGcmFtZShyZXN1bHQsIHRoaXMubG9jYWxBbmNob3JBKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JCXG4gKiBAcGFyYW0ge0FycmF5fSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdGhpcy5ib2R5Qi50b1dvcmxkRnJhbWUocmVzdWx0LCB0aGlzLmxvY2FsQW5jaG9yQik7XG59O1xuXG52YXIgYXBwbHlGb3JjZV9yID0gICAgICAgICAgICAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV9yX3VuaXQgPSAgICAgICAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV91ID0gICAgICAgICAgICAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV9mID0gICAgICAgICAgICAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV93b3JsZEFuY2hvckEgPSAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV93b3JsZEFuY2hvckIgPSAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV9yaSA9ICAgICAgICAgICAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV9yaiA9ICAgICAgICAgICAgIHZlYzIuY3JlYXRlKCksXG4gICAgYXBwbHlGb3JjZV90bXAgPSAgICAgICAgICAgIHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQXBwbHkgdGhlIHNwcmluZyBmb3JjZSB0byB0aGUgY29ubmVjdGVkIGJvZGllcy5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MsXG4gICAgICAgIGQgPSB0aGlzLmRhbXBpbmcsXG4gICAgICAgIGwgPSB0aGlzLnJlc3RMZW5ndGgsXG4gICAgICAgIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICByID0gYXBwbHlGb3JjZV9yLFxuICAgICAgICByX3VuaXQgPSBhcHBseUZvcmNlX3JfdW5pdCxcbiAgICAgICAgdSA9IGFwcGx5Rm9yY2VfdSxcbiAgICAgICAgZiA9IGFwcGx5Rm9yY2VfZixcbiAgICAgICAgdG1wID0gYXBwbHlGb3JjZV90bXA7XG5cbiAgICB2YXIgd29ybGRBbmNob3JBID0gYXBwbHlGb3JjZV93b3JsZEFuY2hvckEsXG4gICAgICAgIHdvcmxkQW5jaG9yQiA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCLFxuICAgICAgICByaSA9IGFwcGx5Rm9yY2VfcmksXG4gICAgICAgIHJqID0gYXBwbHlGb3JjZV9yajtcblxuICAgIC8vIEdldCB3b3JsZCBhbmNob3JzXG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xuXG4gICAgLy8gR2V0IG9mZnNldCBwb2ludHNcbiAgICB2ZWMyLnN1YihyaSwgd29ybGRBbmNob3JBLCBib2R5QS5wb3NpdGlvbik7XG4gICAgdmVjMi5zdWIocmosIHdvcmxkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xuXG4gICAgLy8gQ29tcHV0ZSBkaXN0YW5jZSB2ZWN0b3IgYmV0d2VlbiB3b3JsZCBhbmNob3IgcG9pbnRzXG4gICAgdmVjMi5zdWIociwgd29ybGRBbmNob3JCLCB3b3JsZEFuY2hvckEpO1xuICAgIHZhciBybGVuID0gdmVjMi5sZW4ocik7XG4gICAgdmVjMi5ub3JtYWxpemUocl91bml0LHIpO1xuXG4gICAgLy9jb25zb2xlLmxvZyhybGVuKVxuICAgIC8vY29uc29sZS5sb2coXCJBXCIsdmVjMi5zdHIod29ybGRBbmNob3JBKSxcIkJcIix2ZWMyLnN0cih3b3JsZEFuY2hvckIpKVxuXG4gICAgLy8gQ29tcHV0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBvZiB0aGUgYW5jaG9yIHBvaW50cywgdVxuICAgIHZlYzIuc3ViKHUsIGJvZHlCLnZlbG9jaXR5LCBib2R5QS52ZWxvY2l0eSk7XG4gICAgdmVjMi5jcm9zc1pWKHRtcCwgYm9keUIuYW5ndWxhclZlbG9jaXR5LCByaik7XG4gICAgdmVjMi5hZGQodSwgdSwgdG1wKTtcbiAgICB2ZWMyLmNyb3NzWlYodG1wLCBib2R5QS5hbmd1bGFyVmVsb2NpdHksIHJpKTtcbiAgICB2ZWMyLnN1Yih1LCB1LCB0bXApO1xuXG4gICAgLy8gRiA9IC0gayAqICggeCAtIEwgKSAtIEQgKiAoIHUgKVxuICAgIHZlYzIuc2NhbGUoZiwgcl91bml0LCAtayoocmxlbi1sKSAtIGQqdmVjMi5kb3QodSxyX3VuaXQpKTtcblxuICAgIC8vIEFkZCBmb3JjZXMgdG8gYm9kaWVzXG4gICAgdmVjMi5zdWIoIGJvZHlBLmZvcmNlLCBib2R5QS5mb3JjZSwgZik7XG4gICAgdmVjMi5hZGQoIGJvZHlCLmZvcmNlLCBib2R5Qi5mb3JjZSwgZik7XG5cbiAgICAvLyBBbmd1bGFyIGZvcmNlXG4gICAgdmFyIHJpX3hfZiA9IHZlYzIuY3Jvc3NMZW5ndGgocmksIGYpO1xuICAgIHZhciByal94X2YgPSB2ZWMyLmNyb3NzTGVuZ3RoKHJqLCBmKTtcbiAgICBib2R5QS5hbmd1bGFyRm9yY2UgLT0gcmlfeF9mO1xuICAgIGJvZHlCLmFuZ3VsYXJGb3JjZSArPSByal94X2Y7XG59O1xuIiwidmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBTcHJpbmcgPSByZXF1aXJlKCcuL1NwcmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxTcHJpbmc7XG5cbi8qKlxuICogQSByb3RhdGlvbmFsIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzIHJvdGF0aW9uLiBUaGlzIHNwcmluZyBleHBsaWNpdGx5IGFkZHMgYW5ndWxhckZvcmNlICh0b3JxdWUpIHRvIHRoZSBib2RpZXMuXG4gKlxuICogVGhlIHNwcmluZyBjYW4gYmUgY29tYmluZWQgd2l0aCBhIHt7I2Nyb3NzTGluayBcIlJldm9sdXRlQ29uc3RyYWludFwifX17ey9jcm9zc0xpbmt9fSB0byBtYWtlLCBmb3IgZXhhbXBsZSwgYSBtb3VzZSB0cmFwLlxuICpcbiAqIEBjbGFzcyBSb3RhdGlvbmFsU3ByaW5nXG4gKiBAZXh0ZW5kcyBTcHJpbmdcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc3RBbmdsZV0gVGhlIHJlbGF0aXZlIGFuZ2xlIG9mIGJvZGllcyBhdCB3aGljaCB0aGUgc3ByaW5nIGlzIGF0IHJlc3QuIElmIG5vdCBnaXZlbiwgaXQncyBzZXQgdG8gdGhlIGN1cnJlbnQgcmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gQSBudW1iZXIgPj0gMC5cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbFNwcmluZyhib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgU3ByaW5nLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFJlc3QgYW5nbGUgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgcmVzdEFuZ2xlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RBbmdsZSA9IHR5cGVvZihvcHRpb25zLnJlc3RBbmdsZSkgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLnJlc3RBbmdsZSA6IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XG59XG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZSA9IG5ldyBTcHJpbmcoKTtcblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbFNwcmluZztcblxuLyoqXG4gKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxuICogQG1ldGhvZCBhcHBseUZvcmNlXG4gKi9cblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MsXG4gICAgICAgIGQgPSB0aGlzLmRhbXBpbmcsXG4gICAgICAgIGwgPSB0aGlzLnJlc3RBbmdsZSxcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHggPSBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlLFxuICAgICAgICB1ID0gYm9keUIuYW5ndWxhclZlbG9jaXR5IC0gYm9keUEuYW5ndWxhclZlbG9jaXR5O1xuXG4gICAgdmFyIHRvcnF1ZSA9IC0gayAqICh4IC0gbCkgLSBkICogdSAqIDA7XG5cbiAgICBib2R5QS5hbmd1bGFyRm9yY2UgLT0gdG9ycXVlO1xuICAgIGJvZHlCLmFuZ3VsYXJGb3JjZSArPSB0b3JxdWU7XG59O1xuIiwidmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ByaW5nO1xuXG4vKipcbiAqIEEgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMuIFRoZSBTcHJpbmcgZXhwbGljaXRseSBhZGRzIGZvcmNlIGFuZCBhbmd1bGFyRm9yY2UgdG8gdGhlIGJvZGllcyBhbmQgZG9lcyB0aGVyZWZvcmUgbm90IHB1dCBsb2FkIG9uIHRoZSBjb25zdHJhaW50IHNvbHZlci5cbiAqXG4gKiBAY2xhc3MgU3ByaW5nXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGlmZm5lc3M9MTAwXSAgU3ByaW5nIGNvbnN0YW50IChzZWUgSG9va2VzIExhdykuIEEgbnVtYmVyID49IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZz0xXSAgICAgIEEgbnVtYmVyID49IDAuIERlZmF1bHQ6IDFcbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckFdICAgV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gbG9jYWwgYm9keSBjb29yZGluYXRlcy4gRGVmYXVsdHMgdG8gdGhlIGJvZHkgY2VudGVyLlxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsQW5jaG9yQl1cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdICAgV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuIE92ZXJyaWRlcyB0aGUgb3B0aW9uIFwibG9jYWxBbmNob3JBXCIgaWYgZ2l2ZW4uXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JCXVxuICovXG5mdW5jdGlvbiBTcHJpbmcoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucyx7XG4gICAgICAgIHN0aWZmbmVzczogMTAwLFxuICAgICAgICBkYW1waW5nOiAxLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSBzcHJpbmcuXG4gICAgICogQHByb3BlcnR5IHN0aWZmbmVzc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdGlmZm5lc3MgPSBvcHRpb25zLnN0aWZmbmVzcztcblxuICAgIC8qKlxuICAgICAqIERhbXBpbmcgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgZGFtcGluZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kYW1waW5nID0gb3B0aW9ucy5kYW1waW5nO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QgY29ubmVjdGVkIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGJvZHlBXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuXG4gICAgLyoqXG4gICAgICogU2Vjb25kIGNvbm5lY3RlZCBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QlxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUIgPSBib2R5Qjtcbn1cblxuLyoqXG4gKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxuICogQG1ldGhvZCBhcHBseUZvcmNlXG4gKi9cblNwcmluZy5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Nlc1xufTtcbiIsIi8vIEV4cG9ydCBwMiBjbGFzc2VzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBQUJCIDogICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29sbGlzaW9uL0FBQkInKSxcbiAgICBBbmdsZUxvY2tFcXVhdGlvbiA6ICAgICAgICAgICAgIHJlcXVpcmUoJy4vZXF1YXRpb25zL0FuZ2xlTG9ja0VxdWF0aW9uJyksXG4gICAgQm9keSA6ICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL29iamVjdHMvQm9keScpLFxuICAgIEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIENhcHN1bGUgOiAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFwZXMvQ2Fwc3VsZScpLFxuICAgIENpcmNsZSA6ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFwZXMvQ2lyY2xlJyksXG4gICAgQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKSxcbiAgICBDb250YWN0RXF1YXRpb24gOiAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpLFxuICAgIENvbnRhY3RNYXRlcmlhbCA6ICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWwnKSxcbiAgICBDb252ZXggOiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL0NvbnZleCcpLFxuICAgIERpc3RhbmNlQ29uc3RyYWludCA6ICAgICAgICAgICAgcmVxdWlyZSgnLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnQnKSxcbiAgICBFcXVhdGlvbiA6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vZXF1YXRpb25zL0VxdWF0aW9uJyksXG4gICAgRXZlbnRFbWl0dGVyIDogICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2V2ZW50cy9FdmVudEVtaXR0ZXInKSxcbiAgICBGcmljdGlvbkVxdWF0aW9uIDogICAgICAgICAgICAgIHJlcXVpcmUoJy4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKSxcbiAgICBHZWFyQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29uc3RyYWludHMvR2VhckNvbnN0cmFpbnQnKSxcbiAgICBHcmlkQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29sbGlzaW9uL0dyaWRCcm9hZHBoYXNlJyksXG4gICAgR1NTb2x2ZXIgOiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NvbHZlci9HU1NvbHZlcicpLFxuICAgIEhlaWdodGZpZWxkIDogICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFwZXMvSGVpZ2h0ZmllbGQnKSxcbiAgICBMaW5lIDogICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL0xpbmUnKSxcbiAgICBMb2NrQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29uc3RyYWludHMvTG9ja0NvbnN0cmFpbnQnKSxcbiAgICBNYXRlcmlhbCA6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbWF0ZXJpYWwvTWF0ZXJpYWwnKSxcbiAgICBOYXJyb3dwaGFzZSA6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29sbGlzaW9uL05hcnJvd3BoYXNlJyksXG4gICAgTmFpdmVCcm9hZHBoYXNlIDogICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UnKSxcbiAgICBQYXJ0aWNsZSA6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL1BhcnRpY2xlJyksXG4gICAgUGxhbmUgOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NoYXBlcy9QbGFuZScpLFxuICAgIFJldm9sdXRlQ29uc3RyYWludCA6ICAgICAgICAgICAgcmVxdWlyZSgnLi9jb25zdHJhaW50cy9SZXZvbHV0ZUNvbnN0cmFpbnQnKSxcbiAgICBQcmlzbWF0aWNDb25zdHJhaW50IDogICAgICAgICAgIHJlcXVpcmUoJy4vY29uc3RyYWludHMvUHJpc21hdGljQ29uc3RyYWludCcpLFxuICAgIFJheSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vUmF5JyksXG4gICAgUmF5Y2FzdFJlc3VsdCA6ICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0JyksXG4gICAgUmVjdGFuZ2xlIDogICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NoYXBlcy9SZWN0YW5nbGUnKSxcbiAgICBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiA6ICAgIHJlcXVpcmUoJy4vZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uJyksXG4gICAgU0FQQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlJyksXG4gICAgU2hhcGUgOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NoYXBlcy9TaGFwZScpLFxuICAgIFNvbHZlciA6ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zb2x2ZXIvU29sdmVyJyksXG4gICAgU3ByaW5nIDogICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL29iamVjdHMvU3ByaW5nJyksXG4gICAgTGluZWFyU3ByaW5nIDogICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL29iamVjdHMvTGluZWFyU3ByaW5nJyksXG4gICAgUm90YXRpb25hbFNwcmluZyA6ICAgICAgICAgICAgICByZXF1aXJlKCcuL29iamVjdHMvUm90YXRpb25hbFNwcmluZycpLFxuICAgIFV0aWxzIDogICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi91dGlscy9VdGlscycpLFxuICAgIFdvcmxkIDogICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi93b3JsZC9Xb3JsZCcpLFxuICAgIHZlYzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9tYXRoL3ZlYzInKSxcbiAgICB2ZXJzaW9uIDogICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24sXG59O1xuIiwidmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpXG4sICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhcHN1bGU7XG5cbi8qKlxuICogQ2Fwc3VsZSBzaGFwZSBjbGFzcy5cbiAqIEBjbGFzcyBDYXBzdWxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAcGFyYW0ge051bWJlcn0gW2xlbmd0aD0xXSBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZW5kIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXM9MV0gUmFkaXVzIG9mIHRoZSBjYXBzdWxlXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciByYWRpdXMgPSAxO1xuICogICAgIHZhciBsZW5ndGggPSAyO1xuICogICAgIHZhciBjYXBzdWxlU2hhcGUgPSBuZXcgQ2Fwc3VsZShsZW5ndGgsIHJhZGl1cyk7XG4gKiAgICAgYm9keS5hZGRTaGFwZShjYXBzdWxlU2hhcGUpO1xuICovXG5mdW5jdGlvbiBDYXBzdWxlKGxlbmd0aCwgcmFkaXVzKXtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBlbmQgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aCB8fCAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhZGl1cyBvZiB0aGUgY2Fwc3VsZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmFkaXVzXG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXMgfHwgMTtcblxuICAgIFNoYXBlLmNhbGwodGhpcyxTaGFwZS5DQVBTVUxFKTtcbn1cbkNhcHN1bGUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5DYXBzdWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhcHN1bGU7XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbWFzcyBtb21lbnQgb2YgaW5lcnRpYSBvZiB0aGUgQ2Fwc3VsZS5cbiAqIEBtZXRob2QgY29ucHV0ZU1vbWVudE9mSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAdG9kb1xuICovXG5DYXBzdWxlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgLy8gQXBwcm94aW1hdGUgd2l0aCByZWN0YW5nbGVcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzLFxuICAgICAgICB3ID0gdGhpcy5sZW5ndGggKyByLCAvLyAyKnIgaXMgdG9vIG11Y2gsIDAgaXMgdG9vIGxpdHRsZVxuICAgICAgICBoID0gcioyO1xuICAgIHJldHVybiBtYXNzICogKGgqaCArIHcqdykgLyAxMjtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5DYXBzdWxlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHRoaXMucmFkaXVzICsgdGhpcy5sZW5ndGgvMjtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVBcmVhXG4gKi9cbkNhcHN1bGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IE1hdGguUEkgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICsgdGhpcy5yYWRpdXMgKiAyICogdGhpcy5sZW5ndGg7XG59O1xuXG52YXIgciA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkNhcHN1bGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciByYWRpdXMgPSB0aGlzLnJhZGl1cztcblxuICAgIC8vIENvbXB1dGUgY2VudGVyIHBvc2l0aW9uIG9mIG9uZSBvZiB0aGUgdGhlIGNpcmNsZXMsIHdvcmxkIG9yaWVudGVkLCBidXQgd2l0aCBsb2NhbCBvZmZzZXRcbiAgICB2ZWMyLnNldChyLHRoaXMubGVuZ3RoIC8gMiwwKTtcbiAgICBpZihhbmdsZSAhPT0gMCl7XG4gICAgICAgIHZlYzIucm90YXRlKHIscixhbmdsZSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGJvdW5kc1xuICAgIHZlYzIuc2V0KG91dC51cHBlckJvdW5kLCAgTWF0aC5tYXgoclswXStyYWRpdXMsIC1yWzBdK3JhZGl1cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChyWzFdK3JhZGl1cywgLXJbMV0rcmFkaXVzKSk7XG4gICAgdmVjMi5zZXQob3V0Lmxvd2VyQm91bmQsICBNYXRoLm1pbihyWzBdLXJhZGl1cywgLXJbMF0tcmFkaXVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHJbMV0tcmFkaXVzLCAtclsxXS1yYWRpdXMpKTtcblxuICAgIC8vIEFkZCBvZmZzZXRcbiAgICB2ZWMyLmFkZChvdXQubG93ZXJCb3VuZCwgb3V0Lmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcbiAgICB2ZWMyLmFkZChvdXQudXBwZXJCb3VuZCwgb3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcbn07XG4iLCJ2YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcbiwgICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcblxuLyoqXG4gKiBDaXJjbGUgc2hhcGUgY2xhc3MuXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1cz0xXSBUaGUgcmFkaXVzIG9mIHRoaXMgY2lyY2xlXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgcmFkaXVzID0gMTtcbiAqICAgICB2YXIgY2lyY2xlU2hhcGUgPSBuZXcgQ2lyY2xlKHJhZGl1cyk7XG4gKiAgICAgYm9keS5hZGRTaGFwZShjaXJjbGVTaGFwZSk7XG4gKi9cbmZ1bmN0aW9uIENpcmNsZShyYWRpdXMpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxuICAgICAqIEBwcm9wZXJ0eSByYWRpdXNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzIHx8IDE7XG5cbiAgICBTaGFwZS5jYWxsKHRoaXMsU2hhcGUuQ0lSQ0xFKTtcbn1cbkNpcmNsZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkNpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGU7XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgdmFyIHIgPSB0aGlzLnJhZGl1cztcbiAgICByZXR1cm4gbWFzcyAqIHIgKiByIC8gMjtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5DaXJjbGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5yYWRpdXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlQXJlYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5DaXJjbGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IE1hdGguUEkgKiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xuICAgIHZlYzIuc2V0KG91dC51cHBlckJvdW5kLCAgciwgIHIpO1xuICAgIHZlYzIuc2V0KG91dC5sb3dlckJvdW5kLCAtciwgLXIpO1xuICAgIGlmKHBvc2l0aW9uKXtcbiAgICAgICAgdmVjMi5hZGQob3V0Lmxvd2VyQm91bmQsIG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgICAgIHZlYzIuYWRkKG91dC51cHBlckJvdW5kLCBvdXQudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgIH1cbn07XG4iLCJ2YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcbiwgICBwb2x5ayA9IHJlcXVpcmUoJy4uL21hdGgvcG9seWsnKVxuLCAgIGRlY29tcCA9IHJlcXVpcmUoJ3BvbHktZGVjb21wJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udmV4O1xuXG4vKipcbiAqIENvbnZleCBzaGFwZSBjbGFzcy5cbiAqIEBjbGFzcyBDb252ZXhcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIEFuIGFycmF5IG9mIHZlcnRpY2VzIHRoYXQgc3BhbiB0aGlzIHNoYXBlLiBWZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2UgKENDVykgZGlyZWN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gW2F4ZXNdIEFuIGFycmF5IG9mIHVuaXQgbGVuZ3RoIHZlY3RvcnMsIHJlcHJlc2VudGluZyB0aGUgc3ltbWV0cnkgYXhlcyBpbiB0aGUgY29udmV4LlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBDcmVhdGUgYSBib3hcbiAqICAgICB2YXIgdmVydGljZXMgPSBbWy0xLC0xXSwgWzEsLTFdLCBbMSwxXSwgWy0xLDFdXTtcbiAqICAgICB2YXIgY29udmV4U2hhcGUgPSBuZXcgQ29udmV4KHZlcnRpY2VzKTtcbiAqICAgICBib2R5LmFkZFNoYXBlKGNvbnZleFNoYXBlKTtcbiAqL1xuZnVuY3Rpb24gQ29udmV4KHZlcnRpY2VzLCBheGVzKXtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2VzIGRlZmluZWQgaW4gdGhlIGxvY2FsIGZyYW1lLlxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBeGVzIGRlZmluZWQgaW4gdGhlIGxvY2FsIGZyYW1lLlxuICAgICAqIEBwcm9wZXJ0eSBheGVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXhlcyA9IFtdO1xuXG4gICAgLy8gQ29weSB0aGUgdmVydHNcbiAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVjMi5jcmVhdGUoKTtcbiAgICAgICAgdmVjMi5jb3B5KHYsdmVydGljZXNbaV0pO1xuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2godik7XG4gICAgfVxuXG4gICAgaWYoYXhlcyl7XG4gICAgICAgIC8vIENvcHkgdGhlIGF4ZXNcbiAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBheGlzID0gdmVjMi5jcmVhdGUoKTtcbiAgICAgICAgICAgIHZlYzIuY29weShheGlzLCBheGVzW2ldKTtcbiAgICAgICAgICAgIHRoaXMuYXhlcy5wdXNoKGF4aXMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IGF4ZXMgZnJvbSB0aGUgdmVydGV4IGRhdGFcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgd29ybGQgZWRnZVxuICAgICAgICAgICAgdmFyIHdvcmxkUG9pbnQwID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICB2YXIgd29ybGRQb2ludDEgPSB2ZXJ0aWNlc1soaSsxKSAlIHZlcnRpY2VzLmxlbmd0aF07XG5cbiAgICAgICAgICAgIHZhciBub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAvLyBHZXQgbm9ybWFsIC0ganVzdCByb3RhdGUgOTAgZGVncmVlcyBzaW5jZSB2ZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gQ0NXXG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cobm9ybWFsLCBub3JtYWwpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xuXG4gICAgICAgICAgICB0aGlzLmF4ZXMucHVzaChub3JtYWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNlbnRlciBvZiBtYXNzIG9mIHRoZSBDb252ZXhcbiAgICAgKiBAcHJvcGVydHkgY2VudGVyT2ZNYXNzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY2VudGVyT2ZNYXNzID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBUcmlhbmd1bGF0ZWQgdmVyc2lvbiBvZiB0aGlzIGNvbnZleC4gVGhlIHN0cnVjdHVyZSBpcyBBcnJheSBvZiAzLUFycmF5cywgYW5kIGVhY2ggc3ViYXJyYXkgY29udGFpbnMgMyBpbnRlZ2VycywgcmVmZXJlbmNpbmcgdGhlIHZlcnRpY2VzLlxuICAgICAqIEBwcm9wZXJ0eSB0cmlhbmdsZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy50cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmKHRoaXMudmVydGljZXMubGVuZ3RoKXtcbiAgICAgICAgdGhpcy51cGRhdGVUcmlhbmdsZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVDZW50ZXJPZk1hc3MoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm91bmRpbmcgcmFkaXVzIG9mIHRoZSBjb252ZXhcbiAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzLCBTaGFwZS5DT05WRVgpO1xuXG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xuICAgIHRoaXMudXBkYXRlQXJlYSgpO1xuICAgIGlmKHRoaXMuYXJlYSA8IDApe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb252ZXggdmVydGljZXMgbXVzdCBiZSBnaXZlbiBpbiBjb250ZXItY2xvY2t3aXNlIHdpbmRpbmcuXCIpO1xuICAgIH1cbn1cbkNvbnZleC5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkNvbnZleC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb252ZXg7XG5cbnZhciB0bXBWZWMxID0gdmVjMi5jcmVhdGUoKTtcbnZhciB0bXBWZWMyID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBQcm9qZWN0IGEgQ29udmV4IG9udG8gYSB3b3JsZC1vcmllbnRlZCBheGlzXG4gKiBAbWV0aG9kIHByb2plY3RPbnRvQXhpc1xuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG9mZnNldFxuICogQHBhcmFtICB7QXJyYXl9IGxvY2FsQXhpc1xuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxuICovXG5Db252ZXgucHJvdG90eXBlLnByb2plY3RPbnRvTG9jYWxBeGlzID0gZnVuY3Rpb24obG9jYWxBeGlzLCByZXN1bHQpe1xuICAgIHZhciBtYXg9bnVsbCxcbiAgICAgICAgbWluPW51bGwsXG4gICAgICAgIHYsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBsb2NhbEF4aXMgPSB0bXBWZWMxO1xuXG4gICAgLy8gR2V0IHByb2plY3RlZCBwb3NpdGlvbiBvZiBhbGwgdmVydGljZXNcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdiA9IHRoaXMudmVydGljZXNbaV07XG4gICAgICAgIHZhbHVlID0gdmVjMi5kb3QodiwgbG9jYWxBeGlzKTtcbiAgICAgICAgaWYobWF4ID09PSBudWxsIHx8IHZhbHVlID4gbWF4KXtcbiAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKG1pbiA9PT0gbnVsbCB8fCB2YWx1ZSA8IG1pbil7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKG1pbiA+IG1heCl7XG4gICAgICAgIHZhciB0ID0gbWluO1xuICAgICAgICBtaW4gPSBtYXg7XG4gICAgICAgIG1heCA9IHQ7XG4gICAgfVxuXG4gICAgdmVjMi5zZXQocmVzdWx0LCBtaW4sIG1heCk7XG59O1xuXG5Db252ZXgucHJvdG90eXBlLnByb2plY3RPbnRvV29ybGRBeGlzID0gZnVuY3Rpb24obG9jYWxBeGlzLCBzaGFwZU9mZnNldCwgc2hhcGVBbmdsZSwgcmVzdWx0KXtcbiAgICB2YXIgd29ybGRBeGlzID0gdG1wVmVjMjtcblxuICAgIHRoaXMucHJvamVjdE9udG9Mb2NhbEF4aXMobG9jYWxBeGlzLCByZXN1bHQpO1xuXG4gICAgLy8gUHJvamVjdCB0aGUgcG9zaXRpb24gb2YgdGhlIGJvZHkgb250byB0aGUgYXhpcyAtIG5lZWQgdG8gYWRkIHRoaXMgdG8gdGhlIHJlc3VsdFxuICAgIGlmKHNoYXBlQW5nbGUgIT09IDApe1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZEF4aXMsIGxvY2FsQXhpcywgc2hhcGVBbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd29ybGRBeGlzID0gbG9jYWxBeGlzO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdmVjMi5kb3Qoc2hhcGVPZmZzZXQsIHdvcmxkQXhpcyk7XG5cbiAgICB2ZWMyLnNldChyZXN1bHQsIHJlc3VsdFswXSArIG9mZnNldCwgcmVzdWx0WzFdICsgb2Zmc2V0KTtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGUgdGhlIC50cmlhbmdsZXMgcHJvcGVydHlcbiAqIEBtZXRob2QgdXBkYXRlVHJpYW5nbGVzXG4gKi9cbkNvbnZleC5wcm90b3R5cGUudXBkYXRlVHJpYW5nbGVzID0gZnVuY3Rpb24oKXtcblxuICAgIHRoaXMudHJpYW5nbGVzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZXdyaXRlIG9uIHBvbHlrIG5vdGF0aW9uLCBhcnJheSBvZiBudW1iZXJzXG4gICAgdmFyIHBvbHlrVmVydHMgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzW2ldO1xuICAgICAgICBwb2x5a1ZlcnRzLnB1c2godlswXSx2WzFdKTtcbiAgICB9XG5cbiAgICAvLyBUcmlhbmd1bGF0ZVxuICAgIHZhciB0cmlhbmdsZXMgPSBwb2x5ay5Ucmlhbmd1bGF0ZShwb2x5a1ZlcnRzKTtcblxuICAgIC8vIExvb3Agb3ZlciBhbGwgdHJpYW5nbGVzLCBhZGQgdGhlaXIgaW5lcnRpYSBjb250cmlidXRpb25zIHRvIElcbiAgICBmb3IodmFyIGk9MDsgaTx0cmlhbmdsZXMubGVuZ3RoOyBpKz0zKXtcbiAgICAgICAgdmFyIGlkMSA9IHRyaWFuZ2xlc1tpXSxcbiAgICAgICAgICAgIGlkMiA9IHRyaWFuZ2xlc1tpKzFdLFxuICAgICAgICAgICAgaWQzID0gdHJpYW5nbGVzW2krMl07XG5cbiAgICAgICAgLy8gQWRkIHRvIHRyaWFuZ2xlc1xuICAgICAgICB0aGlzLnRyaWFuZ2xlcy5wdXNoKFtpZDEsaWQyLGlkM10pO1xuICAgIH1cbn07XG5cbnZhciB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWQgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZF90aW1lc19tYXNzID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfYSA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2IgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19jID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfYWMgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19jYSA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2NiID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfbiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogVXBkYXRlIHRoZSAuY2VudGVyT2ZNYXNzIHByb3BlcnR5LlxuICogQG1ldGhvZCB1cGRhdGVDZW50ZXJPZk1hc3NcbiAqL1xuQ29udmV4LnByb3RvdHlwZS51cGRhdGVDZW50ZXJPZk1hc3MgPSBmdW5jdGlvbigpe1xuICAgIHZhciB0cmlhbmdsZXMgPSB0aGlzLnRyaWFuZ2xlcyxcbiAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzLFxuICAgICAgICBjbSA9IHRoaXMuY2VudGVyT2ZNYXNzLFxuICAgICAgICBjZW50cm9pZCA9IHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZCxcbiAgICAgICAgbiA9IHVwZGF0ZUNlbnRlck9mTWFzc19uLFxuICAgICAgICBhID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2EsXG4gICAgICAgIGIgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYixcbiAgICAgICAgYyA9IHVwZGF0ZUNlbnRlck9mTWFzc19jLFxuICAgICAgICBhYyA9IHVwZGF0ZUNlbnRlck9mTWFzc19hYyxcbiAgICAgICAgY2EgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2EsXG4gICAgICAgIGNiID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2NiLFxuICAgICAgICBjZW50cm9pZF90aW1lc19tYXNzID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkX3RpbWVzX21hc3M7XG5cbiAgICB2ZWMyLnNldChjbSwwLDApO1xuICAgIHZhciB0b3RhbEFyZWEgPSAwO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT10cmlhbmdsZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdCA9IHRyaWFuZ2xlc1tpXSxcbiAgICAgICAgICAgIGEgPSB2ZXJ0c1t0WzBdXSxcbiAgICAgICAgICAgIGIgPSB2ZXJ0c1t0WzFdXSxcbiAgICAgICAgICAgIGMgPSB2ZXJ0c1t0WzJdXTtcblxuICAgICAgICB2ZWMyLmNlbnRyb2lkKGNlbnRyb2lkLGEsYixjKTtcblxuICAgICAgICAvLyBHZXQgbWFzcyBmb3IgdGhlIHRyaWFuZ2xlIChkZW5zaXR5PTEgaW4gdGhpcyBjYXNlKVxuICAgICAgICAvLyBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvODAxOTgvYXJlYS1vZi10cmlhbmdsZS12aWEtdmVjdG9yc1xuICAgICAgICB2YXIgbSA9IENvbnZleC50cmlhbmdsZUFyZWEoYSxiLGMpO1xuICAgICAgICB0b3RhbEFyZWEgKz0gbTtcblxuICAgICAgICAvLyBBZGQgdG8gY2VudGVyIG9mIG1hc3NcbiAgICAgICAgdmVjMi5zY2FsZShjZW50cm9pZF90aW1lc19tYXNzLCBjZW50cm9pZCwgbSk7XG4gICAgICAgIHZlYzIuYWRkKGNtLCBjbSwgY2VudHJvaWRfdGltZXNfbWFzcyk7XG4gICAgfVxuXG4gICAgdmVjMi5zY2FsZShjbSxjbSwxL3RvdGFsQXJlYSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIG1hc3MgbW9tZW50IG9mIGluZXJ0aWEgb2YgdGhlIENvbnZleC5cbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAc2VlIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvdG9waWMvMzQyODIyLW1vbWVudC1vZi1pbmVydGlhLW9mLWEtcG9seWdvbi0yZC9cbiAqL1xuQ29udmV4LnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgdmFyIGRlbm9tID0gMC4wLFxuICAgICAgICBudW1lciA9IDAuMCxcbiAgICAgICAgTiA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaiA9IE4tMSwgaSA9IDA7IGkgPCBOOyBqID0gaSwgaSArKyl7XG4gICAgICAgIHZhciBwMCA9IHRoaXMudmVydGljZXNbal07XG4gICAgICAgIHZhciBwMSA9IHRoaXMudmVydGljZXNbaV07XG4gICAgICAgIHZhciBhID0gTWF0aC5hYnModmVjMi5jcm9zc0xlbmd0aChwMCxwMSkpO1xuICAgICAgICB2YXIgYiA9IHZlYzIuZG90KHAxLHAxKSArIHZlYzIuZG90KHAxLHAwKSArIHZlYzIuZG90KHAwLHAwKTtcbiAgICAgICAgZGVub20gKz0gYSAqIGI7XG4gICAgICAgIG51bWVyICs9IGE7XG4gICAgfVxuICAgIHJldHVybiAobWFzcyAvIDYuMCkgKiAoZGVub20gLyBudW1lcik7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIC5ib3VuZGluZ1JhZGl1cyBwcm9wZXJ0eVxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5Db252ZXgucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzLFxuICAgICAgICByMiA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PXZlcnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGwyID0gdmVjMi5zcXVhcmVkTGVuZ3RoKHZlcnRzW2ldKTtcbiAgICAgICAgaWYobDIgPiByMil7XG4gICAgICAgICAgICByMiA9IGwyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IE1hdGguc3FydChyMik7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYXJlYSBvZiB0aGUgdHJpYW5nbGUgc3Bhbm5lZCBieSB0aGUgdGhyZWUgcG9pbnRzIGEsIGIsIGMuIFRoZSBhcmVhIGlzIHBvc2l0aXZlIGlmIHRoZSBwb2ludHMgYXJlIGdpdmVuIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLCBvdGhlcndpc2UgbmVnYXRpdmUuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHRyaWFuZ2xlQXJlYVxuICogQHBhcmFtIHtBcnJheX0gYVxuICogQHBhcmFtIHtBcnJheX0gYlxuICogQHBhcmFtIHtBcnJheX0gY1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Db252ZXgudHJpYW5nbGVBcmVhID0gZnVuY3Rpb24oYSxiLGMpe1xuICAgIHJldHVybiAoKChiWzBdIC0gYVswXSkqKGNbMV0gLSBhWzFdKSktKChjWzBdIC0gYVswXSkqKGJbMV0gLSBhWzFdKSkpICogMC41O1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIC5hcmVhXG4gKiBAbWV0aG9kIHVwZGF0ZUFyZWFcbiAqL1xuQ29udmV4LnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnVwZGF0ZVRyaWFuZ2xlcygpO1xuICAgIHRoaXMuYXJlYSA9IDA7XG5cbiAgICB2YXIgdHJpYW5nbGVzID0gdGhpcy50cmlhbmdsZXMsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBmb3IodmFyIGk9MDsgaSE9PXRyaWFuZ2xlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB0ID0gdHJpYW5nbGVzW2ldLFxuICAgICAgICAgICAgYSA9IHZlcnRzW3RbMF1dLFxuICAgICAgICAgICAgYiA9IHZlcnRzW3RbMV1dLFxuICAgICAgICAgICAgYyA9IHZlcnRzW3RbMl1dO1xuXG4gICAgICAgIC8vIEdldCBtYXNzIGZvciB0aGUgdHJpYW5nbGUgKGRlbnNpdHk9MSBpbiB0aGlzIGNhc2UpXG4gICAgICAgIHZhciBtID0gQ29udmV4LnRyaWFuZ2xlQXJlYShhLGIsYyk7XG4gICAgICAgIHRoaXMuYXJlYSArPSBtO1xuICAgIH1cbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuQ29udmV4LnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICBvdXQuc2V0RnJvbVBvaW50cyh0aGlzLnZlcnRpY2VzLCBwb3NpdGlvbiwgYW5nbGUsIDApO1xufTtcbiIsInZhciBTaGFwZSA9IHJlcXVpcmUoJy4vU2hhcGUnKVxuLCAgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcbiwgICAgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlaWdodGZpZWxkO1xuXG4vKipcbiAqIEhlaWdodGZpZWxkIHNoYXBlIGNsYXNzLiBIZWlnaHQgZGF0YSBpcyBnaXZlbiBhcyBhbiBhcnJheS4gVGhlc2UgZGF0YSBwb2ludHMgYXJlIHNwcmVhZCBvdXQgZXZlbmx5IHdpdGggYSBkaXN0YW5jZSBcImVsZW1lbnRXaWR0aFwiLlxuICogQGNsYXNzIEhlaWdodGZpZWxkXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIEFuIGFycmF5IG9mIFkgdmFsdWVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgdGVycmFpbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluVmFsdWVdIE1pbmltdW0gdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnRzIGluIHRoZSBkYXRhIGFycmF5LiBXaWxsIGJlIGNvbXB1dGVkIGF1dG9tYXRpY2FsbHkgaWYgbm90IGdpdmVuLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFZhbHVlXSBNYXhpbXVtIHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVsZW1lbnRXaWR0aD0wLjFdIFdvcmxkIHNwYWNpbmcgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb24uXG4gKiBAdG9kbyBTaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIGFsb25nIGFsbCBheGVzLCBub3QganVzdCB5XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBHZW5lcmF0ZSBzb21lIGhlaWdodCBkYXRhICh5LXZhbHVlcykuXG4gKiAgICAgdmFyIGRhdGEgPSBbXTtcbiAqICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKXtcbiAqICAgICAgICAgdmFyIHkgPSAwLjUgKiBNYXRoLmNvcygwLjIgKiBpKTtcbiAqICAgICAgICAgZGF0YS5wdXNoKHkpO1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gQ3JlYXRlIHRoZSBoZWlnaHRmaWVsZCBzaGFwZVxuICogICAgIHZhciBoZWlnaHRmaWVsZFNoYXBlID0gbmV3IEhlaWdodGZpZWxkKGRhdGEsIHtcbiAqICAgICAgICAgZWxlbWVudFdpZHRoOiAxIC8vIERpc3RhbmNlIGJldHdlZW4gdGhlIGRhdGEgcG9pbnRzIGluIFggZGlyZWN0aW9uXG4gKiAgICAgfSk7XG4gKiAgICAgdmFyIGhlaWdodGZpZWxkQm9keSA9IG5ldyBCb2R5KCk7XG4gKiAgICAgaGVpZ2h0ZmllbGRCb2R5LmFkZFNoYXBlKGhlaWdodGZpZWxkU2hhcGUpO1xuICogICAgIHdvcmxkLmFkZEJvZHkoaGVpZ2h0ZmllbGRCb2R5KTtcbiAqL1xuZnVuY3Rpb24gSGVpZ2h0ZmllbGQoZGF0YSwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgbWF4VmFsdWUgOiBudWxsLFxuICAgICAgICBtaW5WYWx1ZSA6IG51bGwsXG4gICAgICAgIGVsZW1lbnRXaWR0aCA6IDAuMVxuICAgIH0pO1xuXG4gICAgaWYob3B0aW9ucy5taW5WYWx1ZSA9PT0gbnVsbCB8fCBvcHRpb25zLm1heFZhbHVlID09PSBudWxsKXtcbiAgICAgICAgb3B0aW9ucy5tYXhWYWx1ZSA9IGRhdGFbMF07XG4gICAgICAgIG9wdGlvbnMubWluVmFsdWUgPSBkYXRhWzBdO1xuICAgICAgICBmb3IodmFyIGk9MDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgdiA9IGRhdGFbaV07XG4gICAgICAgICAgICBpZih2ID4gb3B0aW9ucy5tYXhWYWx1ZSl7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tYXhWYWx1ZSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih2IDwgb3B0aW9ucy5taW5WYWx1ZSl7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5taW5WYWx1ZSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBudW1iZXJzLCBvciBoZWlnaHQgdmFsdWVzLCB0aGF0IGFyZSBzcHJlYWQgb3V0IGFsb25nIHRoZSB4IGF4aXMuXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gZGF0YVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAvKipcbiAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGRhdGFcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4VmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLm1heFZhbHVlID0gb3B0aW9ucy5tYXhWYWx1ZTtcblxuICAgIC8qKlxuICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgZGF0YVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5WYWx1ZVxuICAgICAqL1xuICAgIHRoaXMubWluVmFsdWUgPSBvcHRpb25zLm1pblZhbHVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50V2lkdGhcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRXaWR0aCA9IG9wdGlvbnMuZWxlbWVudFdpZHRoO1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzLFNoYXBlLkhFSUdIVEZJRUxEKTtcbn1cbkhlaWdodGZpZWxkLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGVpZ2h0ZmllbGQ7XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIGFyZWEgPSAwO1xuICAgIGZvcih2YXIgaT0wOyBpPGRhdGEubGVuZ3RoLTE7IGkrKyl7XG4gICAgICAgIGFyZWEgKz0gKGRhdGFbaV0rZGF0YVtpKzFdKSAvIDIgKiB0aGlzLmVsZW1lbnRXaWR0aDtcbiAgICB9XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICAvLyBVc2UgdGhlIG1heCBkYXRhIHJlY3RhbmdsZVxuICAgIG91dC51cHBlckJvdW5kWzBdID0gdGhpcy5lbGVtZW50V2lkdGggKiB0aGlzLmRhdGEubGVuZ3RoICsgcG9zaXRpb25bMF07XG4gICAgb3V0LnVwcGVyQm91bmRbMV0gPSB0aGlzLm1heFZhbHVlICsgcG9zaXRpb25bMV07XG4gICAgb3V0Lmxvd2VyQm91bmRbMF0gPSBwb3NpdGlvblswXTtcbiAgICBvdXQubG93ZXJCb3VuZFsxXSA9IC1OdW1iZXIuTUFYX1ZBTFVFOyAvLyBJbmZpbml0eVxufTtcbiIsInZhciBTaGFwZSA9IHJlcXVpcmUoJy4vU2hhcGUnKVxuLCAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKipcbiAqIExpbmUgc2hhcGUgY2xhc3MuIFRoZSBsaW5lIHNoYXBlIGlzIGFsb25nIHRoZSB4IGRpcmVjdGlvbiwgYW5kIHN0cmV0Y2hlcyBmcm9tIFstbGVuZ3RoLzIsIDBdIHRvIFtsZW5ndGgvMiwwXS5cbiAqIEBjbGFzcyBMaW5lXG4gKiBAcGFyYW0ge051bWJlcn0gW2xlbmd0aD0xXSBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBsaW5lXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExpbmUobGVuZ3RoKXtcblxuICAgIC8qKlxuICAgICAqIExlbmd0aCBvZiB0aGlzIGxpbmVcbiAgICAgKiBAcHJvcGVydHkgbGVuZ3RoXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aCB8fCAxO1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzLFNoYXBlLkxJTkUpO1xufVxuTGluZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkxpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZTtcblxuTGluZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiBtYXNzICogTWF0aC5wb3codGhpcy5sZW5ndGgsMikgLyAxMjtcbn07XG5cbkxpbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5sZW5ndGgvMjtcbn07XG5cbnZhciBwb2ludHMgPSBbdmVjMi5jcmVhdGUoKSx2ZWMyLmNyZWF0ZSgpXTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuTGluZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIGwyID0gdGhpcy5sZW5ndGggLyAyO1xuICAgIHZlYzIuc2V0KHBvaW50c1swXSwgLWwyLCAgMCk7XG4gICAgdmVjMi5zZXQocG9pbnRzWzFdLCAgbDIsICAwKTtcbiAgICBvdXQuc2V0RnJvbVBvaW50cyhwb2ludHMscG9zaXRpb24sYW5nbGUsMCk7XG59O1xuXG4iLCJ2YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGU7XG5cbi8qKlxuICogUGFydGljbGUgc2hhcGUgY2xhc3MuXG4gKiBAY2xhc3MgUGFydGljbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqL1xuZnVuY3Rpb24gUGFydGljbGUoKXtcbiAgICBTaGFwZS5jYWxsKHRoaXMsU2hhcGUuUEFSVElDTEUpO1xufVxuUGFydGljbGUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5QYXJ0aWNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJ0aWNsZTtcblxuUGFydGljbGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICByZXR1cm4gMDsgLy8gQ2FuJ3Qgcm90YXRlIGEgcGFydGljbGVcbn07XG5cblBhcnRpY2xlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2ZWMyLmNvcHkob3V0Lmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcbiAgICB2ZWMyLmNvcHkob3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcbn07XG4iLCJ2YXIgU2hhcGUgPSAgcmVxdWlyZSgnLi9TaGFwZScpXG4sICAgIHZlYzIgPSAgcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcbiwgICAgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYW5lO1xuXG4vKipcbiAqIFBsYW5lIHNoYXBlIGNsYXNzLiBUaGUgcGxhbmUgaXMgZmFjaW5nIGluIHRoZSBZIGRpcmVjdGlvbi5cbiAqIEBjbGFzcyBQbGFuZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQbGFuZSgpe1xuICAgIFNoYXBlLmNhbGwodGhpcyxTaGFwZS5QTEFORSk7XG59XG5QbGFuZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblBsYW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lO1xuXG4vKipcbiAqIENvbXB1dGUgbW9tZW50IG9mIGluZXJ0aWFcbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICovXG5QbGFuZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiAwOyAvLyBQbGFuZSBpcyBpbmZpbml0ZS4gVGhlIGluZXJ0aWEgc2hvdWxkIHRoZXJlZm9yZSBiZSBpbmZpbnR5IGJ1dCBieSBjb252ZW50aW9uIHdlIHNldCAwIGhlcmVcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXNcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuUGxhbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuUGxhbmUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBhID0gMCxcbiAgICAgICAgc2V0ID0gdmVjMi5zZXQ7XG4gICAgaWYodHlwZW9mKGFuZ2xlKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICAgIGEgPSBhbmdsZSAlICgyKk1hdGguUEkpO1xuICAgIH1cblxuICAgIGlmKGEgPT09IDApe1xuICAgICAgICAvLyB5IGdvZXMgZnJvbSAtaW5mIHRvIDBcbiAgICAgICAgc2V0KG91dC5sb3dlckJvdW5kLCAtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICBzZXQob3V0LnVwcGVyQm91bmQsICBOdW1iZXIuTUFYX1ZBTFVFLCAgMCk7XG4gICAgfSBlbHNlIGlmKGEgPT09IE1hdGguUEkgLyAyKXtcbiAgICAgICAgLy8geCBnb2VzIGZyb20gMCB0byBpbmZcbiAgICAgICAgc2V0KG91dC5sb3dlckJvdW5kLCAwLCAtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHNldChvdXQudXBwZXJCb3VuZCwgICAgICBOdW1iZXIuTUFYX1ZBTFVFLCAgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgfSBlbHNlIGlmKGEgPT09IE1hdGguUEkpe1xuICAgICAgICAvLyB5IGdvZXMgZnJvbSAwIHRvIGluZlxuICAgICAgICBzZXQob3V0Lmxvd2VyQm91bmQsIC1OdW1iZXIuTUFYX1ZBTFVFLCAwKTtcbiAgICAgICAgc2V0KG91dC51cHBlckJvdW5kLCAgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgfSBlbHNlIGlmKGEgPT09IDMqTWF0aC5QSS8yKXtcbiAgICAgICAgLy8geCBnb2VzIGZyb20gLWluZiB0byAwXG4gICAgICAgIHNldChvdXQubG93ZXJCb3VuZCwgLU51bWJlci5NQVhfVkFMVUUsICAgICAtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHNldChvdXQudXBwZXJCb3VuZCwgIDAsICBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXQgbWF4IGJvdW5kc1xuICAgICAgICBzZXQob3V0Lmxvd2VyQm91bmQsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHNldChvdXQudXBwZXJCb3VuZCwgIE51bWJlci5NQVhfVkFMVUUsICBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB9XG5cbiAgICB2ZWMyLmFkZChvdXQubG93ZXJCb3VuZCwgb3V0Lmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcbiAgICB2ZWMyLmFkZChvdXQudXBwZXJCb3VuZCwgb3V0LnVwcGVyQm91bmQsIHBvc2l0aW9uKTtcbn07XG5cblBsYW5lLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmFyZWEgPSBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuIiwidmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpXG4sICAgQ29udmV4ID0gcmVxdWlyZSgnLi9Db252ZXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGU7XG5cbi8qKlxuICogUmVjdGFuZ2xlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIFJlY3RhbmdsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTFdIFdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0xXSBIZWlnaHRcbiAqIEBleHRlbmRzIENvbnZleFxuICovXG5mdW5jdGlvbiBSZWN0YW5nbGUod2lkdGgsIGhlaWdodCl7XG5cbiAgICAvKipcbiAgICAgKiBUb3RhbCB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHByb3BlcnR5IHdpZHRoXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMTtcblxuICAgIC8qKlxuICAgICAqIFRvdGFsIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHByb3BlcnR5IGhlaWdodFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMTtcblxuICAgIHZhciB2ZXJ0cyA9IFsgICB2ZWMyLmZyb21WYWx1ZXMoLXdpZHRoLzIsIC1oZWlnaHQvMiksXG4gICAgICAgICAgICAgICAgICAgIHZlYzIuZnJvbVZhbHVlcyggd2lkdGgvMiwgLWhlaWdodC8yKSxcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5mcm9tVmFsdWVzKCB3aWR0aC8yLCAgaGVpZ2h0LzIpLFxuICAgICAgICAgICAgICAgICAgICB2ZWMyLmZyb21WYWx1ZXMoLXdpZHRoLzIsICBoZWlnaHQvMildO1xuICAgIHZhciBheGVzID0gW3ZlYzIuZnJvbVZhbHVlcygxLCAwKSwgdmVjMi5mcm9tVmFsdWVzKDAsIDEpXTtcblxuICAgIENvbnZleC5jYWxsKHRoaXMsIHZlcnRzLCBheGVzKTtcblxuICAgIHRoaXMudHlwZSA9IFNoYXBlLlJFQ1RBTkdMRTtcbn1cblJlY3RhbmdsZS5wcm90b3R5cGUgPSBuZXcgQ29udmV4KFtdKTtcblJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWN0YW5nbGU7XG5cbi8qKlxuICogQ29tcHV0ZSBtb21lbnQgb2YgaW5lcnRpYVxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuUmVjdGFuZ2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoLFxuICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgcmV0dXJuIG1hc3MgKiAoaCpoICsgdyp3KSAvIDEyO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1c1xuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5SZWN0YW5nbGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgIGggPSB0aGlzLmhlaWdodDtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTWF0aC5zcXJ0KHcqdyArIGgqaCkgLyAyO1xufTtcblxudmFyIGNvcm5lcjEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvcm5lcjIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvcm5lcjMgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvcm5lcjQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5SZWN0YW5nbGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIG91dC5zZXRGcm9tUG9pbnRzKHRoaXMudmVydGljZXMscG9zaXRpb24sYW5nbGUsMCk7XG59O1xuXG5SZWN0YW5nbGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gU2hhcGU7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igc2hhcGVzLlxuICogQGNsYXNzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIFNoYXBlKHR5cGUpe1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHNoYXBlLiBPbmUgb2Y6XG4gICAgICpcbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0NJUkNMRTpwcm9wZXJ0eVwifX1TaGFwZS5DSVJDTEV7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvUEFSVElDTEU6cHJvcGVydHlcIn19U2hhcGUuUEFSVElDTEV7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvUExBTkU6cHJvcGVydHlcIn19U2hhcGUuUExBTkV7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvQ09OVkVYOnByb3BlcnR5XCJ9fVNoYXBlLkNPTlZFWHt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9MSU5FOnByb3BlcnR5XCJ9fVNoYXBlLkxJTkV7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvUkVDVEFOR0xFOnByb3BlcnR5XCJ9fVNoYXBlLlJFQ1RBTkdMRXt7L2Nyb3NzTGlua319XG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9DQVBTVUxFOnByb3BlcnR5XCJ9fVNoYXBlLkNBUFNVTEV7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvSEVJR0hURklFTEQ6cHJvcGVydHlcIn19U2hhcGUuSEVJR0hURklFTER7ey9jcm9zc0xpbmt9fVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHR5cGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogU2hhcGUgb2JqZWN0IGlkZW50aWZpZXIuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKi9cbiAgICB0aGlzLmlkID0gU2hhcGUuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBCb3VuZGluZyBjaXJjbGUgcmFkaXVzIG9mIHRoaXMgc2hhcGVcbiAgICAgKiBAcHJvcGVydHkgYm91bmRpbmdSYWRpdXNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQ29sbGlzaW9uIGdyb3VwIHRoYXQgdGhpcyBzaGFwZSBiZWxvbmdzIHRvIChiaXQgbWFzaykuIFNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy5hdXJlbGllbnJpYm9uLmNvbS9ibG9nLzIwMTEvMDcvYm94MmQtdHV0b3JpYWwtY29sbGlzaW9uLWZpbHRlcmluZy9cIj50aGlzIHR1dG9yaWFsPC9hPi5cbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uR3JvdXBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIFNldHVwIGJpdHMgZm9yIGVhY2ggYXZhaWxhYmxlIGdyb3VwXG4gICAgICogICAgIHZhciBQTEFZRVIgPSBNYXRoLnBvdygyLDApLFxuICAgICAqICAgICAgICAgRU5FTVkgPSAgTWF0aC5wb3coMiwxKSxcbiAgICAgKiAgICAgICAgIEdST1VORCA9IE1hdGgucG93KDIsMilcbiAgICAgKlxuICAgICAqICAgICAvLyBQdXQgc2hhcGVzIGludG8gdGhlaXIgZ3JvdXBzXG4gICAgICogICAgIHBsYXllcjFTaGFwZS5jb2xsaXNpb25Hcm91cCA9IFBMQVlFUjtcbiAgICAgKiAgICAgcGxheWVyMlNoYXBlLmNvbGxpc2lvbkdyb3VwID0gUExBWUVSO1xuICAgICAqICAgICBlbmVteVNoYXBlICAuY29sbGlzaW9uR3JvdXAgPSBFTkVNWTtcbiAgICAgKiAgICAgZ3JvdW5kU2hhcGUgLmNvbGxpc2lvbkdyb3VwID0gR1JPVU5EO1xuICAgICAqXG4gICAgICogICAgIC8vIEFzc2lnbiBncm91cHMgdGhhdCBlYWNoIHNoYXBlIGNvbGxpZGUgd2l0aC5cbiAgICAgKiAgICAgLy8gTm90ZSB0aGF0IHRoZSBwbGF5ZXJzIGNhbiBjb2xsaWRlIHdpdGggZ3JvdW5kIGFuZCBlbmVtaWVzLCBidXQgbm90IHdpdGggb3RoZXIgcGxheWVycy5cbiAgICAgKiAgICAgcGxheWVyMVNoYXBlLmNvbGxpc2lvbk1hc2sgPSBFTkVNWSB8IEdST1VORDtcbiAgICAgKiAgICAgcGxheWVyMlNoYXBlLmNvbGxpc2lvbk1hc2sgPSBFTkVNWSB8IEdST1VORDtcbiAgICAgKiAgICAgZW5lbXlTaGFwZSAgLmNvbGxpc2lvbk1hc2sgPSBQTEFZRVIgfCBHUk9VTkQ7XG4gICAgICogICAgIGdyb3VuZFNoYXBlIC5jb2xsaXNpb25NYXNrID0gUExBWUVSIHwgRU5FTVk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBIb3cgY29sbGlzaW9uIGNoZWNrIGlzIGRvbmVcbiAgICAgKiAgICAgaWYoc2hhcGVBLmNvbGxpc2lvbkdyb3VwICYgc2hhcGVCLmNvbGxpc2lvbk1hc2spIT0wICYmIChzaGFwZUIuY29sbGlzaW9uR3JvdXAgJiBzaGFwZUEuY29sbGlzaW9uTWFzaykhPTApe1xuICAgICAqICAgICAgICAgLy8gVGhlIHNoYXBlcyB3aWxsIGNvbGxpZGVcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uR3JvdXAgPSAxO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBwcm9kdWNlIGNvbnRhY3QgZm9yY2VzIHdoZW4gaW4gY29udGFjdCB3aXRoIG90aGVyIGJvZGllcy4gTm90ZSB0aGF0IGNvbnRhY3RzIHdpbGwgYmUgZ2VuZXJhdGVkLCBidXQgdGhleSB3aWxsIGJlIGRpc2FibGVkLiBUaGF0IG1lYW5zIHRoYXQgdGhpcyBzaGFwZSB3aWxsIG1vdmUgdGhyb3VnaCBvdGhlciBib2R5IHNoYXBlcywgYnV0IGl0IHdpbGwgc3RpbGwgdHJpZ2dlciBjb250YWN0IGV2ZW50cywgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29sbGlzaW9uUmVzcG9uc2VcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvblJlc3BvbnNlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIENvbGxpc2lvbiBtYXNrIG9mIHRoaXMgc2hhcGUuIFNlZSAuY29sbGlzaW9uR3JvdXAuXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbk1hc2tcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uTWFzayA9ICAxO1xuICAgIGlmKHR5cGUpe1xuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWF0ZXJpYWwgdG8gdXNlIGluIGNvbGxpc2lvbnMgZm9yIHRoaXMgU2hhcGUuIElmIHRoaXMgaXMgc2V0IHRvIG51bGwsIHRoZSB3b3JsZCB3aWxsIHVzZSBkZWZhdWx0IG1hdGVyaWFsIHByb3BlcnRpZXMgaW5zdGVhZC5cbiAgICAgKiBAcHJvcGVydHkgbWF0ZXJpYWxcbiAgICAgKiBAdHlwZSB7TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBcmVhIG9mIHRoaXMgc2hhcGUuXG4gICAgICogQHByb3BlcnR5IGFyZWFcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYXJlYSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGlzIHNoYXBlIHRvIGJlIGEgc2Vuc29yLiBBIHNlbnNvciBkb2VzIG5vdCBnZW5lcmF0ZSBjb250YWN0cywgYnV0IGl0IHN0aWxsIHJlcG9ydHMgY29udGFjdCBldmVudHMuIFRoaXMgaXMgZ29vZCBpZiB5b3Ugd2FudCB0byBrbm93IGlmIGEgc2hhcGUgaXMgb3ZlcmxhcHBpbmcgYW5vdGhlciBzaGFwZSwgd2l0aG91dCB0aGVtIGdlbmVyYXRpbmcgY29udGFjdHMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzZW5zb3JcbiAgICAgKi9cbiAgICB0aGlzLnNlbnNvciA9IGZhbHNlO1xuXG4gICAgdGhpcy51cGRhdGVBcmVhKCk7XG59XG5cblNoYXBlLmlkQ291bnRlciA9IDA7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IENJUkNMRVxuICovXG5TaGFwZS5DSVJDTEUgPSAgICAgIDE7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IFBBUlRJQ0xFXG4gKi9cblNoYXBlLlBBUlRJQ0xFID0gICAgMjtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gUExBTkVcbiAqL1xuU2hhcGUuUExBTkUgPSAgICAgICA0O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBDT05WRVhcbiAqL1xuU2hhcGUuQ09OVkVYID0gICAgICA4O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBMSU5FXG4gKi9cblNoYXBlLkxJTkUgPSAgICAgICAgMTY7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IFJFQ1RBTkdMRVxuICovXG5TaGFwZS5SRUNUQU5HTEUgPSAgIDMyO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBDQVBTVUxFXG4gKi9cblNoYXBlLkNBUFNVTEUgPSAgICAgNjQ7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEhFSUdIVEZJRUxEXG4gKi9cblNoYXBlLkhFSUdIVEZJRUxEID0gMTI4O1xuXG4vKipcbiAqIFNob3VsZCByZXR1cm4gdGhlIG1vbWVudCBvZiBpbmVydGlhIGFyb3VuZCB0aGUgWiBheGlzIG9mIHRoZSBib2R5IGdpdmVuIHRoZSB0b3RhbCBtYXNzLiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcIj5XaWtpcGVkaWEncyBsaXN0IG9mIG1vbWVudHMgb2YgaW5lcnRpYTwvYT4uXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfSBJZiB0aGUgaW5lcnRpYSBpcyBpbmZpbml0eSBvciBpZiB0aGUgb2JqZWN0IHNpbXBseSBpc24ndCBwb3NzaWJsZSB0byByb3RhdGUsIHJldHVybiAwLlxuICovXG5TaGFwZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNoYXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgU2hhcGUuLi5cIik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNpcmNsZSByYWRpdXMgb2YgdGhpcyBzaGFwZS5cbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuU2hhcGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBTaGFwZS4uLlwiKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSAuYXJlYSBwcm9wZXJ0eSBvZiB0aGUgc2hhcGUuXG4gKiBAbWV0aG9kIHVwZGF0ZUFyZWFcbiAqL1xuU2hhcGUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIC8vIFRvIGJlIGltcGxlbWVudGVkIGluIGFsbCBzdWJjbGFzc2VzXG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIHdvcmxkIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggKEFBQkIpIG9mIHRoaXMgc2hhcGUuXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuU2hhcGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIC8vIFRvIGJlIGltcGxlbWVudGVkIGluIGVhY2ggc3ViY2xhc3Ncbn07XG4iLCJ2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXG4sICAgU29sdmVyID0gcmVxdWlyZSgnLi9Tb2x2ZXInKVxuLCAgIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIEZyaWN0aW9uRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdTU29sdmVyO1xuXG4vKipcbiAqIEl0ZXJhdGl2ZSBHYXVzcy1TZWlkZWwgY29uc3RyYWludCBlcXVhdGlvbiBzb2x2ZXIuXG4gKlxuICogQGNsYXNzIEdTU29sdmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFNvbHZlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLml0ZXJhdGlvbnM9MTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9sZXJhbmNlPTBdXG4gKi9cbmZ1bmN0aW9uIEdTU29sdmVyKG9wdGlvbnMpe1xuICAgIFNvbHZlci5jYWxsKHRoaXMsb3B0aW9ucyxTb2x2ZXIuR1MpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIGRvIHdoZW4gc29sdmluZy4gTW9yZSBnaXZlcyBiZXR0ZXIgcmVzdWx0cywgYnV0IGlzIG1vcmUgZXhwZW5zaXZlLlxuICAgICAqIEBwcm9wZXJ0eSBpdGVyYXRpb25zXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLml0ZXJhdGlvbnMgPSBvcHRpb25zLml0ZXJhdGlvbnMgfHwgMTA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXJyb3IgdG9sZXJhbmNlLCBwZXIgY29uc3RyYWludC4gSWYgdGhlIHRvdGFsIGVycm9yIGlzIGJlbG93IHRoaXMgbGltaXQsIHRoZSBzb2x2ZXIgd2lsbCBzdG9wIGl0ZXJhdGluZy4gU2V0IHRvIHplcm8gZm9yIGFzIGdvb2Qgc29sdXRpb24gYXMgcG9zc2libGUsIGJ1dCB0byBzb21ldGhpbmcgbGFyZ2VyIHRoYW4gemVybyB0byBtYWtlIGNvbXB1dGF0aW9ucyBmYXN0ZXIuXG4gICAgICogQHByb3BlcnR5IHRvbGVyYW5jZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50b2xlcmFuY2UgPSBvcHRpb25zLnRvbGVyYW5jZSB8fCAxZS0xMDtcblxuICAgIHRoaXMuYXJyYXlTdGVwID0gMzA7XG4gICAgdGhpcy5sYW1iZGEgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSh0aGlzLmFycmF5U3RlcCk7XG4gICAgdGhpcy5CcyA9ICAgICBuZXcgVXRpbHMuQVJSQVlfVFlQRSh0aGlzLmFycmF5U3RlcCk7XG4gICAgdGhpcy5pbnZDcyA9ICBuZXcgVXRpbHMuQVJSQVlfVFlQRSh0aGlzLmFycmF5U3RlcCk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBzZXQgYWxsIHJpZ2h0IGhhbmQgc2lkZSB0ZXJtcyB0byB6ZXJvIHdoZW4gc29sdmluZy4gQ2FuIGJlIGhhbmR5IGZvciBhIGZldyBhcHBsaWNhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHVzZVplcm9SSFNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZVplcm9SSFMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBzb2x2ZXIgaXRlcmF0aW9ucyB0aGF0IGFyZSBkb25lIHRvIGFwcHJveGltYXRlIG5vcm1hbCBmb3JjZXMuIFdoZW4gdGhlc2UgaXRlcmF0aW9ucyBhcmUgZG9uZSwgZnJpY3Rpb24gZm9yY2Ugd2lsbCBiZSBjb21wdXRlZCBmcm9tIHRoZSBjb250YWN0IG5vcm1hbCBmb3JjZXMuIFRoZXNlIGZyaWN0aW9uIGZvcmNlcyB3aWxsIG92ZXJyaWRlIGFueSBvdGhlciBmcmljdGlvbiBmb3JjZXMgc2V0IGZyb20gdGhlIFdvcmxkIGZvciBleGFtcGxlLlxuICAgICAqIFRoZSBzb2x2ZXIgd2lsbCB1c2UgbGVzcyBpdGVyYXRpb25zIGlmIHRoZSBzb2x1dGlvbiBpcyBiZWxvdyB0aGUgLnRvbGVyYW5jZS5cbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25JdGVyYXRpb25zXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uSXRlcmF0aW9ucyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdGhhdCB3ZXJlIG1hZGUgZHVyaW5nIHRoZSBsYXN0IHNvbHZlLiBJZiAudG9sZXJhbmNlIGlzIHplcm8sIHRoaXMgdmFsdWUgd2lsbCBhbHdheXMgYmUgZXF1YWwgdG8gLml0ZXJhdGlvbnMsIGJ1dCBpZiAudG9sZXJhbmNlIGlzIGxhcmdlciB0aGFuIHplcm8sIGFuZCB0aGUgc29sdmVyIGNhbiBxdWl0IGVhcmx5LCB0aGVuIHRoaXMgbnVtYmVyIHdpbGwgYmUgc29tZXdoZXJlIGJldHdlZW4gMSBhbmQgLml0ZXJhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHVzZWRJdGVyYXRpb25zXG4gICAgICovXG4gICAgdGhpcy51c2VkSXRlcmF0aW9ucyA9IDA7XG59XG5HU1NvbHZlci5wcm90b3R5cGUgPSBuZXcgU29sdmVyKCk7XG5HU1NvbHZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHU1NvbHZlcjtcblxuZnVuY3Rpb24gc2V0QXJyYXlaZXJvKGFycmF5KXtcbiAgICB2YXIgbCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICBhcnJheVtsXSA9ICswLjA7XG4gICAgfVxufVxuXG4vKipcbiAqIFNvbHZlIHRoZSBzeXN0ZW0gb2YgZXF1YXRpb25zXG4gKiBAbWV0aG9kIHNvbHZlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBoICAgICAgIFRpbWUgc3RlcFxuICogQHBhcmFtICB7V29ybGR9ICAgd29ybGQgICAgV29ybGQgdG8gc29sdmVcbiAqL1xuR1NTb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oaCwgd29ybGQpe1xuXG4gICAgdGhpcy5zb3J0RXF1YXRpb25zKCk7XG5cbiAgICB2YXIgaXRlciA9IDAsXG4gICAgICAgIG1heEl0ZXIgPSB0aGlzLml0ZXJhdGlvbnMsXG4gICAgICAgIG1heEZyaWN0aW9uSXRlciA9IHRoaXMuZnJpY3Rpb25JdGVyYXRpb25zLFxuICAgICAgICBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgTmVxID0gZXF1YXRpb25zLmxlbmd0aCxcbiAgICAgICAgdG9sU3F1YXJlZCA9IE1hdGgucG93KHRoaXMudG9sZXJhbmNlKk5lcSwgMiksXG4gICAgICAgIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgTmJvZGllcyA9IHdvcmxkLmJvZGllcy5sZW5ndGgsXG4gICAgICAgIGFkZCA9IHZlYzIuYWRkLFxuICAgICAgICBzZXQgPSB2ZWMyLnNldCxcbiAgICAgICAgdXNlWmVyb1JIUyA9IHRoaXMudXNlWmVyb1JIUyxcbiAgICAgICAgbGFtYmRhID0gdGhpcy5sYW1iZGE7XG5cbiAgICB0aGlzLnVzZWRJdGVyYXRpb25zID0gMDtcblxuICAgIGlmKE5lcSl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgc29sdmUgbWFzc1xuICAgICAgICAgICAgYi51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGluZ3MgdGhhdCBkb2VzIG5vdCBjaGFuZ2UgZHVyaW5nIGl0ZXJhdGlvbiBjYW4gYmUgY29tcHV0ZWQgb25jZVxuICAgIGlmKGxhbWJkYS5sZW5ndGggPCBOZXEpe1xuICAgICAgICBsYW1iZGEgPSB0aGlzLmxhbWJkYSA9ICBuZXcgVXRpbHMuQVJSQVlfVFlQRShOZXEgKyB0aGlzLmFycmF5U3RlcCk7XG4gICAgICAgIHRoaXMuQnMgPSAgICAgICAgICAgICAgIG5ldyBVdGlscy5BUlJBWV9UWVBFKE5lcSArIHRoaXMuYXJyYXlTdGVwKTtcbiAgICAgICAgdGhpcy5pbnZDcyA9ICAgICAgICAgICAgbmV3IFV0aWxzLkFSUkFZX1RZUEUoTmVxICsgdGhpcy5hcnJheVN0ZXApO1xuICAgIH1cbiAgICBzZXRBcnJheVplcm8obGFtYmRhKTtcbiAgICB2YXIgaW52Q3MgPSB0aGlzLmludkNzLFxuICAgICAgICBCcyA9IHRoaXMuQnMsXG4gICAgICAgIGxhbWJkYSA9IHRoaXMubGFtYmRhO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1lcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGVxdWF0aW9uc1tpXTtcbiAgICAgICAgaWYoYy50aW1lU3RlcCAhPT0gaCB8fCBjLm5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGMudGltZVN0ZXAgPSBoO1xuICAgICAgICAgICAgYy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBCc1tpXSA9ICAgICBjLmNvbXB1dGVCKGMuYSxjLmIsaCk7XG4gICAgICAgIGludkNzW2ldID0gIGMuY29tcHV0ZUludkMoYy5lcHNpbG9uKTtcbiAgICB9XG5cbiAgICB2YXIgcSwgQiwgYywgZGVsdGFsYW1iZGFUb3QsaSxqO1xuXG4gICAgaWYoTmVxICE9PSAwKXtcblxuICAgICAgICBmb3IoaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAvLyBSZXNldCB2bGFtYmRhXG4gICAgICAgICAgICBiLnJlc2V0Q29uc3RyYWludFZlbG9jaXR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihtYXhGcmljdGlvbkl0ZXIpe1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGNvbnRhY3QgZXF1YXRpb25zIHRvIGdldCBub3JtYWwgZm9yY2VzXG4gICAgICAgICAgICBmb3IoaXRlcj0wOyBpdGVyIT09bWF4RnJpY3Rpb25JdGVyOyBpdGVyKyspe1xuXG4gICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgdG90YWwgZXJyb3IgZm9yIGVhY2ggaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ID0gMC4wO1xuXG4gICAgICAgICAgICAgICAgZm9yKGo9MDsgaiE9PU5lcTsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGVxdWF0aW9uc1tqXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFsYW1iZGEgPSBHU1NvbHZlci5pdGVyYXRlRXF1YXRpb24oaixjLGMuZXBzaWxvbixCcyxpbnZDcyxsYW1iZGEsdXNlWmVyb1JIUyxoLGl0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBNYXRoLmFicyhkZWx0YWxhbWJkYSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy51c2VkSXRlcmF0aW9ucysrO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxuICAgICAgICAgICAgICAgIGlmKGRlbHRhbGFtYmRhVG90KmRlbHRhbGFtYmRhVG90IDw9IHRvbFNxdWFyZWQpe1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEdTU29sdmVyLnVwZGF0ZU11bHRpcGxpZXJzKGVxdWF0aW9ucywgbGFtYmRhLCAxL2gpO1xuXG4gICAgICAgICAgICAvLyBTZXQgY29tcHV0ZWQgZnJpY3Rpb24gZm9yY2VcbiAgICAgICAgICAgIGZvcihqPTA7IGohPT1OZXE7IGorKyl7XG4gICAgICAgICAgICAgICAgdmFyIGVxID0gZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgICAgIGlmKGVxIGluc3RhbmNlb2YgRnJpY3Rpb25FcXVhdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgayE9PWVxLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgZiArPSBlcS5jb250YWN0RXF1YXRpb25zW2tdLm11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZiAqPSBlcS5mcmljdGlvbkNvZWZmaWNpZW50IC8gZXEuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGVxLm1heEZvcmNlID0gIGY7XG4gICAgICAgICAgICAgICAgICAgIGVxLm1pbkZvcmNlID0gLWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlcXVhdGlvbnNcbiAgICAgICAgZm9yKGl0ZXI9MDsgaXRlciE9PW1heEl0ZXI7IGl0ZXIrKyl7XG5cbiAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHRvdGFsIGVycm9yIGZvciBlYWNoIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ID0gMC4wO1xuXG4gICAgICAgICAgICBmb3Ioaj0wOyBqIT09TmVxOyBqKyspe1xuICAgICAgICAgICAgICAgIGMgPSBlcXVhdGlvbnNbal07XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFsYW1iZGEgPSBHU1NvbHZlci5pdGVyYXRlRXF1YXRpb24oaixjLGMuZXBzaWxvbixCcyxpbnZDcyxsYW1iZGEsdXNlWmVyb1JIUyxoLGl0ZXIpO1xuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ICs9IE1hdGguYWJzKGRlbHRhbGFtYmRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51c2VkSXRlcmF0aW9ucysrO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgZXJyb3IgaXMgc21hbGwgZW5vdWdoIC0gc3RvcCBpdGVyYXRlXG4gICAgICAgICAgICBpZihkZWx0YWxhbWJkYVRvdCpkZWx0YWxhbWJkYVRvdCA8PSB0b2xTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCByZXN1bHQgdG8gdmVsb2NpdHlcbiAgICAgICAgZm9yKGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICBib2RpZXNbaV0uYWRkQ29uc3RyYWludFZlbG9jaXR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBHU1NvbHZlci51cGRhdGVNdWx0aXBsaWVycyhlcXVhdGlvbnMsIGxhbWJkYSwgMS9oKTtcbiAgICB9XG59O1xuXG4vLyBTZXRzIHRoZSAubXVsdGlwbGllciBwcm9wZXJ0eSBvZiBlYWNoIGVxdWF0aW9uXG5HU1NvbHZlci51cGRhdGVNdWx0aXBsaWVycyA9IGZ1bmN0aW9uKGVxdWF0aW9ucywgbGFtYmRhLCBpbnZEdCl7XG4gICAgLy8gU2V0IHRoZSAubXVsdGlwbGllciBwcm9wZXJ0eSBvZiBlYWNoIGVxdWF0aW9uXG4gICAgdmFyIGwgPSBlcXVhdGlvbnMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIGVxdWF0aW9uc1tsXS5tdWx0aXBsaWVyID0gbGFtYmRhW2xdICogaW52RHQ7XG4gICAgfVxufTtcblxuR1NTb2x2ZXIuaXRlcmF0ZUVxdWF0aW9uID0gZnVuY3Rpb24oaixlcSxlcHMsQnMsaW52Q3MsbGFtYmRhLHVzZVplcm9SSFMsZHQsaXRlcil7XG4gICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cbiAgICB2YXIgQiA9IEJzW2pdLFxuICAgICAgICBpbnZDID0gaW52Q3Nbal0sXG4gICAgICAgIGxhbWJkYWogPSBsYW1iZGFbal0sXG4gICAgICAgIEdXbGFtYmRhID0gZXEuY29tcHV0ZUdXbGFtYmRhKCk7XG5cbiAgICB2YXIgbWF4Rm9yY2UgPSBlcS5tYXhGb3JjZSxcbiAgICAgICAgbWluRm9yY2UgPSBlcS5taW5Gb3JjZTtcblxuICAgIGlmKHVzZVplcm9SSFMpe1xuICAgICAgICBCID0gMDtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFsYW1iZGEgPSBpbnZDICogKCBCIC0gR1dsYW1iZGEgLSBlcHMgKiBsYW1iZGFqICk7XG5cbiAgICAvLyBDbGFtcCBpZiB3ZSBhcmUgbm90IHdpdGhpbiB0aGUgbWluL21heCBpbnRlcnZhbFxuICAgIHZhciBsYW1iZGFqX3BsdXNfZGVsdGFsYW1iZGEgPSBsYW1iZGFqICsgZGVsdGFsYW1iZGE7XG4gICAgaWYobGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhIDwgbWluRm9yY2UqZHQpe1xuICAgICAgICBkZWx0YWxhbWJkYSA9IG1pbkZvcmNlKmR0IC0gbGFtYmRhajtcbiAgICB9IGVsc2UgaWYobGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhID4gbWF4Rm9yY2UqZHQpe1xuICAgICAgICBkZWx0YWxhbWJkYSA9IG1heEZvcmNlKmR0IC0gbGFtYmRhajtcbiAgICB9XG4gICAgbGFtYmRhW2pdICs9IGRlbHRhbGFtYmRhO1xuICAgIGVxLmFkZFRvV2xhbWJkYShkZWx0YWxhbWJkYSk7XG5cbiAgICByZXR1cm4gZGVsdGFsYW1iZGE7XG59O1xuIiwidmFyIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4uL2V2ZW50cy9FdmVudEVtaXR0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2x2ZXI7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29uc3RyYWludCBzb2x2ZXJzLlxuICogQGNsYXNzIFNvbHZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuZnVuY3Rpb24gU29sdmVyKG9wdGlvbnMsdHlwZSl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGVxdWF0aW9ucyBpbiB0aGUgc29sdmVyLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHNvcnQgYWxsIGVxdWF0aW9ucyBiZWZvcmUgZWFjaCBzb2x2ZS5cbiAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25Tb3J0RnVuY3Rpb25cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb258Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9uU29ydEZ1bmN0aW9uID0gb3B0aW9ucy5lcXVhdGlvblNvcnRGdW5jdGlvbiB8fCBmYWxzZTtcbn1cblNvbHZlci5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5Tb2x2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29sdmVyO1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbXBsZW1lbnRlZCBpbiBlYWNoIHN1YmNsYXNzXG4gKiBAbWV0aG9kIHNvbHZlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGR0XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKGR0LHdvcmxkKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb2x2ZXIuc29sdmUgc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMhXCIpO1xufTtcblxudmFyIG1vY2tXb3JsZCA9IHtib2RpZXM6W119O1xuXG4vKipcbiAqIFNvbHZlcyBhbGwgY29uc3RyYWludHMgaW4gYW4gaXNsYW5kLlxuICogQG1ldGhvZCBzb2x2ZUlzbGFuZFxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICogQHBhcmFtICB7SXNsYW5kfSBpc2xhbmRcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5zb2x2ZUlzbGFuZCA9IGZ1bmN0aW9uKGR0LGlzbGFuZCl7XG5cbiAgICB0aGlzLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuXG4gICAgaWYoaXNsYW5kLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICAvLyBBZGQgZXF1YXRpb25zIHRvIHNvbHZlclxuICAgICAgICB0aGlzLmFkZEVxdWF0aW9ucyhpc2xhbmQuZXF1YXRpb25zKTtcbiAgICAgICAgbW9ja1dvcmxkLmJvZGllcy5sZW5ndGggPSAwO1xuICAgICAgICBpc2xhbmQuZ2V0Qm9kaWVzKG1vY2tXb3JsZC5ib2RpZXMpO1xuXG4gICAgICAgIC8vIFNvbHZlXG4gICAgICAgIGlmKG1vY2tXb3JsZC5ib2RpZXMubGVuZ3RoKXtcbiAgICAgICAgICAgIHRoaXMuc29sdmUoZHQsbW9ja1dvcmxkKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogU29ydCBhbGwgZXF1YXRpb25zIHVzaW5nIHRoZSAuZXF1YXRpb25Tb3J0RnVuY3Rpb24uIFNob3VsZCBiZSBjYWxsZWQgYnkgc3ViY2xhc3NlcyBiZWZvcmUgc29sdmluZy5cbiAqIEBtZXRob2Qgc29ydEVxdWF0aW9uc1xuICovXG5Tb2x2ZXIucHJvdG90eXBlLnNvcnRFcXVhdGlvbnMgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24pe1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5zb3J0KHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24pO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGFuIGVxdWF0aW9uIHRvIGJlIHNvbHZlZC5cbiAqXG4gKiBAbWV0aG9kIGFkZEVxdWF0aW9uXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICovXG5Tb2x2ZXIucHJvdG90eXBlLmFkZEVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xuICAgIGlmKGVxLmVuYWJsZWQpe1xuICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBlcXVhdGlvbnMuIFNhbWUgYXMgLmFkZEVxdWF0aW9uLCBidXQgdGhpcyB0aW1lIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBvZiBFcXVhdGlvbnNcbiAqXG4gKiBAbWV0aG9kIGFkZEVxdWF0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gZXFzXG4gKi9cblNvbHZlci5wcm90b3R5cGUuYWRkRXF1YXRpb25zID0gZnVuY3Rpb24oZXFzKXtcbiAgICAvL1V0aWxzLmFwcGVuZEFycmF5KHRoaXMuZXF1YXRpb25zLGVxcyk7XG4gICAgZm9yKHZhciBpPTAsIE49ZXFzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tpXTtcbiAgICAgICAgaWYoZXEuZW5hYmxlZCl7XG4gICAgICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGVxdWF0aW9uLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlRXF1YXRpb25cbiAqIEBwYXJhbSB7RXF1YXRpb259IGVxXG4gKi9cblNvbHZlci5wcm90b3R5cGUucmVtb3ZlRXF1YXRpb24gPSBmdW5jdGlvbihlcSl7XG4gICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKGVxKTtcbiAgICBpZihpICE9PSAtMSl7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnNwbGljZShpLDEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBjdXJyZW50bHkgYWRkZWQgZXF1YXRpb25zLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQWxsRXF1YXRpb25zXG4gKi9cblNvbHZlci5wcm90b3R5cGUucmVtb3ZlQWxsRXF1YXRpb25zID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVxdWF0aW9ucy5sZW5ndGg9MDtcbn07XG5cblNvbHZlci5HUyA9IDE7XG5Tb2x2ZXIuSVNMQU5EID0gMjtcbiIsInZhciBUdXBsZURpY3Rpb25hcnkgPSByZXF1aXJlKCcuL1R1cGxlRGljdGlvbmFyeScpO1xudmFyIFV0aWxzID0gcmVxdWlyZSgnLi9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXBLZWVwZXI7XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2Ygb3ZlcmxhcHMgaW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHRoZSBsYXN0IHN0ZXAgc3RhdGUuXG4gKiBAY2xhc3MgT3ZlcmxhcEtlZXBlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE92ZXJsYXBLZWVwZXIoKSB7XG4gICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZSA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuICAgIHRoaXMucmVjb3JkUG9vbCA9IFtdO1xuICAgIHRoaXMudG1wRGljdCA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcbiAgICB0aGlzLnRtcEFycmF5MSA9IFtdO1xufVxuXG4vKipcbiAqIFRpY2tzIG9uZSBzdGVwIGZvcndhcmQgaW4gdGltZS4gVGhpcyB3aWxsIG1vdmUgdGhlIGN1cnJlbnQgb3ZlcmxhcCBzdGF0ZSB0byB0aGUgXCJvbGRcIiBvdmVybGFwIHN0YXRlLCBhbmQgY3JlYXRlIGEgbmV3IG9uZSBhcyBjdXJyZW50LlxuICogQG1ldGhvZCB0aWNrXG4gKi9cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGFzdCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuXG4gICAgLy8gU2F2ZSBvbGQgb2JqZWN0cyBpbnRvIHBvb2xcbiAgICB2YXIgbCA9IGxhc3Qua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGxhc3Qua2V5c1tsXTtcbiAgICAgICAgdmFyIGxhc3RPYmplY3QgPSBsYXN0LmdldEJ5S2V5KGtleSk7XG4gICAgICAgIHZhciBjdXJyZW50T2JqZWN0ID0gY3VycmVudC5nZXRCeUtleShrZXkpO1xuICAgICAgICBpZihsYXN0T2JqZWN0ICYmICFjdXJyZW50T2JqZWN0KXtcbiAgICAgICAgICAgIC8vIFRoZSByZWNvcmQgaXMgb25seSB1c2VkIGluIHRoZSBcImxhc3RcIiBkaWN0LCBhbmQgd2lsbCBiZSByZW1vdmVkLiBXZSBtaWdodCBhcyB3ZWxsIHBvb2wgaXQuXG4gICAgICAgICAgICB0aGlzLnJlY29yZFBvb2wucHVzaChsYXN0T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFyIGxhc3Qgb2JqZWN0XG4gICAgbGFzdC5yZXNldCgpO1xuXG4gICAgLy8gVHJhbnNmZXIgZnJvbSBuZXcgb2JqZWN0IHRvIG9sZFxuICAgIGxhc3QuY29weShjdXJyZW50KTtcblxuICAgIC8vIENsZWFyIGN1cnJlbnQgb2JqZWN0XG4gICAgY3VycmVudC5yZXNldCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldE92ZXJsYXBwaW5nXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtCb2R5fSBzaGFwZUJcbiAqL1xuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuc2V0T3ZlcmxhcHBpbmcgPSBmdW5jdGlvbihib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKSB7XG4gICAgdmFyIGxhc3QgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcblxuICAgIC8vIFN0b3JlIGN1cnJlbnQgY29udGFjdCBzdGF0ZVxuICAgIGlmKCFjdXJyZW50LmdldChzaGFwZUEuaWQsIHNoYXBlQi5pZCkpe1xuXG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZih0aGlzLnJlY29yZFBvb2wubGVuZ3RoKXtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLnJlY29yZFBvb2wucG9wKCk7XG4gICAgICAgICAgICBkYXRhLnNldChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgT3ZlcmxhcEtlZXBlclJlY29yZChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQuc2V0KHNoYXBlQS5pZCwgc2hhcGVCLmlkLCBkYXRhKTtcbiAgICB9XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXROZXdPdmVybGFwcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGlmZih0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlLCB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlLCByZXN1bHQpO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RW5kT3ZlcmxhcHMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHJldHVybiB0aGlzLmdldERpZmYodGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZSwgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZSwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBib2RpZXMgYXJlIGN1cnJlbnRseSBvdmVybGFwcGluZy5cbiAqIEBtZXRob2QgYm9kaWVzQXJlT3ZlcmxhcHBpbmdcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuYm9kaWVzQXJlT3ZlcmxhcHBpbmcgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZTtcbiAgICB2YXIgbCA9IGN1cnJlbnQua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGN1cnJlbnQua2V5c1tsXTtcbiAgICAgICAgdmFyIGRhdGEgPSBjdXJyZW50LmRhdGFba2V5XTtcbiAgICAgICAgaWYoKGRhdGEuYm9keUEgPT09IGJvZHlBICYmIGRhdGEuYm9keUIgPT09IGJvZHlCKSB8fCBkYXRhLmJvZHlBID09PSBib2R5QiAmJiBkYXRhLmJvZHlCID09PSBib2R5QSl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXREaWZmID0gZnVuY3Rpb24oZGljdEEsIGRpY3RCLCByZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgW107XG4gICAgdmFyIGxhc3QgPSBkaWN0QTtcbiAgICB2YXIgY3VycmVudCA9IGRpY3RCO1xuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgbCA9IGN1cnJlbnQua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGtleSA9IGN1cnJlbnQua2V5c1tsXTtcbiAgICAgICAgdmFyIGRhdGEgPSBjdXJyZW50LmRhdGFba2V5XTtcblxuICAgICAgICBpZighZGF0YSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSAnK2tleSsnIGhhZCBubyBkYXRhIScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3REYXRhID0gbGFzdC5kYXRhW2tleV07XG4gICAgICAgIGlmKCFsYXN0RGF0YSl7XG4gICAgICAgICAgICAvLyBOb3Qgb3ZlcmxhcHBpbmcgaW4gbGFzdCBzdGF0ZSwgYnV0IGluIGN1cnJlbnQuXG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5pc05ld092ZXJsYXAgPSBmdW5jdGlvbihzaGFwZUEsIHNoYXBlQil7XG4gICAgdmFyIGlkQSA9IHNoYXBlQS5pZHwwLFxuICAgICAgICBpZEIgPSBzaGFwZUIuaWR8MDtcbiAgICB2YXIgbGFzdCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuICAgIC8vIE5vdCBpbiBsYXN0IGJ1dCBpbiBuZXdcbiAgICByZXR1cm4gISEhbGFzdC5nZXQoaWRBLCBpZEIpICYmICEhY3VycmVudC5nZXQoaWRBLCBpZEIpO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0TmV3Qm9keU92ZXJsYXBzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLnRtcEFycmF5MS5sZW5ndGggPSAwO1xuICAgIHZhciBvdmVybGFwcyA9IHRoaXMuZ2V0TmV3T3ZlcmxhcHModGhpcy50bXBBcnJheTEpO1xuICAgIHJldHVybiB0aGlzLmdldEJvZHlEaWZmKG92ZXJsYXBzLCByZXN1bHQpO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0RW5kQm9keU92ZXJsYXBzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLnRtcEFycmF5MS5sZW5ndGggPSAwO1xuICAgIHZhciBvdmVybGFwcyA9IHRoaXMuZ2V0RW5kT3ZlcmxhcHModGhpcy50bXBBcnJheTEpO1xuICAgIHJldHVybiB0aGlzLmdldEJvZHlEaWZmKG92ZXJsYXBzLCByZXN1bHQpO1xufTtcblxuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUuZ2V0Qm9keURpZmYgPSBmdW5jdGlvbihvdmVybGFwcywgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG4gICAgdmFyIGFjY3VtdWxhdG9yID0gdGhpcy50bXBEaWN0O1xuXG4gICAgdmFyIGwgPSBvdmVybGFwcy5sZW5ndGg7XG5cbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIgZGF0YSA9IG92ZXJsYXBzW2xdO1xuXG4gICAgICAgIC8vIFNpbmNlIHdlIHVzZSBib2R5IGlkJ3MgZm9yIHRoZSBhY2N1bXVsYXRvciwgdGhlc2Ugd2lsbCBiZSBhIHN1YnNldCBvZiB0aGUgb3JpZ2luYWwgb25lXG4gICAgICAgIGFjY3VtdWxhdG9yLnNldChkYXRhLmJvZHlBLmlkfDAsIGRhdGEuYm9keUIuaWR8MCwgZGF0YSk7XG4gICAgfVxuXG4gICAgbCA9IGFjY3VtdWxhdG9yLmtleXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBkYXRhID0gYWNjdW11bGF0b3IuZ2V0QnlLZXkoYWNjdW11bGF0b3Iua2V5c1tsXSk7XG4gICAgICAgIGlmKGRhdGEpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGF0YS5ib2R5QSwgZGF0YS5ib2R5Qik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY2N1bXVsYXRvci5yZXNldCgpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogT3ZlcmxhcCBkYXRhIGNvbnRhaW5lciBmb3IgdGhlIE92ZXJsYXBLZWVwZXJcbiAqIEBjbGFzcyBPdmVybGFwS2VlcGVyUmVjb3JkXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gKi9cbmZ1bmN0aW9uIE92ZXJsYXBLZWVwZXJSZWNvcmQoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQil7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVBXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUEgPSBzaGFwZUE7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVCXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUIgPSBzaGFwZUI7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5QVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlCXG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xufVxuXG4vKipcbiAqIFNldCB0aGUgZGF0YSBmb3IgdGhlIHJlY29yZFxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gKi9cbk92ZXJsYXBLZWVwZXJSZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpe1xuICAgIE92ZXJsYXBLZWVwZXJSZWNvcmQuY2FsbCh0aGlzLCBib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbn07XG4iLCJ2YXIgVXRpbHMgPSByZXF1aXJlKCcuL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHVwbGVEaWN0aW9uYXJ5O1xuXG4vKipcbiAqIEBjbGFzcyBUdXBsZURpY3Rpb25hcnlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUdXBsZURpY3Rpb25hcnkoKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSBzdG9yYWdlXG4gICAgICogQHByb3BlcnR5IGRhdGFcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogS2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgdXNlZC5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBrZXlzXG4gICAgICovXG4gICAgdGhpcy5rZXlzID0gW107XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgZ2l2ZW4gdHdvIGludGVnZXJzXG4gKiBAbWV0aG9kIGdldEtleVxuICogQHBhcmFtICB7bnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbihpZDEsIGlkMikge1xuICAgIGlkMSA9IGlkMXwwO1xuICAgIGlkMiA9IGlkMnwwO1xuXG4gICAgaWYgKCAoaWQxfDApID09PSAoaWQyfDApICl7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZCBmb3IgdmFsdWVzIDwgMl4xNlxuICAgIHJldHVybiAoKGlkMXwwKSA+IChpZDJ8MCkgP1xuICAgICAgICAoaWQxIDw8IDE2KSB8IChpZDIgJiAweEZGRkYpIDpcbiAgICAgICAgKGlkMiA8PCAxNikgfCAoaWQxICYgMHhGRkZGKSl8MFxuICAgICAgICA7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0QnlLZXlcbiAqIEBwYXJhbSAge051bWJlcn0ga2V5XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0QnlLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICBrZXkgPSBrZXl8MDtcbiAgICByZXR1cm4gdGhpcy5kYXRhW2tleV07XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuZ2V0S2V5KGksIGopXTtcbn07XG5cbi8qKlxuICogU2V0IGEgdmFsdWUuXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGksIGosIHZhbHVlKSB7XG4gICAgaWYoIXZhbHVlKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZGF0YSFcIik7XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGksIGopO1xuXG4gICAgLy8gQ2hlY2sgaWYga2V5IGFscmVhZHkgZXhpc3RzXG4gICAgaWYoIXRoaXMuZGF0YVtrZXldKXtcbiAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFba2V5XSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuIGtleTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBkYXRhLlxuICogQG1ldGhvZCByZXNldFxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIGtleXMgPSB0aGlzLmtleXM7XG5cbiAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSkge1xuICAgICAgICBkZWxldGUgZGF0YVtrZXlzW2xdXTtcbiAgICB9XG5cbiAgICBrZXlzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIENvcHkgYW5vdGhlciBUdXBsZURpY3Rpb25hcnkuIE5vdGUgdGhhdCBhbGwgZGF0YSBpbiB0aGlzIGRpY3Rpb25hcnkgd2lsbCBiZSByZW1vdmVkLlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge1R1cGxlRGljdGlvbmFyeX0gZGljdCBUaGUgVHVwbGVEaWN0aW9uYXJ5IHRvIGNvcHkgaW50byB0aGlzIG9uZS5cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oZGljdCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICBVdGlscy5hcHBlbmRBcnJheSh0aGlzLmtleXMsIGRpY3Qua2V5cyk7XG4gICAgdmFyIGwgPSBkaWN0LmtleXMubGVuZ3RoO1xuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBrZXkgPSBkaWN0LmtleXNbbF07XG4gICAgICAgIHRoaXMuZGF0YVtrZXldID0gZGljdC5kYXRhW2tleV07XG4gICAgfVxufTtcbiIsIi8qIGdsb2JhbCBQMl9BUlJBWV9UWVBFICovXG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG5cbi8qKlxuICogTWlzYyB1dGlsaXR5IGZ1bmN0aW9uc1xuICogQGNsYXNzIFV0aWxzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRpbHMoKXt9XG5cbi8qKlxuICogQXBwZW5kIHRoZSB2YWx1ZXMgaW4gYXJyYXkgYiB0byB0aGUgYXJyYXkgYS4gU2VlIDxhIGhyZWY9XCJodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNzQxMjYvaG93LXRvLWFwcGVuZC1hbi1hcnJheS10by1hbi1leGlzdGluZy1qYXZhc2NyaXB0LWFycmF5LzEzNzQxMzEjMTM3NDEzMVwiPnRoaXM8L2E+IGZvciBhbiBleHBsYW5hdGlvbi5cbiAqIEBtZXRob2QgYXBwZW5kQXJyYXlcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICovXG5VdGlscy5hcHBlbmRBcnJheSA9IGZ1bmN0aW9uKGEsYil7XG4gICAgaWYgKGIubGVuZ3RoIDwgMTUwMDAwKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYi5sZW5ndGg7IGkgIT09IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBhLnB1c2goYltpXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEdhcmJhZ2UgZnJlZSBBcnJheS5zcGxpY2UoKS4gRG9lcyBub3QgYWxsb2NhdGUgYSBuZXcgYXJyYXkuXG4gKiBAbWV0aG9kIHNwbGljZVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGhvd21hbnlcbiAqL1xuVXRpbHMuc3BsaWNlID0gZnVuY3Rpb24oYXJyYXksaW5kZXgsaG93bWFueSl7XG4gICAgaG93bWFueSA9IGhvd21hbnkgfHwgMTtcbiAgICBmb3IgKHZhciBpPWluZGV4LCBsZW49YXJyYXkubGVuZ3RoLWhvd21hbnk7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIGhvd21hbnldO1xuICAgIH1cbiAgICBhcnJheS5sZW5ndGggPSBsZW47XG59O1xuXG4vKipcbiAqIFRoZSBhcnJheSB0eXBlIHRvIHVzZSBmb3IgaW50ZXJuYWwgbnVtZXJpYyBjb21wdXRhdGlvbnMgdGhyb3VnaG91dCB0aGUgbGlicmFyeS4gRmxvYXQzMkFycmF5IGlzIHVzZWQgaWYgaXQgaXMgYXZhaWxhYmxlLCBidXQgZmFsbHMgYmFjayBvbiBBcnJheS4gSWYgeW91IHdhbnQgdG8gc2V0IGFycmF5IHR5cGUgbWFudWFsbHksIGluamVjdCBpdCB2aWEgdGhlIGdsb2JhbCB2YXJpYWJsZSBQMl9BUlJBWV9UWVBFLiBTZWUgZXhhbXBsZSBiZWxvdy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IEFSUkFZX1RZUEVcbiAqIEBleGFtcGxlXG4gKiAgICAgPHNjcmlwdD5cbiAqICAgICAgICAgPCEtLSBJbmplY3QgeW91ciBwcmVmZXJyZWQgYXJyYXkgdHlwZSBiZWZvcmUgbG9hZGluZyBwMi5qcyAtLT5cbiAqICAgICAgICAgUDJfQVJSQVlfVFlQRSA9IEFycmF5O1xuICogICAgIDwvc2NyaXB0PlxuICogICAgIDxzY3JpcHQgc3JjPVwicDIuanNcIj48L3NjcmlwdD5cbiAqL1xuaWYodHlwZW9mIFAyX0FSUkFZX1RZUEUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgVXRpbHMuQVJSQVlfVFlQRSA9IFAyX0FSUkFZX1RZUEU7XG59IGVsc2UgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKXtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gRmxvYXQzMkFycmF5O1xufSBlbHNlIHtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gQXJyYXk7XG59XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIGFub3RoZXJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0gIHtvYmplY3R9IGFcbiAqIEBwYXJhbSAge29iamVjdH0gYlxuICovXG5VdGlscy5leHRlbmQgPSBmdW5jdGlvbihhLGIpe1xuICAgIGZvcih2YXIga2V5IGluIGIpe1xuICAgICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxufTtcblxuLyoqXG4gKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGVmYXVsdHNcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuIE1heSBiZSBmYWxzeTogaW4gdGhpcyBjYXNlLCBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRlZmF1bHRzIEFuIG9iamVjdCBjb250YWluaW5nIGRlZmF1bHQgdmFsdWVzLlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgbW9kaWZpZWQgb3B0aW9ucyBvYmplY3QuXG4gKi9cblV0aWxzLmRlZmF1bHRzID0gZnVuY3Rpb24ob3B0aW9ucywgZGVmYXVsdHMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGZvcih2YXIga2V5IGluIGRlZmF1bHRzKXtcbiAgICAgICAgaWYoIShrZXkgaW4gb3B0aW9ucykpe1xuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG4iLCJ2YXIgQm9keSA9IHJlcXVpcmUoJy4uL29iamVjdHMvQm9keScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElzbGFuZDtcblxuLyoqXG4gKiBBbiBpc2xhbmQgb2YgYm9kaWVzIGNvbm5lY3RlZCB3aXRoIGVxdWF0aW9ucy5cbiAqIEBjbGFzcyBJc2xhbmRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJc2xhbmQoKXtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZXF1YXRpb25zIGluIHRoaXMgaXNsYW5kLlxuICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYm9kaWVzIGluIHRoaXMgaXNsYW5kLlxuICAgICAqIEBwcm9wZXJ0eSBib2RpZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ib2RpZXMgPSBbXTtcbn1cblxuLyoqXG4gKiBDbGVhbiB0aGlzIGlzbGFuZCBmcm9tIGJvZGllcyBhbmQgZXF1YXRpb25zLlxuICogQG1ldGhvZCByZXNldFxuICovXG5Jc2xhbmQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVxdWF0aW9ucy5sZW5ndGggPSB0aGlzLmJvZGllcy5sZW5ndGggPSAwO1xufTtcblxudmFyIGJvZHlJZHMgPSBbXTtcblxuLyoqXG4gKiBHZXQgYWxsIHVuaXF1ZSBib2RpZXMgaW4gdGhpcyBpc2xhbmQuXG4gKiBAbWV0aG9kIGdldEJvZGllc1xuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIEJvZHlcbiAqL1xuSXNsYW5kLnByb3RvdHlwZS5nZXRCb2RpZXMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHZhciBib2RpZXMgPSByZXN1bHQgfHwgW10sXG4gICAgICAgIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGJvZHlJZHMubGVuZ3RoID0gMDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PWVxcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tpXTtcbiAgICAgICAgaWYoYm9keUlkcy5pbmRleE9mKGVxLmJvZHlBLmlkKT09PS0xKXtcbiAgICAgICAgICAgIGJvZGllcy5wdXNoKGVxLmJvZHlBKTtcbiAgICAgICAgICAgIGJvZHlJZHMucHVzaChlcS5ib2R5QS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoYm9keUlkcy5pbmRleE9mKGVxLmJvZHlCLmlkKT09PS0xKXtcbiAgICAgICAgICAgIGJvZGllcy5wdXNoKGVxLmJvZHlCKTtcbiAgICAgICAgICAgIGJvZHlJZHMucHVzaChlcS5ib2R5Qi5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvZGllcztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGVudGlyZSBpc2xhbmQgd2FudHMgdG8gc2xlZXAuXG4gKiBAbWV0aG9kIHdhbnRzVG9TbGVlcFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuSXNsYW5kLnByb3RvdHlwZS53YW50c1RvU2xlZXAgPSBmdW5jdGlvbigpe1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuYm9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJvZGllc1tpXTtcbiAgICAgICAgaWYoYi50eXBlID09PSBCb2R5LkRZTkFNSUMgJiYgIWIud2FudHNUb1NsZWVwKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogTWFrZSBhbGwgYm9kaWVzIGluIHRoZSBpc2xhbmQgc2xlZXAuXG4gKiBAbWV0aG9kIHNsZWVwXG4gKi9cbklzbGFuZC5wcm90b3R5cGUuc2xlZXAgPSBmdW5jdGlvbigpe1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuYm9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJvZGllc1tpXTtcbiAgICAgICAgYi5zbGVlcCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4iLCJ2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXG4sICAgSXNsYW5kID0gcmVxdWlyZSgnLi9Jc2xhbmQnKVxuLCAgIElzbGFuZE5vZGUgPSByZXF1aXJlKCcuL0lzbGFuZE5vZGUnKVxuLCAgIEJvZHkgPSByZXF1aXJlKCcuLi9vYmplY3RzL0JvZHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJc2xhbmRNYW5hZ2VyO1xuXG4vKipcbiAqIFNwbGl0cyB0aGUgc3lzdGVtIG9mIGJvZGllcyBhbmQgZXF1YXRpb25zIGludG8gaW5kZXBlbmRlbnQgaXNsYW5kc1xuICpcbiAqIEBjbGFzcyBJc2xhbmRNYW5hZ2VyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBleHRlbmRzIFNvbHZlclxuICovXG5mdW5jdGlvbiBJc2xhbmRNYW5hZ2VyKG9wdGlvbnMpe1xuXG4gICAgLy8gUG9vbGluZyBvZiBub2RlIG9iamVjdHMgc2F2ZXMgc29tZSBHQyBsb2FkXG4gICAgdGhpcy5fbm9kZVBvb2wgPSBbXTtcbiAgICB0aGlzLl9pc2xhbmRQb29sID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXF1YXRpb25zIHRvIHNwbGl0LiBNYW51YWxseSBmaWxsIHRoaXMgYXJyYXkgYmVmb3JlIHJ1bm5pbmcgLnNwbGl0KCkuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZXF1YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcge3sjY3Jvc3NMaW5rIFwiSXNsYW5kXCJ9fXt7L2Nyb3NzTGlua319cy5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBpc2xhbmRzXG4gICAgICovXG4gICAgdGhpcy5pc2xhbmRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0aW5nIGdyYXBoIG5vZGVzLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG5vZGVzXG4gICAgICovXG4gICAgdGhpcy5ub2RlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5vZGUgcXVldWUsIHVzZWQgd2hlbiB0cmF2ZXJzaW5nIHRoZSBncmFwaCBvZiBub2Rlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHF1ZXVlXG4gICAgICovXG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xufVxuXG4vKipcbiAqIEdldCBhbiB1bnZpc2l0ZWQgbm9kZSBmcm9tIGEgbGlzdCBvZiBub2Rlcy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0VW52aXNpdGVkTm9kZVxuICogQHBhcmFtICB7QXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJuIHtJc2xhbmROb2RlfGJvb2xlYW59IFRoZSBub2RlIGlmIGZvdW5kLCBlbHNlIGZhbHNlLlxuICovXG5Jc2xhbmRNYW5hZ2VyLmdldFVudmlzaXRlZE5vZGUgPSBmdW5jdGlvbihub2Rlcyl7XG4gICAgdmFyIE5ub2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ub2RlczsgaSsrKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYoIW5vZGUudmlzaXRlZCAmJiBub2RlLmJvZHkudHlwZSA9PT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVmlzaXQgYSBub2RlLlxuICogQG1ldGhvZCB2aXNpdFxuICogQHBhcmFtICB7SXNsYW5kTm9kZX0gbm9kZVxuICogQHBhcmFtICB7QXJyYXl9IGJkc1xuICogQHBhcmFtICB7QXJyYXl9IGVxc1xuICovXG5Jc2xhbmRNYW5hZ2VyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChub2RlLGJkcyxlcXMpe1xuICAgIGJkcy5wdXNoKG5vZGUuYm9keSk7XG4gICAgdmFyIE5lcXMgPSBub2RlLmVxdWF0aW9ucy5sZW5ndGg7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OZXFzOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBub2RlLmVxdWF0aW9uc1tpXTtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YoZXEpID09PSAtMSl7IC8vIEFscmVhZHkgYWRkZWQ/XG4gICAgICAgICAgICBlcXMucHVzaChlcSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJ1bnMgdGhlIHNlYXJjaCBhbGdvcml0aG0sIHN0YXJ0aW5nIGF0IGEgcm9vdCBub2RlLiBUaGUgcmVzdWx0aW5nIGJvZGllcyBhbmQgZXF1YXRpb25zIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBwcm92aWRlZCBhcnJheXMuXG4gKiBAbWV0aG9kIGJmc1xuICogQHBhcmFtICB7SXNsYW5kTm9kZX0gcm9vdCBUaGUgbm9kZSB0byBzdGFydCBmcm9tXG4gKiBAcGFyYW0gIHtBcnJheX0gYmRzICBBbiBhcnJheSB0byBhcHBlbmQgcmVzdWx0aW5nIEJvZGllcyB0by5cbiAqIEBwYXJhbSAge0FycmF5fSBlcXMgIEFuIGFycmF5IHRvIGFwcGVuZCByZXN1bHRpbmcgRXF1YXRpb25zIHRvLlxuICovXG5Jc2xhbmRNYW5hZ2VyLnByb3RvdHlwZS5iZnMgPSBmdW5jdGlvbihyb290LGJkcyxlcXMpe1xuXG4gICAgLy8gUmVzZXQgdGhlIHZpc2l0IHF1ZXVlXG4gICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgLy8gQWRkIHJvb3Qgbm9kZSB0byBxdWV1ZVxuICAgIHF1ZXVlLnB1c2gocm9vdCk7XG4gICAgcm9vdC52aXNpdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnZpc2l0KHJvb3QsYmRzLGVxcyk7XG5cbiAgICAvLyBQcm9jZXNzIGFsbCBxdWV1ZWQgbm9kZXNcbiAgICB3aGlsZShxdWV1ZS5sZW5ndGgpIHtcblxuICAgICAgICAvLyBHZXQgbmV4dCBub2RlIGluIHRoZSBxdWV1ZVxuICAgICAgICB2YXIgbm9kZSA9IHF1ZXVlLnBvcCgpO1xuXG4gICAgICAgIC8vIFZpc2l0IHVudmlzaXRlZCBuZWlnaGJvcmluZyBub2Rlc1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIHdoaWxlKChjaGlsZCA9IElzbGFuZE1hbmFnZXIuZ2V0VW52aXNpdGVkTm9kZShub2RlLm5laWdoYm9ycykpKSB7XG4gICAgICAgICAgICBjaGlsZC52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmlzaXQoY2hpbGQsYmRzLGVxcyk7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSBpZiBpdCdzIGR5bmFtaWNcbiAgICAgICAgICAgIGlmKGNoaWxkLmJvZHkudHlwZSA9PT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogU3BsaXQgdGhlIHdvcmxkIGludG8gaW5kZXBlbmRlbnQgaXNsYW5kcy4gVGhlIHJlc3VsdCBpcyBzdG9yZWQgaW4gLmlzbGFuZHMuXG4gKiBAbWV0aG9kIHNwbGl0XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZ2VuZXJhdGVkIGlzbGFuZHNcbiAqL1xuSXNsYW5kTWFuYWdlci5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgbm9kZXMgPSB0aGlzLm5vZGVzLFxuICAgICAgICBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucztcblxuICAgIC8vIE1vdmUgb2xkIG5vZGVzIHRvIHRoZSBub2RlIHBvb2xcbiAgICB3aGlsZShub2Rlcy5sZW5ndGgpe1xuICAgICAgICB0aGlzLl9ub2RlUG9vbC5wdXNoKG5vZGVzLnBvcCgpKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmVlZGVkIG5vZGVzLCByZXVzZSBpZiBwb3NzaWJsZVxuICAgIGZvcih2YXIgaT0wOyBpIT09Ym9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYodGhpcy5fbm9kZVBvb2wubGVuZ3RoKXtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZVBvb2wucG9wKCk7XG4gICAgICAgICAgICBub2RlLnJlc2V0KCk7XG4gICAgICAgICAgICBub2RlLmJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgSXNsYW5kTm9kZShib2RpZXNbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBjb25uZWN0aXZpdHkgZGF0YS4gRWFjaCBlcXVhdGlvbiBjb25uZWN0cyAyIGJvZGllcy5cbiAgICBmb3IodmFyIGs9MDsgayE9PWVxdWF0aW9ucy5sZW5ndGg7IGsrKyl7XG4gICAgICAgIHZhciBlcT1lcXVhdGlvbnNba10sXG4gICAgICAgICAgICBpPWJvZGllcy5pbmRleE9mKGVxLmJvZHlBKSxcbiAgICAgICAgICAgIGo9Ym9kaWVzLmluZGV4T2YoZXEuYm9keUIpLFxuICAgICAgICAgICAgbmk9bm9kZXNbaV0sXG4gICAgICAgICAgICBuaj1ub2Rlc1tqXTtcbiAgICAgICAgbmkubmVpZ2hib3JzLnB1c2gobmopO1xuICAgICAgICBuai5uZWlnaGJvcnMucHVzaChuaSk7XG4gICAgICAgIG5pLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICAgICAgbmouZXF1YXRpb25zLnB1c2goZXEpO1xuICAgIH1cblxuICAgIC8vIE1vdmUgb2xkIGlzbGFuZHMgdG8gdGhlIGlzbGFuZCBwb29sXG4gICAgdmFyIGlzbGFuZHMgPSB0aGlzLmlzbGFuZHM7XG4gICAgd2hpbGUoaXNsYW5kcy5sZW5ndGgpe1xuICAgICAgICB2YXIgaXNsYW5kID0gaXNsYW5kcy5wb3AoKTtcbiAgICAgICAgaXNsYW5kLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX2lzbGFuZFBvb2wucHVzaChpc2xhbmQpO1xuICAgIH1cblxuICAgIC8vIEdldCBpc2xhbmRzXG4gICAgdmFyIGNoaWxkO1xuICAgIHdoaWxlKChjaGlsZCA9IElzbGFuZE1hbmFnZXIuZ2V0VW52aXNpdGVkTm9kZShub2RlcykpKXtcblxuICAgICAgICAvLyBDcmVhdGUgbmV3IGlzbGFuZFxuICAgICAgICB2YXIgaXNsYW5kID0gdGhpcy5faXNsYW5kUG9vbC5sZW5ndGggPyB0aGlzLl9pc2xhbmRQb29sLnBvcCgpIDogbmV3IElzbGFuZCgpO1xuXG4gICAgICAgIC8vIEdldCBhbGwgZXF1YXRpb25zIGFuZCBib2RpZXMgaW4gdGhpcyBpc2xhbmRcbiAgICAgICAgdGhpcy5iZnMoY2hpbGQsIGlzbGFuZC5ib2RpZXMsIGlzbGFuZC5lcXVhdGlvbnMpO1xuXG4gICAgICAgIGlzbGFuZHMucHVzaChpc2xhbmQpO1xuICAgIH1cblxuICAgIHJldHVybiBpc2xhbmRzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gSXNsYW5kTm9kZTtcblxuLyoqXG4gKiBIb2xkcyBhIGJvZHkgYW5kIGtlZXBzIHRyYWNrIG9mIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG5lZWRlZCBmb3IgZ3JhcGggdHJhdmVyc2FsLlxuICogQGNsYXNzIElzbGFuZE5vZGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKi9cbmZ1bmN0aW9uIElzbGFuZE5vZGUoYm9keSl7XG5cblx0LyoqXG5cdCAqIFRoZSBib2R5IHRoYXQgaXMgY29udGFpbmVkIGluIHRoaXMgbm9kZS5cblx0ICogQHByb3BlcnR5IHtCb2R5fSBib2R5XG5cdCAqL1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICAvKipcbiAgICAgKiBOZWlnaGJvcmluZyBJc2xhbmROb2Rlc1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG5laWdoYm9yc1xuICAgICAqL1xuICAgIHRoaXMubmVpZ2hib3JzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBFcXVhdGlvbnMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBlcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBub2RlIHdhcyB2aXNpdGluZyBkdXJpbmcgdGhlIGdyYXBoIHRyYXZlcnNhbC5cbiAgICAgKiBAcHJvcGVydHkgdmlzaXRlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudmlzaXRlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIENsZWFuIHRoaXMgbm9kZSBmcm9tIGJvZGllcyBhbmQgZXF1YXRpb25zLlxuICogQG1ldGhvZCByZXNldFxuICovXG5Jc2xhbmROb2RlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lcXVhdGlvbnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLm5laWdoYm9ycy5sZW5ndGggPSAwO1xuICAgIHRoaXMudmlzaXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuYm9keSA9IG51bGw7XG59O1xuIiwiLyogZ2xvYmFsIHBlcmZvcm1hbmNlICovXG4vKmpzaGludCAtVzAyMCAqL1xuXG52YXIgIEdTU29sdmVyID0gcmVxdWlyZSgnLi4vc29sdmVyL0dTU29sdmVyJylcbiwgICAgU29sdmVyID0gcmVxdWlyZSgnLi4vc29sdmVyL1NvbHZlcicpXG4sICAgIE5haXZlQnJvYWRwaGFzZSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UnKVxuLCAgICBSYXkgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUmF5JylcbiwgICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXG4sICAgIENpcmNsZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9DaXJjbGUnKVxuLCAgICBSZWN0YW5nbGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvUmVjdGFuZ2xlJylcbiwgICAgQ29udmV4ID0gcmVxdWlyZSgnLi4vc2hhcGVzL0NvbnZleCcpXG4sICAgIExpbmUgPSByZXF1aXJlKCcuLi9zaGFwZXMvTGluZScpXG4sICAgIFBsYW5lID0gcmVxdWlyZSgnLi4vc2hhcGVzL1BsYW5lJylcbiwgICAgQ2Fwc3VsZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9DYXBzdWxlJylcbiwgICAgUGFydGljbGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvUGFydGljbGUnKVxuLCAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnRFbWl0dGVyJylcbiwgICAgQm9keSA9IHJlcXVpcmUoJy4uL29iamVjdHMvQm9keScpXG4sICAgIFNoYXBlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NoYXBlJylcbiwgICAgTGluZWFyU3ByaW5nID0gcmVxdWlyZSgnLi4vb2JqZWN0cy9MaW5lYXJTcHJpbmcnKVxuLCAgICBNYXRlcmlhbCA9IHJlcXVpcmUoJy4uL21hdGVyaWFsL01hdGVyaWFsJylcbiwgICAgQ29udGFjdE1hdGVyaWFsID0gcmVxdWlyZSgnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJylcbiwgICAgRGlzdGFuY2VDb25zdHJhaW50ID0gcmVxdWlyZSgnLi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50JylcbiwgICAgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKVxuLCAgICBMb2NrQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JylcbiwgICAgUmV2b2x1dGVDb25zdHJhaW50ID0gcmVxdWlyZSgnLi4vY29uc3RyYWludHMvUmV2b2x1dGVDb25zdHJhaW50JylcbiwgICAgUHJpc21hdGljQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnQnKVxuLCAgICBHZWFyQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnRzL0dlYXJDb25zdHJhaW50JylcbiwgICAgcGtnID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJylcbiwgICAgQnJvYWRwaGFzZSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJylcbiwgICAgU0FQQnJvYWRwaGFzZSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlJylcbiwgICAgTmFycm93cGhhc2UgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vTmFycm93cGhhc2UnKVxuLCAgICBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJylcbiwgICAgT3ZlcmxhcEtlZXBlciA9IHJlcXVpcmUoJy4uL3V0aWxzL092ZXJsYXBLZWVwZXInKVxuLCAgICBJc2xhbmRNYW5hZ2VyID0gcmVxdWlyZSgnLi9Jc2xhbmRNYW5hZ2VyJylcbiwgICAgUm90YXRpb25hbFNwcmluZyA9IHJlcXVpcmUoJy4uL29iamVjdHMvUm90YXRpb25hbFNwcmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkO1xuXG5pZih0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnKXtcbiAgICBwZXJmb3JtYW5jZSA9IHt9O1xufVxuaWYoIXBlcmZvcm1hbmNlLm5vdyl7XG4gICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XG4gICAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KXtcbiAgICAgICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgICB9XG4gICAgcGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBub3dPZmZzZXQ7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgZHluYW1pY3Mgd29ybGQsIHdoZXJlIGFsbCBib2RpZXMgYW5kIGNvbnN0cmFpbnRzIGxpdmVzLlxuICpcbiAqIEBjbGFzcyBXb3JsZFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge1NvbHZlcn0gICAgICAgICAgW29wdGlvbnMuc29sdmVyXSAgICAgICAgICAgIERlZmF1bHRzIHRvIEdTU29sdmVyLlxuICogQHBhcmFtIHtBcnJheX0gICAgICAgICAgIFtvcHRpb25zLmdyYXZpdHldICAgICAgICAgICBEZWZhdWx0cyB0byBbMCwtOS43OF1cbiAqIEBwYXJhbSB7QnJvYWRwaGFzZX0gICAgICBbb3B0aW9ucy5icm9hZHBoYXNlXSAgICAgICAgRGVmYXVsdHMgdG8gTmFpdmVCcm9hZHBoYXNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuaXNsYW5kU3BsaXQ9ZmFsc2VdXG4gKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuZG9Qcm9maWxpbmc9ZmFsc2VdXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCh7XG4gKiAgICAgICAgIGdyYXZpdHk6IFswLCAtOS44MV0sXG4gKiAgICAgICAgIGJyb2FkcGhhc2U6IG5ldyBTQVBCcm9hZHBoYXNlKClcbiAqICAgICB9KTtcbiAqL1xuZnVuY3Rpb24gV29ybGQob3B0aW9ucyl7XG4gICAgRXZlbnRFbWl0dGVyLmFwcGx5KHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBBbGwgc3ByaW5ncyBpbiB0aGUgd29ybGQuIFRvIGFkZCBhIHNwcmluZyB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRTcHJpbmc6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNwcmluZ3NcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zcHJpbmdzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBbGwgYm9kaWVzIGluIHRoZSB3b3JsZC4gVG8gYWRkIGEgYm9keSB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRCb2R5Om1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBib2RpZXNcbiAgICAgKi9cbiAgICB0aGlzLmJvZGllcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZWQgYm9keSBjb2xsaXNpb24gcGFpcnMuIFNlZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9kaXNhYmxlQm9keUNvbGxpc2lvbjptZXRob2RcIn19LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnNcbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc29sdmVyIHVzZWQgdG8gc2F0aXNmeSBjb25zdHJhaW50cyBhbmQgY29udGFjdHMuIERlZmF1bHQgaXMge3sjY3Jvc3NMaW5rIFwiR1NTb2x2ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtTb2x2ZXJ9IHNvbHZlclxuICAgICAqL1xuICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgfHwgbmV3IEdTU29sdmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFycm93cGhhc2UgdG8gdXNlIHRvIGdlbmVyYXRlIGNvbnRhY3RzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG5hcnJvd3BoYXNlXG4gICAgICogQHR5cGUge05hcnJvd3BoYXNlfVxuICAgICAqL1xuICAgIHRoaXMubmFycm93cGhhc2UgPSBuZXcgTmFycm93cGhhc2UodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaXNsYW5kIG1hbmFnZXIgb2YgdGhpcyB3b3JsZC5cbiAgICAgKiBAcHJvcGVydHkge0lzbGFuZE1hbmFnZXJ9IGlzbGFuZE1hbmFnZXJcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZE1hbmFnZXIgPSBuZXcgSXNsYW5kTWFuYWdlcigpO1xuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSBpbiB0aGUgd29ybGQuIFRoaXMgaXMgYXBwbGllZCBvbiBhbGwgYm9kaWVzIGluIHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBzdGVwKCkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZ3Jhdml0eVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmdyYXZpdHkgPSB2ZWMyLmZyb21WYWx1ZXMoMCwgLTkuNzgpO1xuICAgIGlmKG9wdGlvbnMuZ3Jhdml0eSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmdyYXZpdHksIG9wdGlvbnMuZ3Jhdml0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIHRoZSBmcmljdGlvbiBtYXggZm9yY2UgKG11Km1hc3MqZ3Jhdml0eSkuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uR3Jhdml0eVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25HcmF2aXR5ID0gdmVjMi5sZW5ndGgodGhpcy5ncmF2aXR5KSB8fCAxMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IC5mcmljdGlvbkdyYXZpdHkgdG8gYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIGxlbmd0aCBvZiAuZ3Jhdml0eS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5XG4gICAgICovXG4gICAgdGhpcy51c2VXb3JsZEdyYXZpdHlBc0ZyaWN0aW9uR3Jhdml0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbGVuZ3RoIG9mIC5ncmF2aXR5IGlzIHplcm8sIGFuZCAudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHk9dHJ1ZSwgdGhlbiBzd2l0Y2ggdG8gdXNpbmcgLmZyaWN0aW9uR3Jhdml0eSBmb3IgZnJpY3Rpb24gaW5zdGVhZC4gVGhpcyBmYWxsYmFjayBpcyB1c2VmdWwgZm9yIGdyYXZpdHlsZXNzIGdhbWVzLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdXNlRnJpY3Rpb25HcmF2aXR5T25aZXJvR3Jhdml0eVxuICAgICAqL1xuICAgIHRoaXMudXNlRnJpY3Rpb25HcmF2aXR5T25aZXJvR3Jhdml0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGRvIHRpbWluZyBtZWFzdXJlbWVudHMgZHVyaW5nIHRoZSBzdGVwKCkgb3Igbm90LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGRvUG9maWxpbmdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRvUHJvZmlsaW5nID0gb3B0aW9ucy5kb1Byb2ZpbGluZyB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEhvdyBtYW55IG1pbGxpc2VjY29uZHMgdGhlIGxhc3Qgc3RlcCgpIHRvb2suIFRoaXMgaXMgdXBkYXRlZCBlYWNoIHN0ZXAgaWYgLmRvUHJvZmlsaW5nIGlzIHNldCB0byB0cnVlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxhc3RTdGVwVGltZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0U3RlcFRpbWUgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYnJvYWRwaGFzZSBhbGdvcml0aG0gdG8gdXNlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJyb2FkcGhhc2VcbiAgICAgKiBAdHlwZSB7QnJvYWRwaGFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJyb2FkcGhhc2UgPSBvcHRpb25zLmJyb2FkcGhhc2UgfHwgbmV3IFNBUEJyb2FkcGhhc2UoKTtcbiAgICB0aGlzLmJyb2FkcGhhc2Uuc2V0V29ybGQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VyLWFkZGVkIGNvbnN0cmFpbnRzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIER1bW15IGRlZmF1bHQgbWF0ZXJpYWwgaW4gdGhlIHdvcmxkLCB1c2VkIGluIC5kZWZhdWx0Q29udGFjdE1hdGVyaWFsXG4gICAgICogQHByb3BlcnR5IHtNYXRlcmlhbH0gZGVmYXVsdE1hdGVyaWFsXG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGNvbnRhY3QgbWF0ZXJpYWwgdG8gdXNlLCBpZiBubyBjb250YWN0IG1hdGVyaWFsIHdhcyBzZXQgZm9yIHRoZSBjb2xsaWRpbmcgbWF0ZXJpYWxzLlxuICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdE1hdGVyaWFsfSBkZWZhdWx0Q29udGFjdE1hdGVyaWFsXG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsID0gbmV3IENvbnRhY3RNYXRlcmlhbCh0aGlzLmRlZmF1bHRNYXRlcmlhbCx0aGlzLmRlZmF1bHRNYXRlcmlhbCk7XG5cbiAgICAvKipcbiAgICAgKiBGb3Iga2VlcGluZyB0cmFjayBvZiB3aGF0IHRpbWUgc3RlcCBzaXplIHdlIHVzZWQgbGFzdCBzdGVwXG4gICAgICogQHByb3BlcnR5IGxhc3RUaW1lU3RlcFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0VGltZVN0ZXAgPSAxLzYwO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgc3ByaW5nIGZvcmNlcyBlYWNoIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IGFwcGx5U3ByaW5nRm9yY2VzXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hcHBseVNwcmluZ0ZvcmNlcyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBib2R5IGRhbXBpbmcgZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBhcHBseURhbXBpbmdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5RGFtcGluZyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBncmF2aXR5IGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgYXBwbHlHcmF2aXR5XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hcHBseUdyYXZpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlL2Rpc2FibGUgY29uc3RyYWludCBzb2x2aW5nIGluIGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgc29sdmVDb25zdHJhaW50c1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc29sdmVDb25zdHJhaW50cyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQ29udGFjdE1hdGVyaWFscyBhZGRlZCB0byB0aGUgV29ybGQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RNYXRlcmlhbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZCB0aW1lLlxuICAgICAqIEBwcm9wZXJ0eSB0aW1lXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWUgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0cnVlIGR1cmluZyB0aGUgc3RlcCgpLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc3RlcHBpbmdcbiAgICAgKi9cbiAgICB0aGlzLnN0ZXBwaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBCb2RpZXMgdGhhdCBhcmUgc2NoZWR1bGVkIHRvIGJlIHJlbW92ZWQgYXQgdGhlIGVuZCBvZiB0aGUgc3RlcC5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBib2RpZXNUb0JlUmVtb3ZlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5ib2RpZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgdGhpcy5maXhlZFN0ZXBUaW1lID0gMC4wO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBlbmFibGUgaXNsYW5kIHNwbGl0dGluZy4gSXNsYW5kIHNwbGl0dGluZyBjYW4gYmUgYW4gYWR2YW50YWdlIGZvciBtYW55IHRoaW5ncywgaW5jbHVkaW5nIHNvbHZlciBwZXJmb3JtYW5jZS4gU2VlIHt7I2Nyb3NzTGluayBcIklzbGFuZE1hbmFnZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc2xhbmRTcGxpdFxuICAgICAqL1xuICAgIHRoaXMuaXNsYW5kU3BsaXQgPSB0eXBlb2Yob3B0aW9ucy5pc2xhbmRTcGxpdCkhPT1cInVuZGVmaW5lZFwiID8gISFvcHRpb25zLmlzbGFuZFNwbGl0IDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byB0aGUgd29ybGQgdG8gZW1pdCB0aGUgXCJpbXBhY3RcIiBldmVudC4gVHVybmluZyB0aGlzIG9mZiBjb3VsZCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIEBwcm9wZXJ0eSBlbWl0SW1wYWN0RXZlbnRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVtaXRJbXBhY3RFdmVudCA9IHRydWU7XG5cbiAgICAvLyBJZCBjb3VudGVyc1xuICAgIHRoaXMuX2NvbnN0cmFpbnRJZENvdW50ZXIgPSAwO1xuICAgIHRoaXMuX2JvZHlJZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgYWZ0ZXIgdGhlIHN0ZXAoKS5cbiAgICAgKiBAZXZlbnQgcG9zdFN0ZXBcbiAgICAgKi9cbiAgICB0aGlzLnBvc3RTdGVwRXZlbnQgPSB7XG4gICAgICAgIHR5cGUgOiBcInBvc3RTdGVwXCIsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkQm9keVxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICAgICAqL1xuICAgIHRoaXMuYWRkQm9keUV2ZW50ID0ge1xuICAgICAgICB0eXBlIDogXCJhZGRCb2R5XCIsXG4gICAgICAgIGJvZHkgOiBudWxsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIHJlbW92ZWQgZnJvbSB0aGUgd29ybGQuXG4gICAgICogQGV2ZW50IHJlbW92ZUJvZHlcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAgICAgKi9cbiAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHtcbiAgICAgICAgdHlwZSA6IFwicmVtb3ZlQm9keVwiLFxuICAgICAgICBib2R5IDogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgc3ByaW5nIGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkU3ByaW5nXG4gICAgICogQHBhcmFtIHtTcHJpbmd9IHNwcmluZ1xuICAgICAqL1xuICAgIHRoaXMuYWRkU3ByaW5nRXZlbnQgPSB7XG4gICAgICAgIHR5cGUgOiBcImFkZFNwcmluZ1wiLFxuICAgICAgICBzcHJpbmcgOiBudWxsLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgZmlyc3QgY29udGFjdCBpcyBjcmVhdGVkIGJldHdlZW4gdHdvIGJvZGllcy4gVGhpcyBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgc3RlcCBoYXMgYmVlbiBkb25lLlxuICAgICAqIEBldmVudCBpbXBhY3RcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICAgICAqL1xuICAgIHRoaXMuaW1wYWN0RXZlbnQgPSB7XG4gICAgICAgIHR5cGU6IFwiaW1wYWN0XCIsXG4gICAgICAgIGJvZHlBIDogbnVsbCxcbiAgICAgICAgYm9keUIgOiBudWxsLFxuICAgICAgICBzaGFwZUEgOiBudWxsLFxuICAgICAgICBzaGFwZUIgOiBudWxsLFxuICAgICAgICBjb250YWN0RXF1YXRpb24gOiBudWxsLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBhZnRlciB0aGUgQnJvYWRwaGFzZSBoYXMgY29sbGVjdGVkIGNvbGxpc2lvbiBwYWlycyBpbiB0aGUgd29ybGQuXG4gICAgICogSW5zaWRlIHRoZSBldmVudCBoYW5kbGVyLCB5b3UgY2FuIG1vZGlmeSB0aGUgcGFpcnMgYXJyYXkgYXMgeW91IGxpa2UsIHRvXG4gICAgICogcHJldmVudCBjb2xsaXNpb25zIGJldHdlZW4gb2JqZWN0cyB0aGF0IHlvdSBkb24ndCB3YW50LlxuICAgICAqIEBldmVudCBwb3N0QnJvYWRwaGFzZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIEFuIGFycmF5IG9mIGNvbGxpc2lvbiBwYWlycy4gSWYgdGhpcyBhcnJheSBpcyBbYm9keTEsYm9keTIsYm9keTMsYm9keTRdLCB0aGVuIHRoZSBib2R5IHBhaXJzIDEsMiBhbmQgMyw0IHdvdWxkIGFkdmFuY2UgdG8gbmFycm93cGhhc2UuXG4gICAgICovXG4gICAgdGhpcy5wb3N0QnJvYWRwaGFzZUV2ZW50ID0ge1xuICAgICAgICB0eXBlOlwicG9zdEJyb2FkcGhhc2VcIixcbiAgICAgICAgcGFpcnM6bnVsbCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSG93IHRvIGRlYWN0aXZhdGUgYm9kaWVzIGR1cmluZyBzaW11bGF0aW9uLiBQb3NzaWJsZSBtb2RlcyBhcmU6IHt7I2Nyb3NzTGluayBcIldvcmxkL05PX1NMRUVQSU5HOnByb3BlcnR5XCJ9fVdvcmxkLk5PX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIldvcmxkL0JPRFlfU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuQk9EWV9TTEVFUElOR3t7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJXb3JsZC9JU0xBTkRfU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuSVNMQU5EX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0uXG4gICAgICogSWYgc2xlZXBpbmcgaXMgZW5hYmxlZCwgeW91IG1pZ2h0IG5lZWQgdG8ge3sjY3Jvc3NMaW5rIFwiQm9keS93YWtlVXA6bWV0aG9kXCJ9fXdha2UgdXB7ey9jcm9zc0xpbmt9fSB0aGUgYm9kaWVzIGlmIHRoZXkgZmFsbCBhc2xlZXAgd2hlbiB0aGV5IHNob3VsZG4ndC4gSWYgeW91IHdhbnQgdG8gZW5hYmxlIHNsZWVwaW5nIGluIHRoZSB3b3JsZCwgYnV0IHdhbnQgdG8gZGlzYWJsZSBpdCBmb3IgYSBwYXJ0aWN1bGFyIGJvZHksIHNlZSB7eyNjcm9zc0xpbmsgXCJCb2R5L2FsbG93U2xlZXA6cHJvcGVydHlcIn19Qm9keS5hbGxvd1NsZWVwe3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHNsZWVwTW9kZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgV29ybGQuTk9fU0xFRVBJTkdcbiAgICAgKi9cbiAgICB0aGlzLnNsZWVwTW9kZSA9IFdvcmxkLk5PX1NMRUVQSU5HO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0d28gc2hhcGVzIHN0YXJ0cyBzdGFydCB0byBvdmVybGFwLiBGaXJlZCBpbiB0aGUgbmFycm93cGhhc2UsIGR1cmluZyBzdGVwLlxuICAgICAqIEBldmVudCBiZWdpbkNvbnRhY3RcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUFcbiAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZUJcbiAgICAgKiBAcGFyYW0ge0JvZHl9ICBib2R5QVxuICAgICAqIEBwYXJhbSB7Qm9keX0gIGJvZHlCXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29udGFjdEVxdWF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuYmVnaW5Db250YWN0RXZlbnQgPSB7XG4gICAgICAgIHR5cGU6XCJiZWdpbkNvbnRhY3RcIixcbiAgICAgICAgc2hhcGVBIDogbnVsbCxcbiAgICAgICAgc2hhcGVCIDogbnVsbCxcbiAgICAgICAgYm9keUEgOiBudWxsLFxuICAgICAgICBib2R5QiA6IG51bGwsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvbnMgOiBbXSxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0d28gc2hhcGVzIHN0b3Agb3ZlcmxhcHBpbmcsIGFmdGVyIHRoZSBuYXJyb3dwaGFzZSAoZHVyaW5nIHN0ZXApLlxuICAgICAqIEBldmVudCBlbmRDb250YWN0XG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVBXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gICAgICogQHBhcmFtIHtCb2R5fSAgYm9keUFcbiAgICAgKiBAcGFyYW0ge0JvZHl9ICBib2R5QlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnRhY3RFcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmVuZENvbnRhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTpcImVuZENvbnRhY3RcIixcbiAgICAgICAgc2hhcGVBIDogbnVsbCxcbiAgICAgICAgc2hhcGVCIDogbnVsbCxcbiAgICAgICAgYm9keUEgOiBudWxsLFxuICAgICAgICBib2R5QiA6IG51bGwsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGVxdWF0aW9ucyBhcmUgYWRkZWQgdG8gdGhlIHNvbHZlciB0byBiZSBzb2x2ZWQuIENhbiBiZSB1c2VkIHRvIGNvbnRyb2wgd2hhdCBlcXVhdGlvbnMgZ29lcyBpbnRvIHRoZSBzb2x2ZXIuXG4gICAgICogQGV2ZW50IHByZVNvbHZlXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29udGFjdEVxdWF0aW9ucyAgQW4gYXJyYXkgb2YgY29udGFjdHMgdG8gYmUgc29sdmVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZyaWN0aW9uRXF1YXRpb25zIEFuIGFycmF5IG9mIGZyaWN0aW9uIGVxdWF0aW9ucyB0byBiZSBzb2x2ZWQuXG4gICAgICovXG4gICAgdGhpcy5wcmVTb2x2ZUV2ZW50ID0ge1xuICAgICAgICB0eXBlOlwicHJlU29sdmVcIixcbiAgICAgICAgY29udGFjdEVxdWF0aW9uczpudWxsLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uczpudWxsLFxuICAgIH07XG5cbiAgICAvLyBGb3Iga2VlcGluZyB0cmFjayBvZiBvdmVybGFwcGluZyBzaGFwZXNcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlID0geyBrZXlzOltdIH07XG4gICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZSA9IHsga2V5czpbXSB9O1xuXG4gICAgdGhpcy5vdmVybGFwS2VlcGVyID0gbmV3IE92ZXJsYXBLZWVwZXIoKTtcbn1cbldvcmxkLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5Xb3JsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXb3JsZDtcblxuLyoqXG4gKiBOZXZlciBkZWFjdGl2YXRlIGJvZGllcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT19TTEVFUElOR1xuICovXG5Xb3JsZC5OT19TTEVFUElORyA9IDE7XG5cbi8qKlxuICogRGVhY3RpdmF0ZSBpbmRpdmlkdWFsIGJvZGllcyBpZiB0aGV5IGFyZSBzbGVlcHkuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gQk9EWV9TTEVFUElOR1xuICovXG5Xb3JsZC5CT0RZX1NMRUVQSU5HID0gMjtcblxuLyoqXG4gKiBEZWFjdGl2YXRlcyBib2RpZXMgdGhhdCBhcmUgaW4gY29udGFjdCwgaWYgYWxsIG9mIHRoZW0gYXJlIHNsZWVweS4gTm90ZSB0aGF0IHlvdSBtdXN0IGVuYWJsZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9pc2xhbmRTcGxpdDpwcm9wZXJ0eVwifX0uaXNsYW5kU3BsaXR7ey9jcm9zc0xpbmt9fSBmb3IgdGhpcyB0byB3b3JrLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IElTTEFORF9TTEVFUElOR1xuICovXG5Xb3JsZC5JU0xBTkRfU0xFRVBJTkcgPSA0O1xuXG4vKipcbiAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHNpbXVsYXRpb24uXG4gKlxuICogQG1ldGhvZCBhZGRDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZENvbnN0cmFpbnQgPSBmdW5jdGlvbihjKXtcbiAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goYyk7XG59O1xuXG4vKipcbiAqIEFkZCBhIENvbnRhY3RNYXRlcmlhbCB0byB0aGUgc2ltdWxhdGlvbi5cbiAqIEBtZXRob2QgYWRkQ29udGFjdE1hdGVyaWFsXG4gKiBAcGFyYW0ge0NvbnRhY3RNYXRlcmlhbH0gY29udGFjdE1hdGVyaWFsXG4gKi9cbldvcmxkLnByb3RvdHlwZS5hZGRDb250YWN0TWF0ZXJpYWwgPSBmdW5jdGlvbihjb250YWN0TWF0ZXJpYWwpe1xuICAgIHRoaXMuY29udGFjdE1hdGVyaWFscy5wdXNoKGNvbnRhY3RNYXRlcmlhbCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjb250YWN0IG1hdGVyaWFsXG4gKlxuICogQG1ldGhvZCByZW1vdmVDb250YWN0TWF0ZXJpYWxcbiAqIEBwYXJhbSB7Q29udGFjdE1hdGVyaWFsfSBjbVxuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQ29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24oY20pe1xuICAgIHZhciBpZHggPSB0aGlzLmNvbnRhY3RNYXRlcmlhbHMuaW5kZXhPZihjbSk7XG4gICAgaWYoaWR4IT09LTEpe1xuICAgICAgICBVdGlscy5zcGxpY2UodGhpcy5jb250YWN0TWF0ZXJpYWxzLGlkeCwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGNvbnRhY3QgbWF0ZXJpYWwgZ2l2ZW4gdHdvIG1hdGVyaWFsc1xuICogQG1ldGhvZCBnZXRDb250YWN0TWF0ZXJpYWxcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQVxuICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxCXG4gKiBAcmV0dXJuIHtDb250YWN0TWF0ZXJpYWx9IFRoZSBtYXRjaGluZyBDb250YWN0TWF0ZXJpYWwsIG9yIGZhbHNlIG9uIGZhaWwuXG4gKiBAdG9kbyBVc2UgZmFzdGVyIGhhc2ggbWFwIHRvIGxvb2t1cCBmcm9tIG1hdGVyaWFsIGlkJ3NcbiAqL1xuV29ybGQucHJvdG90eXBlLmdldENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKG1hdGVyaWFsQSxtYXRlcmlhbEIpe1xuICAgIHZhciBjbWF0cyA9IHRoaXMuY29udGFjdE1hdGVyaWFscztcbiAgICBmb3IodmFyIGk9MCwgTj1jbWF0cy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgY20gPSBjbWF0c1tpXTtcbiAgICAgICAgaWYoIChjbS5tYXRlcmlhbEEuaWQgPT09IG1hdGVyaWFsQS5pZCkgJiYgKGNtLm1hdGVyaWFsQi5pZCA9PT0gbWF0ZXJpYWxCLmlkKSB8fFxuICAgICAgICAgICAgKGNtLm1hdGVyaWFsQS5pZCA9PT0gbWF0ZXJpYWxCLmlkKSAmJiAoY20ubWF0ZXJpYWxCLmlkID09PSBtYXRlcmlhbEEuaWQpICl7XG4gICAgICAgICAgICByZXR1cm4gY207XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgY29uc3RyYWludFxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQ29uc3RyYWludFxuICogQHBhcmFtIHtDb25zdHJhaW50fSBjXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24oYyl7XG4gICAgdmFyIGlkeCA9IHRoaXMuY29uc3RyYWludHMuaW5kZXhPZihjKTtcbiAgICBpZihpZHghPT0tMSl7XG4gICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLmNvbnN0cmFpbnRzLGlkeCwxKTtcbiAgICB9XG59O1xuXG52YXIgc3RlcF9yID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX3J1bml0ID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX3UgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfZiA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF9maE1pbnYgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfdmVsb2R0ID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX21nID0gdmVjMi5jcmVhdGUoKSxcbiAgICB4aXcgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICB4ancgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICB6ZXJvID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgaW50ZXJwdmVsbyA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIFN0ZXAgdGhlIHBoeXNpY3Mgd29ybGQgZm9yd2FyZCBpbiB0aW1lLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gbW9kZXMuIFRoZSBzaW1wbGUgbW9kZSBpcyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uLiBJbiB0aGlzIGNhc2UgeW91IG9ubHkgdXNlIHRoZSBmaXJzdCBhcmd1bWVudC4gVGhlIHNlY29uZCBjYXNlIHVzZXMgaW50ZXJwb2xhdGlvbi4gSW4gdGhhdCB5b3UgYWxzbyBwcm92aWRlIHRoZSB0aW1lIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCB1c2VkLCBhcyB3ZWxsIGFzIHRoZSBtYXhpbXVtIGZpeGVkIHRpbWVzdGVwcyB0byB0YWtlLlxuICpcbiAqIEBtZXRob2Qgc3RlcFxuICogQHBhcmFtIHtOdW1iZXJ9IGR0ICAgICAgICAgICAgICAgICAgICAgICBUaGUgZml4ZWQgdGltZSBzdGVwIHNpemUgdG8gdXNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lU2luY2VMYXN0Q2FsbGVkPTBdICBUaGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBmdW5jdGlvbiB3YXMgbGFzdCBjYWxsZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gW21heFN1YlN0ZXBzPTEwXSAgICAgICAgIE1heGltdW0gbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHRvIHRha2UgcGVyIGZ1bmN0aW9uIGNhbGwuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uXG4gKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCk7XG4gKiAgICAgd29ybGQuc3RlcCgwLjAxKTtcbiAqXG4gKiBAc2VlIGh0dHA6Ly9idWxsZXRwaHlzaWNzLm9yZy9tZWRpYXdpa2ktMS41LjgvaW5kZXgucGhwL1N0ZXBwaW5nX1RoZV9Xb3JsZFxuICovXG5Xb3JsZC5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKGR0LHRpbWVTaW5jZUxhc3RDYWxsZWQsbWF4U3ViU3RlcHMpe1xuICAgIG1heFN1YlN0ZXBzID0gbWF4U3ViU3RlcHMgfHwgMTA7XG4gICAgdGltZVNpbmNlTGFzdENhbGxlZCA9IHRpbWVTaW5jZUxhc3RDYWxsZWQgfHwgMDtcblxuICAgIGlmKHRpbWVTaW5jZUxhc3RDYWxsZWQgPT09IDApeyAvLyBGaXhlZCwgc2ltcGxlIHN0ZXBwaW5nXG5cbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCB0aW1lXG4gICAgICAgIHRoaXMudGltZSArPSBkdDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHdlIHNob3VsZCBoYXZlIHRha2VuIHNpbmNlIHRoZSBsYXN0IHN0ZXBcbiAgICAgICAgdmFyIGludGVybmFsU3RlcHMgPSBNYXRoLmZsb29yKCAodGhpcy50aW1lK3RpbWVTaW5jZUxhc3RDYWxsZWQpIC8gZHQpIC0gTWF0aC5mbG9vcih0aGlzLnRpbWUgLyBkdCk7XG4gICAgICAgIGludGVybmFsU3RlcHMgPSBNYXRoLm1pbihpbnRlcm5hbFN0ZXBzLG1heFN1YlN0ZXBzKTtcblxuICAgICAgICAvLyBEbyBzb21lIGZpeGVkIHN0ZXBzIHRvIGNhdGNoIHVwXG4gICAgICAgIHZhciB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWludGVybmFsU3RlcHM7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG4gICAgICAgICAgICBpZihwZXJmb3JtYW5jZS5ub3coKSAtIHQwID4gZHQqMTAwMCl7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIHNsb3dlciB0aGFuIHJlYWwtdGltZS4gQmV0dGVyIGJhaWwgb3V0LlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IGludGVybmFsIGNsb2NrXG4gICAgICAgIHRoaXMudGltZSArPSB0aW1lU2luY2VMYXN0Q2FsbGVkO1xuXG4gICAgICAgIC8vIENvbXB1dGUgXCJMZWZ0IG92ZXJcIiB0aW1lIHN0ZXBcbiAgICAgICAgdmFyIGggPSB0aGlzLnRpbWUgJSBkdDtcbiAgICAgICAgdmFyIGhfZGl2X2R0ID0gaC9kdDtcblxuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PXRoaXMuYm9kaWVzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5ib2RpZXNbal07XG4gICAgICAgICAgICBpZihiLnR5cGUgIT09IEJvZHkuU1RBVElDICYmIGIuc2xlZXBTdGF0ZSAhPT0gQm9keS5TTEVFUElORyl7XG4gICAgICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICB2ZWMyLnN1YihpbnRlcnB2ZWxvLCBiLnBvc2l0aW9uLCBiLnByZXZpb3VzUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUoaW50ZXJwdmVsbywgaW50ZXJwdmVsbywgaF9kaXZfZHQpO1xuICAgICAgICAgICAgICAgIHZlYzIuYWRkKGIuaW50ZXJwb2xhdGVkUG9zaXRpb24sIGIucG9zaXRpb24sIGludGVycHZlbG8pO1xuXG4gICAgICAgICAgICAgICAgYi5pbnRlcnBvbGF0ZWRBbmdsZSA9IGIuYW5nbGUgKyAoYi5hbmdsZSAtIGIucHJldmlvdXNBbmdsZSkgKiBoX2Rpdl9kdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHN0YXRpYyBib2RpZXMsIGp1c3QgY29weS4gV2hvIGVsc2Ugd2lsbCBkbyBpdD9cbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoYi5pbnRlcnBvbGF0ZWRQb3NpdGlvbiwgYi5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgYi5pbnRlcnBvbGF0ZWRBbmdsZSA9IGIuYW5nbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZW5kT3ZlcmxhcHMgPSBbXTtcblxuLyoqXG4gKiBNYWtlIGEgZml4ZWQgc3RlcC5cbiAqIEBtZXRob2QgaW50ZXJuYWxTdGVwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGR0XG4gKiBAcHJpdmF0ZVxuICovXG5Xb3JsZC5wcm90b3R5cGUuaW50ZXJuYWxTdGVwID0gZnVuY3Rpb24oZHQpe1xuICAgIHRoaXMuc3RlcHBpbmcgPSB0cnVlO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICBkb1Byb2ZpbGluZyA9IHRoaXMuZG9Qcm9maWxpbmcsXG4gICAgICAgIE5zcHJpbmdzID0gdGhpcy5zcHJpbmdzLmxlbmd0aCxcbiAgICAgICAgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncyxcbiAgICAgICAgYm9kaWVzID0gdGhpcy5ib2RpZXMsXG4gICAgICAgIGcgPSB0aGlzLmdyYXZpdHksXG4gICAgICAgIHNvbHZlciA9IHRoaXMuc29sdmVyLFxuICAgICAgICBOYm9kaWVzID0gdGhpcy5ib2RpZXMubGVuZ3RoLFxuICAgICAgICBicm9hZHBoYXNlID0gdGhpcy5icm9hZHBoYXNlLFxuICAgICAgICBucCA9IHRoaXMubmFycm93cGhhc2UsXG4gICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyxcbiAgICAgICAgdDAsIHQxLFxuICAgICAgICBmaE1pbnYgPSBzdGVwX2ZoTWludixcbiAgICAgICAgdmVsb2R0ID0gc3RlcF92ZWxvZHQsXG4gICAgICAgIG1nID0gc3RlcF9tZyxcbiAgICAgICAgc2NhbGUgPSB2ZWMyLnNjYWxlLFxuICAgICAgICBhZGQgPSB2ZWMyLmFkZCxcbiAgICAgICAgcm90YXRlID0gdmVjMi5yb3RhdGUsXG4gICAgICAgIGlzbGFuZE1hbmFnZXIgPSB0aGlzLmlzbGFuZE1hbmFnZXI7XG5cbiAgICB0aGlzLm92ZXJsYXBLZWVwZXIudGljaygpO1xuXG4gICAgdGhpcy5sYXN0VGltZVN0ZXAgPSBkdDtcblxuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgYXBwcm94aW1hdGUgZnJpY3Rpb24gZ3Jhdml0eS5cbiAgICBpZih0aGlzLnVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5KXtcbiAgICAgICAgdmFyIGdyYXZpdHlMZW4gPSB2ZWMyLmxlbmd0aCh0aGlzLmdyYXZpdHkpO1xuICAgICAgICBpZighKGdyYXZpdHlMZW4gPT09IDAgJiYgdGhpcy51c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5KSl7XG4gICAgICAgICAgICAvLyBOb256ZXJvIGdyYXZpdHkuIFVzZSBpdC5cbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25HcmF2aXR5ID0gZ3Jhdml0eUxlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBncmF2aXR5IHRvIGJvZGllc1xuICAgIGlmKHRoaXMuYXBwbHlHcmF2aXR5KXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgZmkgPSBiLmZvcmNlO1xuICAgICAgICAgICAgaWYoYi50eXBlICE9PSBCb2R5LkRZTkFNSUMgfHwgYi5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlYzIuc2NhbGUobWcsZyxiLm1hc3MqYi5ncmF2aXR5U2NhbGUpOyAvLyBGPW0qZ1xuICAgICAgICAgICAgYWRkKGZpLGZpLG1nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBzcHJpbmcgZm9yY2VzXG4gICAgaWYodGhpcy5hcHBseVNwcmluZ0ZvcmNlcyl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TnNwcmluZ3M7IGkrKyl7XG4gICAgICAgICAgICB2YXIgcyA9IHNwcmluZ3NbaV07XG4gICAgICAgICAgICBzLmFwcGx5Rm9yY2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuYXBwbHlEYW1waW5nKXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV07XG4gICAgICAgICAgICBpZihiLnR5cGUgPT09IEJvZHkuRFlOQU1JQyl7XG4gICAgICAgICAgICAgICAgYi5hcHBseURhbXBpbmcoZHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnJvYWRwaGFzZVxuICAgIHZhciByZXN1bHQgPSBicm9hZHBoYXNlLmdldENvbGxpc2lvblBhaXJzKHRoaXMpO1xuXG4gICAgLy8gUmVtb3ZlIGlnbm9yZWQgY29sbGlzaW9uIHBhaXJzXG4gICAgdmFyIGlnbm9yZWRQYWlycyA9IHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnM7XG4gICAgZm9yKHZhciBpPWlnbm9yZWRQYWlycy5sZW5ndGgtMjsgaT49MDsgaS09Mil7XG4gICAgICAgIGZvcih2YXIgaj1yZXN1bHQubGVuZ3RoLTI7IGo+PTA7IGotPTIpe1xuICAgICAgICAgICAgaWYoIChpZ25vcmVkUGFpcnNbaV0gICA9PT0gcmVzdWx0W2pdICYmIGlnbm9yZWRQYWlyc1tpKzFdID09PSByZXN1bHRbaisxXSkgfHxcbiAgICAgICAgICAgICAgICAoaWdub3JlZFBhaXJzW2krMV0gPT09IHJlc3VsdFtqXSAmJiBpZ25vcmVkUGFpcnNbaV0gICA9PT0gcmVzdWx0W2orMV0pKXtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3BsaWNlKGosMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgY29uc3RyYWluZWQgcGFpcnMgd2l0aCBjb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlXG4gICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcbiAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICBpZighYy5jb2xsaWRlQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIGZvcih2YXIgaj1yZXN1bHQubGVuZ3RoLTI7IGo+PTA7IGotPTIpe1xuICAgICAgICAgICAgICAgIGlmKCAoYy5ib2R5QSA9PT0gcmVzdWx0W2pdICYmIGMuYm9keUIgPT09IHJlc3VsdFtqKzFdKSB8fFxuICAgICAgICAgICAgICAgICAgICAoYy5ib2R5QiA9PT0gcmVzdWx0W2pdICYmIGMuYm9keUEgPT09IHJlc3VsdFtqKzFdKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaiwyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb3N0QnJvYWRwaGFzZSBldmVudFxuICAgIHRoaXMucG9zdEJyb2FkcGhhc2VFdmVudC5wYWlycyA9IHJlc3VsdDtcbiAgICB0aGlzLmVtaXQodGhpcy5wb3N0QnJvYWRwaGFzZUV2ZW50KTtcblxuICAgIC8vIE5hcnJvd3BoYXNlXG4gICAgbnAucmVzZXQodGhpcyk7XG4gICAgZm9yKHZhciBpPTAsIE5yZXN1bHRzPXJlc3VsdC5sZW5ndGg7IGkhPT1OcmVzdWx0czsgaSs9Mil7XG4gICAgICAgIHZhciBiaSA9IHJlc3VsdFtpXSxcbiAgICAgICAgICAgIGJqID0gcmVzdWx0W2krMV07XG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIGFsbCBzaGFwZXMgb2YgYm9keSBpXG4gICAgICAgIGZvcih2YXIgaz0wLCBOc2hhcGVzaT1iaS5zaGFwZXMubGVuZ3RoOyBrIT09TnNoYXBlc2k7IGsrKyl7XG4gICAgICAgICAgICB2YXIgc2kgPSBiaS5zaGFwZXNba10sXG4gICAgICAgICAgICAgICAgeGkgPSBiaS5zaGFwZU9mZnNldHNba10sXG4gICAgICAgICAgICAgICAgYWkgPSBiaS5zaGFwZUFuZ2xlc1trXTtcblxuICAgICAgICAgICAgLy8gQWxsIHNoYXBlcyBvZiBib2R5IGpcbiAgICAgICAgICAgIGZvcih2YXIgbD0wLCBOc2hhcGVzaj1iai5zaGFwZXMubGVuZ3RoOyBsIT09TnNoYXBlc2o7IGwrKyl7XG4gICAgICAgICAgICAgICAgdmFyIHNqID0gYmouc2hhcGVzW2xdLFxuICAgICAgICAgICAgICAgICAgICB4aiA9IGJqLnNoYXBlT2Zmc2V0c1tsXSxcbiAgICAgICAgICAgICAgICAgICAgYWogPSBiai5zaGFwZUFuZ2xlc1tsXTtcblxuICAgICAgICAgICAgICAgIHZhciBjbSA9IHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcbiAgICAgICAgICAgICAgICBpZihzaS5tYXRlcmlhbCAmJiBzai5tYXRlcmlhbCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLmdldENvbnRhY3RNYXRlcmlhbChzaS5tYXRlcmlhbCxzai5tYXRlcmlhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRtcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucnVuTmFycm93cGhhc2UobnAsYmksc2kseGksYWksYmosc2oseGosYWosY20sdGhpcy5mcmljdGlvbkdyYXZpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2FrZSB1cCBib2RpZXNcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihib2R5Ll93YWtlVXBBZnRlck5hcnJvd3BoYXNlKXtcbiAgICAgICAgICAgIGJvZHkud2FrZVVwKCk7XG4gICAgICAgICAgICBib2R5Ll93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbWl0IGVuZCBvdmVybGFwIGV2ZW50c1xuICAgIGlmKHRoaXMuaGFzKCdlbmRDb250YWN0Jykpe1xuICAgICAgICB0aGlzLm92ZXJsYXBLZWVwZXIuZ2V0RW5kT3ZlcmxhcHMoZW5kT3ZlcmxhcHMpO1xuICAgICAgICB2YXIgZSA9IHRoaXMuZW5kQ29udGFjdEV2ZW50O1xuICAgICAgICB2YXIgbCA9IGVuZE92ZXJsYXBzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUobC0tKXtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZW5kT3ZlcmxhcHNbbF07XG4gICAgICAgICAgICBlLnNoYXBlQSA9IGRhdGEuc2hhcGVBO1xuICAgICAgICAgICAgZS5zaGFwZUIgPSBkYXRhLnNoYXBlQjtcbiAgICAgICAgICAgIGUuYm9keUEgPSBkYXRhLmJvZHlBO1xuICAgICAgICAgICAgZS5ib2R5QiA9IGRhdGEuYm9keUI7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJlU29sdmVFdmVudCA9IHRoaXMucHJlU29sdmVFdmVudDtcbiAgICBwcmVTb2x2ZUV2ZW50LmNvbnRhY3RFcXVhdGlvbnMgPSBucC5jb250YWN0RXF1YXRpb25zO1xuICAgIHByZVNvbHZlRXZlbnQuZnJpY3Rpb25FcXVhdGlvbnMgPSBucC5mcmljdGlvbkVxdWF0aW9ucztcbiAgICB0aGlzLmVtaXQocHJlU29sdmVFdmVudCk7XG5cbiAgICAvLyB1cGRhdGUgY29uc3RyYWludCBlcXVhdGlvbnNcbiAgICB2YXIgTmNvbnN0cmFpbnRzID0gY29uc3RyYWludHMubGVuZ3RoO1xuICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgIGNvbnN0cmFpbnRzW2ldLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGlmKG5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoIHx8IG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCB8fCBjb25zdHJhaW50cy5sZW5ndGgpe1xuICAgICAgICBpZih0aGlzLmlzbGFuZFNwbGl0KXtcbiAgICAgICAgICAgIC8vIFNwbGl0IGludG8gaXNsYW5kc1xuICAgICAgICAgICAgaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIFV0aWxzLmFwcGVuZEFycmF5KGlzbGFuZE1hbmFnZXIuZXF1YXRpb25zLCBucC5jb250YWN0RXF1YXRpb25zKTtcbiAgICAgICAgICAgIFV0aWxzLmFwcGVuZEFycmF5KGlzbGFuZE1hbmFnZXIuZXF1YXRpb25zLCBucC5mcmljdGlvbkVxdWF0aW9ucyk7XG4gICAgICAgICAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICAgICAgICAgIFV0aWxzLmFwcGVuZEFycmF5KGlzbGFuZE1hbmFnZXIuZXF1YXRpb25zLCBjb25zdHJhaW50c1tpXS5lcXVhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNsYW5kTWFuYWdlci5zcGxpdCh0aGlzKTtcblxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1pc2xhbmRNYW5hZ2VyLmlzbGFuZHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHZhciBpc2xhbmQgPSBpc2xhbmRNYW5hZ2VyLmlzbGFuZHNbaV07XG4gICAgICAgICAgICAgICAgaWYoaXNsYW5kLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICBzb2x2ZXIuc29sdmVJc2xhbmQoZHQsaXNsYW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gQWRkIGNvbnRhY3QgZXF1YXRpb25zIHRvIHNvbHZlclxuICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9ucyhucC5jb250YWN0RXF1YXRpb25zKTtcbiAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbnMobnAuZnJpY3Rpb25FcXVhdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdXNlci1kZWZpbmVkIGNvbnN0cmFpbnQgZXF1YXRpb25zXG4gICAgICAgICAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbnMoY29uc3RyYWludHNbaV0uZXF1YXRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5zb2x2ZUNvbnN0cmFpbnRzKXtcbiAgICAgICAgICAgICAgICBzb2x2ZXIuc29sdmUoZHQsdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgZm9yd2FyZFxuICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgaWYoYm9keS5zbGVlcFN0YXRlICE9PSBCb2R5LlNMRUVQSU5HICYmIGJvZHkudHlwZSAhPT0gQm9keS5TVEFUSUMpe1xuICAgICAgICAgICAgYm9keS5pbnRlZ3JhdGUoZHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgZm9yY2VcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgIGJvZGllc1tpXS5zZXRaZXJvRm9yY2UoKTtcbiAgICB9XG5cbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHQxID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoYXQubGFzdFN0ZXBUaW1lID0gdDEtdDA7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBpbXBhY3QgZXZlbnRcbiAgICBpZih0aGlzLmVtaXRJbXBhY3RFdmVudCAmJiB0aGlzLmhhcygnaW1wYWN0Jykpe1xuICAgICAgICB2YXIgZXYgPSB0aGlzLmltcGFjdEV2ZW50O1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PW5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGVxID0gbnAuY29udGFjdEVxdWF0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmKGVxLmZpcnN0SW1wYWN0KXtcbiAgICAgICAgICAgICAgICBldi5ib2R5QSA9IGVxLmJvZHlBO1xuICAgICAgICAgICAgICAgIGV2LmJvZHlCID0gZXEuYm9keUI7XG4gICAgICAgICAgICAgICAgZXYuc2hhcGVBID0gZXEuc2hhcGVBO1xuICAgICAgICAgICAgICAgIGV2LnNoYXBlQiA9IGVxLnNoYXBlQjtcbiAgICAgICAgICAgICAgICBldi5jb250YWN0RXF1YXRpb24gPSBlcTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2xlZXBpbmcgdXBkYXRlXG4gICAgaWYodGhpcy5zbGVlcE1vZGUgPT09IFdvcmxkLkJPRFlfU0xFRVBJTkcpe1xuICAgICAgICBmb3IoaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIGJvZGllc1tpXS5zbGVlcFRpY2sodGhpcy50aW1lLCBmYWxzZSwgZHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKHRoaXMuc2xlZXBNb2RlID09PSBXb3JsZC5JU0xBTkRfU0xFRVBJTkcgJiYgdGhpcy5pc2xhbmRTcGxpdCl7XG5cbiAgICAgICAgLy8gVGVsbCBhbGwgYm9kaWVzIHRvIHNsZWVwIHRpY2sgYnV0IGRvbnQgc2xlZXAgeWV0XG4gICAgICAgIGZvcihpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUsIHRydWUsIGR0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsZWVwIGlzbGFuZHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5pc2xhbmRNYW5hZ2VyLmlzbGFuZHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGlzbGFuZCA9IHRoaXMuaXNsYW5kTWFuYWdlci5pc2xhbmRzW2ldO1xuICAgICAgICAgICAgaWYoaXNsYW5kLndhbnRzVG9TbGVlcCgpKXtcbiAgICAgICAgICAgICAgICBpc2xhbmQuc2xlZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RlcHBpbmcgPSBmYWxzZTtcblxuICAgIC8vIFJlbW92ZSBib2RpZXMgdGhhdCBhcmUgc2NoZWR1bGVkIGZvciByZW1vdmFsXG4gICAgaWYodGhpcy5ib2RpZXNUb0JlUmVtb3ZlZC5sZW5ndGgpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PXRoaXMuYm9kaWVzVG9CZVJlbW92ZWQubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVCb2R5KHRoaXMuYm9kaWVzVG9CZVJlbW92ZWRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9kaWVzVG9CZVJlbW92ZWQubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQodGhpcy5wb3N0U3RlcEV2ZW50KTtcbn07XG5cbi8qKlxuICogUnVucyBuYXJyb3dwaGFzZSBmb3IgdGhlIHNoYXBlIHBhaXIgaSBhbmQgai5cbiAqIEBtZXRob2QgcnVuTmFycm93cGhhc2VcbiAqIEBwYXJhbSAge05hcnJvd3BoYXNlfSBucFxuICogQHBhcmFtICB7Qm9keX0gYmlcbiAqIEBwYXJhbSAge1NoYXBlfSBzaVxuICogQHBhcmFtICB7QXJyYXl9IHhpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFpXG4gKiBAcGFyYW0gIHtCb2R5fSBialxuICogQHBhcmFtICB7U2hhcGV9IHNqXG4gKiBAcGFyYW0gIHtBcnJheX0geGpcbiAqIEBwYXJhbSAge051bWJlcn0gYWpcbiAqIEBwYXJhbSAge051bWJlcn0gbXVcbiAqL1xuV29ybGQucHJvdG90eXBlLnJ1bk5hcnJvd3BoYXNlID0gZnVuY3Rpb24obnAsYmksc2kseGksYWksYmosc2oseGosYWosY20sZ2xlbil7XG5cbiAgICAvLyBDaGVjayBjb2xsaXNpb24gZ3JvdXBzIGFuZCBtYXNrc1xuICAgIGlmKCEoKHNpLmNvbGxpc2lvbkdyb3VwICYgc2ouY29sbGlzaW9uTWFzaykgIT09IDAgJiYgKHNqLmNvbGxpc2lvbkdyb3VwICYgc2kuY29sbGlzaW9uTWFzaykgIT09IDApKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCB3b3JsZCBwb3NpdGlvbiBhbmQgYW5nbGUgb2YgZWFjaCBzaGFwZVxuICAgIHZlYzIucm90YXRlKHhpdywgeGksIGJpLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh4ancsIHhqLCBiai5hbmdsZSk7XG4gICAgdmVjMi5hZGQoeGl3LCB4aXcsIGJpLnBvc2l0aW9uKTtcbiAgICB2ZWMyLmFkZCh4ancsIHhqdywgYmoucG9zaXRpb24pO1xuICAgIHZhciBhaXcgPSBhaSArIGJpLmFuZ2xlO1xuICAgIHZhciBhancgPSBhaiArIGJqLmFuZ2xlO1xuXG4gICAgbnAuZW5hYmxlRnJpY3Rpb24gPSBjbS5mcmljdGlvbiA+IDA7XG4gICAgbnAuZnJpY3Rpb25Db2VmZmljaWVudCA9IGNtLmZyaWN0aW9uO1xuICAgIHZhciByZWR1Y2VkTWFzcztcbiAgICBpZihiaS50eXBlID09PSBCb2R5LlNUQVRJQyB8fCBiaS50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHJlZHVjZWRNYXNzID0gYmoubWFzcztcbiAgICB9IGVsc2UgaWYoYmoudHlwZSA9PT0gQm9keS5TVEFUSUMgfHwgYmoudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuICAgICAgICByZWR1Y2VkTWFzcyA9IGJpLm1hc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVkdWNlZE1hc3MgPSAoYmkubWFzcypiai5tYXNzKS8oYmkubWFzcytiai5tYXNzKTtcbiAgICB9XG4gICAgbnAuc2xpcEZvcmNlID0gY20uZnJpY3Rpb24qZ2xlbipyZWR1Y2VkTWFzcztcbiAgICBucC5yZXN0aXR1dGlvbiA9IGNtLnJlc3RpdHV0aW9uO1xuICAgIG5wLnN1cmZhY2VWZWxvY2l0eSA9IGNtLnN1cmZhY2VWZWxvY2l0eTtcbiAgICBucC5mcmljdGlvblN0aWZmbmVzcyA9IGNtLmZyaWN0aW9uU3RpZmZuZXNzO1xuICAgIG5wLmZyaWN0aW9uUmVsYXhhdGlvbiA9IGNtLmZyaWN0aW9uUmVsYXhhdGlvbjtcbiAgICBucC5zdGlmZm5lc3MgPSBjbS5zdGlmZm5lc3M7XG4gICAgbnAucmVsYXhhdGlvbiA9IGNtLnJlbGF4YXRpb247XG4gICAgbnAuY29udGFjdFNraW5TaXplID0gY20uY29udGFjdFNraW5TaXplO1xuICAgIG5wLmVuYWJsZWRFcXVhdGlvbnMgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTtcblxuICAgIHZhciByZXNvbHZlciA9IG5wW3NpLnR5cGUgfCBzai50eXBlXSxcbiAgICAgICAgbnVtQ29udGFjdHMgPSAwO1xuICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICB2YXIgc2Vuc29yID0gc2kuc2Vuc29yIHx8IHNqLnNlbnNvcjtcbiAgICAgICAgdmFyIG51bUZyaWN0aW9uQmVmb3JlID0gbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoO1xuICAgICAgICBpZiAoc2kudHlwZSA8IHNqLnR5cGUpIHtcbiAgICAgICAgICAgIG51bUNvbnRhY3RzID0gcmVzb2x2ZXIuY2FsbChucCwgYmksc2kseGl3LGFpdywgYmosc2oseGp3LGFqdywgc2Vuc29yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG51bUNvbnRhY3RzID0gcmVzb2x2ZXIuY2FsbChucCwgYmosc2oseGp3LGFqdywgYmksc2kseGl3LGFpdywgc2Vuc29yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtRnJpY3Rpb25FcXVhdGlvbnMgPSBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggLSBudW1GcmljdGlvbkJlZm9yZTtcblxuICAgICAgICBpZihudW1Db250YWN0cyl7XG5cbiAgICAgICAgICAgIGlmKCBiaS5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICAgICAgYmkudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmXG4gICAgICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSAgPT09IEJvZHkuU0xFRVBJTkcgJiZcbiAgICAgICAgICAgICAgICBiai5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgICAgIGJqLnR5cGUgIT09IEJvZHkuU1RBVElDXG4gICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRCID0gdmVjMi5zcXVhcmVkTGVuZ3RoKGJqLnZlbG9jaXR5KSArIE1hdGgucG93KGJqLmFuZ3VsYXJWZWxvY2l0eSwyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWRCID0gTWF0aC5wb3coYmouc2xlZXBTcGVlZExpbWl0LDIpO1xuICAgICAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEIgPj0gc3BlZWRMaW1pdFNxdWFyZWRCKjIpe1xuICAgICAgICAgICAgICAgICAgICBiaS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggYmouYWxsb3dTbGVlcCAmJlxuICAgICAgICAgICAgICAgIGJqLnR5cGUgPT09IEJvZHkuRFlOQU1JQyAmJlxuICAgICAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgID09PSBCb2R5LlNMRUVQSU5HICYmXG4gICAgICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSAgPT09IEJvZHkuQVdBS0UgJiZcbiAgICAgICAgICAgICAgICBiaS50eXBlICE9PSBCb2R5LlNUQVRJQ1xuICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICB2YXIgc3BlZWRTcXVhcmVkQSA9IHZlYzIuc3F1YXJlZExlbmd0aChiaS52ZWxvY2l0eSkgKyBNYXRoLnBvdyhiaS5hbmd1bGFyVmVsb2NpdHksMik7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQSA9IE1hdGgucG93KGJpLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgICAgICAgICBpZihzcGVlZFNxdWFyZWRBID49IHNwZWVkTGltaXRTcXVhcmVkQSoyKXtcbiAgICAgICAgICAgICAgICAgICAgYmouX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vdmVybGFwS2VlcGVyLnNldE92ZXJsYXBwaW5nKGJpLCBzaSwgYmosIHNqKTtcbiAgICAgICAgICAgIGlmKHRoaXMuaGFzKCdiZWdpbkNvbnRhY3QnKSAmJiB0aGlzLm92ZXJsYXBLZWVwZXIuaXNOZXdPdmVybGFwKHNpLCBzaikpe1xuXG4gICAgICAgICAgICAgICAgLy8gUmVwb3J0IG5ldyBzaGFwZSBvdmVybGFwXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmJlZ2luQ29udGFjdEV2ZW50O1xuICAgICAgICAgICAgICAgIGUuc2hhcGVBID0gc2k7XG4gICAgICAgICAgICAgICAgZS5zaGFwZUIgPSBzajtcbiAgICAgICAgICAgICAgICBlLmJvZHlBID0gYmk7XG4gICAgICAgICAgICAgICAgZS5ib2R5QiA9IGJqO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgY29udGFjdCBlcXVhdGlvbnNcbiAgICAgICAgICAgICAgICBlLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZihudW1Db250YWN0cyk9PT1cIm51bWJlclwiKXtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpPW5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoLW51bUNvbnRhY3RzOyBpPG5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5jb250YWN0RXF1YXRpb25zLnB1c2gobnAuY29udGFjdEVxdWF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRpdmlkZSB0aGUgbWF4IGZyaWN0aW9uIGZvcmNlIGJ5IHRoZSBudW1iZXIgb2YgY29udGFjdHNcbiAgICAgICAgICAgIGlmKHR5cGVvZihudW1Db250YWN0cyk9PT1cIm51bWJlclwiICYmIG51bUZyaWN0aW9uRXF1YXRpb25zID4gMSl7IC8vIFdoeSBkaXZpZGUgYnkgMT9cbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9bnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoLW51bUZyaWN0aW9uRXF1YXRpb25zOyBpPG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBucC5mcmljdGlvbkVxdWF0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZi5zZXRTbGlwRm9yY2UoZi5nZXRTbGlwRm9yY2UoKSAvIG51bUZyaWN0aW9uRXF1YXRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8qKlxuICogQWRkIGEgc3ByaW5nIHRvIHRoZSBzaW11bGF0aW9uXG4gKlxuICogQG1ldGhvZCBhZGRTcHJpbmdcbiAqIEBwYXJhbSB7U3ByaW5nfSBzXG4gKi9cbldvcmxkLnByb3RvdHlwZS5hZGRTcHJpbmcgPSBmdW5jdGlvbihzKXtcbiAgICB0aGlzLnNwcmluZ3MucHVzaChzKTtcbiAgICB0aGlzLmFkZFNwcmluZ0V2ZW50LnNwcmluZyA9IHM7XG4gICAgdGhpcy5lbWl0KHRoaXMuYWRkU3ByaW5nRXZlbnQpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBzcHJpbmdcbiAqXG4gKiBAbWV0aG9kIHJlbW92ZVNwcmluZ1xuICogQHBhcmFtIHtTcHJpbmd9IHNcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZVNwcmluZyA9IGZ1bmN0aW9uKHMpe1xuICAgIHZhciBpZHggPSB0aGlzLnNwcmluZ3MuaW5kZXhPZihzKTtcbiAgICBpZihpZHghPT0tMSl7XG4gICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLnNwcmluZ3MsaWR4LDEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGEgYm9keSB0byB0aGUgc2ltdWxhdGlvblxuICpcbiAqIEBtZXRob2QgYWRkQm9keVxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgd29ybGQgPSBuZXcgV29ybGQoKSxcbiAqICAgICAgICAgYm9keSA9IG5ldyBCb2R5KCk7XG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcbiAqIEB0b2RvIFdoYXQgaWYgdGhpcyBpcyBkb25lIGR1cmluZyBzdGVwP1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkQm9keSA9IGZ1bmN0aW9uKGJvZHkpe1xuICAgIGlmKHRoaXMuYm9kaWVzLmluZGV4T2YoYm9keSkgPT09IC0xKXtcbiAgICAgICAgdGhpcy5ib2RpZXMucHVzaChib2R5KTtcbiAgICAgICAgYm9keS53b3JsZCA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWRkQm9keUV2ZW50LmJvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5hZGRCb2R5RXZlbnQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLiBJZiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgZHVyaW5nIHN0ZXAoKSwgdGhlIGJvZHkgcmVtb3ZhbCBpcyBzY2hlZHVsZWQgdG8gYWZ0ZXIgdGhlIHN0ZXAuXG4gKlxuICogQG1ldGhvZCByZW1vdmVCb2R5XG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZUJvZHkgPSBmdW5jdGlvbihib2R5KXtcbiAgICBpZih0aGlzLnN0ZXBwaW5nKXtcbiAgICAgICAgdGhpcy5ib2RpZXNUb0JlUmVtb3ZlZC5wdXNoKGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJvZHkud29ybGQgPSBudWxsO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5ib2RpZXMuaW5kZXhPZihib2R5KTtcbiAgICAgICAgaWYoaWR4IT09LTEpe1xuICAgICAgICAgICAgVXRpbHMuc3BsaWNlKHRoaXMuYm9kaWVzLGlkeCwxKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQm9keUV2ZW50LmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgYm9keS5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMucmVtb3ZlQm9keUV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGEgYm9keSBieSBpdHMgaWQuXG4gKiBAbWV0aG9kIGdldEJvZHlCeUlkXG4gKiBAcmV0dXJuIHtCb2R5fEJvb2xlYW59IFRoZSBib2R5LCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGZvdW5kLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Qm9keUJ5SWQgPSBmdW5jdGlvbihpZCl7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xuICAgIGZvcih2YXIgaT0wOyBpPGJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiLmlkID09PSBpZCl7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERpc2FibGUgY29sbGlzaW9uIGJldHdlZW4gdHdvIGJvZGllc1xuICogQG1ldGhvZCBkaXNhYmxlQ29sbGlzaW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbldvcmxkLnByb3RvdHlwZS5kaXNhYmxlQm9keUNvbGxpc2lvbiA9IGZ1bmN0aW9uKGJvZHlBLGJvZHlCKXtcbiAgICB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzLnB1c2goYm9keUEsYm9keUIpO1xufTtcblxuLyoqXG4gKiBFbmFibGUgY29sbGlzaW9ucyBiZXR3ZWVuIHRoZSBnaXZlbiB0d28gYm9kaWVzXG4gKiBAbWV0aG9kIGVuYWJsZUNvbGxpc2lvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZW5hYmxlQm9keUNvbGxpc2lvbiA9IGZ1bmN0aW9uKGJvZHlBLGJvZHlCKXtcbiAgICB2YXIgcGFpcnMgPSB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzO1xuICAgIGZvcih2YXIgaT0wOyBpPHBhaXJzLmxlbmd0aDsgaSs9Mil7XG4gICAgICAgIGlmKChwYWlyc1tpXSA9PT0gYm9keUEgJiYgcGFpcnNbaSsxXSA9PT0gYm9keUIpIHx8IChwYWlyc1tpKzFdID09PSBib2R5QSAmJiBwYWlyc1tpXSA9PT0gYm9keUIpKXtcbiAgICAgICAgICAgIHBhaXJzLnNwbGljZShpLDIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiB2MmEodil7XG4gICAgaWYoIXYpe1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmV0dXJuIFt2WzBdLHZbMV1dO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSxiKXtcbiAgICBmb3IodmFyIGtleSBpbiBiKXtcbiAgICAgICAgYVtrZXldID0gYltrZXldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29udGFjdE1hdGVyaWFsVG9KU09OKGNtKXtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZCA6IGNtLmlkLFxuICAgICAgICBtYXRlcmlhbEEgOiAgICAgICAgICAgICBjbS5tYXRlcmlhbEEuaWQsXG4gICAgICAgIG1hdGVyaWFsQiA6ICAgICAgICAgICAgIGNtLm1hdGVyaWFsQi5pZCxcbiAgICAgICAgZnJpY3Rpb24gOiAgICAgICAgICAgICAgY20uZnJpY3Rpb24sXG4gICAgICAgIHJlc3RpdHV0aW9uIDogICAgICAgICAgIGNtLnJlc3RpdHV0aW9uLFxuICAgICAgICBzdGlmZm5lc3MgOiAgICAgICAgICAgICBjbS5zdGlmZm5lc3MsXG4gICAgICAgIHJlbGF4YXRpb24gOiAgICAgICAgICAgIGNtLnJlbGF4YXRpb24sXG4gICAgICAgIGZyaWN0aW9uU3RpZmZuZXNzIDogICAgIGNtLmZyaWN0aW9uU3RpZmZuZXNzLFxuICAgICAgICBmcmljdGlvblJlbGF4YXRpb24gOiAgICBjbS5mcmljdGlvblJlbGF4YXRpb24sXG4gICAgfTtcbn1cblxuLyoqXG4gKiBSZXNldHMgdGhlIFdvcmxkLCByZW1vdmVzIGFsbCBib2RpZXMsIGNvbnN0cmFpbnRzIGFuZCBzcHJpbmdzLlxuICpcbiAqIEBtZXRob2QgY2xlYXJcbiAqL1xuV29ybGQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcblxuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5maXhlZFN0ZXBUaW1lID0gMDtcblxuICAgIC8vIFJlbW92ZSBhbGwgc29sdmVyIGVxdWF0aW9uc1xuICAgIGlmKHRoaXMuc29sdmVyICYmIHRoaXMuc29sdmVyLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICB0aGlzLnNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGNvbnN0cmFpbnRzXG4gICAgdmFyIGNzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICBmb3IodmFyIGk9Y3MubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29uc3RyYWludChjc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBib2RpZXNcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gICAgZm9yKHZhciBpPWJvZGllcy5sZW5ndGgtMTsgaT49MDsgaS0tKXtcbiAgICAgICAgdGhpcy5yZW1vdmVCb2R5KGJvZGllc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBzcHJpbmdzXG4gICAgdmFyIHNwcmluZ3MgPSB0aGlzLnNwcmluZ3M7XG4gICAgZm9yKHZhciBpPXNwcmluZ3MubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlU3ByaW5nKHNwcmluZ3NbaV0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgY29udGFjdCBtYXRlcmlhbHNcbiAgICB2YXIgY21zID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xuICAgIGZvcih2YXIgaT1jbXMubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29udGFjdE1hdGVyaWFsKGNtc1tpXSk7XG4gICAgfVxuXG4gICAgV29ybGQuYXBwbHkodGhpcyk7XG59O1xuXG4vKipcbiAqIEdldCBhIGNvcHkgb2YgdGhpcyBXb3JsZCBpbnN0YW5jZVxuICogQG1ldGhvZCBjbG9uZVxuICogQHJldHVybiB7V29ybGR9XG4gKi9cbldvcmxkLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCk7XG4gICAgd29ybGQuZnJvbUpTT04odGhpcy50b0pTT04oKSk7XG4gICAgcmV0dXJuIHdvcmxkO1xufTtcblxudmFyIGhpdFRlc3RfdG1wMSA9IHZlYzIuY3JlYXRlKCksXG4gICAgaGl0VGVzdF96ZXJvID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgaGl0VGVzdF90bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogVGVzdCBpZiBhIHdvcmxkIHBvaW50IG92ZXJsYXBzIGJvZGllc1xuICogQG1ldGhvZCBoaXRUZXN0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHdvcmxkUG9pbnQgIFBvaW50IHRvIHVzZSBmb3IgaW50ZXJzZWN0aW9uIHRlc3RzXG4gKiBAcGFyYW0gIHtBcnJheX0gIGJvZGllcyAgICAgIEEgbGlzdCBvZiBvYmplY3RzIHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb25cbiAqIEBwYXJhbSAge051bWJlcn0gcHJlY2lzaW9uICAgVXNlZCBmb3IgbWF0Y2hpbmcgYWdhaW5zdCBwYXJ0aWNsZXMgYW5kIGxpbmVzLiBBZGRzIHNvbWUgbWFyZ2luIHRvIHRoZXNlIGluZmluaXRlc2ltYWwgb2JqZWN0cy5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgQXJyYXkgb2YgYm9kaWVzIHRoYXQgb3ZlcmxhcCB0aGUgcG9pbnRcbiAqL1xuV29ybGQucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbih3b3JsZFBvaW50LGJvZGllcyxwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuXG4gICAgLy8gQ3JlYXRlIGEgZHVtbXkgcGFydGljbGUgYm9keSB3aXRoIGEgcGFydGljbGUgc2hhcGUgdG8gdGVzdCBhZ2FpbnN0IHRoZSBib2RpZXNcbiAgICB2YXIgcGIgPSBuZXcgQm9keSh7IHBvc2l0aW9uOndvcmxkUG9pbnQgfSksXG4gICAgICAgIHBzID0gbmV3IFBhcnRpY2xlKCksXG4gICAgICAgIHB4ID0gd29ybGRQb2ludCxcbiAgICAgICAgcGEgPSAwLFxuICAgICAgICB4ID0gaGl0VGVzdF90bXAxLFxuICAgICAgICB6ZXJvID0gaGl0VGVzdF96ZXJvLFxuICAgICAgICB0bXAgPSBoaXRUZXN0X3RtcDI7XG4gICAgcGIuYWRkU2hhcGUocHMpO1xuXG4gICAgdmFyIG4gPSB0aGlzLm5hcnJvd3BoYXNlLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIC8vIENoZWNrIGJvZGllc1xuICAgIGZvcih2YXIgaT0wLCBOPWJvZGllcy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTAsIE5TPWIuc2hhcGVzLmxlbmd0aDsgaiE9PU5TOyBqKyspe1xuICAgICAgICAgICAgdmFyIHMgPSBiLnNoYXBlc1tqXSxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBiLnNoYXBlT2Zmc2V0c1tqXSB8fCB6ZXJvLFxuICAgICAgICAgICAgICAgIGFuZ2xlID0gYi5zaGFwZUFuZ2xlc1tqXSB8fCAwLjA7XG5cbiAgICAgICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBwb3NpdGlvbiArIGFuZ2xlXG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZSh4LCBvZmZzZXQsIGIuYW5nbGUpO1xuICAgICAgICAgICAgdmVjMi5hZGQoeCwgeCwgYi5wb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgYSA9IGFuZ2xlICsgYi5hbmdsZTtcblxuICAgICAgICAgICAgaWYoIChzIGluc3RhbmNlb2YgQ2lyY2xlICAgICYmIG4uY2lyY2xlUGFydGljbGUgIChiLHMseCxhLCAgICAgcGIscHMscHgscGEsIHRydWUpKSB8fFxuICAgICAgICAgICAgICAgIChzIGluc3RhbmNlb2YgQ29udmV4ICAgICYmIG4ucGFydGljbGVDb252ZXggIChwYixwcyxweCxwYSwgYixzLHgsYSwgICAgIHRydWUpKSB8fFxuICAgICAgICAgICAgICAgIChzIGluc3RhbmNlb2YgUGxhbmUgICAgICYmIG4ucGFydGljbGVQbGFuZSAgIChwYixwcyxweCxwYSwgYixzLHgsYSwgICAgIHRydWUpKSB8fFxuICAgICAgICAgICAgICAgIChzIGluc3RhbmNlb2YgQ2Fwc3VsZSAgICYmIG4ucGFydGljbGVDYXBzdWxlIChwYixwcyxweCxwYSwgYixzLHgsYSwgICAgIHRydWUpKSB8fFxuICAgICAgICAgICAgICAgIChzIGluc3RhbmNlb2YgUGFydGljbGUgICYmIHZlYzIuc3F1YXJlZExlbmd0aCh2ZWMyLnN1Yih0bXAseCx3b3JsZFBvaW50KSkgPCBwcmVjaXNpb24qcHJlY2lzaW9uKVxuICAgICAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBFcXVhdGlvbiBwYXJhbWV0ZXJzIGZvciBhbGwgY29uc3RyYWludHMgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzLlxuICogQG1ldGhvZCBzZXRHbG9iYWxFcXVhdGlvblBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1ldGVyc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5yZWxheGF0aW9uXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnN0aWZmbmVzc11cbiAqL1xuV29ybGQucHJvdG90eXBlLnNldEdsb2JhbEVxdWF0aW9uUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpe1xuICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgLy8gU2V0IGZvciBhbGwgY29uc3RyYWludHNcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb25zdHJhaW50c1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGMuZXF1YXRpb25zLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBlcSA9IGMuZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgaWYodHlwZW9mKHBhcmFtZXRlcnMuc3RpZmZuZXNzKSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICAgICAgZXEuc3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0eXBlb2YocGFyYW1ldGVycy5yZWxheGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICAgICAgZXEucmVsYXhhdGlvbiA9IHBhcmFtZXRlcnMucmVsYXhhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBmb3IgYWxsIGNvbnRhY3QgbWF0ZXJpYWxzXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IHRoaXMuY29udGFjdE1hdGVyaWFscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzW2ldO1xuICAgICAgICBpZih0eXBlb2YocGFyYW1ldGVycy5zdGlmZm5lc3MpICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIGMuc3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgICAgICAgICBjLmZyaWN0aW9uU3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mKHBhcmFtZXRlcnMucmVsYXhhdGlvbikgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgYy5yZWxheGF0aW9uID0gcGFyYW1ldGVycy5yZWxheGF0aW9uO1xuICAgICAgICAgICAgYy5mcmljdGlvblJlbGF4YXRpb24gPSBwYXJhbWV0ZXJzLnJlbGF4YXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgZm9yIGRlZmF1bHQgY29udGFjdCBtYXRlcmlhbFxuICAgIHZhciBjID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xuICAgIGlmKHR5cGVvZihwYXJhbWV0ZXJzLnN0aWZmbmVzcykgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICBjLnN0aWZmbmVzcyA9IHBhcmFtZXRlcnMuc3RpZmZuZXNzO1xuICAgICAgICBjLmZyaWN0aW9uU3RpZmZuZXNzID0gcGFyYW1ldGVycy5zdGlmZm5lc3M7XG4gICAgfVxuICAgIGlmKHR5cGVvZihwYXJhbWV0ZXJzLnJlbGF4YXRpb24pICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgYy5yZWxheGF0aW9uID0gcGFyYW1ldGVycy5yZWxheGF0aW9uO1xuICAgICAgICBjLmZyaWN0aW9uUmVsYXhhdGlvbiA9IHBhcmFtZXRlcnMucmVsYXhhdGlvbjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3RpZmZuZXNzIGZvciBhbGwgZXF1YXRpb25zIGFuZCBjb250YWN0IG1hdGVyaWFscy5cbiAqIEBtZXRob2Qgc2V0R2xvYmFsU3RpZmZuZXNzXG4gKiBAcGFyYW0ge051bWJlcn0gc3RpZmZuZXNzXG4gKi9cbldvcmxkLnByb3RvdHlwZS5zZXRHbG9iYWxTdGlmZm5lc3MgPSBmdW5jdGlvbihzdGlmZm5lc3Mpe1xuICAgIHRoaXMuc2V0R2xvYmFsRXF1YXRpb25QYXJhbWV0ZXJzKHtcbiAgICAgICAgc3RpZmZuZXNzOiBzdGlmZm5lc3NcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSByZWxheGF0aW9uIGZvciBhbGwgZXF1YXRpb25zIGFuZCBjb250YWN0IG1hdGVyaWFscy5cbiAqIEBtZXRob2Qgc2V0R2xvYmFsUmVsYXhhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJlbGF4YXRpb25cbiAqL1xuV29ybGQucHJvdG90eXBlLnNldEdsb2JhbFJlbGF4YXRpb24gPSBmdW5jdGlvbihyZWxheGF0aW9uKXtcbiAgICB0aGlzLnNldEdsb2JhbEVxdWF0aW9uUGFyYW1ldGVycyh7XG4gICAgICAgIHJlbGF4YXRpb246IHJlbGF4YXRpb25cbiAgICB9KTtcbn07XG5cbnZhciB0bXBSYXkgPSBuZXcgUmF5KCk7XG5cbi8qKlxuICogUmF5IGNhc3QgYWdhaW5zdCBhbGwgYm9kaWVzLiBUaGUgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaCBoaXQgd2l0aCBhIFJheWNhc3RSZXN1bHQgYXMgc2luZ2xlIGFyZ3VtZW50LlxuICogQG1ldGhvZCByYXljYXN0QWxsXG4gKiBAcGFyYW0gIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbk1hc2s9LTFdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkdyb3VwPS0xXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdEFsbCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zLCBjYWxsYmFjayl7XG4gICAgb3B0aW9ucy5tb2RlID0gUmF5LkFMTDtcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tO1xuICAgIG9wdGlvbnMudG8gPSB0bztcbiAgICBvcHRpb25zLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmF5IGNhc3QsIGFuZCBzdG9wIGF0IHRoZSBmaXJzdCByZXN1bHQuIE5vdGUgdGhhdCB0aGUgb3JkZXIgaXMgcmFuZG9tIC0gYnV0IHRoZSBtZXRob2QgaXMgZmFzdC5cbiAqIEBtZXRob2QgcmF5Y2FzdEFueVxuICogQHBhcmFtICB7VmVjM30gZnJvbVxuICogQHBhcmFtICB7VmVjM30gdG9cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25NYXNrPS0xXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25Hcm91cD0tMV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnJheWNhc3RBbnkgPSBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucywgcmVzdWx0KXtcbiAgICBvcHRpb25zLm1vZGUgPSBSYXkuQU5ZO1xuICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XG4gICAgb3B0aW9ucy50byA9IHRvO1xuICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0O1xuICAgIHJldHVybiB0bXBSYXkuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJheSBjYXN0LCBhbmQgcmV0dXJuIGluZm9ybWF0aW9uIG9mIHRoZSBjbG9zZXN0IGhpdC5cbiAqIEBtZXRob2QgcmF5Y2FzdENsb3Nlc3RcbiAqIEBwYXJhbSAge1ZlYzN9IGZyb21cbiAqIEBwYXJhbSAge1ZlYzN9IHRvXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uTWFzaz0tMV1cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uR3JvdXA9LTFdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yYXljYXN0Q2xvc2VzdCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zLCByZXN1bHQpe1xuICAgIG9wdGlvbnMubW9kZSA9IFJheS5DTE9TRVNUO1xuICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XG4gICAgb3B0aW9ucy50byA9IHRvO1xuICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0O1xuICAgIHJldHVybiB0bXBSYXkuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XG59OyIsIi8qIVxuICogYXN5bmNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYW9sYW4vYXN5bmNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMC0yMDE0IENhb2xhbiBNY01haG9uXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuLypqc2hpbnQgb25ldmFyOiBmYWxzZSwgaW5kZW50OjQgKi9cbi8qZ2xvYmFsIHNldEltbWVkaWF0ZTogZmFsc2UsIHNldFRpbWVvdXQ6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSAqL1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBhc3luYyA9IHt9O1xuXG4gICAgLy8gZ2xvYmFsIG9uIHRoZSBzZXJ2ZXIsIHdpbmRvdyBpbiB0aGUgYnJvd3NlclxuICAgIHZhciByb290LCBwcmV2aW91c19hc3luYztcblxuICAgIHJvb3QgPSB0aGlzO1xuICAgIGlmIChyb290ICE9IG51bGwpIHtcbiAgICAgIHByZXZpb3VzX2FzeW5jID0gcm9vdC5hc3luYztcbiAgICB9XG5cbiAgICBhc3luYy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByb290LmFzeW5jID0gcHJldmlvdXNfYXN5bmM7XG4gICAgICAgIHJldHVybiBhc3luYztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb25seV9vbmNlKGZuKSB7XG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGNhbGxlZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLlwiKTtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBmbi5hcHBseShyb290LCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8vLyBjcm9zcy1icm93c2VyIGNvbXBhdGlibGl0eSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgdmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICB2YXIgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuICAgIHZhciBfZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChhcnIuZm9yRWFjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5mb3JFYWNoKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2ldLCBpLCBhcnIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfbWFwID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGFyci5tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIubWFwKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IoeCwgaSwgYSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1lbW8pIHtcbiAgICAgICAgaWYgKGFyci5yZWR1Y2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKTtcbiAgICAgICAgfVxuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICBtZW1vID0gaXRlcmF0b3IobWVtbywgeCwgaSwgYSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgdmFyIF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICAvLy8vIGV4cG9ydGVkIGFzeW5jIG1vZHVsZSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgLy8vLyBuZXh0VGljayBpbXBsZW1lbnRhdGlvbiB3aXRoIGJyb3dzZXItY29tcGF0aWJsZSBmYWxsYmFjayAvLy8vXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCAhKHByb2Nlc3MubmV4dFRpY2spKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzeW5jLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jLmVhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgb25seV9vbmNlKGRvbmUpICk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2ggPSBhc3luYy5lYWNoO1xuXG4gICAgYXN5bmMuZWFjaFNlcmllcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICB2YXIgaXRlcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltjb21wbGV0ZWRdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpdGVyYXRlKCk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoU2VyaWVzID0gYXN5bmMuZWFjaFNlcmllcztcblxuICAgIGFzeW5jLmVhY2hMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZuID0gX2VhY2hMaW1pdChsaW1pdCk7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIFthcnIsIGl0ZXJhdG9yLCBjYWxsYmFja10pO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaExpbWl0ID0gYXN5bmMuZWFjaExpbWl0O1xuXG4gICAgdmFyIF9lYWNoTGltaXQgPSBmdW5jdGlvbiAobGltaXQpIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgaWYgKCFhcnIubGVuZ3RoIHx8IGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHJ1bm5pbmcgPSAwO1xuXG4gICAgICAgICAgICAoZnVuY3Rpb24gcmVwbGVuaXNoICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgPCBsaW1pdCAmJiBzdGFydGVkIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyW3N0YXJ0ZWQgLSAxXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICB2YXIgZG9QYXJhbGxlbCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvUGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0LCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFtfZWFjaExpbWl0KGxpbWl0KV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBkb1NlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoU2VyaWVzXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBfYXN5bmNNYXAgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1t4LmluZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhc3luYy5tYXAgPSBkb1BhcmFsbGVsKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwU2VyaWVzID0gZG9TZXJpZXMoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9tYXBMaW1pdChsaW1pdCkoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICB2YXIgX21hcExpbWl0ID0gZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFyYWxsZWxMaW1pdChsaW1pdCwgX2FzeW5jTWFwKTtcbiAgICB9O1xuXG4gICAgLy8gcmVkdWNlIG9ubHkgaGFzIGEgc2VyaWVzIHZlcnNpb24sIGFzIGRvaW5nIHJlZHVjZSBpbiBwYXJhbGxlbCB3b24ndFxuICAgIC8vIHdvcmsgaW4gbWFueSBzaXR1YXRpb25zLlxuICAgIGFzeW5jLnJlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoU2VyaWVzKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihtZW1vLCB4LCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGluamVjdCBhbGlhc1xuICAgIGFzeW5jLmluamVjdCA9IGFzeW5jLnJlZHVjZTtcbiAgICAvLyBmb2xkbCBhbGlhc1xuICAgIGFzeW5jLmZvbGRsID0gYXN5bmMucmVkdWNlO1xuXG4gICAgYXN5bmMucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJldmVyc2VkID0gX21hcChhcnIsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSkucmV2ZXJzZSgpO1xuICAgICAgICBhc3luYy5yZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvLyBmb2xkciBhbGlhc1xuICAgIGFzeW5jLmZvbGRyID0gYXN5bmMucmVkdWNlUmlnaHQ7XG5cbiAgICB2YXIgX2ZpbHRlciA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmZpbHRlciA9IGRvUGFyYWxsZWwoX2ZpbHRlcik7XG4gICAgYXN5bmMuZmlsdGVyU2VyaWVzID0gZG9TZXJpZXMoX2ZpbHRlcik7XG4gICAgLy8gc2VsZWN0IGFsaWFzXG4gICAgYXN5bmMuc2VsZWN0ID0gYXN5bmMuZmlsdGVyO1xuICAgIGFzeW5jLnNlbGVjdFNlcmllcyA9IGFzeW5jLmZpbHRlclNlcmllcztcblxuICAgIHZhciBfcmVqZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLnJlamVjdCA9IGRvUGFyYWxsZWwoX3JlamVjdCk7XG4gICAgYXN5bmMucmVqZWN0U2VyaWVzID0gZG9TZXJpZXMoX3JlamVjdCk7XG5cbiAgICB2YXIgX2RldGVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHgpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZGV0ZWN0ID0gZG9QYXJhbGxlbChfZGV0ZWN0KTtcbiAgICBhc3luYy5kZXRlY3RTZXJpZXMgPSBkb1NlcmllcyhfZGV0ZWN0KTtcblxuICAgIGFzeW5jLnNvbWUgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbnkgYWxpYXNcbiAgICBhc3luYy5hbnkgPSBhc3luYy5zb21lO1xuXG4gICAgYXN5bmMuZXZlcnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gYWxsIGFsaWFzXG4gICAgYXN5bmMuYWxsID0gYXN5bmMuZXZlcnk7XG5cbiAgICBhc3luYy5zb3J0QnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMubWFwKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHt2YWx1ZTogeCwgY3JpdGVyaWE6IGNyaXRlcmlhfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgX21hcChyZXN1bHRzLnNvcnQoZm4pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5hdXRvID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB2YXIga2V5cyA9IF9rZXlzKHRhc2tzKTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ1Rhc2tzID0ga2V5cy5sZW5ndGhcbiAgICAgICAgaWYgKCFyZW1haW5pbmdUYXNrcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdmFyIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChmbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBmbikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGFza0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVtYWluaW5nVGFza3MtLVxuICAgICAgICAgICAgX2VhY2gobGlzdGVuZXJzLnNsaWNlKDApLCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYWRkTGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFyZW1haW5pbmdUYXNrcykge1xuICAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgZmluYWwgY2FsbGJhY2sgZnJvbSBjYWxsaW5nIGl0c2VsZiBpZiBpdCBlcnJvcnNcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICAgICAgICAgdGhlQ2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9lYWNoKGtleXMsIGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IF9pc0FycmF5KHRhc2tzW2tdKSA/IHRhc2tzW2tdOiBbdGFza3Nba11dO1xuICAgICAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKF9rZXlzKHJlc3VsdHMpLCBmdW5jdGlvbihya2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1tya2V5XSA9IHJlc3VsdHNbcmtleV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHN1YnNlcXVlbnQgZXJyb3JzIGhpdHRpbmcgY2FsbGJhY2sgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUodGFza0NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVzID0gdGFzay5zbGljZSgwLCBNYXRoLmFicyh0YXNrLmxlbmd0aCAtIDEpKSB8fCBbXTtcbiAgICAgICAgICAgIHZhciByZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZHVjZShyZXF1aXJlcywgZnVuY3Rpb24gKGEsIHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhICYmIHJlc3VsdHMuaGFzT3duUHJvcGVydHkoeCkpO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpICYmICFyZXN1bHRzLmhhc093blByb3BlcnR5KGspO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMucmV0cnkgPSBmdW5jdGlvbih0aW1lcywgdGFzaywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIERFRkFVTFRfVElNRVMgPSA1O1xuICAgICAgICB2YXIgYXR0ZW1wdHMgPSBbXTtcbiAgICAgICAgLy8gVXNlIGRlZmF1bHRzIGlmIHRpbWVzIG5vdCBwYXNzZWRcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0YXNrO1xuICAgICAgICAgICAgdGFzayA9IHRpbWVzO1xuICAgICAgICAgICAgdGltZXMgPSBERUZBVUxUX1RJTUVTO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aW1lcyBpcyBhIG51bWJlclxuICAgICAgICB0aW1lcyA9IHBhcnNlSW50KHRpbWVzLCAxMCkgfHwgREVGQVVMVF9USU1FUztcbiAgICAgICAgdmFyIHdyYXBwZWRUYXNrID0gZnVuY3Rpb24od3JhcHBlZENhbGxiYWNrLCB3cmFwcGVkUmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIHJldHJ5QXR0ZW1wdCA9IGZ1bmN0aW9uKHRhc2ssIGZpbmFsQXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzZXJpZXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrKGZ1bmN0aW9uKGVyciwgcmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0NhbGxiYWNrKCFlcnIgfHwgZmluYWxBdHRlbXB0LCB7ZXJyOiBlcnIsIHJlc3VsdDogcmVzdWx0fSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHdyYXBwZWRSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdoaWxlICh0aW1lcykge1xuICAgICAgICAgICAgICAgIGF0dGVtcHRzLnB1c2gocmV0cnlBdHRlbXB0KHRhc2ssICEodGltZXMtPTEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3luYy5zZXJpZXMoYXR0ZW1wdHMsIGZ1bmN0aW9uKGRvbmUsIGRhdGEpe1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgKHdyYXBwZWRDYWxsYmFjayB8fCBjYWxsYmFjaykoZGF0YS5lcnIsIGRhdGEucmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgY2FsbGJhY2sgaXMgcGFzc2VkLCBydW4gdGhpcyBhcyBhIGNvbnRyb2xsIGZsb3dcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrID8gd3JhcHBlZFRhc2soKSA6IHdyYXBwZWRUYXNrXG4gICAgfTtcblxuICAgIGFzeW5jLndhdGVyZmFsbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFfaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byB3YXRlcmZhbGwgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBJdGVyYXRvciA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHdyYXBJdGVyYXRvcihuZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgd3JhcEl0ZXJhdG9yKGFzeW5jLml0ZXJhdG9yKHRhc2tzKSkoKTtcbiAgICB9O1xuXG4gICAgdmFyIF9wYXJhbGxlbCA9IGZ1bmN0aW9uKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmIChfaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgICAgIGVhY2hmbi5tYXAodGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGVhY2hmbi5lYWNoKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogYXN5bmMubWFwLCBlYWNoOiBhc3luYy5lYWNoIH0sIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnBhcmFsbGVsTGltaXQgPSBmdW5jdGlvbih0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogX21hcExpbWl0KGxpbWl0KSwgZWFjaDogX2VhY2hMaW1pdChsaW1pdCkgfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VyaWVzID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoX2lzQXJyYXkodGFza3MpKSB7XG4gICAgICAgICAgICBhc3luYy5tYXBTZXJpZXModGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5pdGVyYXRvciA9IGZ1bmN0aW9uICh0YXNrcykge1xuICAgICAgICB2YXIgbWFrZUNhbGxiYWNrID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrc1tpbmRleF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLm5leHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmbi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPCB0YXNrcy5sZW5ndGggLSAxKSA/IG1ha2VDYWxsYmFjayhpbmRleCArIDEpOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1ha2VDYWxsYmFjaygwKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuYXBwbHkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KFxuICAgICAgICAgICAgICAgIG51bGwsIGFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2NvbmNhdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByID0gW107XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYikge1xuICAgICAgICAgICAgZm4oeCwgZnVuY3Rpb24gKGVyciwgeSkge1xuICAgICAgICAgICAgICAgIHIgPSByLmNvbmNhdCh5IHx8IFtdKTtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuY29uY2F0ID0gZG9QYXJhbGxlbChfY29uY2F0KTtcbiAgICBhc3luYy5jb25jYXRTZXJpZXMgPSBkb1NlcmllcyhfY29uY2F0KTtcblxuICAgIGFzeW5jLndoaWxzdCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRlc3QoKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLndoaWxzdCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvV2hpbHN0ID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBpZiAodGVzdC5hcHBseShudWxsLCBhcmdzKSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmRvV2hpbHN0KGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMudW50aWwgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGVzdCgpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMudW50aWwodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5kb1VudGlsID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBpZiAoIXRlc3QuYXBwbHkobnVsbCwgYXJncykpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1VudGlsKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMucXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuICAgICAgICBpZiAoY29uY3VycmVuY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcG9zLCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmICghcS5zdGFydGVkKXtcbiAgICAgICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZGF0YS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzXG4gICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHEudGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3JrZXJzID0gMDtcbiAgICAgICAgdmFyIHEgPSB7XG4gICAgICAgICAgICB0YXNrczogW10sXG4gICAgICAgICAgICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgICAgICAgICBwYXVzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBraWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHEuZHJhaW4gPSBudWxsO1xuICAgICAgICAgICAgICBxLnRhc2tzID0gW107XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXEucGF1c2VkICYmIHdvcmtlcnMgPCBxLmNvbmN1cnJlbmN5ICYmIHEudGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXNrID0gcS50YXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocS5lbXB0eSAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXJzIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFzay5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxLmRyYWluICYmIHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5X29uY2UobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcih0YXNrLmRhdGEsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VycztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZGxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSB0cnVlKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG4gICAgXG4gICAgYXN5bmMucHJpb3JpdHlRdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiBfY29tcGFyZVRhc2tzKGEsIGIpe1xuICAgICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIF9iaW5hcnlTZWFyY2goc2VxdWVuY2UsIGl0ZW0sIGNvbXBhcmUpIHtcbiAgICAgICAgICB2YXIgYmVnID0gLTEsXG4gICAgICAgICAgICAgIGVuZCA9IHNlcXVlbmNlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKGJlZyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IGJlZyArICgoZW5kIC0gYmVnICsgMSkgPj4+IDEpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmUoaXRlbSwgc2VxdWVuY2VbbWlkXSkgPj0gMCkge1xuICAgICAgICAgICAgICBiZWcgPSBtaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmQgPSBtaWQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmVnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmICghcS5zdGFydGVkKXtcbiAgICAgICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZGF0YS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzXG4gICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHEudGFza3Muc3BsaWNlKF9iaW5hcnlTZWFyY2gocS50YXNrcywgaXRlbSwgX2NvbXBhcmVUYXNrcykgKyAxLCAwLCBpdGVtKTtcblxuICAgICAgICAgICAgICBpZiAocS5zYXR1cmF0ZWQgJiYgcS50YXNrcy5sZW5ndGggPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYSBub3JtYWwgcXVldWVcbiAgICAgICAgdmFyIHEgPSBhc3luYy5xdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KTtcbiAgICAgICAgXG4gICAgICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5XG4gICAgICAgIHEucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvblxuICAgICAgICBkZWxldGUgcS51bnNoaWZ0O1xuXG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG5cbiAgICBhc3luYy5jYXJnbyA9IGZ1bmN0aW9uICh3b3JrZXIsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHdvcmtpbmcgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB0YXNrcyAgICAgICA9IFtdO1xuXG4gICAgICAgIHZhciBjYXJnbyA9IHtcbiAgICAgICAgICAgIHRhc2tzOiB0YXNrcyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgZHJhaW5lZDogdHJ1ZSxcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYXJnby5kcmFpbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXJnby5zYXR1cmF0ZWQgJiYgdGFza3MubGVuZ3RoID09PSBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJnby5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShjYXJnby5wcm9jZXNzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgICAgICAgICAgIGlmICh3b3JraW5nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZihjYXJnby5kcmFpbiAmJiAhY2FyZ28uZHJhaW5lZCkgY2FyZ28uZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZ28uZHJhaW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdHMgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhc2tzLnNwbGljZSgwLCBwYXlsb2FkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFza3Muc3BsaWNlKDAsIHRhc2tzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHMgPSBfbWFwKHRzLCBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFzay5kYXRhO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYoY2FyZ28uZW1wdHkpIGNhcmdvLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgd29ya2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgd29ya2VyKGRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgX2VhY2godHMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhcmdvO1xuICAgIH07XG5cbiAgICB2YXIgX2NvbnNvbGVfZm4gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lYWNoKGFyZ3MsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZVtuYW1lXSh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGFzeW5jLmxvZyA9IF9jb25zb2xlX2ZuKCdsb2cnKTtcbiAgICBhc3luYy5kaXIgPSBfY29uc29sZV9mbignZGlyJyk7XG4gICAgLyphc3luYy5pbmZvID0gX2NvbnNvbGVfZm4oJ2luZm8nKTtcbiAgICBhc3luYy53YXJuID0gX2NvbnNvbGVfZm4oJ3dhcm4nKTtcbiAgICBhc3luYy5lcnJvciA9IF9jb25zb2xlX2ZuKCdlcnJvcicpOyovXG5cbiAgICBhc3luYy5tZW1vaXplID0gZnVuY3Rpb24gKGZuLCBoYXNoZXIpIHtcbiAgICAgICAgdmFyIG1lbW8gPSB7fTtcbiAgICAgICAgdmFyIHF1ZXVlcyA9IHt9O1xuICAgICAgICBoYXNoZXIgPSBoYXNoZXIgfHwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGhhc2hlci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gbWVtbykge1xuICAgICAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgbWVtb1trZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSBpbiBxdWV1ZXMpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIHFbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vO1xuICAgICAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XG4gICAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9O1xuXG4gICAgYXN5bmMudW5tZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGZuLnVubWVtb2l6ZWQgfHwgZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXAoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMudGltZXNTZXJpZXMgPSBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY291bnRlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN5bmMubWFwU2VyaWVzKGNvdW50ZXIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnNlcSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgICAgdmFyIGZucyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICBhc3luYy5yZWR1Y2UoZm5zLCBhcmdzLCBmdW5jdGlvbiAobmV3YXJncywgZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgbmV3YXJncy5jb25jYXQoW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XG4gICAgICAgICAgICAgICAgfV0pKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGF0LCBbZXJyXS5jb25jYXQocmVzdWx0cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGFzeW5jLmNvbXBvc2UgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XG4gICAgICByZXR1cm4gYXN5bmMuc2VxLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIHZhciBfYXBwbHlFYWNoID0gZnVuY3Rpb24gKGVhY2hmbiwgZm5zIC8qYXJncy4uLiovKSB7XG4gICAgICAgIHZhciBnbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MuY29uY2F0KFtjYl0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdvO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhc3luYy5hcHBseUVhY2ggPSBkb1BhcmFsbGVsKF9hcHBseUVhY2gpO1xuICAgIGFzeW5jLmFwcGx5RWFjaFNlcmllcyA9IGRvU2VyaWVzKF9hcHBseUVhY2gpO1xuXG4gICAgYXN5bmMuZm9yZXZlciA9IGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9O1xuXG4gICAgLy8gTm9kZS5qc1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xuICAgIH1cbiAgICAvLyBBTUQgLyBSZXF1aXJlSlNcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gaW5jbHVkZWQgZGlyZWN0bHkgdmlhIDxzY3JpcHQ+IHRhZ1xuICAgIGVsc2Uge1xuICAgICAgICByb290LmFzeW5jID0gYXN5bmM7XG4gICAgfVxuXG59KCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIEV2ZW50RW1pdHRlciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBFdmVudCBoYW5kbGVyIHRvIGJlIGNhbGxlZC5cbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgQ29udGV4dCBmb3IgZnVuY3Rpb24gZXhlY3V0aW9uLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgZW1pdCBvbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIE1pbmltYWwgRXZlbnRFbWl0dGVyIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBFdmVudEVtaXR0ZXIgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkgeyAvKiBOb3RoaW5nIHRvIHNldCAqLyB9XG5cbi8qKlxuICogSG9sZHMgdGhlIGFzc2lnbmVkIEV2ZW50RW1pdHRlcnMgYnkgbmFtZS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIFJldHVybiBhIGxpc3Qgb2YgYXNzaWduZWQgZXZlbnQgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnRzIHRoYXQgc2hvdWxkIGJlIGxpc3RlZC5cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbZXZlbnRdKSByZXR1cm4gW107XG4gIGlmICh0aGlzLl9ldmVudHNbZXZlbnRdLmZuKSByZXR1cm4gW3RoaXMuX2V2ZW50c1tldmVudF0uZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fZXZlbnRzW2V2ZW50XS5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSB0aGlzLl9ldmVudHNbZXZlbnRdW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBFbWl0IGFuIGV2ZW50IHRvIGFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRpb24gaWYgd2UndmUgZW1pdHRlZCBhbiBldmVudC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2ZW50XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgbGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgRXZlbnRMaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IFRoZSBjb250ZXh0IG9mIHRoZSBmdW5jdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZlbnRdKSB0aGlzLl9ldmVudHNbZXZlbnRdID0gbGlzdGVuZXI7XG4gIGVsc2Uge1xuICAgIGlmICghdGhpcy5fZXZlbnRzW2V2ZW50XS5mbikgdGhpcy5fZXZlbnRzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcbiAgICBlbHNlIHRoaXMuX2V2ZW50c1tldmVudF0gPSBbXG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnRdLCBsaXN0ZW5lclxuICAgIF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGFuIEV2ZW50TGlzdGVuZXIgdGhhdCdzIG9ubHkgY2FsbGVkIG9uY2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IE5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IFRoZSBjb250ZXh0IG9mIHRoZSBmdW5jdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCB0aGlzLCB0cnVlKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIGlmICghdGhpcy5fZXZlbnRzW2V2ZW50XSkgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IGxpc3RlbmVyO1xuICBlbHNlIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1tldmVudF0uZm4pIHRoaXMuX2V2ZW50c1tldmVudF0ucHVzaChsaXN0ZW5lcik7XG4gICAgZWxzZSB0aGlzLl9ldmVudHNbZXZlbnRdID0gW1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSwgbGlzdGVuZXJcbiAgICBdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCB3ZSB3YW50IHRvIHJlbW92ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciB0aGF0IHdlIG5lZWQgdG8gZmluZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmNlIGxpc3RlbmVycy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tldmVudF0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdXG4gICAgLCBldmVudHMgPSBbXTtcblxuICBpZiAoZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLmZuICYmIChsaXN0ZW5lcnMuZm4gIT09IGZuIHx8IChvbmNlICYmICFsaXN0ZW5lcnMub25jZSkpKSB7XG4gICAgICBldmVudHMucHVzaChsaXN0ZW5lcnMpO1xuICAgIH1cbiAgICBpZiAoIWxpc3RlbmVycy5mbikgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHwgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgLy9cbiAgaWYgKGV2ZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBvciBvbmx5IHRoZSBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCB3YW50IHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcblxuICBpZiAoZXZlbnQpIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICBlbHNlIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGRvZXNuJ3QgYXBwbHkgYW55bW9yZS5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIyID0gRXZlbnRFbWl0dGVyO1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlcjMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gVG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciBrZXlzO1xuXHR2YXIgdG8gPSBUb09iamVjdCh0YXJnZXQpO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IGFyZ3VtZW50c1tzXTtcblx0XHRrZXlzID0gT2JqZWN0LmtleXMoT2JqZWN0KGZyb20pKTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dG9ba2V5c1tpXV0gPSBmcm9tW2tleXNbaV1dO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCJ2YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpLFxuICAgIFJlc291cmNlID0gcmVxdWlyZSgnLi9SZXNvdXJjZScpLFxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qKlxuICogTWFuYWdlcyB0aGUgc3RhdGUgYW5kIGxvYWRpbmcgb2YgbXVsdGlwbGUgcmVzb3VyY2VzIHRvIGxvYWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0gW2Jhc2VVcmw9JyddIHtzdHJpbmd9IFRoZSBiYXNlIHVybCBmb3IgYWxsIHJlc291cmNlcyBsb2FkZWQgYnkgdGhpcyBsb2FkZXIuXG4gKiBAcGFyYW0gW2NvbmN1cnJlbmN5PTEwXSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJlc291cmNlcyB0byBsb2FkIGNvbmN1cnJlbnRseS5cbiAqL1xuZnVuY3Rpb24gTG9hZGVyKGJhc2VVcmwsIGNvbmN1cnJlbmN5KSB7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICBjb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IDEwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgdXJsIGZvciBhbGwgcmVzb3VyY2VzIGxvYWRlZCBieSB0aGlzIGxvYWRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsIHx8ICcnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByb2dyZXNzIHBlcmNlbnQgb2YgdGhlIGxvYWRlciBnb2luZyB0aHJvdWdoIHRoZSBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnByb2dyZXNzID0gMDtcblxuICAgIC8qKlxuICAgICAqIExvYWRpbmcgc3RhdGUgb2YgdGhlIGxvYWRlciwgdHJ1ZSBpZiBpdCBpcyBjdXJyZW50bHkgbG9hZGluZyByZXNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBlcmNlbnRhZ2Ugb2YgdG90YWwgcHJvZ3Jlc3MgdGhhdCBhIHNpbmdsZSByZXNvdXJjZSByZXByZXNlbnRzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX3Byb2dyZXNzQ2h1bmsgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1pZGRsZXdhcmUgdG8gcnVuIGJlZm9yZSBsb2FkaW5nIGVhY2ggcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbltdfVxuICAgICAqL1xuICAgIHRoaXMuX2JlZm9yZU1pZGRsZXdhcmUgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtaWRkbGV3YXJlIHRvIHJ1biBhZnRlciBsb2FkaW5nIGVhY2ggcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbltdfVxuICAgICAqL1xuICAgIHRoaXMuX2FmdGVyTWlkZGxld2FyZSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBfbG9hZFJlc291cmNlYCBmdW5jdGlvbiBib3VuZCB3aXRoIHRoaXMgb2JqZWN0IGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX2JvdW5kTG9hZFJlc291cmNlID0gdGhpcy5fbG9hZFJlc291cmNlLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYF9vbkxvYWRgIGZ1bmN0aW9uIGJvdW5kIHdpdGggdGhpcyBvYmplY3QgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlciB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fYm91bmRPbkxvYWQgPSB0aGlzLl9vbkxvYWQuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXNvdXJjZSBidWZmZXIgdGhhdCBmaWxscyB1bnRpbCBgbG9hZGAgaXMgY2FsbGVkIHRvIHN0YXJ0IGxvYWRpbmcgcmVzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyIHtSZXNvdXJjZVtdfVxuICAgICAqL1xuICAgIHRoaXMuX2J1ZmZlciA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byB0cmFjayBsb2FkIGNvbXBsZXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9udW1Ub0xvYWQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc291cmNlcyB3YWl0aW5nIHRvIGJlIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlciB7UmVzb3VyY2VbXX1cbiAgICAgKi9cbiAgICB0aGlzLl9xdWV1ZSA9IGFzeW5jLnF1ZXVlKHRoaXMuX2JvdW5kTG9hZFJlc291cmNlLCBjb25jdXJyZW5jeSk7XG5cbiAgICAvKipcbiAgICAgKiBBbGwgdGhlIHJlc291cmNlcyBmb3IgdGhpcyBsb2FkZXIga2V5ZWQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdDxzdHJpbmcsIFJlc291cmNlPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc291cmNlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBvbmNlIHBlciBsb2FkZWQgb3IgZXJyb3JlZCByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBldmVudCBwcm9ncmVzc1xuICAgICAqIEBtZW1iZXJvZiBMb2FkZXIjXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIG9uY2UgcGVyIGVycm9yZWQgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgZXJyb3JcbiAgICAgKiBAbWVtYmVyb2YgTG9hZGVyI1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBvbmNlIHBlciBsb2FkZWQgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgbG9hZFxuICAgICAqIEBtZW1iZXJvZiBMb2FkZXIjXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIGxvYWRlciBiZWdpbnMgdG8gcHJvY2VzcyB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgc3RhcnRcbiAgICAgKiBAbWVtYmVyb2YgTG9hZGVyI1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBxdWV1ZWQgcmVzb3VyY2VzIGFsbCBsb2FkLlxuICAgICAqXG4gICAgICogQGV2ZW50IGNvbXBsZXRlXG4gICAgICogQG1lbWJlcm9mIExvYWRlciNcbiAgICAgKi9cbn1cblxuTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5Mb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9hZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBMb2FkZXI7XG5cbi8qKlxuICogQWRkcyBhIHJlc291cmNlIChvciBtdWx0aXBsZSByZXNvdXJjZXMpIHRvIHRoZSBsb2FkZXIgcXVldWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gdGFrZSBhIHdpZGUgdmFyaWV0eSBvZiBkaWZmZXJlbnQgcGFyYW1ldGVycy4gVGhlIG9ubHkgdGhpbmcgdGhhdCBpcyBhbHdheXNcbiAqIHJlcXVpcmVkIHRoZSB1cmwgdG8gbG9hZC4gQWxsIHRoZSBmb2xsb3dpbmcgd2lsbCB3b3JrOlxuICpcbiAqIGBgYGpzXG4gKiBsb2FkZXJcbiAqICAgICAvLyBub3JtYWwgcGFyYW0gc3ludGF4XG4gKiAgICAgLmFkZCgna2V5JywgJ2h0dHA6Ly8uLi4nLCBmdW5jdGlvbiAoKSB7fSlcbiAqICAgICAuYWRkKCdodHRwOi8vLi4uJywgZnVuY3Rpb24gKCkge30pXG4gKiAgICAgLmFkZCgnaHR0cDovLy4uLicpXG4gKlxuICogICAgIC8vIG9iamVjdCBzeW50YXhcbiAqICAgICAuYWRkKHtcbiAqICAgICAgICAgbmFtZTogJ2tleTInLFxuICogICAgICAgICB1cmw6ICdodHRwOi8vLi4uJ1xuICogICAgIH0sIGZ1bmN0aW9uICgpIHt9KVxuICogICAgIC5hZGQoe1xuICogICAgICAgICB1cmw6ICdodHRwOi8vLi4uJ1xuICogICAgIH0sIGZ1bmN0aW9uICgpIHt9KVxuICogICAgIC5hZGQoe1xuICogICAgICAgICBuYW1lOiAna2V5MycsXG4gKiAgICAgICAgIHVybDogJ2h0dHA6Ly8uLi4nXG4gKiAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHt9XG4gKiAgICAgfSlcbiAqICAgICAuYWRkKHtcbiAqICAgICAgICAgdXJsOiAnaHR0cHM6Ly8uLi4nLFxuICogICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAqICAgICAgICAgY3Jvc3NPcmlnaW46IHRydWVcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyB5b3UgY2FuIGFsc28gcGFzcyBhbiBhcnJheSBvZiBvYmplY3RzIG9yIHVybHMgb3IgYm90aFxuICogICAgIC5hZGQoW1xuICogICAgICAgICB7IG5hbWU6ICdrZXk0JywgdXJsOiAnaHR0cDovLy4uLicsIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHt9IH0sXG4gKiAgICAgICAgIHsgdXJsOiAnaHR0cDovLy4uLicsIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHt9IH0sXG4gKiAgICAgICAgICdodHRwOi8vLi4uJ1xuICogICAgIF0pO1xuICogYGBgXG4gKlxuICogQGFsaWFzIGVucXVldWVcbiAqIEBwYXJhbSBbbmFtZV0ge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHJlc291cmNlIHRvIGxvYWQsIGlmIG5vdCBwYXNzZWQgdGhlIHVybCBpcyB1c2VkLlxuICogQHBhcmFtIHVybCB7c3RyaW5nfSBUaGUgdXJsIGZvciB0aGlzIHJlc291cmNlLCByZWxhdGl2ZSB0byB0aGUgYmFzZVVybCBvZiB0aGlzIGxvYWRlci5cbiAqIEBwYXJhbSBbb3B0aW9uc10ge29iamVjdH0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2FkLlxuICogQHBhcmFtIFtvcHRpb25zLmNyb3NzT3JpZ2luXSB7Ym9vbGVhbn0gSXMgdGhpcyByZXF1ZXN0IGNyb3NzLW9yaWdpbj8gRGVmYXVsdCBpcyB0byBkZXRlcm1pbmUgYXV0b21hdGljYWxseS5cbiAqIEBwYXJhbSBbb3B0aW9ucy5sb2FkVHlwZT1SZXNvdXJjZS5MT0FEX1RZUEUuWEhSXSB7UmVzb3VyY2UuWEhSX0xPQURfVFlQRX0gSG93IHNob3VsZCB0aGlzIHJlc291cmNlIGJlIGxvYWRlZD9cbiAqIEBwYXJhbSBbb3B0aW9ucy54aHJUeXBlPVJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRFRkFVTFRdIHtSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRX0gSG93IHNob3VsZCB0aGUgZGF0YSBiZWluZ1xuICogICAgICBsb2FkZWQgYmUgaW50ZXJwcmV0ZWQgd2hlbiB1c2luZyBYSFI/XG4gKiBAcGFyYW0gW2NhbGxiYWNrXSB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIHNwZWNpZmljIHJlc291cmNlIGNvbXBsZXRlcyBsb2FkaW5nLlxuICogQHJldHVybiB7TG9hZGVyfVxuICovXG5Mb2FkZXIucHJvdG90eXBlLmFkZCA9IExvYWRlci5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIChuYW1lLCB1cmwsIG9wdGlvbnMsIGNiKSB7XG4gICAgLy8gc3BlY2lhbCBjYXNlIG9mIGFuIGFycmF5IG9mIG9iamVjdHMgb3IgdXJsc1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hZGQobmFtZVtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBpZiBhbiBvYmplY3QgaXMgcGFzc2VkIGluc3RlYWQgb2YgcGFyYW1zXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjYiA9IHVybCB8fCBuYW1lLmNhbGxiYWNrIHx8IG5hbWUub25Db21wbGV0ZTtcbiAgICAgICAgb3B0aW9ucyA9IG5hbWU7XG4gICAgICAgIHVybCA9IG5hbWUudXJsO1xuICAgICAgICBuYW1lID0gbmFtZS5uYW1lIHx8IG5hbWUua2V5IHx8IG5hbWUudXJsO1xuICAgIH1cblxuICAgIC8vIGNhc2Ugd2hlcmUgbm8gbmFtZSBpcyBwYXNzZWQgc2hpZnQgYWxsIGFyZ3Mgb3ZlciBieSBvbmUuXG4gICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHVybDtcbiAgICAgICAgdXJsID0gbmFtZTtcbiAgICB9XG5cbiAgICAvLyBub3cgdGhhdCB3ZSBzaGlmdGVkIG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcHJvcGVyIHVybC5cbiAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB1cmwgcGFzc2VkIHRvIGFkZCByZXNvdXJjZSB0byBsb2FkZXIuJyk7XG4gICAgfVxuXG4gICAgLy8gb3B0aW9ucyBhcmUgb3B0aW9uYWwgc28gcGVvcGxlIG1pZ2h0IHBhc3MgYSBmdW5jdGlvbiBhbmQgbm8gb3B0aW9uc1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHJlc291cmNlIGFscmVhZHkgZXhpc3RzLlxuICAgIGlmICh0aGlzLnJlc291cmNlc1tuYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc291cmNlIHdpdGggbmFtZSBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLicpO1xuICAgIH1cblxuICAgIC8vIGFkZCBiYXNlIHVybCBpZiB0aGlzIGlzbid0IGEgZGF0YSB1cmxcbiAgICBpZiAodXJsLmluZGV4T2YoJ2RhdGE6JykgIT09IDApIHtcbiAgICAgICAgdXJsID0gdGhpcy5iYXNlVXJsICsgdXJsO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB0aGUgc3RvcmUgdGhlIHJlc291cmNlXG4gICAgdGhpcy5yZXNvdXJjZXNbbmFtZV0gPSBuZXcgUmVzb3VyY2UobmFtZSwgdXJsLCBvcHRpb25zKTtcblxuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZXNvdXJjZXNbbmFtZV0ub25jZSgnYWZ0ZXJNaWRkbGV3YXJlJywgY2IpO1xuICAgIH1cblxuICAgIHRoaXMuX251bVRvTG9hZCsrO1xuXG4gICAgLy8gaWYgYWxyZWFkeSBsb2FkaW5nIGFkZCBpdCB0byB0aGUgd29ya2VyIHF1ZXVlXG4gICAgaWYgKHRoaXMuX3F1ZXVlLnN0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5fcXVldWUucHVzaCh0aGlzLnJlc291cmNlc1tuYW1lXSk7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzQ2h1bmsgPSAoMTAwIC0gdGhpcy5wcm9ncmVzcykgLyAodGhpcy5fcXVldWUubGVuZ3RoKCkgKyB0aGlzLl9xdWV1ZS5ydW5uaW5nKCkpO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgYnVmZmVyIGl0IHRvIGJlIGFkZGVkIHRvIHRoZSBxdWV1ZSBsYXRlclxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9idWZmZXIucHVzaCh0aGlzLnJlc291cmNlc1tuYW1lXSk7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzQ2h1bmsgPSAxMDAgLyB0aGlzLl9idWZmZXIubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIFNldHMgdXAgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRoYXQgd2lsbCBydW4gKmJlZm9yZSogdGhlXG4gKiByZXNvdXJjZSBpcyBsb2FkZWQuXG4gKlxuICogQGFsaWFzIHByZVxuICogQHBhcmFtIG1pZGRsZXdhcmUge2Z1bmN0aW9ufSBUaGUgbWlkZGxld2FyZSBmdW5jdGlvbiB0byByZWdpc3Rlci5cbiAqIEByZXR1cm4ge0xvYWRlcn1cbiAqL1xuTG9hZGVyLnByb3RvdHlwZS5iZWZvcmUgPSBMb2FkZXIucHJvdG90eXBlLnByZSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHRoaXMuX2JlZm9yZU1pZGRsZXdhcmUucHVzaChmbik7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB1cCBhIG1pZGRsZXdhcmUgZnVuY3Rpb24gdGhhdCB3aWxsIHJ1biAqYWZ0ZXIqIHRoZVxuICogcmVzb3VyY2UgaXMgbG9hZGVkLlxuICpcbiAqIEBhbGlhcyB1c2VcbiAqIEBwYXJhbSBtaWRkbGV3YXJlIHtmdW5jdGlvbn0gVGhlIG1pZGRsZXdhcmUgZnVuY3Rpb24gdG8gcmVnaXN0ZXIuXG4gKiBAcmV0dXJuIHtMb2FkZXJ9XG4gKi9cbkxvYWRlci5wcm90b3R5cGUuYWZ0ZXIgPSBMb2FkZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHRoaXMuX2FmdGVyTWlkZGxld2FyZS5wdXNoKGZuKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIHF1ZXVlIG9mIHRoZSBsb2FkZXIgdG8gcHJlcGFyZSBmb3IgYSBuZXcgbG9hZC5cbiAqXG4gKiBAcmV0dXJuIHtMb2FkZXJ9XG4gKi9cbkxvYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYnVmZmVyLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLl9xdWV1ZS5raWxsKCk7XG4gICAgdGhpcy5fcXVldWUuc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5fcHJvZ3Jlc3NDaHVuayA9IDA7XG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBsb2FkaW5nIHRoZSBxdWV1ZWQgcmVzb3VyY2VzLlxuICpcbiAqIEBmaXJlcyBzdGFydFxuICogQHBhcmFtIFtjYWxsYmFja10ge2Z1bmN0aW9ufSBPcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgYm91bmQgdG8gdGhlIGBjb21wbGV0ZWAgZXZlbnQuXG4gKiBAcmV0dXJuIHtMb2FkZXJ9XG4gKi9cbkxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjYikge1xuICAgIC8vIHJlZ2lzdGVyIGNvbXBsZXRlIGNhbGxiYWNrIGlmIHRoZXkgcGFzcyBvbmVcbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMub25jZSgnY29tcGxldGUnLCBjYik7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHF1ZXVlIGhhcyBhbHJlYWR5IHN0YXJ0ZWQgd2UgYXJlIGRvbmUgaGVyZVxuICAgIGlmICh0aGlzLl9xdWV1ZS5zdGFydGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIG5vdGlmeSBvZiBzdGFydFxuICAgIHRoaXMuZW1pdCgnc3RhcnQnLCB0aGlzKTtcblxuICAgIC8vIHN0YXJ0IHRoZSBpbnRlcm5hbCBxdWV1ZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2godGhpcy5fYnVmZmVyW2ldKTtcbiAgICB9XG5cbiAgICAvLyBlbXB0eSB0aGUgYnVmZmVyXG4gICAgdGhpcy5fYnVmZmVyLmxlbmd0aCA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTG9hZHMgYSBzaW5nbGUgcmVzb3VyY2UuXG4gKlxuICogQGZpcmVzIHByb2dyZXNzXG4gKiBAcHJpdmF0ZVxuICovXG5Mb2FkZXIucHJvdG90eXBlLl9sb2FkUmVzb3VyY2UgPSBmdW5jdGlvbiAocmVzb3VyY2UsIGRlcXVldWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXNvdXJjZS5fZGVxdWV1ZSA9IGRlcXVldWU7XG5cbiAgICB0aGlzLl9ydW5NaWRkbGV3YXJlKHJlc291cmNlLCB0aGlzLl9iZWZvcmVNaWRkbGV3YXJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJlc291cmNlLm9uKCdwcm9ncmVzcycsIHNlbGYuZW1pdC5iaW5kKHNlbGYsICdwcm9ncmVzcycpKTtcblxuICAgICAgICByZXNvdXJjZS5sb2FkKHNlbGYuX2JvdW5kT25Mb2FkKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIG9uY2UgZWFjaCByZXNvdXJjZSBoYXMgbG9hZGVkLlxuICpcbiAqIEBmaXJlcyBjb21wbGV0ZVxuICogQHByaXZhdGVcbiAqL1xuTG9hZGVyLnByb3RvdHlwZS5fb25Db21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVtaXQoJ2NvbXBsZXRlJywgdGhpcywgdGhpcy5yZXNvdXJjZXMpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgZWFjaCB0aW1lIGEgcmVzb3VyY2VzIGlzIGxvYWRlZC5cbiAqXG4gKiBAZmlyZXMgcHJvZ3Jlc3NcbiAqIEBmaXJlcyBlcnJvclxuICogQGZpcmVzIGxvYWRcbiAqIEBwcml2YXRlXG4gKi9cbkxvYWRlci5wcm90b3R5cGUuX29uTG9hZCA9IGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgIHRoaXMucHJvZ3Jlc3MgKz0gdGhpcy5fcHJvZ3Jlc3NDaHVuaztcblxuICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCB0aGlzLCByZXNvdXJjZSk7XG5cbiAgICBpZiAocmVzb3VyY2UuZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHJlc291cmNlLmVycm9yLCB0aGlzLCByZXNvdXJjZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoJ2xvYWQnLCB0aGlzLCByZXNvdXJjZSk7XG4gICAgfVxuXG4gICAgLy8gcnVuIG1pZGRsZXdhcmUsIHRoaXMgKm11c3QqIGhhcHBlbiBiZWZvcmUgZGVxdWV1ZSBzbyBzdWItYXNzZXRzIGdldCBhZGRlZCBwcm9wZXJseVxuICAgIHRoaXMuX3J1bk1pZGRsZXdhcmUocmVzb3VyY2UsIHRoaXMuX2FmdGVyTWlkZGxld2FyZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvdXJjZS5lbWl0KCdhZnRlck1pZGRsZXdhcmUnLCByZXNvdXJjZSk7XG5cbiAgICAgICAgdGhpcy5fbnVtVG9Mb2FkLS07XG5cbiAgICAgICAgLy8gZG8gY29tcGxldGlvbiBjaGVja1xuICAgICAgICBpZiAodGhpcy5fbnVtVG9Mb2FkID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSB0aGlzIHJlc291cmNlIGZyb20gdGhlIGFzeW5jIHF1ZXVlXG4gICAgcmVzb3VyY2UuX2RlcXVldWUoKTtcbn07XG5cbi8qKlxuICogUnVuIG1pZGRsZXdhcmUgZnVuY3Rpb25zIG9uIGEgcmVzb3VyY2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuTG9hZGVyLnByb3RvdHlwZS5fcnVuTWlkZGxld2FyZSA9IGZ1bmN0aW9uIChyZXNvdXJjZSwgZm5zLCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGFzeW5jLmVhY2hTZXJpZXMoZm5zLCBmdW5jdGlvbiAoZm4sIG5leHQpIHtcbiAgICAgICAgZm4uY2FsbChzZWxmLCByZXNvdXJjZSwgbmV4dCk7XG4gICAgfSwgY2IuYmluZCh0aGlzLCByZXNvdXJjZSkpO1xufTtcblxuTG9hZGVyLkxPQURfVFlQRSA9IFJlc291cmNlLkxPQURfVFlQRTtcbkxvYWRlci5YSFJfUkVBRFlfU1RBVEUgPSBSZXNvdXJjZS5YSFJfUkVBRFlfU1RBVEU7XG5Mb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUgPSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRTtcbiIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJykuRXZlbnRFbWl0dGVyLFxuICAgIC8vIHRlc3RzIGlzIENPUlMgaXMgc3VwcG9ydGVkIGluIFhIUiwgaWYgbm90IHdlIG5lZWQgdG8gdXNlIFhEUlxuICAgIHVzZVhkciA9ICEhKHdpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIChuZXcgWE1MSHR0cFJlcXVlc3QoKSkpKTtcblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBzdGF0ZSBhbmQgbG9hZGluZyBvZiBhIHNpbmdsZSByZXNvdXJjZSByZXByZXNlbnRlZCBieVxuICogYSBzaW5nbGUgVVJMLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIG5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHJlc291cmNlIHRvIGxvYWQuXG4gKiBAcGFyYW0gdXJsIHtzdHJpbmd8c3RyaW5nW119IFRoZSB1cmwgZm9yIHRoaXMgcmVzb3VyY2UsIGZvciBhdWRpby92aWRlbyBsb2FkcyB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgb2Ygc291cmNlcy5cbiAqIEBwYXJhbSBbb3B0aW9uc10ge29iamVjdH0gVGhlIG9wdGlvbnMgZm9yIHRoZSBsb2FkLlxuICogQHBhcmFtIFtvcHRpb25zLmNyb3NzT3JpZ2luXSB7Ym9vbGVhbn0gSXMgdGhpcyByZXF1ZXN0IGNyb3NzLW9yaWdpbj8gRGVmYXVsdCBpcyB0byBkZXRlcm1pbmUgYXV0b21hdGljYWxseS5cbiAqIEBwYXJhbSBbb3B0aW9ucy5sb2FkVHlwZT1SZXNvdXJjZS5MT0FEX1RZUEUuWEhSXSB7UmVzb3VyY2UuTE9BRF9UWVBFfSBIb3cgc2hvdWxkIHRoaXMgcmVzb3VyY2UgYmUgbG9hZGVkP1xuICogQHBhcmFtIFtvcHRpb25zLnhoclR5cGU9UmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuREVGQVVMVF0ge1Jlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFfSBIb3cgc2hvdWxkIHRoZSBkYXRhIGJlaW5nXG4gKiAgICAgIGxvYWRlZCBiZSBpbnRlcnByZXRlZCB3aGVuIHVzaW5nIFhIUj9cbiAqL1xuZnVuY3Rpb24gUmVzb3VyY2UobmFtZSwgdXJsLCBvcHRpb25zKSB7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIG5hbWUgYW5kIHVybCBhcmUgcmVxdWlyZWQgZm9yIGNvbnN0cnVjdGluZyBhIHJlc291cmNlLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cmwgdXNlZCB0byBsb2FkIHRoaXMgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy51cmwgPSB1cmw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSB0aGF0IHdhcyBsb2FkZWQgYnkgdGhlIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7YW55fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIHJlcXVlc3QgY3Jvc3Mtb3JpZ2luPyBJZiB1bnNldCwgZGV0ZXJtaW5lZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSBvcHRpb25zLmNyb3NzT3JpZ2luO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCBvZiBsb2FkaW5nIHRvIHVzZSBmb3IgdGhpcyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1Jlc291cmNlLkxPQURfVFlQRX1cbiAgICAgKi9cbiAgICB0aGlzLmxvYWRUeXBlID0gb3B0aW9ucy5sb2FkVHlwZSB8fCB0aGlzLl9kZXRlcm1pbmVMb2FkVHlwZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgdXNlZCB0byBsb2FkIHRoZSByZXNvdXJjZSB2aWEgWEhSLiBJZiB1bnNldCwgZGV0ZXJtaW5lZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMueGhyVHlwZSA9IG9wdGlvbnMueGhyVHlwZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlcnJvciB0aGF0IG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgKGlmIGFueSkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtFcnJvcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmVycm9yID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBYSFIgb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG8gbG9hZCB0aGlzIHJlc291cmNlLiBUaGlzIGlzIG9ubHkgc2V0XG4gICAgICogd2hlbiBgbG9hZFR5cGVgIGlzIGBSZXNvdXJjZS5MT0FEX1RZUEUuWEhSYC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1hNTEh0dHBSZXF1ZXN0fVxuICAgICAqL1xuICAgIHRoaXMueGhyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBgZGVxdWV1ZWAgbWV0aG9kIHRoYXQgd2lsbCBiZSB1c2VkIGEgc3RvcmFnZSBwbGFjZSBmb3IgdGhlIGFzeW5jIHF1ZXVlIGRlcXVldWUgbWV0aG9kXG4gICAgICogdXNlZCBwcml2YXRlbHkgYnkgdGhlIGxvYWRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGVxdWV1ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYGNvbXBsZXRlYCBmdW5jdGlvbiBib3VuZCB0byB0aGlzIHJlc291cmNlJ3MgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYm91bmRDb21wbGV0ZSA9IHRoaXMuY29tcGxldGUuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBgX29uRXJyb3JgIGZ1bmN0aW9uIGJvdW5kIHRvIHRoaXMgcmVzb3VyY2UncyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7ZnVuY3Rpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9ib3VuZE9uRXJyb3IgPSB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYF9vblByb2dyZXNzYCBmdW5jdGlvbiBib3VuZCB0byB0aGlzIHJlc291cmNlJ3MgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYm91bmRPblByb2dyZXNzID0gdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpO1xuXG4gICAgLy8geGhyIGNhbGxiYWNrc1xuICAgIHRoaXMuX2JvdW5kWGhyT25FcnJvciA9IHRoaXMuX3hock9uRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZFhock9uQWJvcnQgPSB0aGlzLl94aHJPbkFib3J0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRYaHJPbkxvYWQgPSB0aGlzLl94aHJPbkxvYWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZFhkck9uVGltZW91dCA9IHRoaXMuX3hkck9uVGltZW91dC5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSByZXNvdXJjZSBiZWluZ3MgdG8gbG9hZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBzdGFydFxuICAgICAqIEBtZW1iZXJvZiBSZXNvdXJjZSNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgZWFjaCB0aW1lIHByb2dyZXNzIG9mIHRoaXMgcmVzb3VyY2UgbG9hZCB1cGRhdGVzLlxuICAgICAqIE5vdCBhbGwgcmVzb3VyY2VzIHR5cGVzIGFuZCBsb2FkZXIgc3lzdGVtcyBjYW4gc3VwcG9ydCB0aGlzIGV2ZW50XG4gICAgICogc28gc29tZXRpbWVzIGl0IG1heSBub3QgYmUgYXZhaWxhYmxlLiBJZiB0aGUgcmVzb3VyY2VcbiAgICAgKiBpcyBiZWluZyBsb2FkZWQgb24gYSBtb2Rlcm4gYnJvd3NlciwgdXNpbmcgWEhSLCBhbmQgdGhlIHJlbW90ZSBzZXJ2ZXJcbiAgICAgKiBwcm9wZXJseSBzZXRzIENvbnRlbnQtTGVuZ3RoIGhlYWRlcnMsIHRoZW4gdGhpcyB3aWxsIGJlIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBldmVudCBwcm9ncmVzc1xuICAgICAqIEBtZW1iZXJvZiBSZXNvdXJjZSNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgb25jZSB0aGlzIHJlc291cmNlIGhhcyBsb2FkZWQsIGlmIHRoZXJlIHdhcyBhbiBlcnJvciBpdCB3aWxsXG4gICAgICogYmUgaW4gdGhlIGBlcnJvcmAgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY29tcGxldGVcbiAgICAgKiBAbWVtYmVyb2YgUmVzb3VyY2UjXG4gICAgICovXG59XG5cblJlc291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5SZXNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXNvdXJjZTtcbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2U7XG5cbi8qKlxuICogTWFya3MgdGhlIHJlc291cmNlIGFzIGNvbXBsZXRlLlxuICpcbiAqIEBmaXJlcyBjb21wbGV0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETzogQ2xlYW4gdGhpcyB1cCBpbiBhIHdyYXBwZXIgb3Igc29tZXRoaW5nLi4uZ3Jvc3MuLi4uXG4gICAgaWYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRhdGEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZE9uRXJyb3IpO1xuICAgICAgICB0aGlzLmRhdGEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2JvdW5kQ29tcGxldGUpO1xuICAgICAgICB0aGlzLmRhdGEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MpO1xuICAgICAgICB0aGlzLmRhdGEucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCB0aGlzLl9ib3VuZENvbXBsZXRlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy54aHIpIHtcbiAgICAgICAgaWYgKHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fYm91bmRYaHJPbkVycm9yKTtcbiAgICAgICAgICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgdGhpcy5fYm91bmRYaHJPbkFib3J0KTtcbiAgICAgICAgICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fYm91bmRPblByb2dyZXNzKTtcbiAgICAgICAgICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9ib3VuZFhock9uTG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnhoci5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnhoci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMueGhyLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2NvbXBsZXRlJywgdGhpcyk7XG59O1xuXG4vKipcbiAqIEtpY2tzIG9mZiBsb2FkaW5nIG9mIHRoaXMgcmVzb3VyY2UuXG4gKlxuICogQGZpcmVzIHN0YXJ0XG4gKiBAcGFyYW0gW2NhbGxiYWNrXSB7ZnVuY3Rpb259IE9wdGlvbmFsIGNhbGxiYWNrIHRvIGNhbGwgb25jZSB0aGUgcmVzb3VyY2UgaXMgbG9hZGVkLlxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHRoaXMuZW1pdCgnc3RhcnQnLCB0aGlzKTtcblxuICAgIC8vIGlmIGEgY2FsbGJhY2sgaXMgc2V0LCBsaXN0ZW4gZm9yIGNvbXBsZXRlIGV2ZW50XG4gICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMub25jZSgnY29tcGxldGUnLCBjYik7XG4gICAgfVxuXG4gICAgLy8gaWYgdW5zZXQsIGRldGVybWluZSB0aGUgdmFsdWVcbiAgICBpZiAodHlwZW9mIHRoaXMuY3Jvc3NPcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB0aGlzLl9kZXRlcm1pbmVDcm9zc09yaWdpbigpO1xuICAgIH1cblxuICAgIHN3aXRjaCh0aGlzLmxvYWRUeXBlKSB7XG4gICAgICAgIGNhc2UgUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFOlxuICAgICAgICAgICAgdGhpcy5fbG9hZEltYWdlKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJlc291cmNlLkxPQURfVFlQRS5BVURJTzpcbiAgICAgICAgICAgIHRoaXMuX2xvYWRFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSZXNvdXJjZS5MT0FEX1RZUEUuVklERU86XG4gICAgICAgICAgICB0aGlzLl9sb2FkRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUmVzb3VyY2UuTE9BRF9UWVBFLlhIUjpcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICh1c2VYZHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkWGRyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkWGhyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG4vKipcbiAqIExvYWRzIHRoaXMgcmVzb3VyY2VzIHVzaW5nIGFuIEltYWdlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX2xvYWRJbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRhdGEgPSBuZXcgSW1hZ2UoKTtcblxuICAgIGlmICh0aGlzLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuZGF0YS5jcm9zc09yaWdpbiA9ICcnO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YS5zcmMgPSB0aGlzLnVybDtcblxuICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX2JvdW5kT25FcnJvciwgZmFsc2UpO1xuICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fYm91bmRDb21wbGV0ZSwgZmFsc2UpO1xuICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHRoaXMuX2JvdW5kT25Qcm9ncmVzcywgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBMb2FkcyB0aGlzIHJlc291cmNlcyB1c2luZyBhbiBIVE1MQXVkaW9FbGVtZW50IG9yIEhUTUxWaWRlb0VsZW1lbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLl9sb2FkRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdGhpcy5kYXRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudXJsKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudXJsLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlU291cmNlKHR5cGUsIHRoaXMudXJsW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZGF0YS5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVTb3VyY2UodHlwZSwgdGhpcy51cmwpKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZE9uRXJyb3IsIGZhbHNlKTtcbiAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2JvdW5kQ29tcGxldGUsIGZhbHNlKTtcbiAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCB0aGlzLl9ib3VuZENvbXBsZXRlLCBmYWxzZSk7XG5cbiAgICB0aGlzLmRhdGEubG9hZCgpO1xufTtcblxuLyoqXG4gKiBMb2FkcyB0aGlzIHJlc291cmNlcyB1c2luZyBhbiBYTUxIdHRwUmVxdWVzdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX2xvYWRYaHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaWYgdW5zZXQsIGRldGVybWluZSB0aGUgdmFsdWVcbiAgICBpZiAodHlwZW9mIHRoaXMueGhyVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy54aHJUeXBlID0gdGhpcy5fZGV0ZXJtaW5lWGhyVHlwZSgpO1xuICAgIH1cblxuICAgIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gc2V0IHRoZSByZXF1ZXN0IHR5cGUgYW5kIHVybFxuICAgIHhoci5vcGVuKCdHRVQnLCB0aGlzLnVybCwgdHJ1ZSk7XG5cbiAgICAvLyBsb2FkIGpzb24gYXMgdGV4dCBhbmQgcGFyc2UgaXQgb3Vyc2VsdmVzLiBXZSBkbyB0aGlzIGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgIC8vICpjb3VnaCogc2FmYXJpICpjb3VnaCogY2FuJ3QgZGVhbCB3aXRoIGl0LlxuICAgIGlmICh0aGlzLnhoclR5cGUgPT09IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkpTT04gfHwgdGhpcy54aHJUeXBlID09PSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCkge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLnhoclR5cGU7XG4gICAgfVxuXG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fYm91bmRYaHJPbkVycm9yLCBmYWxzZSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgdGhpcy5fYm91bmRYaHJPbkFib3J0LCBmYWxzZSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fYm91bmRPblByb2dyZXNzLCBmYWxzZSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9ib3VuZFhock9uTG9hZCwgZmFsc2UpO1xuXG4gICAgeGhyLnNlbmQoKTtcbn07XG5cbi8qKlxuICogTG9hZHMgdGhpcyByZXNvdXJjZXMgdXNpbmcgYW4gWERvbWFpblJlcXVlc3QuIFRoaXMgaXMgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gc3VwcG9ydCBJRTkgKGdyb3NzKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX2xvYWRYZHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHhkciA9IHRoaXMueGhyID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG5cbiAgICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmZXcgcXVpcmtzLiBPY2Nhc2lvbmFsbHkgaXQgd2lsbCBhYm9ydCByZXF1ZXN0c1xuICAgIC8vIEEgd2F5IHRvIGF2b2lkIHRoaXMgaXMgdG8gbWFrZSBzdXJlIEFMTCBjYWxsYmFja3MgYXJlIHNldCBldmVuIGlmIG5vdCB1c2VkXG4gICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU3ODY5NjYveGRvbWFpbnJlcXVlc3QtYWJvcnRzLXBvc3Qtb24taWUtOVxuICAgIHhkci50aW1lb3V0ID0gNTAwMDtcblxuICAgIHhkci5vbmVycm9yID0gdGhpcy5fYm91bmRYaHJPbkVycm9yO1xuICAgIHhkci5vbnRpbWVvdXQgPSB0aGlzLl9ib3VuZFhkck9uVGltZW91dDtcbiAgICB4ZHIub25wcm9ncmVzcyA9IHRoaXMuX2JvdW5kT25Qcm9ncmVzcztcbiAgICB4ZHIub25sb2FkID0gdGhpcy5fYm91bmRYaHJPbkxvYWQ7XG5cbiAgICB4ZHIub3BlbignR0VUJywgdGhpcy51cmwsIHRydWUpO1xuXG4gICAgLy8gIE5vdGU6IFRoZSB4ZHIuc2VuZCgpIGNhbGwgaXMgd3JhcHBlZCBpbiBhIHRpbWVvdXQgdG8gcHJldmVudCBhbiBpc3N1ZSB3aXRoIHRoZSBpbnRlcmZhY2Ugd2hlcmUgc29tZSByZXF1ZXN0cyBhcmUgbG9zdFxuICAgIC8vICBpZiBtdWx0aXBsZSBYRG9tYWluUmVxdWVzdHMgYXJlIGJlaW5nIHNlbnQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAvLyBTb21lIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9pc3N1ZXMvMTI0OFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB4ZHIuc2VuZCgpO1xuICAgIH0sIDApO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc291cmNlIHVzZWQgaW4gbG9hZGluZyB2aWEgYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gdHlwZSB7c3RyaW5nfSBUaGUgZWxlbWVudCB0eXBlICh2aWRlbyBvciBhdWRpbykuXG4gKiBAcGFyYW0gdXJsIHtzdHJpbmd9IFRoZSBzb3VyY2UgVVJMIHRvIGxvYWQgZnJvbS5cbiAqIEBwYXJhbSBbbWltZV0ge3N0cmluZ30gVGhlIG1pbWUgdHlwZSBvZiB0aGUgdmlkZW9cbiAqIEBwcml2YXRlXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5fY3JlYXRlU291cmNlID0gZnVuY3Rpb24gKHR5cGUsIHVybCwgbWltZSkge1xuICAgIGlmICghbWltZSkge1xuICAgICAgICBtaW1lID0gdHlwZSArICcvJyArIHVybC5zdWJzdHIodXJsLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XG5cbiAgICBzb3VyY2Uuc3JjID0gdXJsO1xuICAgIHNvdXJjZS50eXBlID0gbWltZTtcblxuICAgIHJldHVybiBzb3VyY2U7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiBhIGxvYWQgZXJyb3JzIG91dC5cbiAqXG4gKiBAcGFyYW0gZXJyb3Ige0Vycm9yfSBUaGUgZXJyb3IgdGhhdCBoYXBwZW5lZC5cbiAqIEBwcml2YXRlXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5fb25FcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuZXJyb3IgPSBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGVsZW1lbnQgdXNpbmcgJyArIGV2ZW50LnRhcmdldC5ub2RlTmFtZSk7XG4gICAgdGhpcy5jb21wbGV0ZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgYSBsb2FkIHByb2dyZXNzIGV2ZW50IGZpcmVzIGZvciB4aHIveGRyLlxuICpcbiAqIEBmaXJlcyBwcm9ncmVzc1xuICogQHBhcmFtIGV2ZW50IHtYTUxIdHRwUmVxdWVzdFByb2dyZXNzRXZlbnR8RXZlbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5SZXNvdXJjZS5wcm90b3R5cGUuX29uUHJvZ3Jlc3MgPSAgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHRoaXMsIGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiBhbiBlcnJvciBldmVudCBmaXJlcyBmb3IgeGhyL3hkci5cbiAqXG4gKiBAcGFyYW0gZXZlbnQge1hNTEh0dHBSZXF1ZXN0RXJyb3JFdmVudHxFdmVudH1cbiAqIEBwcml2YXRlXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5feGhyT25FcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIHJlcVR5cGUoZXZlbnQudGFyZ2V0KSArICcgUmVxdWVzdCBmYWlsZWQuICcgK1xuICAgICAgICAnU3RhdHVzOiAnICsgZXZlbnQudGFyZ2V0LnN0YXR1cyArICcsIHRleHQ6IFwiJyArIGV2ZW50LnRhcmdldC5zdGF0dXNUZXh0ICsgJ1wiJ1xuICAgICk7XG5cbiAgICB0aGlzLmNvbXBsZXRlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiBhbiBhYm9ydCBldmVudCBmaXJlcyBmb3IgeGhyLlxuICpcbiAqIEBwYXJhbSBldmVudCB7WE1MSHR0cFJlcXVlc3RBYm9ydEV2ZW50fVxuICogQHByaXZhdGVcbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLl94aHJPbkFib3J0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5lcnJvciA9IG5ldyBFcnJvcihyZXFUeXBlKGV2ZW50LnRhcmdldCkgKyAnIFJlcXVlc3Qgd2FzIGFib3J0ZWQgYnkgdGhlIHVzZXIuJyk7XG4gICAgdGhpcy5jb21wbGV0ZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgYSB0aW1lb3V0IGV2ZW50IGZpcmVzIGZvciB4ZHIuXG4gKlxuICogQHBhcmFtIGV2ZW50IHtFdmVudH1cbiAqIEBwcml2YXRlXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5feGRyT25UaW1lb3V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5lcnJvciA9IG5ldyBFcnJvcihyZXFUeXBlKGV2ZW50LnRhcmdldCkgKyAnIFJlcXVlc3QgdGltZWQgb3V0LicpO1xuICAgIHRoaXMuY29tcGxldGUoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gZGF0YSBzdWNjZXNzZnVsbHkgbG9hZHMgZnJvbSBhbiB4aHIveGRyIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIGV2ZW50IHtYTUxIdHRwUmVxdWVzdExvYWRFdmVudHxFdmVudH1cbiAqIEBwcml2YXRlXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5feGhyT25Mb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHhociA9IGV2ZW50LnRhcmdldDtcblxuICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgLy8gaWYgdGV4dCwganVzdCByZXR1cm4gaXRcbiAgICAgICAgaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBqc29uLCBwYXJzZSBpbnRvIGpzb24gb2JqZWN0XG4gICAgICAgIGVsc2UgaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuSlNPTikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGxvYWRlZCBqc29uOicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHhtbCwgcGFyc2UgaW50byBhbiB4bWwgZG9jdW1lbnQgb3IgZGl2IGVsZW1lbnRcbiAgICAgICAgZWxzZSBpZiAodGhpcy54aHJUeXBlID09PSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LkRPTVBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkb21wYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhoci5yZXNwb25zZVRleHQsICd0ZXh0L3htbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGl2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgbG9hZGVkIHhtbDonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlciB0eXBlcyBqdXN0IHJldHVybiB0aGUgcmVzcG9uc2VcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgRXJyb3IoJ1snICsgeGhyLnN0YXR1cyArICddJyArIHhoci5zdGF0dXNUZXh0ICsgJzonICsgeGhyLnJlc3BvbnNlVVJMKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlKCk7XG59O1xuXG5mdW5jdGlvbiByZXFUeXBlKHhocikge1xuICAgIHJldHVybiB4aHIudG9TdHJpbmcoKS5yZXBsYWNlKCdvYmplY3QgJywgJycpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGBjcm9zc09yaWdpbmAgcHJvcGVydHkgZm9yIHRoaXMgcmVzb3VyY2UgYmFzZWQgb24gaWYgdGhlIHVybFxuICogZm9yIHRoaXMgcmVzb3VyY2UgaXMgY3Jvc3Mtb3JpZ2luLiBJZiBjcm9zc09yaWdpbiB3YXMgbWFudWFsbHkgc2V0LCB0aGlzXG4gKiBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNyb3NzT3JpZ2luIHZhbHVlIHRvIHVzZSAob3IgZW1wdHkgc3RyaW5nIGZvciBub25lKS5cbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLl9kZXRlcm1pbmVDcm9zc09yaWdpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBkYXRhOiBhbmQgamF2YXNjcmlwdDogdXJscyBhcmUgY29uc2lkZXJlZCBzYW1lLW9yaWdpblxuICAgIGlmICh0aGlzLnVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGEgY3Jvc3Mtb3JpZ2luIHVybFxuICAgIHZhciBsb2MgPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbiAgICBhLmhyZWYgPSB0aGlzLnVybDtcblxuICAgIC8vIGlmIGNyb3NzIG9yaWdpblxuICAgIGlmIChhLmhvc3RuYW1lICE9PSBsb2MuaG9zdG5hbWUgfHwgYS5wb3J0ICE9PSBsb2MucG9ydCB8fCBhLnByb3RvY29sICE9PSBsb2MucHJvdG9jb2wpIHtcbiAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMnO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgcmVzcG9uc2VUeXBlIG9mIGFuIFhIUiByZXF1ZXN0IGJhc2VkIG9uIHRoZSBleHRlbnNpb24gb2YgdGhlXG4gKiByZXNvdXJjZSBiZWluZyBsb2FkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge1Jlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFfSBUaGUgcmVzcG9uc2VUeXBlIHRvIHVzZS5cbiAqL1xuUmVzb3VyY2UucHJvdG90eXBlLl9kZXRlcm1pbmVYaHJUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHQgPSB0aGlzLnVybC5zdWJzdHIodGhpcy51cmwubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuXG4gICAgc3dpdGNoKGV4dCkge1xuICAgICAgICAvLyB4bWxcbiAgICAgICAgY2FzZSAneGh0bWwnOlxuICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgY2FzZSAnaHRtJzpcbiAgICAgICAgY2FzZSAneG1sJzpcbiAgICAgICAgY2FzZSAndG14JzpcbiAgICAgICAgY2FzZSAndHN4JzpcbiAgICAgICAgY2FzZSAnc3ZnJzpcbiAgICAgICAgICAgIHJldHVybiBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVDtcblxuICAgICAgICAvLyBpbWFnZXNcbiAgICAgICAgY2FzZSAnZ2lmJzpcbiAgICAgICAgY2FzZSAncG5nJzpcbiAgICAgICAgY2FzZSAnYm1wJzpcbiAgICAgICAgY2FzZSAnanBnJzpcbiAgICAgICAgY2FzZSAnanBlZyc6XG4gICAgICAgIGNhc2UgJ3RpZic6XG4gICAgICAgIGNhc2UgJ3RpZmYnOlxuICAgICAgICBjYXNlICd3ZWJwJzpcbiAgICAgICAgICAgIHJldHVybiBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CO1xuXG4gICAgICAgIC8vIGpzb25cbiAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICByZXR1cm4gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuSlNPTjtcblxuICAgICAgICAvLyB0ZXh0XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICBjYXNlICd0eHQnOlxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLlRFWFQ7XG4gICAgfVxufTtcblxuUmVzb3VyY2UucHJvdG90eXBlLl9kZXRlcm1pbmVMb2FkVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ID0gdGhpcy51cmwuc3Vic3RyKHRoaXMudXJsLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcblxuICAgIHN3aXRjaChleHQpIHtcbiAgICAgICAgLy8gaW1hZ2VzXG4gICAgICAgIGNhc2UgJ2dpZic6XG4gICAgICAgIGNhc2UgJ3BuZyc6XG4gICAgICAgIGNhc2UgJ2JtcCc6XG4gICAgICAgIGNhc2UgJ2pwZyc6XG4gICAgICAgIGNhc2UgJ2pwZWcnOlxuICAgICAgICBjYXNlICd0aWYnOlxuICAgICAgICBjYXNlICd0aWZmJzpcbiAgICAgICAgY2FzZSAnd2VicCc6XG4gICAgICAgICAgICByZXR1cm4gUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gUmVzb3VyY2UuTE9BRF9UWVBFLlhIUjtcbiAgICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG1pbWUgdHlwZSBvZiBhbiBYSFIgcmVxdWVzdCBiYXNlZCBvbiB0aGUgcmVzcG9uc2VUeXBlIG9mXG4gKiByZXNvdXJjZSBiZWluZyBsb2FkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG1pbWUgdHlwZSB0byB1c2UuXG4gKi9cblJlc291cmNlLnByb3RvdHlwZS5fZ2V0TWltZUZyb21YaHJUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICBjYXNlIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJVRkZFUjpcbiAgICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24vb2N0ZXQtYmluYXJ5JztcblxuICAgICAgICBjYXNlIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkJMT0I6XG4gICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL2Jsb2InO1xuXG4gICAgICAgIGNhc2UgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL3htbCc7XG5cbiAgICAgICAgY2FzZSBSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRS5KU09OOlxuICAgICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi9qc29uJztcblxuICAgICAgICBjYXNlIFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLkRFRkFVTFQ6XG4gICAgICAgIGNhc2UgUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVDpcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAndGV4dC9wbGFpbic7XG5cbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSB0eXBlcyBvZiBsb2FkaW5nIGEgcmVzb3VyY2UgY2FuIHVzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBMT0FEX1RZUEVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMT0FEX1RZUEUuWEhSIC0gVXNlcyBYTUxIdHRwUmVxdWVzdCB0byBsb2FkIHRoZSByZXNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMT0FEX1RZUEUuSU1BR0UgLSBVc2VzIGFuIGBJbWFnZWAgb2JqZWN0IHRvIGxvYWQgdGhlIHJlc291cmNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IExPQURfVFlQRS5BVURJTyAtIFVzZXMgYW4gYEF1ZGlvYCBvYmplY3QgdG8gbG9hZCB0aGUgcmVzb3VyY2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gTE9BRF9UWVBFLlZJREVPIC0gVXNlcyBhIGBWaWRlb2Agb2JqZWN0IHRvIGxvYWQgdGhlIHJlc291cmNlLlxuICovXG5SZXNvdXJjZS5MT0FEX1RZUEUgPSB7XG4gICAgWEhSOiAgICAxLFxuICAgIElNQUdFOiAgMixcbiAgICBBVURJTzogIDMsXG4gICAgVklERU86ICA0XG59O1xuXG4vKipcbiAqIFRoZSBYSFIgcmVhZHkgc3RhdGVzLCB1c2VkIGludGVybmFsbHkuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAcHJvcGVydHkge29iamVjdH0gWEhSX1JFQURZX1NUQVRFXG4gKiBAcHJvcGVydHkge251bWJlcn0gWEhSX1JFQURZX1NUQVRFLlVOU0VOVCAtIG9wZW4oKWhhcyBub3QgYmVlbiBjYWxsZWQgeWV0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFhIUl9SRUFEWV9TVEFURS5PUEVORUQgLSBzZW5kKCloYXMgbm90IGJlZW4gY2FsbGVkIHlldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBYSFJfUkVBRFlfU1RBVEUuSEVBREVSU19SRUNFSVZFRCAtIHNlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCBoZWFkZXJzIGFuZCBzdGF0dXMgYXJlIGF2YWlsYWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBYSFJfUkVBRFlfU1RBVEUuTE9BRElORyAtIERvd25sb2FkaW5nOyByZXNwb25zZVRleHQgaG9sZHMgcGFydGlhbCBkYXRhLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFhIUl9SRUFEWV9TVEFURS5ET05FIC0gVGhlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAqL1xuUmVzb3VyY2UuWEhSX1JFQURZX1NUQVRFID0ge1xuICAgIFVOU0VOVDogMCxcbiAgICBPUEVORUQ6IDEsXG4gICAgSEVBREVSU19SRUNFSVZFRDogMixcbiAgICBMT0FESU5HOiAzLFxuICAgIERPTkU6IDRcbn07XG5cbi8qKlxuICogVGhlIFhIUiByZWFkeSBzdGF0ZXMsIHVzZWQgaW50ZXJuYWxseS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBYSFJfUkVTUE9OU0VfVFlQRVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFhIUl9SRVNQT05TRV9UWVBFLkRFRkFVTFQgLSBkZWZhdWx0cyB0byB0ZXh0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSIC0gQXJyYXlCdWZmZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBYSFJfUkVTUE9OU0VfVFlQRS5CTE9CIC0gQmxvYlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5UIC0gRG9jdW1lbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBYSFJfUkVTUE9OU0VfVFlQRS5KU09OIC0gT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gWEhSX1JFU1BPTlNFX1RZUEUuVEVYVCAtIFN0cmluZ1xuICovXG5SZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRSA9IHtcbiAgICBERUZBVUxUOiAgICAndGV4dCcsXG4gICAgQlVGRkVSOiAgICAgJ2FycmF5YnVmZmVyJyxcbiAgICBCTE9COiAgICAgICAnYmxvYicsXG4gICAgRE9DVU1FTlQ6ICAgJ2RvY3VtZW50JyxcbiAgICBKU09OOiAgICAgICAnanNvbicsXG4gICAgVEVYVDogICAgICAgJ3RleHQnXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAvLyBwcml2YXRlIHByb3BlcnR5XG4gICAgX2tleVN0cjogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLFxuXG4gICAgZW5jb2RlQmluYXJ5OiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgICAgIHZhciBieXRlYnVmZmVyO1xuICAgICAgICB2YXIgZW5jb2RlZENoYXJJbmRleGVzID0gbmV3IEFycmF5KDQpO1xuICAgICAgICB2YXIgaW54ID0gMDtcbiAgICAgICAgdmFyIGpueCA9IDA7XG4gICAgICAgIHZhciBwYWRkaW5nQnl0ZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChpbnggPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEZpbGwgYnl0ZSBidWZmZXIgYXJyYXlcbiAgICAgICAgICAgIGJ5dGVidWZmZXIgPSBuZXcgQXJyYXkoMyk7XG4gICAgICAgICAgICBmb3IgKGpueCA9IDA7IGpueCA8IGJ5dGVidWZmZXIubGVuZ3RoOyBqbngrKykge1xuICAgICAgICAgICAgICAgIGlmIChpbnggPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgYXdheSBoaWdoLW9yZGVyIGJ5dGUsIGFzIGRvY3VtZW50ZWQgYXQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL0VuL1VzaW5nX1hNTEh0dHBSZXF1ZXN0I0hhbmRsaW5nX2JpbmFyeV9kYXRhXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVidWZmZXJbam54XSA9IGlucHV0LmNoYXJDb2RlQXQoaW54KyspICYgMHhmZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVidWZmZXJbam54XSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgZWFjaCBlbmNvZGVkIGNoYXJhY3RlciwgNiBiaXRzIGF0IGEgdGltZVxuICAgICAgICAgICAgLy8gaW5kZXggMTogZmlyc3QgNiBiaXRzXG4gICAgICAgICAgICBlbmNvZGVkQ2hhckluZGV4ZXNbMF0gPSBieXRlYnVmZmVyWzBdID4+IDI7XG4gICAgICAgICAgICAvLyBpbmRleCAyOiBzZWNvbmQgNiBiaXRzICgyIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgZnJvbSBpbnB1dCBieXRlIDEgKyA0IG1vc3Qgc2lnbmlmaWNhbnQgYml0cyBmcm9tIGJ5dGUgMilcbiAgICAgICAgICAgIGVuY29kZWRDaGFySW5kZXhlc1sxXSA9ICgoYnl0ZWJ1ZmZlclswXSAmIDB4MykgPDwgNCkgfCAoYnl0ZWJ1ZmZlclsxXSA+PiA0KTtcbiAgICAgICAgICAgIC8vIGluZGV4IDM6IHRoaXJkIDYgYml0cyAoNCBsZWFzdCBzaWduaWZpY2FudCBiaXRzIGZyb20gaW5wdXQgYnl0ZSAyICsgMiBtb3N0IHNpZ25pZmljYW50IGJpdHMgZnJvbSBieXRlIDMpXG4gICAgICAgICAgICBlbmNvZGVkQ2hhckluZGV4ZXNbMl0gPSAoKGJ5dGVidWZmZXJbMV0gJiAweDBmKSA8PCAyKSB8IChieXRlYnVmZmVyWzJdID4+IDYpO1xuICAgICAgICAgICAgLy8gaW5kZXggMzogZm9ydGggNiBiaXRzICg2IGxlYXN0IHNpZ25pZmljYW50IGJpdHMgZnJvbSBpbnB1dCBieXRlIDMpXG4gICAgICAgICAgICBlbmNvZGVkQ2hhckluZGV4ZXNbM10gPSBieXRlYnVmZmVyWzJdICYgMHgzZjtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgcGFkZGluZyBoYXBwZW5lZCwgYW5kIGFkanVzdCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgcGFkZGluZ0J5dGVzID0gaW54IC0gKGlucHV0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgc3dpdGNoIChwYWRkaW5nQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBsYXN0IDIgY2hhcmFjdGVycyB0byBwYWRkaW5nIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZENoYXJJbmRleGVzWzNdID0gNjQ7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWRDaGFySW5kZXhlc1syXSA9IDY0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGxhc3QgY2hhcmFjdGVyIHRvIHBhZGRpbmcgY2hhclxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVkQ2hhckluZGV4ZXNbM10gPSA2NDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gTm8gcGFkZGluZyAtIHByb2NlZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm93IHdlIHdpbGwgZ3JhYiBlYWNoIGFwcHJvcHJpYXRlIGNoYXJhY3RlciBvdXQgb2Ygb3VyIGtleXN0cmluZ1xuICAgICAgICAgICAgLy8gYmFzZWQgb24gb3VyIGluZGV4IGFycmF5IGFuZCBhcHBlbmQgaXQgdG8gdGhlIG91dHB1dCBzdHJpbmdcbiAgICAgICAgICAgIGZvciAoam54ID0gMDsgam54IDwgZW5jb2RlZENoYXJJbmRleGVzLmxlbmd0aDsgam54KyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gdGhpcy5fa2V5U3RyLmNoYXJBdChlbmNvZGVkQ2hhckluZGV4ZXNbam54XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL0xvYWRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cy5SZXNvdXJjZSA9IHJlcXVpcmUoJy4vUmVzb3VyY2UnKTtcblxubW9kdWxlLmV4cG9ydHMubWlkZGxld2FyZSA9IHtcbiAgICBjYWNoaW5nOiB7XG4gICAgICAgIG1lbW9yeTogcmVxdWlyZSgnLi9taWRkbGV3YXJlcy9jYWNoaW5nL21lbW9yeScpXG4gICAgfSxcbiAgICBwYXJzaW5nOiB7XG4gICAgICAgIGJsb2I6IHJlcXVpcmUoJy4vbWlkZGxld2FyZXMvcGFyc2luZy9ibG9iJylcbiAgICB9XG59O1xuIiwiLy8gYSBzaW1wbGUgaW4tbWVtb3J5IGNhY2hlIGZvciByZXNvdXJjZXNcbnZhciBjYWNoZSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlc291cmNlLCBuZXh0KSB7XG4gICAgICAgIC8vIGlmIGNhY2hlZCwgdGhlbiBzZXQgZGF0YSBhbmQgY29tcGxldGUgdGhlIHJlc291cmNlXG4gICAgICAgIGlmIChjYWNoZVtyZXNvdXJjZS51cmxdKSB7XG4gICAgICAgICAgICByZXNvdXJjZS5kYXRhID0gY2FjaGVbcmVzb3VyY2UudXJsXTtcbiAgICAgICAgICAgIHJlc291cmNlLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbm90IGNhY2hlZCwgd2FpdCBmb3IgY29tcGxldGUgYW5kIHN0b3JlIGl0IGluIHRoZSBjYWNoZS5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvdXJjZS5vbmNlKCdjb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgIGNhY2hlW3RoaXMudXJsXSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsInZhciBSZXNvdXJjZSA9IHJlcXVpcmUoJy4uLy4uL1Jlc291cmNlJyksXG4gICAgYjY0ID0gcmVxdWlyZSgnLi4vLi4vYjY0Jyk7XG5cbndpbmRvdy5VUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG5cbi8vIGEgbWlkZGxld2FyZSBmb3IgdHJhbnNmb3JtaW5nIFhIUiBsb2FkZWQgQmxvYnMgaW50byBtb3JlIHVzZWZ1bCBvYmplY3RzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVzb3VyY2UsIG5leHQpIHtcbiAgICAgICAgaWYgKCFyZXNvdXJjZS5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyB3YXMgYW4gWEhSIGxvYWQgb2YgYSBibG9iXG4gICAgICAgIGlmIChyZXNvdXJjZS54aHIgJiYgcmVzb3VyY2UueGhyVHlwZSA9PT0gUmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQikge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYmxvYiBzdXBwb3J0IHdlIHByb2JhYmx5IGdvdCBhIGJpbmFyeSBzdHJpbmcgYmFja1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuQmxvYiB8fCB0eXBlb2YgcmVzb3VyY2UuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHJlc291cmNlLnhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFuIGltYWdlLCBjb252ZXJ0IHRoZSBiaW5hcnkgc3RyaW5nIGludG8gYSBkYXRhIHVybFxuICAgICAgICAgICAgICAgIGlmICh0eXBlICYmIHR5cGUuaW5kZXhPZignaW1hZ2UnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5kYXRhID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmRhdGEuc3JjID0gJ2RhdGE6JyArIHR5cGUgKyAnO2Jhc2U2NCwnICsgYjY0LmVuY29kZUJpbmFyeShyZXNvdXJjZS54aHIucmVzcG9uc2VUZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY29udGVudCB0eXBlIHNheXMgdGhpcyBpcyBhbiBpbWFnZSwgdGhlbiB3ZSBzaG91bGQgdHJhbnNmb3JtIHRoZSBibG9iIGludG8gYW4gSW1hZ2Ugb2JqZWN0XG4gICAgICAgICAgICBlbHNlIGlmIChyZXNvdXJjZS5kYXRhLnR5cGUuaW5kZXhPZignaW1hZ2UnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHJlc291cmNlLmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgcmVzb3VyY2UuYmxvYiA9IHJlc291cmNlLmRhdGE7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UuZGF0YSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIHJlc291cmNlLmRhdGEuc3JjID0gc3JjO1xuXG4gICAgICAgICAgICAgICAgLy8gY2xlYW51cCB0aGUgbm8gbG9uZ2VyIHVzZWQgYmxvYiBhZnRlciB0aGUgaW1hZ2UgbG9hZHNcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5kYXRhLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChzcmMpO1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5kYXRhLm9ubG9hZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwicGl4aS5qc1wiLFxuICBcInZlcnNpb25cIjogXCIzLjAuMC1yYzRcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlBpeGkuanMgaXMgYSBmYXN0IGxpZ2h0d2VpZ2h0IDJEIGxpYnJhcnkgdGhhdCB3b3JrcyBhY3Jvc3MgYWxsIGRldmljZXMuXCIsXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJNYXQgR3JvdmVzXCJcbiAgfSxcbiAgXCJjb250cmlidXRvcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIkNoYWQgRW5nbGVyXCIsXG4gICAgICBcImVtYWlsXCI6IFwiY2hhZEBwYW50aGVyZGV2LmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJSaWNoYXJkIERhdmV5XCIsXG4gICAgICBcImVtYWlsXCI6IFwicmRhdmV5QGdtYWlsLmNvbVwiXG4gICAgfVxuICBdLFxuICBcIm1haW5cIjogXCIuL3NyYy9pbmRleC5qc1wiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cDovL2dvb2Rib3lkaWdpdGFsLmNvbS9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9Hb29kQm95RGlnaXRhbC9waXhpLmpzL2lzc3Vlc1wiXG4gIH0sXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL0dvb2RCb3lEaWdpdGFsL3BpeGkuanMuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJndWxwIHRlc3RcIixcbiAgICBcImRvY3NcIjogXCJqc2RvYyAtYyAuL2d1bHAvdXRpbC9qc2RvYy5jb25mLmpzb24gLVIgUkVBRE1FLm1kXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYXN5bmNcIjogXCJeMC45LjBcIixcbiAgICBcImJyZnNcIjogXCJeMS4yLjBcIixcbiAgICBcImV2ZW50ZW1pdHRlcjNcIjogXCJeMC4xLjZcIixcbiAgICBcIm9iamVjdC1hc3NpZ25cIjogXCJeMi4wLjBcIixcbiAgICBcInJlc291cmNlLWxvYWRlclwiOiBcIl4xLjMuMlwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeOC4wLjJcIixcbiAgICBcImNoYWlcIjogXCJeMS4xMC4wXCIsXG4gICAgXCJkZWxcIjogXCJeMS4xLjBcIixcbiAgICBcImd1bHBcIjogXCJeMy44LjEwXCIsXG4gICAgXCJndWxwLWNhY2hlZFwiOiBcIl4xLjAuMVwiLFxuICAgIFwiZ3VscC1jb25jYXRcIjogXCJeMi41LjJcIixcbiAgICBcImd1bHAtZGVidWdcIjogXCJeMi4wLjBcIixcbiAgICBcImd1bHAtanNoaW50XCI6IFwiXjEuOS4wXCIsXG4gICAgXCJndWxwLW1pcnJvclwiOiBcIl4wLjQuMFwiLFxuICAgIFwiZ3VscC1wbHVtYmVyXCI6IFwiXjAuNi42XCIsXG4gICAgXCJndWxwLXJlbmFtZVwiOiBcIl4xLjIuMFwiLFxuICAgIFwiZ3VscC1zb3VyY2VtYXBzXCI6IFwiXjEuNS4wXCIsXG4gICAgXCJndWxwLXVnbGlmeVwiOiBcIl4xLjAuMlwiLFxuICAgIFwiZ3VscC11dGlsXCI6IFwiXjMuMC4xXCIsXG4gICAgXCJpbmstZG9jc3RyYXBcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL1BpbGF0Y2gvZG9jc3RyYXAuZ2l0XCIsXG4gICAgXCJqc2RvY1wiOiBcIl4zLjMuMC1hbHBoYTEzXCIsXG4gICAgXCJqc2hpbnQtc3VtbWFyeVwiOiBcIl4wLjQuMFwiLFxuICAgIFwia2FybWFcIjogXCJeMC4xMi4yOFwiLFxuICAgIFwia2FybWEtZmlyZWZveC1sYXVuY2hlclwiOiBcIl4wLjEuMFwiLFxuICAgIFwia2FybWEtbW9jaGFcIjogXCJeMC4xLjEwXCIsXG4gICAgXCJrYXJtYS1zcGVjLXJlcG9ydGVyXCI6IFwiXjAuMC4xNlwiLFxuICAgIFwibWluaW1pc3RcIjogXCJeMS4xLjBcIixcbiAgICBcIm1vY2hhXCI6IFwiXjIuMS4wXCIsXG4gICAgXCJyZXF1aXJlLWRpclwiOiBcIl4wLjEuMFwiLFxuICAgIFwicnVuLXNlcXVlbmNlXCI6IFwiXjEuMC4yXCIsXG4gICAgXCJ2aW55bC1idWZmZXJcIjogXCJeMS4wLjBcIixcbiAgICBcInZpbnlsLXNvdXJjZS1zdHJlYW1cIjogXCJeMS4wLjBcIixcbiAgICBcIndhdGNoaWZ5XCI6IFwiXjIuMi4xXCJcbiAgfSxcbiAgXCJicm93c2VyaWZ5XCI6IHtcbiAgICBcInRyYW5zZm9ybVwiOiBbXG4gICAgICBcImJyZnNcIlxuICAgIF1cbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiMzRjOGRiMGVjZjgwODliNjFmYTQ5MmY2M2YzM2RlNjA1ZTU1N2ViOVwiLFxuICBcIl9pZFwiOiBcInBpeGkuanNAMy4wLjAtcmM0XCIsXG4gIFwiX3NoYXN1bVwiOiBcImFkZDUxNzQ5Y2QxNjYyMDIwZTc2NzAyMjg1YzU5NzViMTgyMTEwZDJcIixcbiAgXCJfZnJvbVwiOiBcInBpeGkuanNAPj0zLjAuMC1yYzQgPDQuMC4wXCIsXG4gIFwiX25wbVZlcnNpb25cIjogXCIxLjQuMjNcIixcbiAgXCJfbnBtVXNlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiZW5nbGVyY2pcIixcbiAgICBcImVtYWlsXCI6IFwiZW5nbGVyY2pAbGl2ZS5jb21cIlxuICB9LFxuICBcIm1haW50YWluZXJzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJlbmdsZXJjalwiLFxuICAgICAgXCJlbWFpbFwiOiBcImVuZ2xlcmNqQGxpdmUuY29tXCJcbiAgICB9XG4gIF0sXG4gIFwiZGlzdFwiOiB7XG4gICAgXCJzaGFzdW1cIjogXCJhZGQ1MTc0OWNkMTY2MjAyMGU3NjcwMjI4NWM1OTc1YjE4MjExMGQyXCIsXG4gICAgXCJ0YXJiYWxsXCI6IFwiaHR0cDovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9waXhpLmpzLy0vcGl4aS5qcy0zLjAuMC1yYzQudGd6XCJcbiAgfSxcbiAgXCJkaXJlY3Rvcmllc1wiOiB7fSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9waXhpLmpzLy0vcGl4aS5qcy0zLjAuMC1yYzQudGd6XCIsXG4gIFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiXG59XG4iLCIvKipcbiAqIENvbnN0YW50IHZhbHVlcyB1c2VkIGluIHBpeGlcbiAqXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBTdHJpbmcgb2YgdGhlIGN1cnJlbnQgUElYSSB2ZXJzaW9uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFZFUlNJT05cbiAgICAgKi9cbiAgICBWRVJTSU9OOiByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFBJXzIgLSBUd28gUGlcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgUElfMjogTWF0aC5QSSAqIDIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gUkFEX1RPX0RFRyAtIENvbnN0YW50IGNvbnZlcnNpb24gZmFjdG9yIGZvciBjb252ZXJ0aW5nIHJhZGlhbnMgdG8gZGVncmVlc1xuICAgICAqIEBjb25zdGFudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBSQURfVE9fREVHOiAxODAgLyBNYXRoLlBJLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IERFR19UT19SQUQgLSBDb25zdGFudCBjb252ZXJzaW9uIGZhY3RvciBmb3IgY29udmVydGluZyBkZWdyZWVzIHRvIHJhZGlhbnNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgREVHX1RPX1JBRDogTWF0aC5QSSAvIDE4MCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IHRvIGlkZW50aWZ5IHRoZSBSZW5kZXJlciBUeXBlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBjb25zdGFudFxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBSRU5ERVJFUl9UWVBFXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFJFTkRFUkVSX1RZUEUuVU5LTk9XTlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSRU5ERVJFUl9UWVBFLldFQkdMXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFJFTkRFUkVSX1RZUEUuQ0FOVkFTXG4gICAgICovXG4gICAgUkVOREVSRVJfVFlQRToge1xuICAgICAgICBVTktOT1dOOiAgICAwLFxuICAgICAgICBXRUJHTDogICAgICAxLFxuICAgICAgICBDQU5WQVM6ICAgICAyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFZhcmlvdXMgYmxlbmQgbW9kZXMgc3VwcG9ydGVkIGJ5IFBJWEkuIElNUE9SVEFOVCAtIFRoZSBXZWJHTCByZW5kZXJlciBvbmx5IHN1cHBvcnRzXG4gICAgICogdGhlIE5PUk1BTCwgQURELCBNVUxUSVBMWSBhbmQgU0NSRUVOIGJsZW5kIG1vZGVzLiBBbnl0aGluZyBlbHNlIHdpbGwgc2lsZW50bHkgYWN0IGxpa2VcbiAgICAgKiBOT1JNQUwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IEJMRU5EX01PREVTXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLk5PUk1BTFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCTEVORF9NT0RFUy5BRERcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuTVVMVElQTFlcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuU0NSRUVOXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLk9WRVJMQVlcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuREFSS0VOXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLkxJR0hURU5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuQ09MT1JfRE9ER0VcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuQ09MT1JfQlVSTlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCTEVORF9NT0RFUy5IQVJEX0xJR0hUXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLlNPRlRfTElHSFRcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuRElGRkVSRU5DRVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCTEVORF9NT0RFUy5FWENMVVNJT05cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuSFVFXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJMRU5EX01PREVTLlNBVFVSQVRJT05cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuQ09MT1JcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkxFTkRfTU9ERVMuTFVNSU5PU0lUWVxuICAgICAqL1xuICAgIEJMRU5EX01PREVTOiB7XG4gICAgICAgIE5PUk1BTDogICAgICAgICAwLFxuICAgICAgICBBREQ6ICAgICAgICAgICAgMSxcbiAgICAgICAgTVVMVElQTFk6ICAgICAgIDIsXG4gICAgICAgIFNDUkVFTjogICAgICAgICAzLFxuICAgICAgICBPVkVSTEFZOiAgICAgICAgNCxcbiAgICAgICAgREFSS0VOOiAgICAgICAgIDUsXG4gICAgICAgIExJR0hURU46ICAgICAgICA2LFxuICAgICAgICBDT0xPUl9ET0RHRTogICAgNyxcbiAgICAgICAgQ09MT1JfQlVSTjogICAgIDgsXG4gICAgICAgIEhBUkRfTElHSFQ6ICAgICA5LFxuICAgICAgICBTT0ZUX0xJR0hUOiAgICAgMTAsXG4gICAgICAgIERJRkZFUkVOQ0U6ICAgICAxMSxcbiAgICAgICAgRVhDTFVTSU9OOiAgICAgIDEyLFxuICAgICAgICBIVUU6ICAgICAgICAgICAgMTMsXG4gICAgICAgIFNBVFVSQVRJT046ICAgICAxNCxcbiAgICAgICAgQ09MT1I6ICAgICAgICAgIDE1LFxuICAgICAgICBMVU1JTk9TSVRZOiAgICAgMTZcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNjYWxlIG1vZGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBieSBwaXhpLlxuICAgICAqXG4gICAgICogVGhlIERFRkFVTFQgc2NhbGUgbW9kZSBhZmZlY3RzIHRoZSBkZWZhdWx0IHNjYWxpbmcgbW9kZSBvZiBmdXR1cmUgb3BlcmF0aW9ucy5cbiAgICAgKiBJdCBjYW4gYmUgcmUtYXNzaWduZWQgdG8gZWl0aGVyIExJTkVBUiBvciBORUFSRVNULCBkZXBlbmRpbmcgdXBvbiBzdWl0YWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gU0NBTEVfTU9ERVNcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gU0NBTEVfTU9ERVMuREVGQVVMVD1MSU5FQVJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gU0NBTEVfTU9ERVMuTElORUFSIFNtb290aCBzY2FsaW5nXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNDQUxFX01PREVTLk5FQVJFU1QgUGl4ZWxhdGluZyBzY2FsaW5nXG4gICAgICovXG4gICAgU0NBTEVfTU9ERVM6IHtcbiAgICAgICAgREVGQVVMVDogICAgMCxcbiAgICAgICAgTElORUFSOiAgICAgMCxcbiAgICAgICAgTkVBUkVTVDogICAgMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlZml4IHRoYXQgZGVub3RlcyBhIFVSTCBpcyBmb3IgYSByZXRpbmEgYXNzZXRcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gUkVUSU5BX1BSRUZJWFxuICAgICAqL1xuICAgIC8vZXhhbXBsZTogJ0AyeCcsXG4gICAgUkVUSU5BX1BSRUZJWDogL0AoLispeC8sXG5cbiAgICBSRVNPTFVUSU9OOjEsXG5cbiAgICBGSUxURVJfUkVTT0xVVElPTjoxLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgcmVuZGVyIG9wdGlvbnMgaWYgbm9uZSBhcmUgc3VwcGxpZWQgdG8ge0BsaW5rIFBJWEkuV2ViR0xSZW5kZXJlcn1cbiAgICAgKiBvciB7QGxpbmsgUElYSS5DYW52YXNSZW5kZXJlcn0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IERFRkFVTFRfUkVOREVSX09QVElPTlNcbiAgICAgKiBAcHJvcGVydHkge0hUTUxDYW52YXNFbGVtZW50fSBERUZBVUxUX1JFTkRFUl9PUFRJT05TLnZpZXc9bnVsbFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gREVGQVVMVF9SRU5ERVJfT1BUSU9OUy50cmFuc3BhcmVudD1mYWxzZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gREVGQVVMVF9SRU5ERVJfT1BUSU9OUy5hbnRpYWxpYXM9ZmFsc2VcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IERFRkFVTFRfUkVOREVSX09QVElPTlMuZm9yY2VGWEFBPWZhbHNlXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBERUZBVUxUX1JFTkRFUl9PUFRJT05TLnByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBERUZBVUxUX1JFTkRFUl9PUFRJT05TLnJlc29sdXRpb249MVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBERUZBVUxUX1JFTkRFUl9PUFRJT05TLmJhY2tncm91bmRDb2xvcj0weDAwMDAwMFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gREVGQVVMVF9SRU5ERVJfT1BUSU9OUy5jbGVhckJlZm9yZVJlbmRlcj10cnVlXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBERUZBVUxUX1JFTkRFUl9PUFRJT05TLmF1dG9SZXNpemU9ZmFsc2VcbiAgICAgKi9cbiAgICBERUZBVUxUX1JFTkRFUl9PUFRJT05TOiB7XG4gICAgICAgIHZpZXc6IG51bGwsXG4gICAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgIGZvcmNlRlhBQTogZmFsc2UsXG4gICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxuICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogMHgwMDAwMDAsXG4gICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50cyB0aGF0IGlkZW50aWZ5IHNoYXBlcywgbWFpbmx5IHRvIHByZXZlbnQgYGluc3RhbmNlb2ZgIGNhbGxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBjb25zdGFudFxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBTSEFQRVNcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gU0hBUEVTLlBPTFk9MFxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBTSEFQRVMuUkVDVD0xXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFNIQVBFUy5DSVJDPTJcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gU0hBUEVTLkVMSVA9M1xuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBTSEFQRVMuUlJFQz00XG4gICAgICovXG4gICAgU0hBUEVTOiB7XG4gICAgICAgIFBPTFk6IDAsXG4gICAgICAgIFJFQ1Q6IDEsXG4gICAgICAgIENJUkM6IDIsXG4gICAgICAgIEVMSVA6IDMsXG4gICAgICAgIFJSRUM6IDRcbiAgICB9LFxuXG4gICAgU1BSSVRFX0JBVENIX1NJWkU6IDIwMDAgLy9uaWNlIGJhbGFuY2UgYmV0d2VlbiBtb2JpbGUgYW5kIGRlc2t0b3AgbWFjaGluZXNcbn07XG4iLCJ2YXIgbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKSxcbiAgICBEaXNwbGF5T2JqZWN0ID0gcmVxdWlyZSgnLi9EaXNwbGF5T2JqZWN0JyksXG4gICAgUmVuZGVyVGV4dHVyZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL1JlbmRlclRleHR1cmUnKSxcbiAgICBfdGVtcE1hdHJpeCA9IG5ldyBtYXRoLk1hdHJpeCgpO1xuXG4vKipcbiAqIEEgQ29udGFpbmVyIHJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIGRpc3BsYXkgb2JqZWN0cy5cbiAqIEl0IGlzIHRoZSBiYXNlIGNsYXNzIG9mIGFsbCBkaXNwbGF5IG9iamVjdHMgdGhhdCBhY3QgYXMgYSBjb250YWluZXIgZm9yIG90aGVyIG9iamVjdHMuXG4gKlxuICpgYGBqc1xuICogdmFyIGNvbnRhaW5lciA9IG5ldyBQSVhJLkNvbnRhaW5lcigpO1xuICogY29udGFpbmVyLmFkZENoaWxkKHNwcml0ZSk7XG4gKiBgYGBcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xuZnVuY3Rpb24gQ29udGFpbmVyKClcbntcbiAgICBEaXNwbGF5T2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgb2YgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtEaXNwbGF5T2JqZWN0W119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xufVxuXG4vLyBjb25zdHJ1Y3RvclxuQ29udGFpbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRGlzcGxheU9iamVjdC5wcm90b3R5cGUpO1xuQ29udGFpbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhaW5lcjtcbm1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb250YWluZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIENvbnRhaW5lciNcbiAgICAgKi9cbiAgICB3aWR0aDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlLnggKiB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS53aWR0aDtcblxuICAgICAgICAgICAgaWYgKHdpZHRoICE9PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUueCA9IHZhbHVlIC8gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gMTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIENvbnRhaW5lciwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgQ29udGFpbmVyI1xuICAgICAqL1xuICAgIGhlaWdodDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAgdGhpcy5zY2FsZS55ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcblxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChoZWlnaHQgIT09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZS55ID0gdmFsdWUgLyBoZWlnaHQgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogQWRkcyBhIGNoaWxkIHRvIHRoZSBjb250YWluZXIuXG4gKlxuICogQHBhcmFtIGNoaWxkIHtEaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCB0byBhZGQgdG8gdGhlIGNvbnRhaW5lclxuICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRoYXQgd2FzIGFkZGVkLlxuICovXG5Db250YWluZXIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKVxue1xuICAgIHJldHVybiB0aGlzLmFkZENoaWxkQXQoY2hpbGQsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGNoaWxkIHRvIHRoZSBjb250YWluZXIgYXQgYSBzcGVjaWZpZWQgaW5kZXguIElmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKlxuICogQHBhcmFtIGNoaWxkIHtEaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdG8gYWRkXG4gKiBAcGFyYW0gaW5kZXgge051bWJlcn0gVGhlIGluZGV4IHRvIHBsYWNlIHRoZSBjaGlsZCBpblxuICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRoYXQgd2FzIGFkZGVkLlxuICovXG5Db250YWluZXIucHJvdG90eXBlLmFkZENoaWxkQXQgPSBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KVxue1xuICAgIC8vIHByZXZlbnQgYWRkaW5nIHNlbGYgYXMgY2hpbGRcbiAgICBpZiAoY2hpbGQgPT09IHRoaXMpXG4gICAge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAge1xuICAgICAgICBpZiAoY2hpbGQucGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjaGlsZCArICdhZGRDaGlsZEF0OiBUaGUgaW5kZXggJysgaW5kZXggKycgc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAnICsgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU3dhcHMgdGhlIHBvc2l0aW9uIG9mIDIgRGlzcGxheSBPYmplY3RzIHdpdGhpbiB0aGlzIGNvbnRhaW5lci5cbiAqXG4gKiBAcGFyYW0gY2hpbGQge0Rpc3BsYXlPYmplY3R9XG4gKiBAcGFyYW0gY2hpbGQyIHtEaXNwbGF5T2JqZWN0fVxuICovXG5Db250YWluZXIucHJvdG90eXBlLnN3YXBDaGlsZHJlbiA9IGZ1bmN0aW9uIChjaGlsZCwgY2hpbGQyKVxue1xuICAgIGlmIChjaGlsZCA9PT0gY2hpbGQyKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbmRleDEgPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgIHZhciBpbmRleDIgPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQyKTtcblxuICAgIGlmIChpbmRleDEgPCAwIHx8IGluZGV4MiA8IDApXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N3YXBDaGlsZHJlbjogQm90aCB0aGUgc3VwcGxpZWQgRGlzcGxheU9iamVjdHMgbXVzdCBiZSBjaGlsZHJlbiBvZiB0aGUgY2FsbGVyLicpO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW5baW5kZXgxXSA9IGNoaWxkMjtcbiAgICB0aGlzLmNoaWxkcmVuW2luZGV4Ml0gPSBjaGlsZDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggcG9zaXRpb24gb2YgYSBjaGlsZCBEaXNwbGF5T2JqZWN0IGluc3RhbmNlXG4gKlxuICogQHBhcmFtIGNoaWxkIHtEaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZSB0byBpZGVudGlmeVxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggcG9zaXRpb24gb2YgdGhlIGNoaWxkIGRpc3BsYXkgb2JqZWN0IHRvIGlkZW50aWZ5XG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uIChjaGlsZClcbntcbiAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1cHBsaWVkIERpc3BsYXlPYmplY3QgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBjYWxsZXInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIGFuIGV4aXN0aW5nIGNoaWxkIGluIHRoZSBkaXNwbGF5IG9iamVjdCBjb250YWluZXJcbiAqXG4gKiBAcGFyYW0gY2hpbGQge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCBEaXNwbGF5T2JqZWN0IGluc3RhbmNlIGZvciB3aGljaCB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIGluZGV4IG51bWJlclxuICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9IFRoZSByZXN1bHRpbmcgaW5kZXggbnVtYmVyIGZvciB0aGUgY2hpbGQgZGlzcGxheSBvYmplY3RcbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5zZXRDaGlsZEluZGV4ID0gZnVuY3Rpb24gKGNoaWxkLCBpbmRleClcbntcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3VwcGxpZWQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuXG4gICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoY3VycmVudEluZGV4LCAxKTsgLy9yZW1vdmUgZnJvbSBvbGQgcG9zaXRpb25cbiAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpOyAvL2FkZCBhdCBuZXcgcG9zaXRpb25cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICpcbiAqIEBwYXJhbSBpbmRleCB7TnVtYmVyfSBUaGUgaW5kZXggdG8gZ2V0IHRoZSBjaGlsZCBhdFxuICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgYW55LlxuICovXG5Db250YWluZXIucHJvdG90eXBlLmdldENoaWxkQXQgPSBmdW5jdGlvbiAoaW5kZXgpXG57XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0Q2hpbGRBdDogU3VwcGxpZWQgaW5kZXggJyArIGluZGV4ICsgJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2hpbGQgbGlzdCwgb3IgdGhlIHN1cHBsaWVkIERpc3BsYXlPYmplY3QgaXMgbm90IGEgY2hpbGQgb2YgdGhlIGNhbGxlcicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2luZGV4XTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGNoaWxkIGZyb20gdGhlIGNvbnRhaW5lci5cbiAqXG4gKiBAcGFyYW0gY2hpbGQge0Rpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IHRvIHJlbW92ZVxuICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpXG57XG4gICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQ2hpbGRBdChpbmRleCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjaGlsZCBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXggcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9IFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGZyb21cbiAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyByZW1vdmVkLlxuICovXG5Db250YWluZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkQXQgPSBmdW5jdGlvbiAoaW5kZXgpXG57XG4gICAgdmFyIGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KGluZGV4KTtcblxuICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgY29udGFpbmVyIHRoYXQgYXJlIHdpdGhpbiB0aGUgYmVnaW4gYW5kIGVuZCBpbmRleGVzLlxuICpcbiAqIEBwYXJhbSBiZWdpbkluZGV4IHtOdW1iZXJ9IFRoZSBiZWdpbm5pbmcgcG9zaXRpb24uIERlZmF1bHQgdmFsdWUgaXMgMC5cbiAqIEBwYXJhbSBlbmRJbmRleCB7TnVtYmVyfSBUaGUgZW5kaW5nIHBvc2l0aW9uLiBEZWZhdWx0IHZhbHVlIGlzIHNpemUgb2YgdGhlIGNvbnRhaW5lci5cbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uIChiZWdpbkluZGV4LCBlbmRJbmRleClcbntcbiAgICB2YXIgYmVnaW4gPSBiZWdpbkluZGV4IHx8IDA7XG4gICAgdmFyIGVuZCA9IHR5cGVvZiBlbmRJbmRleCA9PT0gJ251bWJlcicgPyBlbmRJbmRleCA6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciByYW5nZSA9IGVuZCAtIGJlZ2luO1xuXG4gICAgaWYgKHJhbmdlID4gMCAmJiByYW5nZSA8PSBlbmQpXG4gICAge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuY2hpbGRyZW4uc3BsaWNlKGJlZ2luLCByYW5nZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW1vdmVkW2ldLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuZ2UgPT09IDAgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdyZW1vdmVDaGlsZHJlbjogbnVtZXJpYyB2YWx1ZXMgYXJlIG91dHNpZGUgdGhlIGFjY2VwdGFibGUgcmFuZ2UuJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBVc2VmdWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdGV4dHVyZSBvZiB0aGUgZGlzcGxheSBvYmplY3QgdGhhdCBjYW4gdGhlbiBiZSB1c2VkIHRvIGNyZWF0ZSBzcHJpdGVzXG4gKiBUaGlzIGNhbiBiZSBxdWl0ZSB1c2VmdWwgaWYgeW91ciBkaXNwbGF5T2JqZWN0IGlzIHN0YXRpYyAvIGNvbXBsaWNhdGVkIGFuZCBuZWVkcyB0byBiZSByZXVzZWQgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogQHBhcmFtIHJlbmRlcmVyIHtDYW52YXNSZW5kZXJlcnxXZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGV4dHVyZS5cbiAqIEBwYXJhbSByZXNvbHV0aW9uIHtOdW1iZXJ9IFRoZSByZXNvbHV0aW9uIG9mIHRoZSB0ZXh0dXJlIGJlaW5nIGdlbmVyYXRlZFxuICogQHBhcmFtIHNjYWxlTW9kZSB7TnVtYmVyfSBTZWUge0BsaW5rIFNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcmV0dXJuIHtUZXh0dXJlfSBhIHRleHR1cmUgb2YgdGhlIGRpc3BsYXkgb2JqZWN0XG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUuZ2VuZXJhdGVUZXh0dXJlID0gZnVuY3Rpb24gKHJlbmRlcmVyLCByZXNvbHV0aW9uLCBzY2FsZU1vZGUpXG57XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcblxuICAgIHZhciByZW5kZXJUZXh0dXJlID0gbmV3IFJlbmRlclRleHR1cmUocmVuZGVyZXIsIGJvdW5kcy53aWR0aCB8IDAsIGJvdW5kcy5oZWlnaHQgfCAwLCByZW5kZXJlciwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKTtcblxuICAgIF90ZW1wTWF0cml4LnR4ID0gLWJvdW5kcy54O1xuICAgIF90ZW1wTWF0cml4LnR5ID0gLWJvdW5kcy55O1xuXG4gICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcywgX3RlbXBNYXRyaXgpO1xuXG4gICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XG59O1xuXG4vKlxuICogVXBkYXRlcyB0aGUgdHJhbnNmb3JtIG9uIGFsbCBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciBmb3IgcmVuZGVyaW5nXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICghdGhpcy52aXNpYmxlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcbiAgICB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0udXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfVxufTtcblxuLy8gcGVyZm9ybWFuY2UgaW5jcmVhc2UgdG8gYXZvaWQgdXNpbmcgY2FsbC4uICgxMHggZmFzdGVyKVxuQ29udGFpbmVyLnByb3RvdHlwZS5jb250YWluZXJVcGRhdGVUcmFuc2Zvcm0gPSBDb250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgQ29udGFpbmVyIGFzIGEgcmVjdGFuZ2xlLiBUaGUgYm91bmRzIGNhbGN1bGF0aW9uIHRha2VzIGFsbCB2aXNpYmxlIGNoaWxkcmVuIGludG8gY29uc2lkZXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZighdGhpcy5fY3VycmVudEJvdW5kcylcbiAgICB7XG5cbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5SZWN0YW5nbGUuRU1QVFk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPIHRoZSBib3VuZHMgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsY3VsYXRlZCB0aGlzIHJlbmRlciBzZXNzaW9uIHNvIHJldHVybiB3aGF0IHdlIGhhdmVcblxuICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuXG4gICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgICAgICB2YXIgY2hpbGRCb3VuZHM7XG4gICAgICAgIHZhciBjaGlsZE1heFg7XG4gICAgICAgIHZhciBjaGlsZE1heFk7XG5cbiAgICAgICAgdmFyIGNoaWxkVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgIGlmICghY2hpbGQudmlzaWJsZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGRWaXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgY2hpbGRCb3VuZHMgPSB0aGlzLmNoaWxkcmVuW2ldLmdldEJvdW5kcygpO1xuXG4gICAgICAgICAgICBtaW5YID0gbWluWCA8IGNoaWxkQm91bmRzLnggPyBtaW5YIDogY2hpbGRCb3VuZHMueDtcbiAgICAgICAgICAgIG1pblkgPSBtaW5ZIDwgY2hpbGRCb3VuZHMueSA/IG1pblkgOiBjaGlsZEJvdW5kcy55O1xuXG4gICAgICAgICAgICBjaGlsZE1heFggPSBjaGlsZEJvdW5kcy53aWR0aCArIGNoaWxkQm91bmRzLng7XG4gICAgICAgICAgICBjaGlsZE1heFkgPSBjaGlsZEJvdW5kcy5oZWlnaHQgKyBjaGlsZEJvdW5kcy55O1xuXG4gICAgICAgICAgICBtYXhYID0gbWF4WCA+IGNoaWxkTWF4WCA/IG1heFggOiBjaGlsZE1heFg7XG4gICAgICAgICAgICBtYXhZID0gbWF4WSA+IGNoaWxkTWF4WSA/IG1heFkgOiBjaGlsZE1heFk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoaWxkVmlzaWJsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGguUmVjdGFuZ2xlLkVNUFRZO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcblxuICAgICAgICBib3VuZHMueCA9IG1pblg7XG4gICAgICAgIGJvdW5kcy55ID0gbWluWTtcbiAgICAgICAgYm91bmRzLndpZHRoID0gbWF4WCAtIG1pblg7XG4gICAgICAgIGJvdW5kcy5oZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgICAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gYm91bmRzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qm91bmRzO1xufTtcblxuQ29udGFpbmVyLnByb3RvdHlwZS5jb250YWluZXJHZXRCb3VuZHMgPSBDb250YWluZXIucHJvdG90eXBlLmdldEJvdW5kcztcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIG5vbi1nbG9iYWwgbG9jYWwgYm91bmRzIG9mIHRoZSBDb250YWluZXIgYXMgYSByZWN0YW5nbGUuXG4gKiBUaGUgY2FsY3VsYXRpb24gdGFrZXMgYWxsIHZpc2libGUgY2hpbGRyZW4gaW50byBjb25zaWRlcmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWFcbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIG1hdHJpeENhY2hlID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBtYXRoLk1hdHJpeC5JREVOVElUWTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpXG4gICAge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIH1cblxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBtYXRyaXhDYWNoZTtcblxuICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBudWxsO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCk7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1dlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlclxuICovXG5Db250YWluZXIucHJvdG90eXBlLnJlbmRlcldlYkdMID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuXG4gICAgLy8gaWYgdGhlIG9iamVjdCBpcyBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXMgZWxlbWVudFxuICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGksIGo7XG5cbiAgICAvLyBkbyBhIHF1aWNrIGNoZWNrIHRvIHNlZSBpZiB0aGlzIGVsZW1lbnQgaGFzIGEgbWFzayBvciBhIGZpbHRlci5cbiAgICBpZiAodGhpcy5fbWFzayB8fCB0aGlzLl9maWx0ZXJzKVxuICAgIHtcbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XG5cbiAgICAgICAgLy8gcHVzaCBmaWx0ZXIgZmlyc3QgYXMgd2UgbmVlZCB0byBlbnN1cmUgdGhlIHN0ZW5jaWwgYnVmZmVyIGlzIGNvcnJlY3QgZm9yIGFueSBtYXNraW5nXG4gICAgICAgIGlmICh0aGlzLl9maWx0ZXJzKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLnB1c2hGaWx0ZXIodGhpcywgdGhpcy5fZmlsdGVycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWFzaylcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyZXIubWFza01hbmFnZXIucHVzaE1hc2sodGhpcywgdGhpcy5fbWFzayk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5jdXJyZW50UmVuZGVyZXIuc3RhcnQoKTtcblxuICAgICAgICAvLyBhZGQgdGhpcyBvYmplY3QgdG8gdGhlIGJhdGNoLCBvbmx5IHJlbmRlcmVkIGlmIGl0IGhhcyBhIHRleHR1cmUuXG4gICAgICAgIHRoaXMuX3JlbmRlcldlYkdMKHJlbmRlcmVyKTtcblxuICAgICAgICAvLyBub3cgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBhbmQgbWFrZSBzdXJlIHRoZXkgZ2V0IHJlbmRlcmVkXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXJXZWJHTChyZW5kZXJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcblxuICAgICAgICBpZiAodGhpcy5fbWFzaylcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyZXIubWFza01hbmFnZXIucG9wTWFzayh0aGlzLCB0aGlzLl9tYXNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9maWx0ZXJzKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLnBvcEZpbHRlcigpO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX3JlbmRlcldlYkdMKHJlbmRlcmVyKTtcblxuICAgICAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucmVuZGVyV2ViR0wocmVuZGVyZXIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBUbyBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdWJjbGFzc1xuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyXG4gKiBAcHJpdmF0ZVxuICovXG5Db250YWluZXIucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIChyZW5kZXJlcikgLy8ganNoaW50IHVudXNlZDpmYWxzZVxue1xuICAgIC8vIHRoaXMgaXMgd2hlcmUgY29udGVudCBpdHNlbGYgZ2V0cyByZW5kZXJlZC4uLlxufTtcblxuLyoqXG4gKiBUbyBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdWJjbGFzc1xuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7Q2FudmFzUmVuZGVyZXJ9IFRoZSByZW5kZXJlclxuICogQHByaXZhdGVcbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKSAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG57XG4gICAgLy8gdGhpcyBpcyB3aGVyZSBjb250ZW50IGl0c2VsZiBnZXRzIHJlbmRlcmVkLi4uXG59O1xuXG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge0NhbnZhc1JlbmRlcmVyfSBUaGUgcmVuZGVyZXJcbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiAocmVuZGVyZXIpXG57XG4gICAgLy8gaWYgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzXG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy5hbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2spXG4gICAge1xuICAgICAgICByZW5kZXJlci5tYXNrTWFuYWdlci5wdXNoTWFzayh0aGlzLl9tYXNrLCByZW5kZXJlcik7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyQ2FudmFzKHJlbmRlcmVyKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXJDYW52YXMocmVuZGVyZXIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrKVxuICAgIHtcbiAgICAgICAgcmVuZGVyZXIubWFza01hbmFnZXIucG9wTWFzayhyZW5kZXJlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgY29udGFpbmVyXG4gKiBAcGFyYW0gZGVzdHJveUNoaWxkcmVuIHtib29sZWFufSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGxcbiAqL1xuQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGRlc3Ryb3lDaGlsZHJlbilcbntcbiAgICBEaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICBpZihkZXN0cm95Q2hpbGRyZW4pXG4gICAge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLmRlc3Ryb3koZGVzdHJveUNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlQ2hpbGRyZW4oKTtcblxuICAgIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xufTtcbiIsInZhciBtYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpLFxuICAgIFJlbmRlclRleHR1cmUgPSByZXF1aXJlKCcuLi90ZXh0dXJlcy9SZW5kZXJUZXh0dXJlJyksXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpLkV2ZW50RW1pdHRlcixcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgX3RlbXBNYXRyaXggPSBuZXcgbWF0aC5NYXRyaXgoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIG9iamVjdHMgdGhhdCBhcmUgcmVuZGVyZWQgb24gdGhlIHNjcmVlbi5cbiAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgY2xhc3MgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBvbiBpdHMgb3duIHJhdGhlciBpdCBzaG91bGQgYmUgZXh0ZW5kZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5mdW5jdGlvbiBEaXNwbGF5T2JqZWN0KClcbntcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQb2ludH1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IG1hdGguUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsZSBmYWN0b3Igb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BvaW50fVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGUgPSBuZXcgbWF0aC5Qb2ludCgxLCAxKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXZvdCBwb2ludCBvZiB0aGUgZGlzcGxheU9iamVjdCB0aGF0IGl0IHJvdGF0ZXMgYXJvdW5kXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQb2ludH1cbiAgICAgKi9cbiAgICB0aGlzLnBpdm90ID0gbmV3IG1hdGguUG9pbnQoMCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFscGhhID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBvYmplY3QuIElmIGZhbHNlIHRoZSBvYmplY3Qgd2lsbCBub3QgYmUgZHJhd24sIGFuZFxuICAgICAqIHRoZSB1cGRhdGVUcmFuc2Zvcm0gZnVuY3Rpb24gd2lsbCBub3QgYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQ2FuIHRoaXMgb2JqZWN0IGJlIHJlbmRlcmVkLCBpZiBmYWxzZSB0aGUgb2JqZWN0IHdpbGwgbm90IGJlIGRyYXduIGJ1dCB0aGUgdXBkYXRlVHJhbnNmb3JtXG4gICAgICogbWV0aG9kcyB3aWxsIHN0aWxsIGJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXNwbGF5IG9iamVjdCBjb250YWluZXIgdGhhdCBjb250YWlucyB0aGlzIGRpc3BsYXkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Q29udGFpbmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtdWx0aXBsaWVkIGFscGhhIG9mIHRoZSBkaXNwbGF5T2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy53b3JsZEFscGhhID0gMTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gd29ybGQgKHBhcmVudCkgZmFjdG9yc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7TWF0cml4fVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgbWF0aC5NYXRyaXgoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcmVhIHRoZSBmaWx0ZXIgaXMgYXBwbGllZCB0by4gVGhpcyBpcyB1c2VkIGFzIG1vcmUgb2YgYW4gb3B0aW1pc2F0aW9uXG4gICAgICogcmF0aGVyIHRoYW4gZmlndXJpbmcgb3V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGVhY2ggZnJhbWUgeW91IGNhbiBzZXQgdGhpcyByZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1JlY3RhbmdsZX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogY2FjaGVkIHNpbiByb3RhdGlvblxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3IgPSAwO1xuXG4gICAgLyoqXG4gICAgICogY2FjaGVkIGNvcyByb3RhdGlvblxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY3IgPSAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9yaWdpbmFsLCBjYWNoZWQgYm91bmRzIG9mIHRoZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1JlY3RhbmdsZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBtYXRoLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IHVwLXRvLWRhdGUgYm91bmRzIG9mIHRoZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1JlY3RhbmdsZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9yaWdpbmFsLCBjYWNoZWQgbWFzayBvZiB0aGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtSZWN0YW5nbGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9tYXNrID0gbnVsbDtcblxuICAgIC8vVE9ETyByZW5hbWUgdG8gX2lzTWFza1xuICAgLy8gdGhpcy5pc01hc2sgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBpbnRlcm5hbCBmbGFnLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSBmYWxzZTtcbiAgICB0aGlzLl9jYWNoZWRPYmplY3QgPSBudWxsO1xufVxuXG4vLyBjb25zdHJ1Y3RvclxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXNwbGF5T2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBEaXNwbGF5T2JqZWN0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhEaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeCBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBEaXNwbGF5T2JqZWN0I1xuICAgICAqL1xuICAgIHg6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0IG9uIHRoZSB5IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIERpc3BsYXlPYmplY3QjXG4gICAgICovXG4gICAgeToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHNwcml0ZSBpcyBnbG9iYWxseSB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgRGlzcGxheU9iamVjdCNcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB3b3JsZFZpc2libGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXM7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0udmlzaWJsZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbS5wYXJlbnQ7XG4gICAgICAgICAgICB9IHdoaWxlIChpdGVtKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1hc2sgZm9yIHRoZSBkaXNwbGF5T2JqZWN0LiBBIG1hc2sgaXMgYW4gb2JqZWN0IHRoYXQgbGltaXRzIHRoZSB2aXNpYmlsaXR5IG9mIGFuIG9iamVjdCB0byB0aGUgc2hhcGUgb2YgdGhlIG1hc2sgYXBwbGllZCB0byBpdC5cbiAgICAgKiBJbiBQSVhJIGEgcmVndWxhciBtYXNrIG11c3QgYmUgYSBQSVhJLkdyYXBoaWNzIG9iamVjdC4gVGhpcyBhbGxvd3MgZm9yIG11Y2ggZmFzdGVyIG1hc2tpbmcgaW4gY2FudmFzIGFzIGl0IHV0aWxpc2VzIHNoYXBlIGNsaXBwaW5nLlxuICAgICAqIFRvIHJlbW92ZSBhIG1hc2ssIHNldCB0aGlzIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtHcmFwaGljc31cbiAgICAgKiBAbWVtYmVyb2YgRGlzcGxheU9iamVjdCNcbiAgICAgKi9cbiAgICBtYXNrOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hc2s7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWFzaylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXNrLnJlbmRlcmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9tYXNrID0gdmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXNrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hc2sucmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGZpbHRlcnMgZm9yIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgICAqICogSU1QT1JUQU5UOiBUaGlzIGlzIGEgd2ViR0wgb25seSBmZWF0dXJlIGFuZCB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIGNhbnZhcyByZW5kZXJlci5cbiAgICAgKiBUbyByZW1vdmUgZmlsdGVycyBzaW1wbHkgc2V0IHRoaXMgcHJvcGVydHkgdG8gJ251bGwnXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtGaWx0ZXJbXX1cbiAgICAgKiBAbWVtYmVyb2YgRGlzcGxheU9iamVjdCNcbiAgICAgKi9cbiAgICBmaWx0ZXJzOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnMgJiYgdGhpcy5fZmlsdGVycy5zbGljZSgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVycyA9IHZhbHVlICYmIHZhbHVlLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG4vKlxuICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXG4gKlxuICogVE9ETyAtIE9wdGltaXphdGlvbiBwYXNzIVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpXG57XG5cbiAgICAvLyBjcmVhdGUgc29tZSBtYXRyaXggcmVmcyBmb3IgZWFzeSBhY2Nlc3NcbiAgICB2YXIgcHQgPSB0aGlzLnBhcmVudC53b3JsZFRyYW5zZm9ybTtcbiAgICB2YXIgd3QgPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgLy8gdGVtcG9yYXJ5IG1hdHJpeCB2YXJpYWJsZXNcbiAgICB2YXIgYSwgYiwgYywgZCwgdHgsIHR5O1xuXG4gICAgLy8gc28gaWYgcm90YXRpb24gaXMgYmV0d2VlbiAwIHRoZW4gd2UgY2FuIHNpbXBsaWZ5IHRoZSBtdWx0aXBsaWNhdGlvbiBwcm9jZXNzLi4uXG4gICAgaWYgKHRoaXMucm90YXRpb24gJSBDT05TVC5QSV8yKVxuICAgIHtcbiAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSByb3RhdGlvbiBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgcmVuZGVyLiBUaGlzIG1lYW5zIHdlIG9ubHkgbmVlZCB0byB1c2Ugc2luIGFuZCBjb3Mgd2hlbiByb3RhdGlvbiBhY3R1YWxseSBjaGFuZ2VzXG4gICAgICAgIGlmICh0aGlzLnJvdGF0aW9uICE9PSB0aGlzLnJvdGF0aW9uQ2FjaGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb25DYWNoZSA9IHRoaXMucm90YXRpb247XG4gICAgICAgICAgICB0aGlzLl9zciA9IE1hdGguc2luKHRoaXMucm90YXRpb24pO1xuICAgICAgICAgICAgdGhpcy5fY3IgPSBNYXRoLmNvcyh0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgbWF0cml4IHZhbHVlcyBvZiB0aGUgZGlzcGxheW9iamVjdCBiYXNlZCBvbiBpdHMgdHJhbnNmb3JtIHByb3BlcnRpZXMuLlxuICAgICAgICBhICA9ICB0aGlzLl9jciAqIHRoaXMuc2NhbGUueDtcbiAgICAgICAgYiAgPSAgdGhpcy5fc3IgKiB0aGlzLnNjYWxlLng7XG4gICAgICAgIGMgID0gLXRoaXMuX3NyICogdGhpcy5zY2FsZS55O1xuICAgICAgICBkICA9ICB0aGlzLl9jciAqIHRoaXMuc2NhbGUueTtcbiAgICAgICAgdHggPSAgdGhpcy5wb3NpdGlvbi54O1xuICAgICAgICB0eSA9ICB0aGlzLnBvc2l0aW9uLnk7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIHBpdm90Li4gbm90IG9mdGVuIHVzZWQgc28gZ2VhcmVkIHRvd2FyZHMgdGhhdCBmYWN0IVxuICAgICAgICBpZiAodGhpcy5waXZvdC54IHx8IHRoaXMucGl2b3QueSlcbiAgICAgICAge1xuICAgICAgICAgICAgdHggLT0gdGhpcy5waXZvdC54ICogYSArIHRoaXMucGl2b3QueSAqIGM7XG4gICAgICAgICAgICB0eSAtPSB0aGlzLnBpdm90LnggKiBiICsgdGhpcy5waXZvdC55ICogZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbmNhdCB0aGUgcGFyZW50IG1hdHJpeCB3aXRoIHRoZSBvYmplY3RzIHRyYW5zZm9ybS5cbiAgICAgICAgd3QuYSAgPSBhICAqIHB0LmEgKyBiICAqIHB0LmM7XG4gICAgICAgIHd0LmIgID0gYSAgKiBwdC5iICsgYiAgKiBwdC5kO1xuICAgICAgICB3dC5jICA9IGMgICogcHQuYSArIGQgICogcHQuYztcbiAgICAgICAgd3QuZCAgPSBjICAqIHB0LmIgKyBkICAqIHB0LmQ7XG4gICAgICAgIHd0LnR4ID0gdHggKiBwdC5hICsgdHkgKiBwdC5jICsgcHQudHg7XG4gICAgICAgIHd0LnR5ID0gdHggKiBwdC5iICsgdHkgKiBwdC5kICsgcHQudHk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vIGxldHMgZG8gdGhlIGZhc3QgdmVyc2lvbiBhcyB3ZSBrbm93IHRoZXJlIGlzIG5vIHJvdGF0aW9uLi5cbiAgICAgICAgYSAgPSB0aGlzLnNjYWxlLng7XG4gICAgICAgIGQgID0gdGhpcy5zY2FsZS55O1xuXG4gICAgICAgIHR4ID0gdGhpcy5wb3NpdGlvbi54IC0gdGhpcy5waXZvdC54ICogYTtcbiAgICAgICAgdHkgPSB0aGlzLnBvc2l0aW9uLnkgLSB0aGlzLnBpdm90LnkgKiBkO1xuXG4gICAgICAgIHd0LmEgID0gYSAgKiBwdC5hO1xuICAgICAgICB3dC5iICA9IGEgICogcHQuYjtcbiAgICAgICAgd3QuYyAgPSBkICAqIHB0LmM7XG4gICAgICAgIHd0LmQgID0gZCAgKiBwdC5kO1xuICAgICAgICB3dC50eCA9IHR4ICogcHQuYSArIHR5ICogcHQuYyArIHB0LnR4O1xuICAgICAgICB3dC50eSA9IHR4ICogcHQuYiArIHR5ICogcHQuZCArIHB0LnR5O1xuICAgIH1cblxuICAgIC8vIG11bHRpcGx5IHRoZSBhbHBoYXMuLlxuICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuXG4gICAgLy8gcmVzZXQgdGhlIGJvdW5kcyBlYWNoIHRpbWUgdGhpcyBpcyBjYWxsZWQhXG4gICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IG51bGw7XG59O1xuXG4vLyBwZXJmb3JtYW5jZSBpbmNyZWFzZSB0byBhdm9pZCB1c2luZyBjYWxsLi4gKDEweCBmYXN0ZXIpXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtID0gRGlzcGxheU9iamVjdC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtO1xuXG4vKipcbiAqXG4gKlxuICogUmV0cmlldmVzIHRoZSBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QgYXMgYSByZWN0YW5nbGUgb2JqZWN0XG4gKlxuICogQHBhcmFtIG1hdHJpeCB7TWF0cml4fVxuICogQHJldHVybiB7UmVjdGFuZ2xlfSB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYXJlYVxuICovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAobWF0cml4KSAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG57XG4gICAgcmV0dXJuIG1hdGguUmVjdGFuZ2xlLkVNUFRZO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgZGlzcGxheU9iamVjdCBhcyBhIHJlY3RhbmdsZSBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gKi9cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmdldExvY2FsQm91bmRzID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMobWF0aC5NYXRyaXguSURFTlRJVFkpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0XG4gKlxuICogQHBhcmFtIHBvc2l0aW9uIHtQb2ludH0gVGhlIHdvcmxkIG9yaWdpbiB0byBjYWxjdWxhdGUgZnJvbVxuICogQHJldHVybiB7UG9pbnR9IEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3RcbiAqL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUudG9HbG9iYWwgPSBmdW5jdGlvbiAocG9zaXRpb24pXG57XG4gICAgLy8gZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIGxvdFxuICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5KHBvc2l0aW9uKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbG9jYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0IHJlbGF0aXZlIHRvIGFub3RoZXIgcG9pbnRcbiAqXG4gKiBAcGFyYW0gcG9zaXRpb24ge1BvaW50fSBUaGUgd29ybGQgb3JpZ2luIHRvIGNhbGN1bGF0ZSBmcm9tXG4gKiBAcGFyYW0gW2Zyb21dIHtEaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCB0byBjYWxjdWxhdGUgdGhlIGdsb2JhbCBwb3NpdGlvbiBmcm9tXG4gKiBAcmV0dXJuIHtQb2ludH0gQSBwb2ludCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGlzIG9iamVjdFxuICovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS50b0xvY2FsID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBmcm9tKVxue1xuICAgIGlmIChmcm9tKVxuICAgIHtcbiAgICAgICAgcG9zaXRpb24gPSBmcm9tLnRvR2xvYmFsKHBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgbG90XG4gICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgcmV0dXJuIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvc2l0aW9uKTtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyXG4gKiBAcHJpdmF0ZVxuICovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIChyZW5kZXJlcikgLy8ganNoaW50IHVudXNlZDpmYWxzZVxue1xuICAgIC8vIE9WRVJXUklURTtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge0NhbnZhc1JlbmRlcmVyfSBUaGUgcmVuZGVyZXJcbiAqIEBwcml2YXRlXG4gKi9cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLnJlbmRlckNhbnZhcyA9IGZ1bmN0aW9uIChyZW5kZXJlcikgLy8ganNoaW50IHVudXNlZDpmYWxzZVxue1xuICAgIC8vIE9WRVJXUklURTtcbn07XG4vKipcbiAqIFVzZWZ1bCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0ZXh0dXJlIG9mIHRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IGNhbiB0aGVuIGJlIHVzZWQgdG8gY3JlYXRlIHNwcml0ZXNcbiAqIFRoaXMgY2FuIGJlIHF1aXRlIHVzZWZ1bCBpZiB5b3VyIGRpc3BsYXlPYmplY3QgaXMgc3RhdGljIC8gY29tcGxpY2F0ZWQgYW5kIG5lZWRzIHRvIGJlIHJldXNlZCBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge0NhbnZhc1JlbmRlcmVyfFdlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0ZXh0dXJlLlxuICogQHBhcmFtIHJlc29sdXRpb24ge051bWJlcn0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUgYmVpbmcgZ2VuZXJhdGVkXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtOdW1iZXJ9IFNlZSB7QGxpbmsgU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqIEByZXR1cm4ge1RleHR1cmV9IGEgdGV4dHVyZSBvZiB0aGUgZGlzcGxheSBvYmplY3RcbiAqL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZ2VuZXJhdGVUZXh0dXJlID0gZnVuY3Rpb24gKHJlbmRlcmVyLCByZXNvbHV0aW9uLCBzY2FsZU1vZGUpXG57XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcblxuICAgIHZhciByZW5kZXJUZXh0dXJlID0gbmV3IFJlbmRlclRleHR1cmUocmVuZGVyZXIsIGJvdW5kcy53aWR0aCB8IDAsIGJvdW5kcy5oZWlnaHQgfCAwLCByZW5kZXJlciwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKTtcblxuICAgIF90ZW1wTWF0cml4LnR4ID0gLWJvdW5kcy54O1xuICAgIF90ZW1wTWF0cml4LnR5ID0gLWJvdW5kcy55O1xuXG4gICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcywgX3RlbXBNYXRyaXgpO1xuXG4gICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XG59O1xuXG4vKipcbiAqIEJhc2UgZGVzdHJveSBtZXRob2QgZm9yIGdlbmVyaWMgZGlzcGxheSBvYmplY3RzXG4gKlxuICovXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcbntcblxuICAgIHRoaXMucG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMuc2NhbGUgPSBudWxsO1xuICAgIHRoaXMucGl2b3QgPSBudWxsO1xuXG4gICAgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gbnVsbDtcbiAgICB0aGlzLl9tYXNrID0gbnVsbDtcblxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBudWxsO1xuICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG5cbiAgICB0aGlzLmxpc3RlbmVycyA9IG51bGw7XG59O1xuIiwidmFyIENvbnRhaW5lciA9IHJlcXVpcmUoJy4uL2Rpc3BsYXkvQ29udGFpbmVyJyksXG4gICAgU3ByaXRlID0gcmVxdWlyZSgnLi4vc3ByaXRlcy9TcHJpdGUnKSxcbiAgICBUZXh0dXJlID0gcmVxdWlyZSgnLi4vdGV4dHVyZXMvVGV4dHVyZScpLFxuICAgIENhbnZhc0J1ZmZlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVycy9jYW52YXMvdXRpbHMvQ2FudmFzQnVmZmVyJyksXG4gICAgQ2FudmFzR3JhcGhpY3MgPSByZXF1aXJlKCcuLi9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc0dyYXBoaWNzJyksXG4gICAgR3JhcGhpY3NEYXRhID0gcmVxdWlyZSgnLi9HcmFwaGljc0RhdGEnKSxcbiAgICBtYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpLFxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICB0ZW1wUG9pbnQgPSBuZXcgbWF0aC5Qb2ludCgpO1xuXG4vKipcbiAqIFRoZSBHcmFwaGljcyBjbGFzcyBjb250YWlucyBtZXRob2RzIHVzZWQgdG8gZHJhdyBwcmltaXRpdmUgc2hhcGVzIHN1Y2ggYXMgbGluZXMsIGNpcmNsZXMgYW5kXG4gKiByZWN0YW5nbGVzIHRvIHRoZSBkaXNwbGF5LCBhbmQgdG8gY29sb3IgYW5kIGZpbGwgdGhlbS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIENvbnRhaW5lclxuICogQG1lbWJlcm9mIFBJWElcbiAqL1xuZnVuY3Rpb24gR3JhcGhpY3MoKVxue1xuICAgIENvbnRhaW5lci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFscGhhIHZhbHVlIHVzZWQgd2hlbiBmaWxsaW5nIHRoZSBHcmFwaGljcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuZmlsbEFscGhhID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCAodGhpY2tuZXNzKSBvZiBhbnkgbGluZXMgZHJhd24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMubGluZVdpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb2xvciBvZiBhbnkgbGluZXMgZHJhd24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMubGluZUNvbG9yID0gMDtcblxuICAgIC8qKlxuICAgICAqIEdyYXBoaWNzIGRhdGFcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0dyYXBoaWNzRGF0YVtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5ncmFwaGljc0RhdGEgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIGdyYXBoaWMgc2hhcGUuIFRoaXMgaXMgYSBoZXggdmFsdWUuIEFwcGx5IGEgdmFsdWUgb2YgMHhGRkZGRkYgdG8gcmVzZXQgdGhlIHRpbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICB0aGlzLnRpbnQgPSAweEZGRkZGRjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyB0aW50IGFwcGxpZWQgdG8gdGhlIGdyYXBoaWMgc2hhcGUuIFVzZWQgdG8gY29tcGFyZSB0byB0aGUgY3VycmVudCB0aW50IGFuZCBjaGVjayBpZiB0aGVyZXMgY2hhbmdlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICB0aGlzLl9wcmV2VGludCA9IDB4RkZGRkZGO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgZ3JhcGhpYyBzaGFwZS4gQXBwbHkgYSB2YWx1ZSBvZiBibGVuZE1vZGVzLk5PUk1BTCB0byByZXNldCB0aGUgYmxlbmQgbW9kZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBDT05TVC5CTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgICovXG4gICAgdGhpcy5ibGVuZE1vZGUgPSBDT05TVC5CTEVORF9NT0RFUy5OT1JNQUw7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHBhdGhcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0dyYXBoaWNzRGF0YX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgY29udGFpbmluZyBzb21lIFdlYkdMLXJlbGF0ZWQgcHJvcGVydGllcyB1c2VkIGJ5IHRoZSBXZWJHTCByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdDxudW1iZXIsIG9iamVjdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAvLyBUT0RPIC0gX3dlYmdsIHNob3VsZCB1c2UgYSBwcm90b3R5cGUgb2JqZWN0LCBub3QgYSByYW5kb20gdW5kb2N1bWVudGVkIG9iamVjdC4uLlxuICAgIHRoaXMuX3dlYkdMID0ge307XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgc2hhcGUgaXMgYmVpbmcgdXNlZCBhcyBhIG1hc2suXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNNYXNrID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm91bmRzJyBwYWRkaW5nIHVzZWQgZm9yIGJvdW5kcyBjYWxjdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kc1BhZGRpbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQSBjYWNoZSBvZiB0aGUgbG9jYWwgYm91bmRzIHRvIHByZXZlbnQgcmVjYWxjdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1JlY3RhbmdsZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xvY2FsQm91bmRzID0gbmV3IG1hdGguUmVjdGFuZ2xlKDAsMCwxLDEpO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBkZXRlY3QgaWYgdGhlIGdyYXBoaWNzIG9iamVjdCBoYXMgY2hhbmdlZC4gSWYgdGhpcyBpcyBzZXQgdG8gdHJ1ZSB0aGVuIHRoZSBncmFwaGljc1xuICAgICAqIG9iamVjdCB3aWxsIGJlIHJlY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZGV0ZWN0IGlmIHRoZSBXZWJHTCBncmFwaGljcyBvYmplY3QgaGFzIGNoYW5nZWQuIElmIHRoaXMgaXMgc2V0IHRvIHRydWUgdGhlbiB0aGVcbiAgICAgKiBncmFwaGljcyBvYmplY3Qgd2lsbCBiZSByZWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5nbERpcnR5ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGRldGVjdCBpZiB0aGUgY2FjaGVkIHNwcml0ZSBvYmplY3QgbmVlZHMgdG8gYmUgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNhY2hlZFNwcml0ZURpcnR5ID0gZmFsc2U7XG59XG5cbi8vIGNvbnN0cnVjdG9yXG5HcmFwaGljcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbnRhaW5lci5wcm90b3R5cGUpO1xuR3JhcGhpY3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JhcGhpY3M7XG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoaWNzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhHcmFwaGljcy5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBXaGVuIGNhY2hlQXNCaXRtYXAgaXMgc2V0IHRvIHRydWUgdGhlIGdyYXBoaWNzIG9iamVjdCB3aWxsIGJlIHJlbmRlcmVkIGFzIGlmIGl0IHdhcyBhIHNwcml0ZS5cbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3VyIGdyYXBoaWNzIGVsZW1lbnQgZG9lcyBub3QgY2hhbmdlIG9mdGVuLCBhcyBpdCB3aWxsIHNwZWVkIHVwIHRoZSByZW5kZXJpbmdcbiAgICAgKiBvZiB0aGUgb2JqZWN0IGluIGV4Y2hhbmdlIGZvciB0YWtpbmcgdXAgdGV4dHVyZSBtZW1vcnkuIEl0IGlzIGFsc28gdXNlZnVsIGlmIHlvdSBuZWVkIHRoZSBncmFwaGljc1xuICAgICAqIG9iamVjdCB0byBiZSBhbnRpLWFsaWFzZWQsIGJlY2F1c2UgaXQgd2lsbCBiZSByZW5kZXJlZCB1c2luZyBjYW52YXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkIGlmXG4gICAgICogeW91IGFyZSBjb25zdGFudGx5IHJlZHJhd2luZyB0aGUgZ3JhcGhpY3MgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIEdyYXBoaWNzI1xuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBHcmFwaGljcyBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB7R3JhcGhpY3N9XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGNsb25lID0gbmV3IEdyYXBoaWNzKCk7XG5cbiAgICBjbG9uZS5yZW5kZXJhYmxlICAgID0gdGhpcy5yZW5kZXJhYmxlO1xuICAgIGNsb25lLmZpbGxBbHBoYSAgICAgPSB0aGlzLmZpbGxBbHBoYTtcbiAgICBjbG9uZS5saW5lV2lkdGggICAgID0gdGhpcy5saW5lV2lkdGg7XG4gICAgY2xvbmUubGluZUNvbG9yICAgICA9IHRoaXMubGluZUNvbG9yO1xuICAgIGNsb25lLnRpbnQgICAgICAgICAgPSB0aGlzLnRpbnQ7XG4gICAgY2xvbmUuYmxlbmRNb2RlICAgICA9IHRoaXMuYmxlbmRNb2RlO1xuICAgIGNsb25lLmlzTWFzayAgICAgICAgPSB0aGlzLmlzTWFzaztcbiAgICBjbG9uZS5ib3VuZHNQYWRkaW5nID0gdGhpcy5ib3VuZHNQYWRkaW5nO1xuICAgIGNsb25lLmRpcnR5ICAgICAgICAgPSB0aGlzLmRpcnR5O1xuICAgIGNsb25lLmdsRGlydHkgICAgICAgPSB0aGlzLmdsRGlydHk7XG4gICAgY2xvbmUuY2FjaGVkU3ByaXRlRGlydHkgPSB0aGlzLmNhY2hlZFNwcml0ZURpcnR5O1xuXG4gICAgLy8gY29weSBncmFwaGljcyBkYXRhXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSlcbiAgICB7XG4gICAgICAgIGNsb25lLmdyYXBoaWNzRGF0YS5wdXNoKHRoaXMuZ3JhcGhpY3NEYXRhLmNsb25lKCkpO1xuICAgIH1cblxuICAgIGNsb25lLmN1cnJlbnRQYXRoID0gY2xvbmUuZ3JhcGhpY3NEYXRhW2Nsb25lLmdyYXBoaWNzRGF0YS5sZW5ndGggLSAxXTtcblxuICAgIGNsb25lLnVwZGF0ZUxvY2FsQm91bmRzKCk7XG5cbiAgICByZXR1cm4gY2xvbmU7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgbGluZSBzdHlsZSB1c2VkIGZvciBzdWJzZXF1ZW50IGNhbGxzIHRvIEdyYXBoaWNzIG1ldGhvZHMgc3VjaCBhcyB0aGUgbGluZVRvKCkgbWV0aG9kIG9yIHRoZSBkcmF3Q2lyY2xlKCkgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSBsaW5lV2lkdGgge251bWJlcn0gd2lkdGggb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gKiBAcGFyYW0gY29sb3Ige251bWJlcn0gY29sb3Igb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gKiBAcGFyYW0gYWxwaGEge251bWJlcn0gYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gKiBAcmV0dXJuIHtHcmFwaGljc31cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmxpbmVTdHlsZSA9IGZ1bmN0aW9uIChsaW5lV2lkdGgsIGNvbG9yLCBhbHBoYSlcbntcbiAgICB0aGlzLmxpbmVXaWR0aCA9IGxpbmVXaWR0aCB8fCAwO1xuICAgIHRoaXMubGluZUNvbG9yID0gY29sb3IgfHwgMDtcbiAgICB0aGlzLmxpbmVBbHBoYSA9IChhcmd1bWVudHMubGVuZ3RoIDwgMykgPyAxIDogYWxwaGE7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGhhbGZ3YXkgdGhyb3VnaCBhIGxpbmU/IHN0YXJ0IGEgbmV3IG9uZSFcbiAgICAgICAgICAgIHRoaXMuZHJhd1NoYXBlKCBuZXcgbWF0aC5Qb2x5Z29uKCB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5zbGljZSgtMikgKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaXRzIGVtcHR5IHNvIGxldHMganVzdCBzZXQgdGhlIGxpbmUgcHJvcGVydGllc1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGgubGluZUNvbG9yID0gdGhpcy5saW5lQ29sb3I7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmxpbmVBbHBoYSA9IHRoaXMubGluZUFscGhhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1vdmVzIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gdG8geCwgeS5cbiAqXG4gKiBAcGFyYW0geCB7bnVtYmVyfSB0aGUgWCBjb29yZGluYXRlIHRvIG1vdmUgdG9cbiAqIEBwYXJhbSB5IHtudW1iZXJ9IHRoZSBZIGNvb3JkaW5hdGUgdG8gbW92ZSB0b1xuICogQHJldHVybiB7R3JhcGhpY3N9XG4gICovXG5HcmFwaGljcy5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKHgsIHkpXG57XG4gICAgdGhpcy5kcmF3U2hhcGUobmV3IG1hdGguUG9seWdvbihbeCx5XSkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERyYXdzIGEgbGluZSB1c2luZyB0aGUgY3VycmVudCBsaW5lIHN0eWxlIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiB0byAoeCwgeSk7XG4gKiBUaGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIGlzIHRoZW4gc2V0IHRvICh4LCB5KS5cbiAqXG4gKiBAcGFyYW0geCB7bnVtYmVyfSB0aGUgWCBjb29yZGluYXRlIHRvIGRyYXcgdG9cbiAqIEBwYXJhbSB5IHtudW1iZXJ9IHRoZSBZIGNvb3JkaW5hdGUgdG8gZHJhdyB0b1xuICogQHJldHVybiB7R3JhcGhpY3N9XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSlcbntcbiAgICB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5wdXNoKHgsIHkpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gKiBCYXNlZCBvbjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg1MDk3L2hvdy1kby1pLWltcGxlbWVudC1hLWJlemllci1jdXJ2ZS1pbi1jXG4gKlxuICogQHBhcmFtIGNwWCB7bnVtYmVyfSBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSBjcFkge251bWJlcn0gQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0gdG9YIHtudW1iZXJ9IERlc3RpbmF0aW9uIHBvaW50IHhcbiAqIEBwYXJhbSB0b1kge251bWJlcn0gRGVzdGluYXRpb24gcG9pbnQgeVxuICogQHJldHVybiB7R3JhcGhpY3N9XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24gKGNwWCwgY3BZLCB0b1gsIHRvWSlcbntcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzID0gWzAsIDBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMubW92ZVRvKDAsMCk7XG4gICAgfVxuXG4gICAgdmFyIHhhLFxuICAgICAgICB5YSxcbiAgICAgICAgbiA9IDIwLFxuICAgICAgICBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcblxuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKVxuICAgIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oMCwgMCk7XG4gICAgfVxuXG4gICAgdmFyIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMl07XG4gICAgdmFyIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV07XG5cbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbjsgKytpKVxuICAgIHtcbiAgICAgICAgaiA9IGkgLyBuO1xuXG4gICAgICAgIHhhID0gZnJvbVggKyAoIChjcFggLSBmcm9tWCkgKiBqICk7XG4gICAgICAgIHlhID0gZnJvbVkgKyAoIChjcFkgLSBmcm9tWSkgKiBqICk7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goIHhhICsgKCAoKGNwWCArICggKHRvWCAtIGNwWCkgKiBqICkpIC0geGEpICogaiApLFxuICAgICAgICAgICAgICAgICAgICAgeWEgKyAoICgoY3BZICsgKCAodG9ZIC0gY3BZKSAqIGogKSkgLSB5YSkgKiBqICkgKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gKlxuICogQHBhcmFtIGNwWCB7bnVtYmVyfSBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSBjcFkge251bWJlcn0gQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0gY3BYMiB7bnVtYmVyfSBTZWNvbmQgQ29udHJvbCBwb2ludCB4XG4gKiBAcGFyYW0gY3BZMiB7bnVtYmVyfSBTZWNvbmQgQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0gdG9YIHtudW1iZXJ9IERlc3RpbmF0aW9uIHBvaW50IHhcbiAqIEBwYXJhbSB0b1kge251bWJlcn0gRGVzdGluYXRpb24gcG9pbnQgeVxuICogQHJldHVybiB7R3JhcGhpY3N9XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gKGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSlcbntcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzID0gWzAsIDBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMubW92ZVRvKDAsMCk7XG4gICAgfVxuXG4gICAgdmFyIG4gPSAyMCxcbiAgICAgICAgZHQsXG4gICAgICAgIGR0MixcbiAgICAgICAgZHQzLFxuICAgICAgICB0MixcbiAgICAgICAgdDMsXG4gICAgICAgIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzO1xuXG4gICAgdmFyIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMl07XG4gICAgdmFyIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV07XG5cbiAgICB2YXIgaiA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyArK2kpXG4gICAge1xuICAgICAgICBqID0gaSAvIG47XG5cbiAgICAgICAgZHQgPSAoMSAtIGopO1xuICAgICAgICBkdDIgPSBkdCAqIGR0O1xuICAgICAgICBkdDMgPSBkdDIgKiBkdDtcblxuICAgICAgICB0MiA9IGogKiBqO1xuICAgICAgICB0MyA9IHQyICogajtcblxuICAgICAgICBwb2ludHMucHVzaCggZHQzICogZnJvbVggKyAzICogZHQyICogaiAqIGNwWCArIDMgKiBkdCAqIHQyICogY3BYMiArIHQzICogdG9YLFxuICAgICAgICAgICAgICAgICAgICAgZHQzICogZnJvbVkgKyAzICogZHQyICogaiAqIGNwWSArIDMgKiBkdCAqIHQyICogY3BZMiArIHQzICogdG9ZKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGUgYXJjVG8oKSBtZXRob2QgY3JlYXRlcyBhbiBhcmMvY3VydmUgYmV0d2VlbiB0d28gdGFuZ2VudHMgb24gdGhlIGNhbnZhcy5cbiAqXG4gKiBcImJvcnJvd2VkXCIgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Z4Y2FudmFzLyAtIHRoYW5rcyBnb29nbGUhXG4gKlxuICogQHBhcmFtIHgxIHtudW1iZXJ9IFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJjXG4gKiBAcGFyYW0geTEge251bWJlcn0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmNcbiAqIEBwYXJhbSB4MiB7bnVtYmVyfSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGFyY1xuICogQHBhcmFtIHkyIHtudW1iZXJ9IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgYXJjXG4gKiBAcGFyYW0gcmFkaXVzIHtudW1iZXJ9IFRoZSByYWRpdXMgb2YgdGhlIGFyY1xuICogQHJldHVybiB7R3JhcGhpY3N9XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5hcmNUbyA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKVxue1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMucHVzaCh4MSwgeTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMubW92ZVRvKHgxLCB5MSk7XG4gICAgfVxuXG4gICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLFxuICAgICAgICBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoLTJdLFxuICAgICAgICBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoLTFdLFxuICAgICAgICBhMSA9IGZyb21ZIC0geTEsXG4gICAgICAgIGIxID0gZnJvbVggLSB4MSxcbiAgICAgICAgYTIgPSB5MiAgIC0geTEsXG4gICAgICAgIGIyID0geDIgICAtIHgxLFxuICAgICAgICBtbSA9IE1hdGguYWJzKGExICogYjIgLSBiMSAqIGEyKTtcblxuICAgIGlmIChtbSA8IDEuMGUtOCB8fCByYWRpdXMgPT09IDApXG4gICAge1xuICAgICAgICBpZiAocG9pbnRzW3BvaW50cy5sZW5ndGgtMl0gIT09IHgxIHx8IHBvaW50c1twb2ludHMubGVuZ3RoLTFdICE9PSB5MSlcbiAgICAgICAge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeDEsIHkxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgZGQgPSBhMSAqIGExICsgYjEgKiBiMSxcbiAgICAgICAgICAgIGNjID0gYTIgKiBhMiArIGIyICogYjIsXG4gICAgICAgICAgICB0dCA9IGExICogYTIgKyBiMSAqIGIyLFxuICAgICAgICAgICAgazEgPSByYWRpdXMgKiBNYXRoLnNxcnQoZGQpIC8gbW0sXG4gICAgICAgICAgICBrMiA9IHJhZGl1cyAqIE1hdGguc3FydChjYykgLyBtbSxcbiAgICAgICAgICAgIGoxID0gazEgKiB0dCAvIGRkLFxuICAgICAgICAgICAgajIgPSBrMiAqIHR0IC8gY2MsXG4gICAgICAgICAgICBjeCA9IGsxICogYjIgKyBrMiAqIGIxLFxuICAgICAgICAgICAgY3kgPSBrMSAqIGEyICsgazIgKiBhMSxcbiAgICAgICAgICAgIHB4ID0gYjEgKiAoazIgKyBqMSksXG4gICAgICAgICAgICBweSA9IGExICogKGsyICsgajEpLFxuICAgICAgICAgICAgcXggPSBiMiAqIChrMSArIGoyKSxcbiAgICAgICAgICAgIHF5ID0gYTIgKiAoazEgKyBqMiksXG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gTWF0aC5hdGFuMihweSAtIGN5LCBweCAtIGN4KSxcbiAgICAgICAgICAgIGVuZEFuZ2xlICAgPSBNYXRoLmF0YW4yKHF5IC0gY3ksIHF4IC0gY3gpO1xuXG4gICAgICAgIHRoaXMuYXJjKGN4ICsgeDEsIGN5ICsgeTEsIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGIxICogYTIgPiBiMiAqIGExKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGUgYXJjIG1ldGhvZCBjcmVhdGVzIGFuIGFyYy9jdXJ2ZSAodXNlZCB0byBjcmVhdGUgY2lyY2xlcywgb3IgcGFydHMgb2YgY2lyY2xlcykuXG4gKlxuICogQHBhcmFtIGN4IHtudW1iZXJ9IFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gKiBAcGFyYW0gY3kge251bWJlcn0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAqIEBwYXJhbSByYWRpdXMge251bWJlcn0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gKiBAcGFyYW0gc3RhcnRBbmdsZSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgYW5nbGUsIGluIHJhZGlhbnMgKDAgaXMgYXQgdGhlIDMgbydjbG9jayBwb3NpdGlvbiBvZiB0aGUgYXJjJ3MgY2lyY2xlKVxuICogQHBhcmFtIGVuZEFuZ2xlIHtudW1iZXJ9IFRoZSBlbmRpbmcgYW5nbGUsIGluIHJhZGlhbnNcbiAqIEBwYXJhbSBhbnRpY2xvY2t3aXNlIHtib29sZWFufSBPcHRpb25hbC4gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGRyYXdpbmcgc2hvdWxkIGJlIGNvdW50ZXJjbG9ja3dpc2Ugb3IgY2xvY2t3aXNlLiBGYWxzZSBpcyBkZWZhdWx0LCBhbmQgaW5kaWNhdGVzIGNsb2Nrd2lzZSwgd2hpbGUgdHJ1ZSBpbmRpY2F0ZXMgY291bnRlci1jbG9ja3dpc2UuXG4gKiBAcmV0dXJuIHtHcmFwaGljc31cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uKGN4LCBjeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSlcbntcbiAgICB2YXIgc3RhcnRYID0gY3ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHJhZGl1cztcbiAgICB2YXIgc3RhcnRZID0gY3kgKyBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIHJhZGl1cztcbiAgICB2YXIgcG9pbnRzO1xuXG4gICAgaWYoIHRoaXMuY3VycmVudFBhdGggKVxuICAgIHtcbiAgICAgICAgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHM7XG5cbiAgICAgICAgaWYocG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoIHBvaW50c1twb2ludHMubGVuZ3RoLTJdICE9PSBzdGFydFggfHwgcG9pbnRzW3BvaW50cy5sZW5ndGgtMV0gIT09IHN0YXJ0WSlcbiAgICAgICAge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMubW92ZVRvKHN0YXJ0WCwgc3RhcnRZKTtcbiAgICAgICAgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHM7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0QW5nbGUgPT09IGVuZEFuZ2xlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYoICFhbnRpY2xvY2t3aXNlICYmIGVuZEFuZ2xlIDw9IHN0YXJ0QW5nbGUgKVxuICAgIHtcbiAgICAgICAgZW5kQW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gICAgfVxuICAgIGVsc2UgaWYoIGFudGljbG9ja3dpc2UgJiYgc3RhcnRBbmdsZSA8PSBlbmRBbmdsZSApXG4gICAge1xuICAgICAgICBzdGFydEFuZ2xlICs9IE1hdGguUEkgKiAyO1xuICAgIH1cblxuICAgIHZhciBzd2VlcCA9IGFudGljbG9ja3dpc2UgPyAoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAqLTEgOiAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICB2YXIgc2VncyA9ICBNYXRoLmNlaWwoIE1hdGguYWJzKHN3ZWVwKS8gKE1hdGguUEkgKiAyKSApICogNDA7XG5cbiAgICBpZiggc3dlZXAgPT09IDAgKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHRoZXRhID0gc3dlZXAvKHNlZ3MqMik7XG4gICAgdmFyIHRoZXRhMiA9IHRoZXRhKjI7XG5cbiAgICB2YXIgY1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgIHZhciBzVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICB2YXIgc2VnTWludXMgPSBzZWdzIC0gMTtcblxuICAgIHZhciByZW1haW5kZXIgPSAoIHNlZ01pbnVzICUgMSApIC8gc2VnTWludXM7XG5cbiAgICBmb3IodmFyIGk9MDsgaTw9c2VnTWludXM7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciByZWFsID0gIGkgKyByZW1haW5kZXIgKiBpO1xuXG5cbiAgICAgICAgdmFyIGFuZ2xlID0gKCh0aGV0YSkgKyBzdGFydEFuZ2xlICsgKHRoZXRhMiAqIHJlYWwpKTtcblxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgdmFyIHMgPSAtTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAgIHBvaW50cy5wdXNoKCggKGNUaGV0YSAqICBjKSArIChzVGhldGEgKiBzKSApICogcmFkaXVzICsgY3gsXG4gICAgICAgICAgICAgICAgICAgICggKGNUaGV0YSAqIC1zKSArIChzVGhldGEgKiBjKSApICogcmFkaXVzICsgY3kpO1xuICAgIH1cblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIHNpbXBsZSBvbmUtY29sb3IgZmlsbCB0aGF0IHN1YnNlcXVlbnQgY2FsbHMgdG8gb3RoZXIgR3JhcGhpY3MgbWV0aG9kc1xuICogKHN1Y2ggYXMgbGluZVRvKCkgb3IgZHJhd0NpcmNsZSgpKSB1c2Ugd2hlbiBkcmF3aW5nLlxuICpcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIGZpbGxcbiAqIEBwYXJhbSBhbHBoYSB7bnVtYmVyfSB0aGUgYWxwaGEgb2YgdGhlIGZpbGxcbiAqIEByZXR1cm4ge0dyYXBoaWNzfVxuICovXG5HcmFwaGljcy5wcm90b3R5cGUuYmVnaW5GaWxsID0gZnVuY3Rpb24gKGNvbG9yLCBhbHBoYSlcbntcbiAgICB0aGlzLmZpbGxpbmcgPSB0cnVlO1xuICAgIHRoaXMuZmlsbENvbG9yID0gY29sb3IgfHwgMDtcbiAgICB0aGlzLmZpbGxBbHBoYSA9IChhbHBoYSA9PT0gdW5kZWZpbmVkKSA/IDEgOiBhbHBoYTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLmxlbmd0aCA8PSAyKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmZpbGwgPSB0aGlzLmZpbGxpbmc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmZpbGxDb2xvciA9IHRoaXMuZmlsbENvbG9yO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5maWxsQWxwaGEgPSB0aGlzLmZpbGxBbHBoYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbGllcyBhIGZpbGwgdG8gdGhlIGxpbmVzIGFuZCBzaGFwZXMgdGhhdCB3ZXJlIGFkZGVkIHNpbmNlIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGJlZ2luRmlsbCgpIG1ldGhvZC5cbiAqXG4gKiBAcmV0dXJuIHtHcmFwaGljc31cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmVuZEZpbGwgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuZmlsbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZmlsbENvbG9yID0gbnVsbDtcbiAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgWSBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICogQHJldHVybiB7R3JhcGhpY3N9XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3UmVjdCA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApXG57XG4gICAgdGhpcy5kcmF3U2hhcGUobmV3IG1hdGguUmVjdGFuZ2xlKHgseSwgd2lkdGgsIGhlaWdodCkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSByYWRpdXMge251bWJlcn0gUmFkaXVzIG9mIHRoZSByZWN0YW5nbGUgY29ybmVyc1xuICovXG5HcmFwaGljcy5wcm90b3R5cGUuZHJhd1JvdW5kZWRSZWN0ID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMgKVxue1xuICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBtYXRoLlJvdW5kZWRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRHJhd3MgYSBjaXJjbGUuXG4gKlxuICogQHBhcmFtIHgge251bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gKiBAcGFyYW0gcmFkaXVzIHtudW1iZXJ9IFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICogQHJldHVybiB7R3JhcGhpY3N9XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3Q2lyY2xlID0gZnVuY3Rpb24gKHgsIHksIHJhZGl1cylcbntcbiAgICB0aGlzLmRyYXdTaGFwZShuZXcgbWF0aC5DaXJjbGUoeCx5LCByYWRpdXMpKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEcmF3cyBhbiBlbGxpcHNlLlxuICpcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZVxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gVGhlIGhhbGYgd2lkdGggb2YgdGhlIGVsbGlwc2VcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gVGhlIGhhbGYgaGVpZ2h0IG9mIHRoZSBlbGxpcHNlXG4gKiBAcmV0dXJuIHtHcmFwaGljc31cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmRyYXdFbGxpcHNlID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgdGhpcy5kcmF3U2hhcGUobmV3IG1hdGguRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRHJhd3MgYSBwb2x5Z29uIHVzaW5nIHRoZSBnaXZlbiBwYXRoLlxuICpcbiAqIEBwYXJhbSBwYXRoIHtBcnJheX0gVGhlIHBhdGggZGF0YSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcG9seWdvbi5cbiAqIEByZXR1cm4ge0dyYXBoaWNzfVxuICovXG5HcmFwaGljcy5wcm90b3R5cGUuZHJhd1BvbHlnb24gPSBmdW5jdGlvbiAocGF0aClcbntcbiAgICAvLyBwcmV2ZW50cyBhbiBhcmd1bWVudCBhc3NpZ25tZW50IGRlb3B0XG4gICAgLy8gc2VlIHNlY3Rpb24gMy4xOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMy1tYW5hZ2luZy1hcmd1bWVudHNcbiAgICB2YXIgcG9pbnRzID0gcGF0aDtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgIHtcbiAgICAgICAgLy8gcHJldmVudHMgYW4gYXJndW1lbnQgbGVhayBkZW9wdFxuICAgICAgICAvLyBzZWUgc2VjdGlvbiAzLjI6IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzLW1hbmFnaW5nLWFyZ3VtZW50c1xuICAgICAgICBwb2ludHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHBvaW50c1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBtYXRoLlBvbHlnb24ocG9pbnRzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBncmFwaGljcyB0aGF0IHdlcmUgZHJhd24gdG8gdGhpcyBHcmFwaGljcyBvYmplY3QsIGFuZCByZXNldHMgZmlsbCBhbmQgbGluZSBzdHlsZSBzZXR0aW5ncy5cbiAqXG4gKiBAcmV0dXJuIHtHcmFwaGljc31cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmxpbmVXaWR0aCA9IDA7XG4gICAgdGhpcy5maWxsaW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmNsZWFyRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gW107XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXNlZnVsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRleHR1cmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdCB0aGF0IGNhbiB0aGVuIGJlIHVzZWQgdG8gY3JlYXRlIHNwcml0ZXNcbiAqIFRoaXMgY2FuIGJlIHF1aXRlIHVzZWZ1bCBpZiB5b3VyIGdlb21ldHJ5IGlzIGNvbXBsaWNhdGVkIGFuZCBuZWVkcyB0byBiZSByZXVzZWQgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogQHBhcmFtIHJlc29sdXRpb24ge251bWJlcn0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUgYmVpbmcgZ2VuZXJhdGVkXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtudW1iZXJ9IFNob3VsZCBiZSBvbmUgb2YgdGhlIHNjYWxlTW9kZSBjb25zdHNcbiAqIEByZXR1cm4ge1RleHR1cmV9IGEgdGV4dHVyZSBvZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0XG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5nZW5lcmF0ZVRleHR1cmUgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHJlc29sdXRpb24sIHNjYWxlTW9kZSlcbntcblxuICAgIHJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IDE7XG5cbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuXG4gICAgdmFyIGNhbnZhc0J1ZmZlciA9IG5ldyBDYW52YXNCdWZmZXIoYm91bmRzLndpZHRoICogcmVzb2x1dGlvbiwgYm91bmRzLmhlaWdodCAqIHJlc29sdXRpb24pO1xuXG4gICAgdmFyIHRleHR1cmUgPSBUZXh0dXJlLmZyb21DYW52YXMoY2FudmFzQnVmZmVyLmNhbnZhcywgc2NhbGVNb2RlKTtcbiAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuXG4gICAgY2FudmFzQnVmZmVyLmNvbnRleHQuc2NhbGUocmVzb2x1dGlvbiwgcmVzb2x1dGlvbik7XG5cbiAgICBjYW52YXNCdWZmZXIuY29udGV4dC50cmFuc2xhdGUoLWJvdW5kcy54LC1ib3VuZHMueSk7XG5cbiAgICBDYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljcyh0aGlzLCBjYW52YXNCdWZmZXIuY29udGV4dCk7XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbiAocmVuZGVyZXIpXG57XG4gICAgLy8gaWYgdGhlIHNwcml0ZSBpcyBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXMgZWxlbWVudFxuXG4gICAgLy8gdGhpcyBjb2RlIG1heSBzdGlsbCBiZSBuZWVkZWQgc28gbGVhdmluZyBmb3Igbm93Li5cbiAgICAvL1xuICAgIC8qXG4gICAgaWYgKHRoaXMuX2NhY2hlQXNCaXRtYXApXG4gICAge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSB8fCB0aGlzLmNhY2hlZFNwcml0ZURpcnR5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZUNhY2hlZFNwcml0ZSgpO1xuXG4gICAgICAgICAgICAvLyB3ZSB3aWxsIGFsc28gbmVlZCB0byB1cGRhdGUgdGhlIHRleHR1cmUgb24gdGhlIGdwdSB0b28hXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZFNwcml0ZVRleHR1cmUoKTtcblxuICAgICAgICAgICAgdGhpcy5jYWNoZWRTcHJpdGVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLndvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG5cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5yZW5kZXJXZWJHTC5jYWxsKHRoaXMuX2NhY2hlZFNwcml0ZSwgcmVuZGVyZXIpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAqL1xuXG4gICAgaWYgKHRoaXMuZ2xEaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmdsRGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zLmdyYXBoaWNzKTtcbiAgICByZW5kZXJlci5wbHVnaW5zLmdyYXBoaWNzLnJlbmRlcih0aGlzKTtcblxufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7Q2FudmFzUmVuZGVyZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5HcmFwaGljcy5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uIChyZW5kZXJlcilcbntcbiAgICBpZiAodGhpcy5pc01hc2sgPT09IHRydWUpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHRpbnQgaGFzIGNoYW5nZWQsIHNldCB0aGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIGRpcnR5LlxuICAgIGlmICh0aGlzLl9wcmV2VGludCAhPT0gdGhpcy50aW50KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wcmV2VGludCA9IHRoaXMudGludDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2FjaGVBc0JpdG1hcClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5IHx8IHRoaXMuY2FjaGVkU3ByaXRlRGlydHkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlQ2FjaGVkU3ByaXRlKCk7XG5cbiAgICAgICAgICAgIC8vIHdlIHdpbGwgYWxzbyBuZWVkIHRvIHVwZGF0ZSB0aGUgdGV4dHVyZVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRTcHJpdGVUZXh0dXJlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU3ByaXRlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbHBoYSA9IHRoaXMuYWxwaGE7XG5cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzLmNhbGwodGhpcy5fY2FjaGVkU3ByaXRlLCByZW5kZXJlcik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmNvbnRleHQ7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgICAgIGlmICh0aGlzLmJsZW5kTW9kZSAhPT0gcmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSA9IHRoaXMuYmxlbmRNb2RlO1xuICAgICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3JlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShcbiAgICAgICAgICAgIHRyYW5zZm9ybS5hICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgIHRyYW5zZm9ybS5iICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgIHRyYW5zZm9ybS5jICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgIHRyYW5zZm9ybS5kICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgIHRyYW5zZm9ybS50eCAqIHJlc29sdXRpb24sXG4gICAgICAgICAgICB0cmFuc2Zvcm0udHkgKiByZXNvbHV0aW9uXG4gICAgICAgICk7XG5cbiAgICAgICAgQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3ModGhpcywgY29udGV4dCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhpYyBzaGFwZSBhcyBhIHJlY3RhbmdsZSBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhXG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAobWF0cml4KVxue1xuICAgIGlmKCF0aGlzLl9jdXJyZW50Qm91bmRzKVxuICAgIHtcblxuICAgICAgICAvLyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0IGlmIHRoZSBpdGVtIGlzIGEgbWFzayFcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmFibGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLlJlY3RhbmdsZS5FTVBUWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxvY2FsQm91bmRzKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ2xEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZFNwcml0ZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLl9sb2NhbEJvdW5kcztcblxuICAgICAgICB2YXIgdzAgPSBib3VuZHMueDtcbiAgICAgICAgdmFyIHcxID0gYm91bmRzLndpZHRoICsgYm91bmRzLng7XG5cbiAgICAgICAgdmFyIGgwID0gYm91bmRzLnk7XG4gICAgICAgIHZhciBoMSA9IGJvdW5kcy5oZWlnaHQgKyBib3VuZHMueTtcblxuICAgICAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBtYXRyaXggfHwgdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgICAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7XG4gICAgICAgIHZhciBiID0gd29ybGRUcmFuc2Zvcm0uYjtcbiAgICAgICAgdmFyIGMgPSB3b3JsZFRyYW5zZm9ybS5jO1xuICAgICAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7XG4gICAgICAgIHZhciB0eCA9IHdvcmxkVHJhbnNmb3JtLnR4O1xuICAgICAgICB2YXIgdHkgPSB3b3JsZFRyYW5zZm9ybS50eTtcblxuICAgICAgICB2YXIgeDEgPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICAgICAgdmFyIHkxID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG5cbiAgICAgICAgdmFyIHgyID0gYSAqIHcwICsgYyAqIGgxICsgdHg7XG4gICAgICAgIHZhciB5MiA9IGQgKiBoMSArIGIgKiB3MCArIHR5O1xuXG4gICAgICAgIHZhciB4MyA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgICAgICB2YXIgeTMgPSBkICogaDAgKyBiICogdzAgKyB0eTtcblxuICAgICAgICB2YXIgeDQgPSAgYSAqIHcxICsgYyAqIGgwICsgdHg7XG4gICAgICAgIHZhciB5NCA9ICBkICogaDAgKyBiICogdzEgKyB0eTtcblxuICAgICAgICB2YXIgbWF4WCA9IHgxO1xuICAgICAgICB2YXIgbWF4WSA9IHkxO1xuXG4gICAgICAgIHZhciBtaW5YID0geDE7XG4gICAgICAgIHZhciBtaW5ZID0geTE7XG5cbiAgICAgICAgbWluWCA9IHgyIDwgbWluWCA/IHgyIDogbWluWDtcbiAgICAgICAgbWluWCA9IHgzIDwgbWluWCA/IHgzIDogbWluWDtcbiAgICAgICAgbWluWCA9IHg0IDwgbWluWCA/IHg0IDogbWluWDtcblxuICAgICAgICBtaW5ZID0geTIgPCBtaW5ZID8geTIgOiBtaW5ZO1xuICAgICAgICBtaW5ZID0geTMgPCBtaW5ZID8geTMgOiBtaW5ZO1xuICAgICAgICBtaW5ZID0geTQgPCBtaW5ZID8geTQgOiBtaW5ZO1xuXG4gICAgICAgIG1heFggPSB4MiA+IG1heFggPyB4MiA6IG1heFg7XG4gICAgICAgIG1heFggPSB4MyA+IG1heFggPyB4MyA6IG1heFg7XG4gICAgICAgIG1heFggPSB4NCA+IG1heFggPyB4NCA6IG1heFg7XG5cbiAgICAgICAgbWF4WSA9IHkyID4gbWF4WSA/IHkyIDogbWF4WTtcbiAgICAgICAgbWF4WSA9IHkzID4gbWF4WSA/IHkzIDogbWF4WTtcbiAgICAgICAgbWF4WSA9IHk0ID4gbWF4WSA/IHk0IDogbWF4WTtcblxuICAgICAgICB0aGlzLl9ib3VuZHMueCA9IG1pblg7XG4gICAgICAgIHRoaXMuX2JvdW5kcy53aWR0aCA9IG1heFggLSBtaW5YO1xuXG4gICAgICAgIHRoaXMuX2JvdW5kcy55ID0gbWluWTtcbiAgICAgICAgdGhpcy5fYm91bmRzLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCb3VuZHM7XG59O1xuXG4vKipcbiogVGVzdHMgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyBncmFwaGljcyBvYmplY3RcbipcbiogQHBhcmFtIHBvaW50IHtQb2ludH0gdGhlIHBvaW50IHRvIHRlc3RcbiogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgdGVzdFxuKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24oIHBvaW50IClcbntcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgIHRlbXBQb2ludCk7XG5cbiAgICB2YXIgZ3JhcGhpY3NEYXRhID0gdGhpcy5ncmFwaGljc0RhdGE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3NEYXRhW2ldO1xuXG4gICAgICAgIGlmICghZGF0YS5maWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgZGVhbCB3aXRoIGZpbGxzLi5cbiAgICAgICAgaWYgKGRhdGEuc2hhcGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICggZGF0YS5zaGFwZS5jb250YWlucyggdGVtcFBvaW50LngsIHRlbXBQb2ludC55ICkgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGJvdW5kcyBvZiB0aGUgb2JqZWN0XG4gKlxuICovXG5HcmFwaGljcy5wcm90b3R5cGUudXBkYXRlTG9jYWxCb3VuZHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG5cbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgaWYgKHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aClcbiAgICB7XG4gICAgICAgIHZhciBzaGFwZSwgcG9pbnRzLCB4LCB5LCB3LCBoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5ncmFwaGljc0RhdGFbaV07XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBkYXRhLmxpbmVXaWR0aDtcbiAgICAgICAgICAgIHNoYXBlID0gZGF0YS5zaGFwZTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IENPTlNULlNIQVBFUy5SRUNUIHx8IHR5cGUgPT09IENPTlNULlNIQVBFUy5SUkVDKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHggPSBzaGFwZS54IC0gbGluZVdpZHRoLzI7XG4gICAgICAgICAgICAgICAgeSA9IHNoYXBlLnkgLSBsaW5lV2lkdGgvMjtcbiAgICAgICAgICAgICAgICB3ID0gc2hhcGUud2lkdGggKyBsaW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgaCA9IHNoYXBlLmhlaWdodCArIGxpbmVXaWR0aDtcblxuICAgICAgICAgICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICAgICAgICAgIG1heFggPSB4ICsgdyA+IG1heFggPyB4ICsgdyA6IG1heFg7XG5cbiAgICAgICAgICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgICAgICAgICBtYXhZID0geSArIGggPiBtYXhZID8geSArIGggOiBtYXhZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gQ09OU1QuU0hBUEVTLkNJUkMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICAgICAgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICAgICAgdyA9IHNoYXBlLnJhZGl1cyArIGxpbmVXaWR0aC8yO1xuICAgICAgICAgICAgICAgIGggPSBzaGFwZS5yYWRpdXMgKyBsaW5lV2lkdGgvMjtcblxuICAgICAgICAgICAgICAgIG1pblggPSB4IC0gdyA8IG1pblggPyB4IC0gdyA6IG1pblg7XG4gICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcblxuICAgICAgICAgICAgICAgIG1pblkgPSB5IC0gaCA8IG1pblkgPyB5IC0gaCA6IG1pblk7XG4gICAgICAgICAgICAgICAgbWF4WSA9IHkgKyBoID4gbWF4WSA/IHkgKyBoIDogbWF4WTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IENPTlNULlNIQVBFUy5FTElQKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgICAgIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgICAgIHcgPSBzaGFwZS53aWR0aCArIGxpbmVXaWR0aC8yO1xuICAgICAgICAgICAgICAgIGggPSBzaGFwZS5oZWlnaHQgKyBsaW5lV2lkdGgvMjtcblxuICAgICAgICAgICAgICAgIG1pblggPSB4IC0gdyA8IG1pblggPyB4IC0gdyA6IG1pblg7XG4gICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcblxuICAgICAgICAgICAgICAgIG1pblkgPSB5IC0gaCA8IG1pblkgPyB5IC0gaCA6IG1pblk7XG4gICAgICAgICAgICAgICAgbWF4WSA9IHkgKyBoID4gbWF4WSA/IHkgKyBoIDogbWF4WTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBQT0xZXG4gICAgICAgICAgICAgICAgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqICs9IDIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gcG9pbnRzW2orMV07XG5cbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHgtbGluZVdpZHRoIDwgbWluWCA/IHgtbGluZVdpZHRoIDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHgrbGluZVdpZHRoID4gbWF4WCA/IHgrbGluZVdpZHRoIDogbWF4WDtcblxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0geS1saW5lV2lkdGggPCBtaW5ZID8geS1saW5lV2lkdGggOiBtaW5ZO1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0geStsaW5lV2lkdGggPiBtYXhZID8geStsaW5lV2lkdGggOiBtYXhZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBtaW5YID0gMDtcbiAgICAgICAgbWF4WCA9IDA7XG4gICAgICAgIG1pblkgPSAwO1xuICAgICAgICBtYXhZID0gMDtcbiAgICB9XG5cbiAgICB2YXIgcGFkZGluZyA9IHRoaXMuYm91bmRzUGFkZGluZztcblxuICAgIHRoaXMuX2xvY2FsQm91bmRzLnggPSBtaW5YIC0gcGFkZGluZztcbiAgICB0aGlzLl9sb2NhbEJvdW5kcy53aWR0aCA9IChtYXhYIC0gbWluWCkgKyBwYWRkaW5nICogMjtcblxuICAgIHRoaXMuX2xvY2FsQm91bmRzLnkgPSBtaW5ZIC0gcGFkZGluZztcbiAgICB0aGlzLl9sb2NhbEJvdW5kcy5oZWlnaHQgPSAobWF4WSAtIG1pblkpICsgcGFkZGluZyAqIDI7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgY2FjaGVkIHNwcml0ZSB3aGVuIHRoZSBzcHJpdGUgaGFzIGNhY2hlQXNCaXRtYXAgPSB0cnVlXG4gKlxuICogQHByaXZhdGVcbiAqL1xuLypcbkdyYXBoaWNzLnByb3RvdHlwZS5fZ2VuZXJhdGVDYWNoZWRTcHJpdGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBib3VuZHMgPSB0aGlzLmdldExvY2FsQm91bmRzKCk7XG5cbiAgICBpZiAoIXRoaXMuX2NhY2hlZFNwcml0ZSlcbiAgICB7XG4gICAgICAgIHZhciBjYW52YXNCdWZmZXIgPSBuZXcgQ2FudmFzQnVmZmVyKGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gVGV4dHVyZS5mcm9tQ2FudmFzKGNhbnZhc0J1ZmZlci5jYW52YXMpO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZSA9IG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5idWZmZXIgPSBjYW52YXNCdWZmZXI7XG5cbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLndvcmxkVHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlci5yZXNpemUoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBsZXZlcmFnZSB0aGUgYW5jaG9yIHRvIGFjY291bnQgZm9yIHRoZSBvZmZzZXQgb2YgdGhlIGVsZW1lbnRcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYW5jaG9yLnggPSAtKCBib3VuZHMueCAvIGJvdW5kcy53aWR0aCApO1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbmNob3IueSA9IC0oIGJvdW5kcy55IC8gYm91bmRzLmhlaWdodCApO1xuXG4gICAgLy8gdGhpcy5fY2FjaGVkU3ByaXRlLmJ1ZmZlci5jb250ZXh0LnNhdmUoKTtcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYnVmZmVyLmNvbnRleHQudHJhbnNsYXRlKC1ib3VuZHMueCwtYm91bmRzLnkpO1xuXG4gICAgLy8gbWFrZSBzdXJlIHdlIHNldCB0aGUgYWxwaGEgb2YgdGhlIGdyYXBoaWNzIHRvIDEgZm9yIHRoZSByZW5kZXIuLlxuICAgIHRoaXMud29ybGRBbHBoYSA9IDE7XG5cbiAgICAvLyBub3cgcmVuZGVyIHRoZSBncmFwaGljLi5cbiAgICBDYW52YXNHcmFwaGljcy5yZW5kZXJHcmFwaGljcyh0aGlzLCB0aGlzLl9jYWNoZWRTcHJpdGUuYnVmZmVyLmNvbnRleHQpO1xuXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFscGhhID0gdGhpcy5hbHBoYTtcbn07XG4qL1xuLyoqXG4gKiBVcGRhdGVzIHRleHR1cmUgc2l6ZSBiYXNlZCBvbiBjYW52YXMgc2l6ZVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbi8qXG5HcmFwaGljcy5wcm90b3R5cGUudXBkYXRlQ2FjaGVkU3ByaXRlVGV4dHVyZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGNhY2hlZFNwcml0ZSA9IHRoaXMuX2NhY2hlZFNwcml0ZTtcbiAgICB2YXIgdGV4dHVyZSA9IGNhY2hlZFNwcml0ZS50ZXh0dXJlO1xuICAgIHZhciBjYW52YXMgPSBjYWNoZWRTcHJpdGUuYnVmZmVyLmNhbnZhcztcblxuICAgIHRleHR1cmUuYmFzZVRleHR1cmUud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgIHRleHR1cmUuY3JvcC53aWR0aCA9IHRleHR1cmUuZnJhbWUud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgdGV4dHVyZS5jcm9wLmhlaWdodCA9IHRleHR1cmUuZnJhbWUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcblxuICAgIGNhY2hlZFNwcml0ZS5fd2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgY2FjaGVkU3ByaXRlLl9oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuXG4gICAgLy8gdXBkYXRlIHRoZSBkaXJ0eSBiYXNlIHRleHR1cmVzXG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5kaXJ0eSgpO1xufTsqL1xuXG4vKipcbiAqIERlc3Ryb3lzIGEgcHJldmlvdXMgY2FjaGVkIHNwcml0ZS5cbiAqXG4gKi9cbi8qXG5HcmFwaGljcy5wcm90b3R5cGUuZGVzdHJveUNhY2hlZFNwcml0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLnRleHR1cmUuZGVzdHJveSh0cnVlKTtcblxuICAgIC8vIGxldCB0aGUgZ2MgY29sbGVjdCB0aGUgdW51c2VkIHNwcml0ZVxuICAgIC8vIFRPRE8gY291bGQgYmUgb2JqZWN0IHBvb2xlZCFcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUgPSBudWxsO1xufTsqL1xuXG4vKipcbiAqIERyYXdzIHRoZSBnaXZlbiBzaGFwZSB0byB0aGlzIEdyYXBoaWNzIG9iamVjdC4gQ2FuIGJlIGFueSBvZiBDaXJjbGUsIFJlY3RhbmdsZSwgRWxsaXBzZSwgTGluZSBvciBQb2x5Z29uLlxuICpcbiAqIEBwYXJhbSBzaGFwZSB7Q2lyY2xlfFJlY3RhbmdsZXxFbGxpcHNlfExpbmV8UG9seWdvbn0gVGhlIHNoYXBlIG9iamVjdCB0byBkcmF3LlxuICogQHJldHVybiB7R3JhcGhpY3NEYXRhfSBUaGUgZ2VuZXJhdGVkIEdyYXBoaWNzRGF0YSBvYmplY3QuXG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3U2hhcGUgPSBmdW5jdGlvbiAoc2hhcGUpXG57XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgpXG4gICAge1xuICAgICAgICAvLyBjaGVjayBjdXJyZW50IHBhdGghXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPD0gMilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcblxuICAgIHZhciBkYXRhID0gbmV3IEdyYXBoaWNzRGF0YSh0aGlzLmxpbmVXaWR0aCwgdGhpcy5saW5lQ29sb3IsIHRoaXMubGluZUFscGhhLCB0aGlzLmZpbGxDb2xvciwgdGhpcy5maWxsQWxwaGEsIHRoaXMuZmlsbGluZywgc2hhcGUpO1xuXG4gICAgdGhpcy5ncmFwaGljc0RhdGEucHVzaChkYXRhKTtcblxuICAgIGlmIChkYXRhLnR5cGUgPT09IENPTlNULlNIQVBFUy5QT0xZKVxuICAgIHtcbiAgICAgICAgZGF0YS5zaGFwZS5jbG9zZWQgPSB0aGlzLmZpbGxpbmc7XG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBkYXRhO1xuICAgIH1cblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGRhdGE7XG59O1xuIiwiLyoqXG4gKiBBIEdyYXBoaWNzRGF0YSBvYmplY3QuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIGxpbmVXaWR0aCB7bnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIGxpbmUgdG8gZHJhd1xuICogQHBhcmFtIGxpbmVDb2xvciB7bnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIGxpbmUgdG8gZHJhd1xuICogQHBhcmFtIGxpbmVBbHBoYSB7bnVtYmVyfSB0aGUgYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhd1xuICogQHBhcmFtIGZpbGxDb2xvciB7bnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIGZpbGxcbiAqIEBwYXJhbSBmaWxsQWxwaGEge251bWJlcn0gdGhlIGFscGhhIG9mIHRoZSBmaWxsXG4gKiBAcGFyYW0gZmlsbCAgICAgIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgc2hhcGUgaXMgZmlsbGVkIHdpdGggYSBjb2xvdXJcbiAqIEBwYXJhbSBzaGFwZSAgICAge0NpcmNsZXxSZWN0YW5nbGV8RWxsaXBzZXxMaW5lfFBvbHlnb259IFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cbiAqL1xuZnVuY3Rpb24gR3JhcGhpY3NEYXRhKGxpbmVXaWR0aCwgbGluZUNvbG9yLCBsaW5lQWxwaGEsIGZpbGxDb2xvciwgZmlsbEFscGhhLCBmaWxsLCBzaGFwZSlcbntcbiAgICAvKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGRyYXdcbiAgICAgKi9cbiAgICB0aGlzLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSB0aGUgY29sb3Igb2YgdGhlIGxpbmUgdG8gZHJhd1xuICAgICAqL1xuICAgIHRoaXMubGluZUNvbG9yID0gbGluZUNvbG9yO1xuICAgIC8qXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSB0aGUgYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhd1xuICAgICAqL1xuICAgIHRoaXMubGluZUFscGhhID0gbGluZUFscGhhO1xuICAgIC8qXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBjYWNoZWQgdGludCBvZiB0aGUgbGluZSB0byBkcmF3XG4gICAgICovXG4gICAgdGhpcy5fbGluZVRpbnQgPSBsaW5lQ29sb3I7XG5cbiAgICAvKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGhlIGNvbG9yIG9mIHRoZSBmaWxsXG4gICAgICovXG4gICAgdGhpcy5maWxsQ29sb3IgPSBmaWxsQ29sb3I7XG5cbiAgICAvKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGhlIGFscGhhIG9mIHRoZSBmaWxsXG4gICAgICovXG4gICAgdGhpcy5maWxsQWxwaGEgPSBmaWxsQWxwaGE7XG5cbiAgICAvKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gY2FjaGVkIHRpbnQgb2YgdGhlIGZpbGxcbiAgICAgKi9cbiAgICB0aGlzLl9maWxsVGludCA9IGZpbGxDb2xvcjtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIHNoYXBlIGlzIGZpbGxlZCB3aXRoIGEgY29sb3VyXG4gICAgICovXG4gICAgdGhpcy5maWxsID0gZmlsbDtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7Q2lyY2xlfFJlY3RhbmdsZXxFbGxpcHNlfExpbmV8UG9seWdvbn0gVGhlIHNoYXBlIG9iamVjdCB0byBkcmF3LlxuICAgICAqL1xuICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBUaGUgdHlwZSBvZiB0aGUgc2hhcGUsIHNlZSB0aGUgQ29uc3QuU2hhcGVzIGZpbGUgZm9yIGFsbCB0aGUgZXhpc3RpbmcgdHlwZXMsXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gc2hhcGUudHlwZTtcbn1cblxuR3JhcGhpY3NEYXRhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyYXBoaWNzRGF0YTtcbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3NEYXRhO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgR3JhcGhpY3NEYXRhIG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHtHcmFwaGljc0RhdGF9XG4gKi9cbkdyYXBoaWNzRGF0YS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBuZXcgR3JhcGhpY3NEYXRhKFxuICAgICAgICB0aGlzLmxpbmVXaWR0aCxcbiAgICAgICAgdGhpcy5saW5lQ29sb3IsXG4gICAgICAgIHRoaXMubGluZUFscGhhLFxuICAgICAgICB0aGlzLmZpbGxDb2xvcixcbiAgICAgICAgdGhpcy5maWxsQWxwaGEsXG4gICAgICAgIHRoaXMuZmlsbCxcbiAgICAgICAgdGhpcy5zaGFwZVxuICAgICk7XG59O1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKSxcbiAgICBtYXRoID0gcmVxdWlyZSgnLi4vLi4vbWF0aCcpLFxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKSxcbiAgICBPYmplY3RSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy93ZWJnbC91dGlscy9PYmplY3RSZW5kZXJlcicpLFxuICAgIFdlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xSZW5kZXJlcicpLFxuICAgIFdlYkdMR3JhcGhpY3NEYXRhID0gcmVxdWlyZSgnLi9XZWJHTEdyYXBoaWNzRGF0YScpO1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGdyYXBoaWNzIG9iamVjdC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgT2JqZWN0UmVuZGVyZXJcbiAqIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHRoaXMgb2JqZWN0IHJlbmRlcmVyIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gR3JhcGhpY3NSZW5kZXJlcihyZW5kZXJlcilcbntcbiAgICBPYmplY3RSZW5kZXJlci5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcblxuICAgIHRoaXMuZ3JhcGhpY3NEYXRhUG9vbCA9IFtdO1xuXG4gICAgdGhpcy5wcmltaXRpdmVTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuY29tcGxleFByaW1pdGl2ZVNoYWRlciA9IG51bGw7XG59XG5cbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPYmplY3RSZW5kZXJlci5wcm90b3R5cGUpO1xuR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmFwaGljc1JlbmRlcmVyO1xubW9kdWxlLmV4cG9ydHMgPSBHcmFwaGljc1JlbmRlcmVyO1xuXG5XZWJHTFJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdncmFwaGljcycsIEdyYXBoaWNzUmVuZGVyZXIpO1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZXJlIGlzIGEgV2ViR0wgY29udGV4dCBjaGFuZ2VcbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqL1xuR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24oKVxue1xuXG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgcmVuZGVyZXIuXG4gKlxuICovXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmdyYXBoaWNzRGF0YVBvb2wgPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIGEgZ3JhcGhpY3Mgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBncmFwaGljcyB7R3JhcGhpY3N9IFRoZSBncmFwaGljcyBvYmplY3QgdG8gcmVuZGVyLlxuICovXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihncmFwaGljcylcbntcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xuXG4gICAgdmFyIHNoYWRlciA9IHJlbmRlcmVyLnNoYWRlck1hbmFnZXIucGx1Z2lucy5wcmltaXRpdmVTaGFkZXIsXG4gICAgICAgIHdlYkdMRGF0YTtcblxuICAgIGlmIChncmFwaGljcy5kaXJ0eSlcbiAgICB7XG4gICAgICAgIHRoaXMudXBkYXRlR3JhcGhpY3MoZ3JhcGhpY3MsIGdsKTtcbiAgICB9XG5cbiAgICB2YXIgd2ViR0wgPSBncmFwaGljcy5fd2ViR0xbZ2wuaWRdO1xuXG4gICAgLy8gVGhpcyAgY291bGQgYmUgc3BlZWRlZCB1cCBmb3Igc3VyZSFcblxuICAgIHJlbmRlcmVyLmJsZW5kTW9kZU1hbmFnZXIuc2V0QmxlbmRNb2RlKCBncmFwaGljcy5ibGVuZE1vZGUgKTtcblxuLy8gICAgdmFyIG1hdHJpeCA9ICBncmFwaGljcy53b3JsZFRyYW5zZm9ybS5jbG9uZSgpO1xuLy8gICAgdmFyIG1hdHJpeCA9ICByZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXguY2xvbmUoKTtcbi8vICAgIG1hdHJpeC5hcHBlbmQoZ3JhcGhpY3Mud29ybGRUcmFuc2Zvcm0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3ZWJHTC5kYXRhLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKHdlYkdMLmRhdGFbaV0ubW9kZSA9PT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gd2ViR0wuZGF0YVtpXTtcblxuICAgICAgICAgICAgcmVuZGVyZXIuc3RlbmNpbE1hbmFnZXIucHVzaFN0ZW5jaWwoZ3JhcGhpY3MsIHdlYkdMRGF0YSwgcmVuZGVyZXIpO1xuXG4gICAgICAgICAgICAvLyByZW5kZXIgcXVhZC4uXG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfRkFOLCA0LCBnbC5VTlNJR05FRF9TSE9SVCwgKCB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGggLSA0ICkgKiAyICk7XG5cbiAgICAgICAgICAgIHJlbmRlcmVyLnN0ZW5jaWxNYW5hZ2VyLnBvcFN0ZW5jaWwoZ3JhcGhpY3MsIHdlYkdMRGF0YSwgcmVuZGVyZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gd2ViR0wuZGF0YVtpXTtcblxuXG4gICAgICAgICAgICBzaGFkZXIgPSByZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnByaW1pdGl2ZVNoYWRlcjtcblxuICAgICAgICAgICAgcmVuZGVyZXIuc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoIHNoYWRlciApOy8vYWN0aXZhdGVQcmltaXRpdmVTaGFkZXIoKTtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgZ3JhcGhpY3Mud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKSk7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgcmVuZGVyZXIuY3VycmVudFJlbmRlclRhcmdldC5wcm9qZWN0aW9uTWF0cml4LnRvQXJyYXkodHJ1ZSkpO1xuXG4gICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHNoYWRlci51bmlmb3Jtcy50aW50Ll9sb2NhdGlvbiwgdXRpbHMuaGV4MnJnYihncmFwaGljcy50aW50KSk7XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybXMuYWxwaGEuX2xvY2F0aW9uLCBncmFwaGljcy53b3JsZEFscGhhKTtcblxuXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmJ1ZmZlcik7XG5cbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiA2LCAwKTtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCA0LCBnbC5GTE9BVCwgZmFsc2UsNCAqIDYsIDIgKiA0KTtcblxuICAgICAgICAgICAgLy8gc2V0IHRoZSBpbmRleCBidWZmZXIhXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB3ZWJHTERhdGEuaW5kZXhCdWZmZXIpO1xuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX1NUUklQLCAgd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBncmFwaGljcyBvYmplY3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7R3JhcGhpY3N9IFRoZSBncmFwaGljcyBvYmplY3QgdG8gdXBkYXRlXG4gKi9cbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUdyYXBoaWNzID0gZnVuY3Rpb24oZ3JhcGhpY3MpXG57XG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgICAvLyBnZXQgdGhlIGNvbnRleHRzIGdyYXBoaWNzIG9iamVjdFxuICAgIHZhciB3ZWJHTCA9IGdyYXBoaWNzLl93ZWJHTFtnbC5pZF07XG5cbiAgICAvLyBpZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0IGRvZXMgbm90IGV4aXN0IGluIHRoZSB3ZWJHTCBjb250ZXh0IHRpbWUgdG8gY3JlYXRlIGl0IVxuICAgIGlmICghd2ViR0wpXG4gICAge1xuICAgICAgICB3ZWJHTCA9IGdyYXBoaWNzLl93ZWJHTFtnbC5pZF0gPSB7bGFzdEluZGV4OjAsIGRhdGE6W10sIGdsOmdsfTtcbiAgICB9XG5cbiAgICAvLyBmbGFnIHRoZSBncmFwaGljcyBhcyBub3QgZGlydHkgYXMgd2UgYXJlIGFib3V0IHRvIHVwZGF0ZSBpdC4uLlxuICAgIGdyYXBoaWNzLmRpcnR5ID0gZmFsc2U7XG5cbiAgICB2YXIgaTtcblxuICAgIC8vIGlmIHRoZSB1c2VyIGNsZWFyZWQgdGhlIGdyYXBoaWNzIG9iamVjdCB3ZSB3aWxsIG5lZWQgdG8gY2xlYXIgZXZlcnkgb2JqZWN0XG4gICAgaWYgKGdyYXBoaWNzLmNsZWFyRGlydHkpXG4gICAge1xuICAgICAgICBncmFwaGljcy5jbGVhckRpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gbG9wIHRocm91Z2ggYW5kIHJldHVybiBhbGwgdGhlIHdlYkdMRGF0YXMgdG8gdGhlIG9iamVjdCBwb29sIHNvIHRoYW4gY2FuIGJlIHJldXNlZCBsYXRlciBvblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgd2ViR0wuZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGdyYXBoaWNzRGF0YSA9IHdlYkdMLmRhdGFbaV07XG4gICAgICAgICAgICBncmFwaGljc0RhdGEucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhUG9vbC5wdXNoKCBncmFwaGljc0RhdGEgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBhcnJheSBhbmQgcmVzZXQgdGhlIGluZGV4Li5cbiAgICAgICAgd2ViR0wuZGF0YSA9IFtdO1xuICAgICAgICB3ZWJHTC5sYXN0SW5kZXggPSAwO1xuICAgIH1cblxuICAgIHZhciB3ZWJHTERhdGE7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggdGhlIGdyYXBoaWNzIGRhdGFzIGFuZCBjb25zdHJ1Y3QgZWFjaCBvbmUuLlxuICAgIC8vIGlmIHRoZSBvYmplY3QgaXMgYSBjb21wbGV4IGZpbGwgdGhlbiB0aGUgbmV3IHN0ZW5jaWwgYnVmZmVyIHRlY2huaXF1ZSB3aWxsIGJlIHVzZWRcbiAgICAvLyBvdGhlciB3aXNlIGdyYXBoaWNzIG9iamVjdHMgd2lsbCBiZSBwdXNoZWQgaW50byBhIGJhdGNoLi5cbiAgICBmb3IgKGkgPSB3ZWJHTC5sYXN0SW5kZXg7IGkgPCBncmFwaGljcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgZGF0YSA9IGdyYXBoaWNzLmdyYXBoaWNzRGF0YVtpXTtcblxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUE9MWSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gbmVlZCB0byBhZGQgdGhlIHBvaW50cyB0aGUgdGhlIGdyYXBoaWNzIG9iamVjdC4uXG4gICAgICAgICAgICBkYXRhLnBvaW50cyA9IGRhdGEuc2hhcGUucG9pbnRzLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoZGF0YS5zaGFwZS5jbG9zZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gY2xvc2UgdGhlIHBvbHkgaWYgdGhlIHZhbHVlIGlzIHRydWUhXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucG9pbnRzWzBdICE9PSBkYXRhLnBvaW50c1tkYXRhLnBvaW50cy5sZW5ndGgtMl0gfHwgZGF0YS5wb2ludHNbMV0gIT09IGRhdGEucG9pbnRzW2RhdGEucG9pbnRzLmxlbmd0aC0xXSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucG9pbnRzLnB1c2goZGF0YS5wb2ludHNbMF0sIGRhdGEucG9pbnRzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1BS0UgU1VSRSBXRSBIQVZFIFRIRSBDT1JSRUNUIFRZUEUuLlxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb2ludHMubGVuZ3RoID49IDYpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb2ludHMubGVuZ3RoIDwgNiAqIDIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYkdMRGF0YSA9IHRoaXMuc3dpdGNoTW9kZSh3ZWJHTCwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5EcmF3VXNpbmdTaW1wbGUgPSB0aGlzLmJ1aWxkUG9seShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhjYW5EcmF3VXNpbmdTaW1wbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbkRyYXdVc2luZ1NpbXBsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIGNvbnNvbGUubG9nKFwiPD4+PlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYkdMRGF0YSA9IHRoaXMuc3dpdGNoTW9kZSh3ZWJHTCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZENvbXBsZXhQb2x5KGRhdGEsIHdlYkdMRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYkdMRGF0YSA9IHRoaXMuc3dpdGNoTW9kZSh3ZWJHTCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkQ29tcGxleFBvbHkoZGF0YSwgd2ViR0xEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEubGluZVdpZHRoID4gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3ZWJHTERhdGEgPSB0aGlzLnN3aXRjaE1vZGUod2ViR0wsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRMaW5lKGRhdGEsIHdlYkdMRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB3ZWJHTERhdGEgPSB0aGlzLnN3aXRjaE1vZGUod2ViR0wsIDApO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUkVDVClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUmVjdGFuZ2xlKGRhdGEsIHdlYkdMRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLnR5cGUgPT09IENPTlNULlNIQVBFUy5DSVJDIHx8IGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLkVMSVApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZENpcmNsZShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUlJFQylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUm91bmRlZFJlY3RhbmdsZShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2ViR0wubGFzdEluZGV4Kys7XG4gICAgfVxuXG4gICAgLy8gdXBsb2FkIGFsbCB0aGUgZGlydHkgZGF0YS4uLlxuICAgIGZvciAoaSA9IDA7IGkgPCB3ZWJHTC5kYXRhLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgd2ViR0xEYXRhID0gd2ViR0wuZGF0YVtpXTtcblxuICAgICAgICBpZiAod2ViR0xEYXRhLmRpcnR5KVxuICAgICAgICB7XG4gICAgICAgICAgICB3ZWJHTERhdGEudXBsb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB3ZWJHTCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiAqIEBwYXJhbSB0eXBlIHtudW1iZXJ9IFRPRE8gQEFsdmluXG4gKi9cbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLnN3aXRjaE1vZGUgPSBmdW5jdGlvbiAod2ViR0wsIHR5cGUpXG57XG4gICAgdmFyIHdlYkdMRGF0YTtcblxuICAgIGlmICghd2ViR0wuZGF0YS5sZW5ndGgpXG4gICAge1xuICAgICAgICB3ZWJHTERhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YVBvb2wucG9wKCkgfHwgbmV3IFdlYkdMR3JhcGhpY3NEYXRhKHdlYkdMLmdsKTtcbiAgICAgICAgd2ViR0xEYXRhLm1vZGUgPSB0eXBlO1xuICAgICAgICB3ZWJHTC5kYXRhLnB1c2god2ViR0xEYXRhKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgd2ViR0xEYXRhID0gd2ViR0wuZGF0YVt3ZWJHTC5kYXRhLmxlbmd0aC0xXTtcblxuICAgICAgICBpZiAoKHdlYkdMRGF0YS5wb2ludHMubGVuZ3RoID4gMzIwMDAwKSB8fCB3ZWJHTERhdGEubW9kZSAhPT0gdHlwZSB8fCB0eXBlID09PSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICB3ZWJHTERhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YVBvb2wucG9wKCkgfHwgbmV3IFdlYkdMR3JhcGhpY3NEYXRhKHdlYkdMLmdsKTtcbiAgICAgICAgICAgIHdlYkdMRGF0YS5tb2RlID0gdHlwZTtcbiAgICAgICAgICAgIHdlYkdMLmRhdGEucHVzaCh3ZWJHTERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2ViR0xEYXRhLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB3ZWJHTERhdGE7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHJlY3RhbmdsZSB0byBkcmF3XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBncmFwaGljc0RhdGEge0dyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICogQHBhcmFtIHdlYkdMRGF0YSB7b2JqZWN0fSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4gKi9cbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkUmVjdGFuZ2xlID0gZnVuY3Rpb24gKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKVxue1xuICAgIC8vIC0tLSAvL1xuICAgIC8vIG5lZWQgdG8gY29udmVydCBwb2ludHMgdG8gYSBuaWNlIHJlZ3VsYXIgZGF0YVxuICAgIC8vXG4gICAgdmFyIHJlY3REYXRhID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgIHZhciB4ID0gcmVjdERhdGEueDtcbiAgICB2YXIgeSA9IHJlY3REYXRhLnk7XG4gICAgdmFyIHdpZHRoID0gcmVjdERhdGEud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJlY3REYXRhLmhlaWdodDtcblxuICAgIGlmIChncmFwaGljc0RhdGEuZmlsbClcbiAgICB7XG4gICAgICAgIHZhciBjb2xvciA9IHV0aWxzLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxDb2xvcik7XG4gICAgICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XG5cbiAgICAgICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgICAgICB2YXIgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgICAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuXG4gICAgICAgIHZhciB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoLzY7XG5cbiAgICAgICAgLy8gc3RhcnRcbiAgICAgICAgdmVydHMucHVzaCh4LCB5KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICB2ZXJ0cy5wdXNoKHggLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAvLyBpbnNlcnQgMiBkZWFkIHRyaWFuZ2xlcy4uXG4gICAgICAgIGluZGljZXMucHVzaCh2ZXJ0UG9zLCB2ZXJ0UG9zLCB2ZXJ0UG9zKzEsIHZlcnRQb3MrMiwgdmVydFBvcyszLCB2ZXJ0UG9zKzMpO1xuICAgIH1cblxuICAgIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoKVxuICAgIHtcbiAgICAgICAgdmFyIHRlbXBQb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSBbeCwgeSxcbiAgICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSxcbiAgICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSArIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgIHgsIHkgKyBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICB4LCB5XTtcblxuXG4gICAgICAgIHRoaXMuYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHJvdW5kZWQgcmVjdGFuZ2xlIHRvIGRyYXdcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7R3JhcGhpY3N9IFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gd2ViR0xEYXRhIHtvYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgd2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoaXMgc2hhcGVcbiAqL1xuR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRSb3VuZGVkUmVjdGFuZ2xlID0gZnVuY3Rpb24gKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKVxue1xuICAgIHZhciBycmVjdERhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgdmFyIHggPSBycmVjdERhdGEueDtcbiAgICB2YXIgeSA9IHJyZWN0RGF0YS55O1xuICAgIHZhciB3aWR0aCA9IHJyZWN0RGF0YS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gcnJlY3REYXRhLmhlaWdodDtcblxuICAgIHZhciByYWRpdXMgPSBycmVjdERhdGEucmFkaXVzO1xuXG4gICAgdmFyIHJlY1BvaW50cyA9IFtdO1xuICAgIHJlY1BvaW50cy5wdXNoKHgsIHkgKyByYWRpdXMpO1xuICAgIHRoaXMucXVhZHJhdGljQmV6aWVyQ3VydmUoeCwgeSArIGhlaWdodCAtIHJhZGl1cywgeCwgeSArIGhlaWdodCwgeCArIHJhZGl1cywgeSArIGhlaWdodCwgcmVjUG9pbnRzKTtcbiAgICB0aGlzLnF1YWRyYXRpY0JlemllckN1cnZlKHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMsIHJlY1BvaW50cyk7XG4gICAgdGhpcy5xdWFkcmF0aWNCZXppZXJDdXJ2ZSh4ICsgd2lkdGgsIHkgKyByYWRpdXMsIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoIC0gcmFkaXVzLCB5LCByZWNQb2ludHMpO1xuICAgIHRoaXMucXVhZHJhdGljQmV6aWVyQ3VydmUoeCArIHJhZGl1cywgeSwgeCwgeSwgeCwgeSArIHJhZGl1cyArIDAuMDAwMDAwMDAwMSwgcmVjUG9pbnRzKTtcbiAgICAvLyB0aGlzIHRpbnkgbnVtYmVyIGRlYWxzIHdpdGggdGhlIGlzc3VlIHRoYXQgb2NjdXJzIHdoZW4gcG9pbnRzIG92ZXJsYXAgYW5kIHBvbHlLIGZhaWxzIHRvIHRyaWFuZ3VsYXRlIHRoZSBpdGVtLlxuICAgIC8vIFRPRE8gLSBmaXggdGhpcyBwcm9wZXJseSwgdGhpcyBpcyBub3QgdmVyeSBlbGVnYW50Li4gYnV0IGl0IHdvcmtzIGZvciBub3cuXG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmZpbGwpXG4gICAge1xuICAgICAgICB2YXIgY29sb3IgPSB1dGlscy5oZXgycmdiKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xuICAgICAgICB2YXIgYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuXG4gICAgICAgIHZhciByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgICAgICB2YXIgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICAgICAgdmFyIHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICAgICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcblxuICAgICAgICB2YXIgdmVjUG9zID0gdmVydHMubGVuZ3RoLzY7XG5cbiAgICAgICAgLy9UT0RPIHVzZSB0aGlzIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0XG4gICAgICAgIHZhciB0cmlhbmdsZXMgPSB1dGlscy5Qb2x5Sy5Ucmlhbmd1bGF0ZShyZWNQb2ludHMpO1xuICAgICAgICAvL1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkrPTMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaV0gKyB2ZWNQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlY1Bvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2krMV0gKyB2ZWNQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpKzJdICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSsyXSArIHZlY1Bvcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVjUG9pbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHJlY1BvaW50c1tpXSwgcmVjUG9pbnRzWysraV0sIHIsIGcsIGIsIGFscGhhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoKVxuICAgIHtcbiAgICAgICAgdmFyIHRlbXBQb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSByZWNQb2ludHM7XG5cbiAgICAgICAgdGhpcy5idWlsZExpbmUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSB0ZW1wUG9pbnRzO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZS4gKGhlbHBlciBmdW5jdGlvbi4uKVxuICogQmFzZWQgb246IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZnJvbVgge251bWJlcn0gT3JpZ2luIHBvaW50IHhcbiAqIEBwYXJhbSBmcm9tWSB7bnVtYmVyfSBPcmlnaW4gcG9pbnQgeFxuICogQHBhcmFtIGNwWCB7bnVtYmVyfSBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSBjcFkge251bWJlcn0gQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0gdG9YIHtudW1iZXJ9IERlc3RpbmF0aW9uIHBvaW50IHhcbiAqIEBwYXJhbSB0b1kge251bWJlcn0gRGVzdGluYXRpb24gcG9pbnQgeVxuICogQHBhcmFtIFtvdXRdIHtudW1iZXJbXX0gVGhlIG91dHB1dCBhcnJheSB0byBhZGQgcG9pbnRzIGludG8uIElmIG5vdCBwYXNzZWQsIGEgbmV3IGFycmF5IGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJbXX0gYW4gYXJyYXkgb2YgcG9pbnRzXG4gKi9cbkdyYXBoaWNzUmVuZGVyZXIucHJvdG90eXBlLnF1YWRyYXRpY0JlemllckN1cnZlID0gZnVuY3Rpb24gKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIHRvWCwgdG9ZLCBvdXQpXG57XG4gICAgdmFyIHhhLFxuICAgICAgICB5YSxcbiAgICAgICAgeGIsXG4gICAgICAgIHliLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBuID0gMjAsXG4gICAgICAgIHBvaW50cyA9IG91dCB8fCBbXTtcblxuICAgIGZ1bmN0aW9uIGdldFB0KG4xICwgbjIsIHBlcmMpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBuMiAtIG4xO1xuXG4gICAgICAgIHJldHVybiBuMSArICggZGlmZiAqIHBlcmMgKTtcbiAgICB9XG5cbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSsrICkge1xuICAgICAgICBqID0gaSAvIG47XG5cbiAgICAgICAgLy8gVGhlIEdyZWVuIExpbmVcbiAgICAgICAgeGEgPSBnZXRQdCggZnJvbVggLCBjcFggLCBqICk7XG4gICAgICAgIHlhID0gZ2V0UHQoIGZyb21ZICwgY3BZICwgaiApO1xuICAgICAgICB4YiA9IGdldFB0KCBjcFggLCB0b1ggLCBqICk7XG4gICAgICAgIHliID0gZ2V0UHQoIGNwWSAsIHRvWSAsIGogKTtcblxuICAgICAgICAvLyBUaGUgQmxhY2sgRG90XG4gICAgICAgIHggPSBnZXRQdCggeGEgLCB4YiAsIGogKTtcbiAgICAgICAgeSA9IGdldFB0KCB5YSAsIHliICwgaiApO1xuXG4gICAgICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludHM7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIGNpcmNsZSB0byBkcmF3XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBncmFwaGljc0RhdGEge0dyYXBoaWNzfSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIGRyYXdcbiAqIEBwYXJhbSB3ZWJHTERhdGEge29iamVjdH0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICovXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZENpcmNsZSA9IGZ1bmN0aW9uIChncmFwaGljc0RhdGEsIHdlYkdMRGF0YSlcbntcbiAgICAvLyBuZWVkIHRvIGNvbnZlcnQgcG9pbnRzIHRvIGEgbmljZSByZWd1bGFyIGRhdGFcbiAgICB2YXIgY2lyY2xlRGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICB2YXIgeCA9IGNpcmNsZURhdGEueDtcbiAgICB2YXIgeSA9IGNpcmNsZURhdGEueTtcbiAgICB2YXIgd2lkdGg7XG4gICAgdmFyIGhlaWdodDtcblxuICAgIC8vIFRPRE8gLSBiaXQgaGFja3k/P1xuICAgIGlmIChncmFwaGljc0RhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLkNJUkMpXG4gICAge1xuICAgICAgICB3aWR0aCA9IGNpcmNsZURhdGEucmFkaXVzO1xuICAgICAgICBoZWlnaHQgPSBjaXJjbGVEYXRhLnJhZGl1cztcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgd2lkdGggPSBjaXJjbGVEYXRhLndpZHRoO1xuICAgICAgICBoZWlnaHQgPSBjaXJjbGVEYXRhLmhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgdG90YWxTZWdzID0gNDA7XG4gICAgdmFyIHNlZyA9IChNYXRoLlBJICogMikgLyB0b3RhbFNlZ3MgO1xuXG4gICAgdmFyIGkgPSAwO1xuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5maWxsKVxuICAgIHtcbiAgICAgICAgdmFyIGNvbG9yID0gdXRpbHMuaGV4MnJnYihncmFwaGljc0RhdGEuZmlsbENvbG9yKTtcbiAgICAgICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcblxuICAgICAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICAgICAgdmFyIGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG5cbiAgICAgICAgdmFyIHZlY1BvcyA9IHZlcnRzLmxlbmd0aC82O1xuXG4gICAgICAgIGluZGljZXMucHVzaCh2ZWNQb3MpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbFNlZ3MgKyAxIDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHgseSwgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHggKyBNYXRoLnNpbihzZWcgKiBpKSAqIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICB5ICsgTWF0aC5jb3Moc2VnICogaSkgKiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHZlY1BvcysrLCB2ZWNQb3MrKyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRpY2VzLnB1c2godmVjUG9zLTEpO1xuICAgIH1cblxuICAgIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoKVxuICAgIHtcbiAgICAgICAgdmFyIHRlbXBQb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxTZWdzICsgMTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzLnB1c2goeCArIE1hdGguc2luKHNlZyAqIGkpICogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArIE1hdGguY29zKHNlZyAqIGkpICogaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhd1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ3JhcGhpY3NEYXRhIHtHcmFwaGljc30gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB3ZWJHTERhdGEge29iamVjdH0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICovXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZExpbmUgPSBmdW5jdGlvbiAoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgLy8gVE9ETyBPUFRJTUlTRSFcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgbGluZSB3aWR0aCBpcyBhbiBvZGQgbnVtYmVyIGFkZCAwLjUgdG8gYWxpZ24gdG8gYSB3aG9sZSBwaXhlbFxuICAgIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoJTIpXG4gICAge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBwb2ludHNbaV0gKz0gMC41O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2V0IGZpcnN0IGFuZCBsYXN0IHBvaW50Li4gZmlndXJlIG91dCB0aGUgbWlkZGxlIVxuICAgIHZhciBmaXJzdFBvaW50ID0gbmV3IG1hdGguUG9pbnQocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgIHZhciBsYXN0UG9pbnQgPSBuZXcgbWF0aC5Qb2ludChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcblxuICAgIC8vIGlmIHRoZSBmaXJzdCBwb2ludCBpcyB0aGUgbGFzdCBwb2ludCAtIGdvbm5hIGhhdmUgaXNzdWVzIDopXG4gICAgaWYgKGZpcnN0UG9pbnQueCA9PT0gbGFzdFBvaW50LnggJiYgZmlyc3RQb2ludC55ID09PSBsYXN0UG9pbnQueSlcbiAgICB7XG4gICAgICAgIC8vIG5lZWQgdG8gY2xvbmUgYXMgd2UgYXJlIGdvaW5nIHRvIHNsaWdodGx5IG1vZGlmeSB0aGUgc2hhcGUuLlxuICAgICAgICBwb2ludHMgPSBwb2ludHMuc2xpY2UoKTtcblxuICAgICAgICBwb2ludHMucG9wKCk7XG4gICAgICAgIHBvaW50cy5wb3AoKTtcblxuICAgICAgICBsYXN0UG9pbnQgPSBuZXcgbWF0aC5Qb2ludChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcblxuICAgICAgICB2YXIgbWlkUG9pbnRYID0gbGFzdFBvaW50LnggKyAoZmlyc3RQb2ludC54IC0gbGFzdFBvaW50LngpICowLjU7XG4gICAgICAgIHZhciBtaWRQb2ludFkgPSBsYXN0UG9pbnQueSArIChmaXJzdFBvaW50LnkgLSBsYXN0UG9pbnQueSkgKjAuNTtcblxuICAgICAgICBwb2ludHMudW5zaGlmdChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gICAgICAgIHBvaW50cy5wdXNoKG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgICB9XG5cbiAgICB2YXIgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG4gICAgdmFyIGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuICAgIHZhciBpbmRleENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgaW5kZXhTdGFydCA9IHZlcnRzLmxlbmd0aC82O1xuXG4gICAgLy8gRFJBVyB0aGUgTGluZVxuICAgIHZhciB3aWR0aCA9IGdyYXBoaWNzRGF0YS5saW5lV2lkdGggLyAyO1xuXG4gICAgLy8gc29ydCBjb2xvclxuICAgIHZhciBjb2xvciA9IHV0aWxzLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmxpbmVDb2xvcik7XG4gICAgdmFyIGFscGhhID0gZ3JhcGhpY3NEYXRhLmxpbmVBbHBoYTtcbiAgICB2YXIgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgdmFyIGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgIHZhciBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgIHZhciBweCwgcHksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3k7XG4gICAgdmFyIHBlcnB4LCBwZXJweSwgcGVycDJ4LCBwZXJwMnksIHBlcnAzeCwgcGVycDN5O1xuICAgIHZhciBhMSwgYjEsIGMxLCBhMiwgYjIsIGMyO1xuICAgIHZhciBkZW5vbSwgcGRpc3QsIGRpc3Q7XG5cbiAgICBwMXggPSBwb2ludHNbMF07XG4gICAgcDF5ID0gcG9pbnRzWzFdO1xuXG4gICAgcDJ4ID0gcG9pbnRzWzJdO1xuICAgIHAyeSA9IHBvaW50c1szXTtcblxuICAgIHBlcnB4ID0gLShwMXkgLSBwMnkpO1xuICAgIHBlcnB5ID0gIHAxeCAtIHAyeDtcblxuICAgIGRpc3QgPSBNYXRoLnNxcnQocGVycHgqcGVycHggKyBwZXJweSpwZXJweSk7XG5cbiAgICBwZXJweCAvPSBkaXN0O1xuICAgIHBlcnB5IC89IGRpc3Q7XG4gICAgcGVycHggKj0gd2lkdGg7XG4gICAgcGVycHkgKj0gd2lkdGg7XG5cbiAgICAvLyBzdGFydFxuICAgIHZlcnRzLnB1c2gocDF4IC0gcGVycHggLCBwMXkgLSBwZXJweSxcbiAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYSk7XG5cbiAgICB2ZXJ0cy5wdXNoKHAxeCArIHBlcnB4ICwgcDF5ICsgcGVycHksXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aC0xOyBpKyspXG4gICAge1xuICAgICAgICBwMXggPSBwb2ludHNbKGktMSkqMl07XG4gICAgICAgIHAxeSA9IHBvaW50c1soaS0xKSoyICsgMV07XG5cbiAgICAgICAgcDJ4ID0gcG9pbnRzWyhpKSoyXTtcbiAgICAgICAgcDJ5ID0gcG9pbnRzWyhpKSoyICsgMV07XG5cbiAgICAgICAgcDN4ID0gcG9pbnRzWyhpKzEpKjJdO1xuICAgICAgICBwM3kgPSBwb2ludHNbKGkrMSkqMiArIDFdO1xuXG4gICAgICAgIHBlcnB4ID0gLShwMXkgLSBwMnkpO1xuICAgICAgICBwZXJweSA9IHAxeCAtIHAyeDtcblxuICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4KnBlcnB4ICsgcGVycHkqcGVycHkpO1xuICAgICAgICBwZXJweCAvPSBkaXN0O1xuICAgICAgICBwZXJweSAvPSBkaXN0O1xuICAgICAgICBwZXJweCAqPSB3aWR0aDtcbiAgICAgICAgcGVycHkgKj0gd2lkdGg7XG5cbiAgICAgICAgcGVycDJ4ID0gLShwMnkgLSBwM3kpO1xuICAgICAgICBwZXJwMnkgPSBwMnggLSBwM3g7XG5cbiAgICAgICAgZGlzdCA9IE1hdGguc3FydChwZXJwMngqcGVycDJ4ICsgcGVycDJ5KnBlcnAyeSk7XG4gICAgICAgIHBlcnAyeCAvPSBkaXN0O1xuICAgICAgICBwZXJwMnkgLz0gZGlzdDtcbiAgICAgICAgcGVycDJ4ICo9IHdpZHRoO1xuICAgICAgICBwZXJwMnkgKj0gd2lkdGg7XG5cbiAgICAgICAgYTEgPSAoLXBlcnB5ICsgcDF5KSAtICgtcGVycHkgKyBwMnkpO1xuICAgICAgICBiMSA9ICgtcGVycHggKyBwMngpIC0gKC1wZXJweCArIHAxeCk7XG4gICAgICAgIGMxID0gKC1wZXJweCArIHAxeCkgKiAoLXBlcnB5ICsgcDJ5KSAtICgtcGVycHggKyBwMngpICogKC1wZXJweSArIHAxeSk7XG4gICAgICAgIGEyID0gKC1wZXJwMnkgKyBwM3kpIC0gKC1wZXJwMnkgKyBwMnkpO1xuICAgICAgICBiMiA9ICgtcGVycDJ4ICsgcDJ4KSAtICgtcGVycDJ4ICsgcDN4KTtcbiAgICAgICAgYzIgPSAoLXBlcnAyeCArIHAzeCkgKiAoLXBlcnAyeSArIHAyeSkgLSAoLXBlcnAyeCArIHAyeCkgKiAoLXBlcnAyeSArIHAzeSk7XG5cbiAgICAgICAgZGVub20gPSBhMSpiMiAtIGEyKmIxO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhkZW5vbSkgPCAwLjEgKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGRlbm9tKz0xMC4xO1xuICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSBwZXJweCAsIHAyeSAtIHBlcnB5LFxuICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggKyBwZXJweCAsIHAyeSArIHBlcnB5LFxuICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBweCA9IChiMSpjMiAtIGIyKmMxKS9kZW5vbTtcbiAgICAgICAgcHkgPSAoYTIqYzEgLSBhMSpjMikvZGVub207XG5cblxuICAgICAgICBwZGlzdCA9IChweCAtcDJ4KSAqIChweCAtcDJ4KSArIChweSAtcDJ5KSArIChweSAtcDJ5KTtcblxuXG4gICAgICAgIGlmIChwZGlzdCA+IDE0MCAqIDE0MClcbiAgICAgICAge1xuICAgICAgICAgICAgcGVycDN4ID0gcGVycHggLSBwZXJwMng7XG4gICAgICAgICAgICBwZXJwM3kgPSBwZXJweSAtIHBlcnAyeTtcblxuICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChwZXJwM3gqcGVycDN4ICsgcGVycDN5KnBlcnAzeSk7XG4gICAgICAgICAgICBwZXJwM3ggLz0gZGlzdDtcbiAgICAgICAgICAgIHBlcnAzeSAvPSBkaXN0O1xuICAgICAgICAgICAgcGVycDN4ICo9IHdpZHRoO1xuICAgICAgICAgICAgcGVycDN5ICo9IHdpZHRoO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnAzeCwgcDJ5IC1wZXJwM3kpO1xuICAgICAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4ICsgcGVycDN4LCBwMnkgK3BlcnAzeSk7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSBwZXJwM3gsIHAyeSAtcGVycDN5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICBpbmRleENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIHZlcnRzLnB1c2gocHggLCBweSk7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSAocHgtcDJ4KSwgcDJ5IC0gKHB5IC0gcDJ5KSk7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHAxeCA9IHBvaW50c1sobGVuZ3RoLTIpKjJdO1xuICAgIHAxeSA9IHBvaW50c1sobGVuZ3RoLTIpKjIgKyAxXTtcblxuICAgIHAyeCA9IHBvaW50c1sobGVuZ3RoLTEpKjJdO1xuICAgIHAyeSA9IHBvaW50c1sobGVuZ3RoLTEpKjIgKyAxXTtcblxuICAgIHBlcnB4ID0gLShwMXkgLSBwMnkpO1xuICAgIHBlcnB5ID0gcDF4IC0gcDJ4O1xuXG4gICAgZGlzdCA9IE1hdGguc3FydChwZXJweCpwZXJweCArIHBlcnB5KnBlcnB5KTtcbiAgICBwZXJweCAvPSBkaXN0O1xuICAgIHBlcnB5IC89IGRpc3Q7XG4gICAgcGVycHggKj0gd2lkdGg7XG4gICAgcGVycHkgKj0gd2lkdGg7XG5cbiAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnB4ICwgcDJ5IC0gcGVycHkpO1xuICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgdmVydHMucHVzaChwMnggKyBwZXJweCAsIHAyeSArIHBlcnB5KTtcbiAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgIGluZGljZXMucHVzaChpbmRleFN0YXJ0KTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleENvdW50OyBpKyspXG4gICAge1xuICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCsrKTtcbiAgICB9XG5cbiAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydC0xKTtcbn07XG5cbi8qKlxuICogQnVpbGRzIGEgY29tcGxleCBwb2x5Z29uIHRvIGRyYXdcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdyYXBoaWNzRGF0YSB7R3JhcGhpY3N9IFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gd2ViR0xEYXRhIHtvYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgd2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoaXMgc2hhcGVcbiAqL1xuR3JhcGhpY3NSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRDb21wbGV4UG9seSA9IGZ1bmN0aW9uIChncmFwaGljc0RhdGEsIHdlYkdMRGF0YSlcbntcbiAgICAvL1RPRE8gLSBubyBuZWVkIHRvIGNvcHkgdGhpcyBhcyBpdCBnZXRzIHR1cm5lZCBpbnRvIGEgRkxvYXQzMkFycmF5IGFueXdheXMuLlxuICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzLnNsaWNlKCk7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDYpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2V0IGZpcnN0IGFuZCBsYXN0IHBvaW50Li4gZmlndXJlIG91dCB0aGUgbWlkZGxlIVxuICAgIHZhciBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG4gICAgd2ViR0xEYXRhLnBvaW50cyA9IHBvaW50cztcbiAgICB3ZWJHTERhdGEuYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuICAgIHdlYkdMRGF0YS5jb2xvciA9IHV0aWxzLmhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxDb2xvcik7XG5cbiAgICAvLyBjYWxjbGF0ZSB0aGUgYm91bmRzLi5cbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuXG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIHZhciB4LHk7XG5cbiAgICAvLyBnZXQgc2l6ZS4uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKz0yKVxuICAgIHtcbiAgICAgICAgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgeSA9IHBvaW50c1tpKzFdO1xuXG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcblxuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGEgcXVhZCB0byB0aGUgZW5kIGNvcyB0aGVyZSBpcyBubyBwb2ludCBtYWtpbmcgYW5vdGhlciBidWZmZXIhXG4gICAgcG9pbnRzLnB1c2gobWluWCwgbWluWSxcbiAgICAgICAgICAgICAgICBtYXhYLCBtaW5ZLFxuICAgICAgICAgICAgICAgIG1heFgsIG1heFksXG4gICAgICAgICAgICAgICAgbWluWCwgbWF4WSk7XG5cbiAgICAvLyBwdXNoIGEgcXVhZCBvbnRvIHRoZSBlbmQuLlxuXG4gICAgLy9UT0RPIC0gdGhpcyBhaW50IG5lZWRlZCFcbiAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKCBpICk7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHBvbHlnb24gdG8gZHJhd1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ3JhcGhpY3NEYXRhIHtXZWJHTEdyYXBoaWNzRGF0YX0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB3ZWJHTERhdGEge29iamVjdH0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICovXG5HcmFwaGljc1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZFBvbHkgPSBmdW5jdGlvbiAoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDYpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2V0IGZpcnN0IGFuZCBsYXN0IHBvaW50Li4gZmlndXJlIG91dCB0aGUgbWlkZGxlIVxuICAgIHZhciB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgdmFyIGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcblxuICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcblxuICAgIC8vIHNvcnQgY29sb3JcbiAgICB2YXIgY29sb3IgPSB1dGlscy5oZXgycmdiKGdyYXBoaWNzRGF0YS5maWxsQ29sb3IpO1xuICAgIHZhciBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XG4gICAgdmFyIHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgIHZhciBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICB2YXIgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICB2YXIgdHJpYW5nbGVzID0gdXRpbHMuUG9seUsuVHJpYW5ndWxhdGUocG9pbnRzKTtcblxuICAgIGlmICghdHJpYW5nbGVzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDY7XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSs9MylcbiAgICB7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaV0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlcnRQb3MpO1xuICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2krMV0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpKzJdICt2ZXJ0UG9zKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpKzJdICsgdmVydFBvcyk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmVydHMucHVzaChwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSxcbiAgICAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuIiwiLyoqXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyBXZWJHTCBzcGVjaWZpYyBwcm9wZXJ0aWVzIHRvIGJlIHVzZWQgYnkgdGhlIFdlYkdMIHJlbmRlcmVyXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gV2ViR0xHcmFwaGljc0RhdGEoZ2wpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8vVE9ETyBkb2VzIHRoaXMgbmVlZCB0byBiZSBzcGxpdCBiZWZvcmUgdXBsb2Rpbmc/P1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGNvbG9yIGNvbXBvbmVudHMgKHIsZyxiKVxuICAgICAqIEBtZW1iZXIge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29sb3IgPSBbMCwwLDBdOyAvLyBjb2xvciBzcGxpdCFcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHBvaW50cyB0byBkcmF3XG4gICAgICogQG1lbWJlciB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5wb2ludHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlc1xuICAgICAqIEBtZW1iZXIge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuaW5kaWNlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIGJ1ZmZlclxuICAgICAqIEBtZW1iZXIge1dlYkdMQnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggYnVmZmVyXG4gICAgICogQG1lbWJlciB7V2ViR0xCdWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgLyoqXG4gICAgICogdG9kbyBAYWx2aW5cbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tb2RlID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbHBoYSBvZiB0aGUgZ3JhcGhpY3NcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbHBoYSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZ3JhcGhpY3MgaXMgZGlydHkgb3Igbm90XG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn1cblxuV2ViR0xHcmFwaGljc0RhdGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2ViR0xHcmFwaGljc0RhdGE7XG5tb2R1bGUuZXhwb3J0cyA9IFdlYkdMR3JhcGhpY3NEYXRhO1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgdmVydGljZXMgYW5kIHRoZSBpbmRpY2VzXG4gKi9cbldlYkdMR3JhcGhpY3NEYXRhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaW5kaWNlcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgYnVmZmVycyBhbmQgdXBsb2FkcyB0aGUgZGF0YVxuICovXG5XZWJHTEdyYXBoaWNzRGF0YS5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbi8vICAgIHRoaXMubGFzdEluZGV4ID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDtcbiAgICB0aGlzLmdsUG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnBvaW50cyk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmdsUG9pbnRzLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICB0aGlzLmdsSW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmluZGljZXMpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5nbEluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG4iLCIvKipcbiAqIEBmaWxlICAgICAgICBNYWluIGV4cG9ydCBvZiB0aGUgUElYSSBjb3JlIGxpYnJhcnlcbiAqIEBhdXRob3IgICAgICBNYXQgR3JvdmVzIDxtYXRAZ29vZGJveWRpZ2l0YWwuY29tPlxuICogQGNvcHlyaWdodCAgIDIwMTMtMjAxNSBHb29kQm95RGlnaXRhbFxuICogQGxpY2Vuc2UgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vR29vZEJveURpZ2l0YWwvcGl4aS5qcy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVCBMaWNlbnNlfVxuICovXG5cbi8qKlxuICogQG5hbWVzcGFjZSBQSVhJXG4gKi9cbi8vIGV4cG9ydCBjb3JlIGFuZCBjb25zdC4gV2UgYXNzaWduIGNvcmUgdG8gY29uc3Qgc28gdGhhdCB0aGUgbm9uLXJlZmVyZW5jZSB0eXBlcyBpbiBjb25zdCByZW1haW4gaW4tdGFjdFxudmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24ocmVxdWlyZSgnLi9jb25zdCcpLCByZXF1aXJlKCcuL21hdGgnKSwge1xuICAgIC8vIHV0aWxzXG4gICAgdXRpbHM6IHJlcXVpcmUoJy4vdXRpbHMnKSxcbiAgICBtYXRoOiByZXF1aXJlKCcuL21hdGgnKSxcblxuICAgIC8vIGRpc3BsYXlcbiAgICBEaXNwbGF5T2JqZWN0OiAgICAgICAgICByZXF1aXJlKCcuL2Rpc3BsYXkvRGlzcGxheU9iamVjdCcpLFxuICAgIENvbnRhaW5lcjogICAgICAgICAgICAgIHJlcXVpcmUoJy4vZGlzcGxheS9Db250YWluZXInKSxcblxuICAgIC8vIHNwcml0ZXNcbiAgICBTcHJpdGU6ICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3Nwcml0ZXMvU3ByaXRlJyksXG4gICAgUGFydGljbGVDb250YWluZXI6ICAgICAgcmVxdWlyZSgnLi9wYXJ0aWNsZXMvUGFydGljbGVDb250YWluZXInKSxcbiAgICBTcHJpdGVSZW5kZXJlcjogICAgICAgICByZXF1aXJlKCcuL3Nwcml0ZXMvd2ViZ2wvU3ByaXRlUmVuZGVyZXInKSxcbiAgICBQYXJ0aWNsZVJlbmRlcmVyOiAgICAgICByZXF1aXJlKCcuL3BhcnRpY2xlcy93ZWJnbC9QYXJ0aWNsZVJlbmRlcmVyJyksXG5cbiAgICAvLyB0ZXh0XG4gICAgVGV4dDogICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi90ZXh0L1RleHQnKSxcblxuICAgIC8vIHByaW1pdGl2ZXNcbiAgICBHcmFwaGljczogICAgICAgICAgICAgICByZXF1aXJlKCcuL2dyYXBoaWNzL0dyYXBoaWNzJyksXG4gICAgR3JhcGhpY3NEYXRhOiAgICAgICAgICAgcmVxdWlyZSgnLi9ncmFwaGljcy9HcmFwaGljc0RhdGEnKSxcbiAgICBHcmFwaGljc1JlbmRlcmVyOiAgICAgICByZXF1aXJlKCcuL2dyYXBoaWNzL3dlYmdsL0dyYXBoaWNzUmVuZGVyZXInKSxcblxuICAgIC8vIHRleHR1cmVzXG4gICAgVGV4dHVyZTogICAgICAgICAgICAgICAgcmVxdWlyZSgnLi90ZXh0dXJlcy9UZXh0dXJlJyksXG4gICAgQmFzZVRleHR1cmU6ICAgICAgICAgICAgcmVxdWlyZSgnLi90ZXh0dXJlcy9CYXNlVGV4dHVyZScpLFxuICAgIFJlbmRlclRleHR1cmU6ICAgICAgICAgIHJlcXVpcmUoJy4vdGV4dHVyZXMvUmVuZGVyVGV4dHVyZScpLFxuICAgIFZpZGVvQmFzZVRleHR1cmU6ICAgICAgIHJlcXVpcmUoJy4vdGV4dHVyZXMvVmlkZW9CYXNlVGV4dHVyZScpLFxuICAgIFRleHR1cmVVdnM6ICAgICAgICAgICAgIHJlcXVpcmUoJy4vdGV4dHVyZXMvVGV4dHVyZVV2cycpLFxuXG4gICAgLy8gcmVuZGVyZXJzIC0gY2FudmFzXG4gICAgQ2FudmFzUmVuZGVyZXI6ICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvY2FudmFzL0NhbnZhc1JlbmRlcmVyJyksXG4gICAgQ2FudmFzR3JhcGhpY3M6ICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc0dyYXBoaWNzJyksXG4gICAgQ2FudmFzQnVmZmVyOiAgICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvY2FudmFzL3V0aWxzL0NhbnZhc0J1ZmZlcicpLFxuXG4gICAgLy8gcmVuZGVyZXJzIC0gd2ViZ2xcbiAgICBXZWJHTFJlbmRlcmVyOiAgICAgICAgICByZXF1aXJlKCcuL3JlbmRlcmVycy93ZWJnbC9XZWJHTFJlbmRlcmVyJyksXG4gICAgU2hhZGVyTWFuYWdlcjogICAgICAgICAgcmVxdWlyZSgnLi9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvU2hhZGVyTWFuYWdlcicpLFxuICAgIFNoYWRlcjogICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vcmVuZGVyZXJzL3dlYmdsL3NoYWRlcnMvU2hhZGVyJyksXG5cbiAgICAvLyBmaWx0ZXJzIC0gd2ViZ2xcbiAgICBBYnN0cmFjdEZpbHRlcjogICAgICAgICByZXF1aXJlKCcuL3JlbmRlcmVycy93ZWJnbC9maWx0ZXJzL0Fic3RyYWN0RmlsdGVyJyksXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGhlbHBlciBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHdoaWNoIHJlbmRlcmVyIHlvdSBzaG91bGQgYmUgdXNpbmcuXG4gICAgICogV2ViR0wgaXMgdGhlIHByZWZlcnJlZCByZW5kZXJlciBhcyBpdCBpcyBhIGxvdCBmYXN0ZXIuIElmIHdlYkdMIGlzIG5vdCBzdXBwb3J0ZWQgYnlcbiAgICAgKiB0aGUgYnJvd3NlciB0aGVuIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSBjYW52YXMgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQSVhJXG4gICAgICogQHBhcmFtIHdpZHRoPTgwMCB7bnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIHJlbmRlcmVycyB2aWV3XG4gICAgICogQHBhcmFtIGhlaWdodD02MDAge251bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyZXJzIHZpZXdcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIHtvYmplY3R9IFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIFtvcHRpb25zLnZpZXddIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGNhbnZhcyB0byB1c2UgYXMgYSB2aWV3LCBvcHRpb25hbFxuICAgICAqIEBwYXJhbSBbb3B0aW9ucy50cmFuc3BhcmVudD1mYWxzZV0ge2Jvb2xlYW59IElmIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudCwgZGVmYXVsdCBmYWxzZVxuICAgICAqIEBwYXJhbSBbb3B0aW9ucy5hbnRpYWxpYXM9ZmFsc2VdIHtib29sZWFufSBzZXRzIGFudGlhbGlhcyAob25seSBhcHBsaWNhYmxlIGluIGNocm9tZSBhdCB0aGUgbW9tZW50KVxuICAgICAqIEBwYXJhbSBbb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2VdIHtib29sZWFufSBlbmFibGVzIGRyYXdpbmcgYnVmZmVyIHByZXNlcnZhdGlvbiwgZW5hYmxlIHRoaXMgaWYgeW91XG4gICAgICogICAgICBuZWVkIHRvIGNhbGwgdG9EYXRhVXJsIG9uIHRoZSB3ZWJnbCBjb250ZXh0XG4gICAgICogQHBhcmFtIFtvcHRpb25zLnJlc29sdXRpb249MV0ge251bWJlcn0gdGhlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlcmVyLCByZXRpbmEgd291bGQgYmUgMlxuICAgICAqIEBwYXJhbSBbbm9XZWJHTD1mYWxzZV0ge2Jvb2xlYW59IHByZXZlbnRzIHNlbGVjdGlvbiBvZiBXZWJHTCByZW5kZXJlciwgZXZlbiBpZiBzdWNoIGlzIHByZXNlbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1dlYkdMUmVuZGVyZXJ8Q2FudmFzUmVuZGVyZXJ9IFJldHVybnMgV2ViR0wgcmVuZGVyZXIgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgQ2FudmFzUmVuZGVyZXJcbiAgICAgKi9cbiAgICBhdXRvRGV0ZWN0UmVuZGVyZXI6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zLCBub1dlYkdMKVxuICAgIHtcbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCA4MDA7XG4gICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCA2MDA7XG5cbiAgICAgICAgaWYgKCFub1dlYkdMICYmIGNvcmUudXRpbHMuaXNXZWJHTFN1cHBvcnRlZCgpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvcmUuV2ViR0xSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgY29yZS5DYW52YXNSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcbiAgICB9XG59KTtcbiIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcblxuLyoqXG4gKiBUaGUgcGl4aSBNYXRyaXggY2xhc3MgYXMgYW4gb2JqZWN0LCB3aGljaCBtYWtlcyBpdCBhIGxvdCBmYXN0ZXIsXG4gKiBoZXJlIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgaXQgOlxuICogfCBhIHwgYiB8IHR4fFxuICogfCBjIHwgZCB8IHR5fFxuICogfCAwIHwgMCB8IDEgfFxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xuZnVuY3Rpb24gTWF0cml4KClcbntcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuYSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMuYiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMuYyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuZCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMudHggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnR5ID0gMDtcbn1cblxuTWF0cml4LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hdHJpeDtcbm1vZHVsZS5leHBvcnRzID0gTWF0cml4O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBNYXRyaXggb2JqZWN0IGJhc2VkIG9uIHRoZSBnaXZlbiBhcnJheS4gVGhlIEVsZW1lbnQgdG8gTWF0cml4IG1hcHBpbmcgb3JkZXIgaXMgYXMgZm9sbG93czpcbiAqXG4gKiBhID0gYXJyYXlbMF1cbiAqIGIgPSBhcnJheVsxXVxuICogYyA9IGFycmF5WzNdXG4gKiBkID0gYXJyYXlbNF1cbiAqIHR4ID0gYXJyYXlbMl1cbiAqIHR5ID0gYXJyYXlbNV1cbiAqXG4gKiBAcGFyYW0gYXJyYXkge251bWJlcltdfSBUaGUgYXJyYXkgdGhhdCB0aGUgbWF0cml4IHdpbGwgYmUgcG9wdWxhdGVkIGZyb20uXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGFycmF5KVxue1xuICAgIHRoaXMuYSA9IGFycmF5WzBdO1xuICAgIHRoaXMuYiA9IGFycmF5WzFdO1xuICAgIHRoaXMuYyA9IGFycmF5WzNdO1xuICAgIHRoaXMuZCA9IGFycmF5WzRdO1xuICAgIHRoaXMudHggPSBhcnJheVsyXTtcbiAgICB0aGlzLnR5ID0gYXJyYXlbNV07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgZnJvbSB0aGUgY3VycmVudCBNYXRyaXggb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB0cmFuc3Bvc2Uge2Jvb2xlYW59IFdoZXRoZXIgd2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeCBvciBub3RcbiAqIEByZXR1cm4ge251bWJlcltdfSB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheSB3aGljaCBjb250YWlucyB0aGUgbWF0cml4XG4gKi9cbk1hdHJpeC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICh0cmFuc3Bvc2UpXG57XG4gICAgaWYgKCF0aGlzLmFycmF5KVxuICAgIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG4gICAgfVxuXG4gICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcblxuICAgIGlmICh0cmFuc3Bvc2UpXG4gICAge1xuICAgICAgICBhcnJheVswXSA9IHRoaXMuYTtcbiAgICAgICAgYXJyYXlbMV0gPSB0aGlzLmI7XG4gICAgICAgIGFycmF5WzJdID0gMDtcbiAgICAgICAgYXJyYXlbM10gPSB0aGlzLmM7XG4gICAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xuICAgICAgICBhcnJheVs1XSA9IDA7XG4gICAgICAgIGFycmF5WzZdID0gdGhpcy50eDtcbiAgICAgICAgYXJyYXlbN10gPSB0aGlzLnR5O1xuICAgICAgICBhcnJheVs4XSA9IDE7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGFycmF5WzBdID0gdGhpcy5hO1xuICAgICAgICBhcnJheVsxXSA9IHRoaXMuYztcbiAgICAgICAgYXJyYXlbMl0gPSB0aGlzLnR4O1xuICAgICAgICBhcnJheVszXSA9IHRoaXMuYjtcbiAgICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICAgIGFycmF5WzVdID0gdGhpcy50eTtcbiAgICAgICAgYXJyYXlbNl0gPSAwO1xuICAgICAgICBhcnJheVs3XSA9IDA7XG4gICAgICAgIGFycmF5WzhdID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59O1xuXG4vKipcbiAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXG4gKiBDYW4gYmUgdXNlZCB0byBnbyBmcm9tIGEgY2hpbGQncyBjb29yZGluYXRlIHNwYWNlIHRvIHRoZSB3b3JsZCBjb29yZGluYXRlIHNwYWNlLiAoZS5nLiByZW5kZXJpbmcpXG4gKlxuICogQHBhcmFtIHBvcyB7UG9pbnR9IFRoZSBvcmlnaW5cbiAqIEBwYXJhbSBbbmV3UG9zXSB7UG9pbnR9IFRoZSBwb2ludCB0aGF0IHRoZSBuZXcgcG9zaXRpb24gaXMgYXNzaWduZWQgdG8gKGFsbG93ZWQgdG8gYmUgc2FtZSBhcyBpbnB1dClcbiAqIEByZXR1cm4ge1BvaW50fSBUaGUgbmV3IHBvaW50LCB0cmFuc2Zvcm1lZCB0aHJvdWdoIHRoaXMgbWF0cml4XG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAocG9zLCBuZXdQb3MpXG57XG4gICAgbmV3UG9zID0gbmV3UG9zIHx8IG5ldyBQb2ludCgpO1xuXG4gICAgdmFyIHggPSBwb3MueDtcbiAgICB2YXIgeSA9IHBvcy55O1xuXG4gICAgbmV3UG9zLnggPSB0aGlzLmEgKiB4ICsgdGhpcy5jICogeSArIHRoaXMudHg7XG4gICAgbmV3UG9zLnkgPSB0aGlzLmIgKiB4ICsgdGhpcy5kICogeSArIHRoaXMudHk7XG5cbiAgICByZXR1cm4gbmV3UG9zO1xufTtcblxuLyoqXG4gKiBHZXQgYSBuZXcgcG9zaXRpb24gd2l0aCB0aGUgaW52ZXJzZSBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkLlxuICogQ2FuIGJlIHVzZWQgdG8gZ28gZnJvbSB0aGUgd29ybGQgY29vcmRpbmF0ZSBzcGFjZSB0byBhIGNoaWxkJ3MgY29vcmRpbmF0ZSBzcGFjZS4gKGUuZy4gaW5wdXQpXG4gKlxuICogQHBhcmFtIHBvcyB7UG9pbnR9IFRoZSBvcmlnaW5cbiAqIEBwYXJhbSBbbmV3UG9zXSB7UG9pbnR9IFRoZSBwb2ludCB0aGF0IHRoZSBuZXcgcG9zaXRpb24gaXMgYXNzaWduZWQgdG8gKGFsbG93ZWQgdG8gYmUgc2FtZSBhcyBpbnB1dClcbiAqIEByZXR1cm4ge1BvaW50fSBUaGUgbmV3IHBvaW50LCBpbnZlcnNlLXRyYW5zZm9ybWVkIHRocm91Z2ggdGhpcyBtYXRyaXhcbiAqL1xuTWF0cml4LnByb3RvdHlwZS5hcHBseUludmVyc2UgPSBmdW5jdGlvbiAocG9zLCBuZXdQb3MpXG57XG4gICAgbmV3UG9zID0gbmV3UG9zIHx8IG5ldyBQb2ludCgpO1xuXG4gICAgdmFyIGlkID0gMSAvICh0aGlzLmEgKiB0aGlzLmQgKyB0aGlzLmMgKiAtdGhpcy5iKTtcblxuICAgIHZhciB4ID0gcG9zLng7XG4gICAgdmFyIHkgPSBwb3MueTtcblxuICAgIG5ld1Bvcy54ID0gdGhpcy5kICogaWQgKiB4ICsgLXRoaXMuYyAqIGlkICogeSArICh0aGlzLnR5ICogdGhpcy5jIC0gdGhpcy50eCAqIHRoaXMuZCkgKiBpZDtcbiAgICBuZXdQb3MueSA9IHRoaXMuYSAqIGlkICogeSArIC10aGlzLmIgKiBpZCAqIHggKyAoLXRoaXMudHkgKiB0aGlzLmEgKyB0aGlzLnR4ICogdGhpcy5iKSAqIGlkO1xuXG4gICAgcmV0dXJuIG5ld1Bvcztcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbWF0cml4IG9uIHRoZSB4IGFuZCB5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHJldHVybiB7TWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICovXG5NYXRyaXgucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KVxue1xuICAgIHRoaXMudHggKz0geDtcbiAgICB0aGlzLnR5ICs9IHk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbGllcyBhIHNjYWxlIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIGFtb3VudCB0byBzY2FsZSBob3Jpem9udGFsbHlcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBhbW91bnQgdG8gc2NhbGUgdmVydGljYWxseVxuICogQHJldHVybiB7TWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICovXG5NYXRyaXgucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHgsIHkpXG57XG4gICAgdGhpcy5hICo9IHg7XG4gICAgdGhpcy5kICo9IHk7XG4gICAgdGhpcy5jICo9IHg7XG4gICAgdGhpcy5iICo9IHk7XG4gICAgdGhpcy50eCAqPSB4O1xuICAgIHRoaXMudHkgKj0geTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEFwcGxpZXMgYSByb3RhdGlvbiB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICogQHJldHVybiB7TWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICovXG5NYXRyaXgucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIChhbmdsZSlcbntcbiAgICB2YXIgY29zID0gTWF0aC5jb3MoIGFuZ2xlICk7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKCBhbmdsZSApO1xuXG4gICAgdmFyIGExID0gdGhpcy5hO1xuICAgIHZhciBjMSA9IHRoaXMuYztcbiAgICB2YXIgdHgxID0gdGhpcy50eDtcblxuICAgIHRoaXMuYSA9IGExICogY29zLXRoaXMuYiAqIHNpbjtcbiAgICB0aGlzLmIgPSBhMSAqIHNpbit0aGlzLmIgKiBjb3M7XG4gICAgdGhpcy5jID0gYzEgKiBjb3MtdGhpcy5kICogc2luO1xuICAgIHRoaXMuZCA9IGMxICogc2luK3RoaXMuZCAqIGNvcztcbiAgICB0aGlzLnR4ID0gdHgxICogY29zIC0gdGhpcy50eSAqIHNpbjtcbiAgICB0aGlzLnR5ID0gdHgxICogc2luICsgdGhpcy50eSAqIGNvcztcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBnaXZlbiBNYXRyaXggdG8gdGhpcyBNYXRyaXguXG4gKlxuICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeFxuICogQHJldHVybiB7TWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICovXG5NYXRyaXgucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChtYXRyaXgpXG57XG4gICAgdmFyIGExID0gdGhpcy5hO1xuICAgIHZhciBiMSA9IHRoaXMuYjtcbiAgICB2YXIgYzEgPSB0aGlzLmM7XG4gICAgdmFyIGQxID0gdGhpcy5kO1xuXG4gICAgdGhpcy5hICA9IG1hdHJpeC5hICogYTEgKyBtYXRyaXguYiAqIGMxO1xuICAgIHRoaXMuYiAgPSBtYXRyaXguYSAqIGIxICsgbWF0cml4LmIgKiBkMTtcbiAgICB0aGlzLmMgID0gbWF0cml4LmMgKiBhMSArIG1hdHJpeC5kICogYzE7XG4gICAgdGhpcy5kICA9IG1hdHJpeC5jICogYjEgKyBtYXRyaXguZCAqIGQxO1xuXG4gICAgdGhpcy50eCA9IG1hdHJpeC50eCAqIGExICsgbWF0cml4LnR5ICogYzEgKyB0aGlzLnR4O1xuICAgIHRoaXMudHkgPSBtYXRyaXgudHggKiBiMSArIG1hdHJpeC50eSAqIGQxICsgdGhpcy50eTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxuICpcbiAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXhcbiAqIEByZXR1cm4ge01hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAqL1xuTWF0cml4LnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24obWF0cml4KVxue1xuICAgIHZhciB0eDEgPSB0aGlzLnR4O1xuXG4gICAgaWYgKG1hdHJpeC5hICE9PSAxIHx8IG1hdHJpeC5iICE9PSAwIHx8IG1hdHJpeC5jICE9PSAwIHx8IG1hdHJpeC5kICE9PSAxKVxuICAgIHtcbiAgICAgICAgdmFyIGExID0gdGhpcy5hO1xuICAgICAgICB2YXIgYzEgPSB0aGlzLmM7XG4gICAgICAgIHRoaXMuYSAgPSBhMSptYXRyaXguYSt0aGlzLmIqbWF0cml4LmM7XG4gICAgICAgIHRoaXMuYiAgPSBhMSptYXRyaXguYit0aGlzLmIqbWF0cml4LmQ7XG4gICAgICAgIHRoaXMuYyAgPSBjMSptYXRyaXguYSt0aGlzLmQqbWF0cml4LmM7XG4gICAgICAgIHRoaXMuZCAgPSBjMSptYXRyaXguYit0aGlzLmQqbWF0cml4LmQ7XG4gICAgfVxuXG4gICAgdGhpcy50eCA9IHR4MSptYXRyaXguYSt0aGlzLnR5Km1hdHJpeC5jK21hdHJpeC50eDtcbiAgICB0aGlzLnR5ID0gdHgxKm1hdHJpeC5iK3RoaXMudHkqbWF0cml4LmQrbWF0cml4LnR5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEludmVydHMgdGhpcyBtYXRyaXhcbiAqXG4gKiBAcmV0dXJuIHtNYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBhMSA9IHRoaXMuYTtcbiAgICB2YXIgYjEgPSB0aGlzLmI7XG4gICAgdmFyIGMxID0gdGhpcy5jO1xuICAgIHZhciBkMSA9IHRoaXMuZDtcbiAgICB2YXIgdHgxID0gdGhpcy50eDtcbiAgICB2YXIgbiA9IGExKmQxLWIxKmMxO1xuXG4gICAgdGhpcy5hID0gZDEvbjtcbiAgICB0aGlzLmIgPSAtYjEvbjtcbiAgICB0aGlzLmMgPSAtYzEvbjtcbiAgICB0aGlzLmQgPSBhMS9uO1xuICAgIHRoaXMudHggPSAoYzEqdGhpcy50eS1kMSp0eDEpL247XG4gICAgdGhpcy50eSA9IC0oYTEqdGhpcy50eS1iMSp0eDEpL247XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBSZXNldHMgdGhpcyBNYXRpeCB0byBhbiBpZGVudGl0eSAoZGVmYXVsdCkgbWF0cml4LlxuICpcbiAqIEByZXR1cm4ge01hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAqL1xuTWF0cml4LnByb3RvdHlwZS5pZGVudGl0eSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5hID0gMTtcbiAgICB0aGlzLmIgPSAwO1xuICAgIHRoaXMuYyA9IDA7XG4gICAgdGhpcy5kID0gMTtcbiAgICB0aGlzLnR4ID0gMDtcbiAgICB0aGlzLnR5ID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IE1hdHJpeCBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB7TWF0cml4fSBBIGNvcHkgb2YgdGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAqL1xuTWF0cml4LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICBtYXRyaXguYSA9IHRoaXMuYTtcbiAgICBtYXRyaXguYiA9IHRoaXMuYjtcbiAgICBtYXRyaXguYyA9IHRoaXMuYztcbiAgICBtYXRyaXguZCA9IHRoaXMuZDtcbiAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xuICAgIG1hdHJpeC50eSA9IHRoaXMudHk7XG5cbiAgICByZXR1cm4gbWF0cml4O1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG1hdHJpeCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgb25lcyBpbiB0aGlzIG1hdHJpeFxuICpcbiAqIEByZXR1cm4ge01hdHJpeH0gVGhlIG1hdHJpeCBnaXZlbiBpbiBwYXJhbWV0ZXIgd2l0aCBpdHMgdmFsdWVzIHVwZGF0ZWQuXG4gKi9cbk1hdHJpeC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChtYXRyaXgpXG57XG4gICAgbWF0cml4LmEgPSB0aGlzLmE7XG4gICAgbWF0cml4LmIgPSB0aGlzLmI7XG4gICAgbWF0cml4LmMgPSB0aGlzLmM7XG4gICAgbWF0cml4LmQgPSB0aGlzLmQ7XG4gICAgbWF0cml4LnR4ID0gdGhpcy50eDtcbiAgICBtYXRyaXgudHkgPSB0aGlzLnR5O1xuXG4gICAgcmV0dXJuIG1hdHJpeDtcbn07XG5cbi8qKlxuICogQSBkZWZhdWx0IChpZGVudGl0eSkgbWF0cml4XG4gKi9cbk1hdHJpeC5JREVOVElUWSA9IG5ldyBNYXRyaXgoKTtcbi8qKlxuICogQSB0ZW1wIG1hdHJpeFxuICovXG5NYXRyaXguVEVNUF9NQVRSSVggPSBuZXcgTWF0cml4KCk7XG4iLCIvKipcbiAqIFRoZSBQb2ludCBvYmplY3QgcmVwcmVzZW50cyBhIGxvY2F0aW9uIGluIGEgdHdvLWRpbWVuc2lvbmFsIGNvb3JkaW5hdGUgc3lzdGVtLCB3aGVyZSB4IHJlcHJlc2VudHNcbiAqIHRoZSBob3Jpem9udGFsIGF4aXMgYW5kIHkgcmVwcmVzZW50cyB0aGUgdmVydGljYWwgYXhpcy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gW3g9MF0ge251bWJlcn0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAqIEBwYXJhbSBbeT0wXSB7bnVtYmVyfSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICovXG5mdW5jdGlvbiBQb2ludCh4LCB5KVxue1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy54ID0geCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5IHx8IDA7XG59XG5cblBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50O1xubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2ludFxuICpcbiAqIEByZXR1cm4ge1BvaW50fSBhIGNvcHkgb2YgdGhlIHBvaW50XG4gKi9cblBvaW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG59O1xuXG4vKipcbiAqIENvcGllcyB4IGFuZCB5IGZyb20gdGhlIGdpdmVuIHBvaW50XG4gKlxuICogQHBhcmFtIHAge1BvaW50fVxuICovXG5Qb2ludC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgdGhpcy5zZXQocC54LCBwLnkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGVxdWFsIHRvIHRoaXMgcG9pbnRcbiAqXG4gKiBAcGFyYW0gcCB7UG9pbnR9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuUG9pbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIChwLnggPT09IHRoaXMueCkgJiYgKHAueSA9PT0gdGhpcy55KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcG9pbnQgdG8gYSBuZXcgeCBhbmQgeSBwb3NpdGlvbi5cbiAqIElmIHkgaXMgb21pdHRlZCwgYm90aCB4IGFuZCB5IHdpbGwgYmUgc2V0IHRvIHguXG4gKlxuICogQHBhcmFtIFt4PTBdIHtudW1iZXJ9IHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXG4gKiBAcGFyYW0gW3k9MF0ge251bWJlcn0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcbiAqL1xuUG9pbnQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh4LCB5KVxue1xuICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICB0aGlzLnkgPSB5IHx8ICggKHkgIT09IDApID8gdGhpcy54IDogMCApIDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQb2ludDogICAgICByZXF1aXJlKCcuL1BvaW50JyksXG4gICAgTWF0cml4OiAgICAgcmVxdWlyZSgnLi9NYXRyaXgnKSxcblxuICAgIENpcmNsZTogICAgIHJlcXVpcmUoJy4vc2hhcGVzL0NpcmNsZScpLFxuICAgIEVsbGlwc2U6ICAgIHJlcXVpcmUoJy4vc2hhcGVzL0VsbGlwc2UnKSxcbiAgICBQb2x5Z29uOiAgICByZXF1aXJlKCcuL3NoYXBlcy9Qb2x5Z29uJyksXG4gICAgUmVjdGFuZ2xlOiAgcmVxdWlyZSgnLi9zaGFwZXMvUmVjdGFuZ2xlJyksXG4gICAgUm91bmRlZFJlY3RhbmdsZTogcmVxdWlyZSgnLi9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZScpXG59O1xuIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyksXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG4vKipcbiAqIFRoZSBDaXJjbGUgb2JqZWN0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYSBoaXQgYXJlYSBmb3IgZGlzcGxheU9iamVjdHNcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBjaXJjbGVcbiAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGlzIGNpcmNsZVxuICogQHBhcmFtIHJhZGl1cyB7bnVtYmVyfSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAqL1xuZnVuY3Rpb24gQ2lyY2xlKHgsIHksIHJhZGl1cylcbntcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueCA9IHggfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy55ID0geSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IENPTlNULlNIQVBFUy5DSVJDO1xufVxuXG5DaXJjbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlO1xubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgQ2lyY2xlIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7Q2lyY2xlfSBhIGNvcHkgb2YgdGhlIENpcmNsZVxuICovXG5DaXJjbGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMpO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGNpcmNsZVxuICpcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgQ2lyY2xlXG4gKi9cbkNpcmNsZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoeCwgeSlcbntcbiAgICBpZiAodGhpcy5yYWRpdXMgPD0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZHggPSAodGhpcy54IC0geCksXG4gICAgICAgIGR5ID0gKHRoaXMueSAtIHkpLFxuICAgICAgICByMiA9IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7XG5cbiAgICBkeCAqPSBkeDtcbiAgICBkeSAqPSBkeTtcblxuICAgIHJldHVybiAoZHggKyBkeSA8PSByMik7XG59O1xuXG4vKipcbiogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGNpcmNsZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbipcbiogQHJldHVybiB7UmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcbiovXG5DaXJjbGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54IC0gdGhpcy5yYWRpdXMsIHRoaXMueSAtIHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMik7XG59O1xuIiwidmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vUmVjdGFuZ2xlJyksXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG4vKipcbiAqIFRoZSBFbGxpcHNlIG9iamVjdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgaGl0IGFyZWEgZm9yIGRpc3BsYXlPYmplY3RzXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHgge251bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXG4gKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2VcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSBUaGUgaGFsZiB3aWR0aCBvZiB0aGlzIGVsbGlwc2VcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gVGhlIGhhbGYgaGVpZ2h0IG9mIHRoaXMgZWxsaXBzZVxuICovXG5mdW5jdGlvbiBFbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnggPSB4IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueSA9IHkgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gQ09OU1QuU0hBUEVTLkVMSVA7XG59XG5cbkVsbGlwc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWxsaXBzZTtcbm1vZHVsZS5leHBvcnRzID0gRWxsaXBzZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBFbGxpcHNlIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7RWxsaXBzZX0gYSBjb3B5IG9mIHRoZSBlbGxpcHNlXG4gKi9cbkVsbGlwc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gbmV3IEVsbGlwc2UodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBlbGxpcHNlXG4gKlxuICogQHBhcmFtIHgge251bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkcyBhcmUgd2l0aGluIHRoaXMgZWxsaXBzZVxuICovXG5FbGxpcHNlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh4LCB5KVxue1xuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvL25vcm1hbGl6ZSB0aGUgY29vcmRzIHRvIGFuIGVsbGlwc2Ugd2l0aCBjZW50ZXIgMCwwXG4gICAgdmFyIG5vcm14ID0gKCh4IC0gdGhpcy54KSAvIHRoaXMud2lkdGgpLFxuICAgICAgICBub3JteSA9ICgoeSAtIHRoaXMueSkgLyB0aGlzLmhlaWdodCk7XG5cbiAgICBub3JteCAqPSBub3JteDtcbiAgICBub3JteSAqPSBub3JteTtcblxuICAgIHJldHVybiAobm9ybXggKyBub3JteSA8PSAxKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGVsbGlwc2UgYXMgYSBSZWN0YW5nbGUgb2JqZWN0XG4gKlxuICogQHJldHVybiB7UmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcbiAqL1xuRWxsaXBzZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSB0aGlzLndpZHRoLCB0aGlzLnkgLSB0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufTtcbiIsInZhciBQb2ludCA9IHJlcXVpcmUoJy4uL1BvaW50JyksXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSBwb2ludHMge1BvaW50W118bnVtYmVyW118Li4uUG9pbnR8Li4ubnVtYmVyfSBUaGlzIGNhbiBiZSBhbiBhcnJheSBvZiBQb2ludHMgdGhhdCBmb3JtIHRoZSBwb2x5Z29uLFxuICogICAgICBhIGZsYXQgYXJyYXkgb2YgbnVtYmVycyB0aGF0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgW3gseSwgeCx5LCAuLi5dLCBvciB0aGUgYXJndW1lbnRzIHBhc3NlZCBjYW4gYmVcbiAqICAgICAgYWxsIHRoZSBwb2ludHMgb2YgdGhlIHBvbHlnb24gZS5nLiBgbmV3IFBJWEkuUG9seWdvbihuZXcgUElYSS5Qb2ludCgpLCBuZXcgUElYSS5Qb2ludCgpLCAuLi4pYCwgb3IgdGhlXG4gKiAgICAgIGFyZ3VtZW50cyBwYXNzZWQgY2FuIGJlIGZsYXQgeCx5IHZhbHVlcyBlLmcuIGBuZXcgUG9seWdvbih4LHksIHgseSwgeCx5LCAuLi4pYCB3aGVyZSBgeGAgYW5kIGB5YCBhcmVcbiAqICAgICAgTnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gUG9seWdvbihwb2ludHNfKVxue1xuICAgIC8vIHByZXZlbnRzIGFuIGFyZ3VtZW50IGFzc2lnbm1lbnQgZGVvcHRcbiAgICAvLyBzZWUgc2VjdGlvbiAzLjE6IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzLW1hbmFnaW5nLWFyZ3VtZW50c1xuICAgIHZhciBwb2ludHMgPSBwb2ludHNfO1xuXG4gICAgLy9pZiBwb2ludHMgaXNuJ3QgYW4gYXJyYXksIHVzZSBhcmd1bWVudHMgYXMgdGhlIGFycmF5XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpXG4gICAge1xuICAgICAgICAvLyBwcmV2ZW50cyBhbiBhcmd1bWVudCBsZWFrIGRlb3B0XG4gICAgICAgIC8vIHNlZSBzZWN0aW9uIDMuMjogaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMtbWFuYWdpbmctYXJndW1lbnRzXG4gICAgICAgIHBvaW50cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHBvaW50cy5sZW5ndGg7ICsrYSkge1xuICAgICAgICAgICAgcG9pbnRzW2FdID0gYXJndW1lbnRzW2FdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhpcyBpcyBhbiBhcnJheSBvZiBwb2ludHMsIGNvbnZlcnQgaXQgdG8gYSBmbGF0IGFycmF5IG9mIG51bWJlcnNcbiAgICBpZiAocG9pbnRzWzBdIGluc3RhbmNlb2YgUG9pbnQpXG4gICAge1xuICAgICAgICB2YXIgcCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgcC5wdXNoKHBvaW50c1tpXS54LCBwb2ludHNbaV0ueSk7XG4gICAgICAgIH1cblxuICAgICAgICBwb2ludHMgPSBwO1xuICAgIH1cblxuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHRoZSBwb2ludHMgb2YgdGhpcyBwb2x5Z29uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBDT05TVC5TSEFQRVMuUE9MWTtcbn1cblxuUG9seWdvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2x5Z29uO1xubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvbHlnb25cbiAqXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSBhIGNvcHkgb2YgdGhlIHBvbHlnb25cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBuZXcgUG9seWdvbih0aGlzLnBvaW50cy5zbGljZSgpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBwb2x5Z29uXG4gKlxuICogQHBhcmFtIHgge251bWJlcn0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIHkge251bWJlcn0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgsIHkpXG57XG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuXG4gICAgLy8gdXNlIHNvbWUgcmF5Y2FzdGluZyB0byB0ZXN0IGhpdHNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGggLyAyO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBsZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBqID0gaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHhpID0gdGhpcy5wb2ludHNbaSAqIDJdLCB5aSA9IHRoaXMucG9pbnRzW2kgKiAyICsgMV0sXG4gICAgICAgICAgICB4aiA9IHRoaXMucG9pbnRzW2ogKiAyXSwgeWogPSB0aGlzLnBvaW50c1tqICogMiArIDFdLFxuICAgICAgICAgICAgaW50ZXJzZWN0ID0gKCh5aSA+IHkpICE9PSAoeWogPiB5KSkgJiYgKHggPCAoeGogLSB4aSkgKiAoeSAtIHlpKSAvICh5aiAtIHlpKSArIHhpKTtcblxuICAgICAgICBpZiAoaW50ZXJzZWN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc2lkZTtcbn07XG4iLCJ2YXIgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG4vKipcbiAqIHRoZSBSZWN0YW5nbGUgb2JqZWN0IGlzIGFuIGFyZWEgZGVmaW5lZCBieSBpdHMgcG9zaXRpb24sIGFzIGluZGljYXRlZCBieSBpdHMgdG9wLWxlZnQgY29ybmVyIHBvaW50ICh4LCB5KSBhbmQgYnkgaXRzIHdpZHRoIGFuZCBpdHMgaGVpZ2h0LlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSBUaGUgb3ZlcmFsbCB3aWR0aCBvZiB0aGlzIHJlY3RhbmdsZVxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBUaGUgb3ZlcmFsbCBoZWlnaHQgb2YgdGhpcyByZWN0YW5nbGVcbiAqL1xuZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnggPSB4IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMueSA9IHkgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gQ09OU1QuU0hBUEVTLlJFQ1Q7XG59XG5cblJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWN0YW5nbGU7XG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZTtcblxuLyoqXG4gKiBBIGNvbnN0YW50IGVtcHR5IHJlY3RhbmdsZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RhbnRcbiAqL1xuUmVjdGFuZ2xlLkVNUFRZID0gbmV3IFJlY3RhbmdsZSgwLCAwLCAwLCAwKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIFJlY3RhbmdsZVxuICpcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX0gYSBjb3B5IG9mIHRoZSByZWN0YW5nbGVcbiAqL1xuUmVjdGFuZ2xlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcbiAqXG4gKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxuICovXG5SZWN0YW5nbGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgsIHkpXG57XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDwgdGhpcy54ICsgdGhpcy53aWR0aClcbiAgICB7XG4gICAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbiIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogVGhlIFJvdW5kZWQgUmVjdGFuZ2xlIG9iamVjdCBpcyBhbiBhcmVhIHRoYXQgaGFzIG5pY2Ugcm91bmRlZCBjb3JuZXJzLCBhcyBpbmRpY2F0ZWQgYnkgaXRzIHRvcC1sZWZ0IGNvcm5lciBwb2ludCAoeCwgeSkgYW5kIGJ5IGl0cyB3aWR0aCBhbmQgaXRzIGhlaWdodCBhbmQgaXRzIHJhZGl1cy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcbiAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZVxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IFRoZSBvdmVyYWxsIHdpZHRoIG9mIHRoaXMgcm91bmRlZCByZWN0YW5nbGVcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gVGhlIG92ZXJhbGwgaGVpZ2h0IG9mIHRoaXMgcm91bmRlZCByZWN0YW5nbGVcbiAqIEBwYXJhbSByYWRpdXMge251bWJlcn0gQ29udHJvbHMgdGhlIHJhZGl1cyBvZiB0aGUgcm91bmRlZCBjb3JuZXJzXG4gKi9cbmZ1bmN0aW9uIFJvdW5kZWRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKVxue1xuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy54ID0geCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDIwXG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXMgfHwgMjA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gQ09OU1QuU0hBUEVTLlJSRUM7XG59XG5cblJvdW5kZWRSZWN0YW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm91bmRlZFJlY3RhbmdsZTtcbm1vZHVsZS5leHBvcnRzID0gUm91bmRlZFJlY3RhbmdsZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBSb3VuZGVkIFJlY3RhbmdsZVxuICpcbiAqIEByZXR1cm4ge1JvdW5kZWRSZWN0YW5nbGV9IGEgY29weSBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcbiAqL1xuUm91bmRlZFJlY3RhbmdsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBuZXcgUm91bmRlZFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucmFkaXVzKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSb3VuZGVkIFJlY3RhbmdsZVxuICpcbiAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgUm91bmRlZCBSZWN0YW5nbGVcbiAqL1xuUm91bmRlZFJlY3RhbmdsZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoeCwgeSlcbntcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHggPj0gdGhpcy54ICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aClcbiAgICB7XG4gICAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG4iLCJ2YXIgQ29udGFpbmVyID0gcmVxdWlyZSgnLi4vZGlzcGxheS9Db250YWluZXInKTtcblxuLyoqXG4gKiBUaGUgUGFydGljbGVDb250YWluZXIgY2xhc3MgaXMgYSByZWFsbHkgZmFzdCB2ZXJzaW9uIG9mIHRoZSBDb250YWluZXIgYnVpbHQgc29sZWx5IGZvciBzcGVlZCxcbiAqIHNvIHVzZSB3aGVuIHlvdSBuZWVkIGEgbG90IG9mIHNwcml0ZXMgb3IgcGFydGljbGVzLiBUaGUgdHJhZGVvZmYgb2YgdGhlIFBhcnRpY2xlQ29udGFpbmVyIGlzIHRoYXQgYWR2YW5jZWRcbiAqIGZ1bmN0aW9uYWxpdHkgd2lsbCBub3Qgd29yay4gUGFydGljbGVDb250YWluZXIgaW1wbGVtZW50cyBvbmx5IHRoZSBiYXNpYyBvYmplY3QgdHJhbnNmb3JtIChwb3NpdGlvbiwgc2NhbGUsIHJvdGF0aW9uKS5cbiAqIEFueSBvdGhlciBmdW5jdGlvbmFsaXR5IGxpa2UgdGludGluZywgbWFza2luZywgZXRjIHdpbGwgbm90IHdvcmsgb24gc3ByaXRlcyBpbiB0aGlzIGJhdGNoLlxuICpcbiAqIEl0J3MgZXh0cmVtZWx5IGVhc3kgdG8gdXNlIDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGNvbnRhaW5lciA9IG5ldyBQYXJ0aWNsZUNvbnRhaW5lcigpO1xuICpcbiAqIGZvciAodmFyIGkgPSAwOyBpIDwgMTAwOyArK2kpXG4gKiB7XG4gKiAgICAgdmFyIHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoXCJteUltYWdlLnBuZ1wiKTtcbiAqICAgICBjb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFuZCBoZXJlIHlvdSBoYXZlIGEgaHVuZHJlZCBzcHJpdGVzIHRoYXQgd2lsbCBiZSByZW5kZXJlciBhdCB0aGUgc3BlZWQgb2YgbGlnaHQuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBDb250YWluZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKlxuICogQHBhcmFtIFtzaXplPTE1MDAwXSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGltYWdlcyBpbiB0aGUgU3ByaXRlQmF0Y2ggYmVmb3JlIGl0IGZsdXNoZXMuXG4gKiBAcGFyYW0gW3Byb3BlcnRpZXNdIHtvYmplY3R9IFRoZSBwcm9wZXJ0aWVzIG9mIGNoaWxkcmVuIHRoYXQgc2hvdWxkIGJlIHVwbG9hZGVkIHRvIHRoZSBncHUgYW5kIGFwcGxpZWQuXG4gKiBAcGFyYW0gW3Byb3BlcnRpZXMuc2NhbGU9ZmFsc2VdIHtib29sZWFufSBXaGVuIHRydWUsIHNjYWxlIGJlIHVwbG9hZGVkIGFuZCBhcHBsaWVkLlxuICogQHBhcmFtIFtwcm9wZXJ0aWVzLnBvc2l0aW9uPXRydWVdIHtib29sZWFufSBXaGVuIHRydWUsIHBvc2l0aW9uIGJlIHVwbG9hZGVkIGFuZCBhcHBsaWVkLlxuICogQHBhcmFtIFtwcm9wZXJ0aWVzLnJvdGF0aW9uPWZhbHNlXSB7Ym9vbGVhbn0gV2hlbiB0cnVlLCByb3RhdGlvbiBiZSB1cGxvYWRlZCBhbmQgYXBwbGllZC5cbiAqIEBwYXJhbSBbcHJvcGVydGllcy51dnM9ZmFsc2VdIHtib29sZWFufSBXaGVuIHRydWUsIHV2cyBiZSB1cGxvYWRlZCBhbmQgYXBwbGllZC5cbiAqIEBwYXJhbSBbcHJvcGVydGllcy5hbHBoYT1mYWxzZV0ge2Jvb2xlYW59IFdoZW4gdHJ1ZSwgYWxwaGEgYmUgdXBsb2FkZWQgYW5kIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIFBhcnRpY2xlQ29udGFpbmVyKHNpemUsIHByb3BlcnRpZXMpXG57XG4gICAgQ29udGFpbmVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcHJvcGVydGllcyB0byBiZSBkeW5hbWljICh0cnVlKSAvIHN0YXRpYyAoZmFsc2UpXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHthcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBbZmFsc2UsIHRydWUsIGZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc2l6ZSA9IHNpemUgfHwgMTUwMDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtXZWJHTEJ1ZmZlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3VwZGF0ZVN0YXRpYyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJhY3RpdmVDaGlsZHJlbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xufVxuXG5QYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbnRhaW5lci5wcm90b3R5cGUpO1xuUGFydGljbGVDb250YWluZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGljbGVDb250YWluZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlQ29udGFpbmVyO1xuXG4vKipcbiAqIFNldHMgdGhlIHByaXZhdGUgcHJvcGVydGllcyBhcnJheSB0byBkeW5hbWljIC8gc3RhdGljIGJhc2VkIG9uIHRoZSBwYXNzZWQgcHJvcGVydGllcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0gcHJvcGVydGllcyB7b2JqZWN0fSBUaGUgcHJvcGVydGllcyB0byBiZSB1cGxvYWRlZFxuICovXG5QYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUuc2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpXG57XG4gICAgaWYgKCBwcm9wZXJ0aWVzICkge1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzWzBdID0gJ3NjYWxlJyBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnNjYWxlIDogdGhpcy5fcHJvcGVydGllc1swXTtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc1sxXSA9ICdwb3NpdGlvbicgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy5wb3NpdGlvbiA6IHRoaXMuX3Byb3BlcnRpZXNbMV07XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXNbMl0gPSAncm90YXRpb24nIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMucm90YXRpb24gOiB0aGlzLl9wcm9wZXJ0aWVzWzJdO1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzWzNdID0gJ3V2cycgaW4gcHJvcGVydGllcyA/ICEhcHJvcGVydGllcy51dnMgOiB0aGlzLl9wcm9wZXJ0aWVzWzNdO1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzWzRdID0gJ2FscGhhJyBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLmFscGhhIDogdGhpcy5fcHJvcGVydGllc1s0XTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG9iamVjdCB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZ1xuICpcbiAqIEBwcml2YXRlXG4gKi9cblBhcnRpY2xlQ29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIFRPRE8gZG9uJ3QgbmVlZCB0byFcbiAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAvLyAgUElYSS5Db250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKCB0aGlzICk7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGNvbnRhaW5lciB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1dlYkdMUmVuZGVyZXJ9IFRoZSB3ZWJnbCByZW5kZXJlclxuICogQHByaXZhdGVcbiAqL1xuUGFydGljbGVDb250YWluZXIucHJvdG90eXBlLnJlbmRlcldlYkdMID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5yZW5kZXJhYmxlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbmRlcmVyLnNldE9iamVjdFJlbmRlcmVyKCByZW5kZXJlci5wbHVnaW5zLnBhcnRpY2xlICk7XG4gICAgcmVuZGVyZXIucGx1Z2lucy5wYXJ0aWNsZS5yZW5kZXIoIHRoaXMgKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGNoaWxkIHRvIHRoaXMgcGFydGljbGUgY29udGFpbmVyIGF0IGEgc3BlY2lmaWVkIGluZGV4LiBJZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcyBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICpcbiAqIEBwYXJhbSBjaGlsZCB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRvIGFkZFxuICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9IFRoZSBpbmRleCB0byBwbGFjZSB0aGUgY2hpbGQgaW5cbiAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyBhZGRlZC5cbiAqL1xuUGFydGljbGVDb250YWluZXIucHJvdG90eXBlLmFkZENoaWxkQXQgPSBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KVxue1xuICAgIC8vIHByZXZlbnQgYWRkaW5nIHNlbGYgYXMgY2hpbGRcbiAgICBpZiAoY2hpbGQgPT09IHRoaXMpXG4gICAge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAge1xuICAgICAgICBpZiAoY2hpbGQucGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVN0YXRpYyA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2hpbGQgKyAnYWRkQ2hpbGRBdDogVGhlIGluZGV4ICcrIGluZGV4ICsnIHN1cHBsaWVkIGlzIG91dCBvZiBib3VuZHMgJyArIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjaGlsZCBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXggcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9IFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGZyb21cbiAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyByZW1vdmVkLlxuICovXG5QYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQ2hpbGRBdCA9IGZ1bmN0aW9uIChpbmRleClcbntcbiAgICB2YXIgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoaW5kZXgpO1xuXG4gICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5fdXBkYXRlU3RhdGljID0gdHJ1ZTtcblxuICAgIHJldHVybiBjaGlsZDtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge0NhbnZhc1JlbmRlcmVyfSBUaGUgY2FudmFzIHJlbmRlcmVyXG4gKiBAcHJpdmF0ZVxuICovXG5QYXJ0aWNsZUNvbnRhaW5lci5wcm90b3R5cGUucmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5yZW5kZXJhYmxlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0gcmVuZGVyZXIuY29udGV4dDtcbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICB2YXIgaXNSb3RhdGVkID0gdHJ1ZTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG5cbiAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSlcbiAgICB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgICAgaWYgKCFjaGlsZC52aXNpYmxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmcmFtZSA9IGNoaWxkLnRleHR1cmUuZnJhbWU7XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMud29ybGRBbHBoYSAqIGNoaWxkLmFscGhhO1xuXG4gICAgICAgIGlmIChjaGlsZC5yb3RhdGlvbiAlIChNYXRoLlBJICogMikgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGZhc3Rlc3QgIHdheSB0byBvcHRpbWlzZSEgLSBpZiByb3RhdGlvbiBpcyAwIHRoZW4gd2UgY2FuIGF2b2lkIGFueSBraW5kIG9mIHNldFRyYW5zZm9ybSBjYWxsXG4gICAgICAgICAgICBpZiAoaXNSb3RhdGVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uYSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmIsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5jLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLnR4LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udHlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaXNSb3RhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgIGNoaWxkLnRleHR1cmUuYmFzZVRleHR1cmUuc291cmNlLFxuICAgICAgICAgICAgICAgIGZyYW1lLngsXG4gICAgICAgICAgICAgICAgZnJhbWUueSxcbiAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgKChjaGlsZC5hbmNob3IueCkgKiAoLWZyYW1lLndpZHRoICogY2hpbGQuc2NhbGUueCkgKyBjaGlsZC5wb3NpdGlvbi54ICArIDAuNSkgfCAwLFxuICAgICAgICAgICAgICAgICgoY2hpbGQuYW5jaG9yLnkpICogKC1mcmFtZS5oZWlnaHQgKiBjaGlsZC5zY2FsZS55KSArIGNoaWxkLnBvc2l0aW9uLnkgICsgMC41KSB8IDAsXG4gICAgICAgICAgICAgICAgZnJhbWUud2lkdGggKiBjaGlsZC5zY2FsZS54LFxuICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCAqIGNoaWxkLnNjYWxlLnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWlzUm90YXRlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpc1JvdGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZC5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZFRyYW5zZm9ybSA9IGNoaWxkLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgICAgICAgICBpZiAocmVuZGVyZXIucm91bmRQaXhlbHMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLmEsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLmIsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLmMsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLmQsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLnR4IHwgMCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0udHkgfCAwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0uYSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0uYixcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0uYyxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0uZCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUcmFuc2Zvcm0udHgsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVHJhbnNmb3JtLnR5XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgY2hpbGQudGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgZnJhbWUueCxcbiAgICAgICAgICAgICAgICBmcmFtZS55LFxuICAgICAgICAgICAgICAgIGZyYW1lLndpZHRoLFxuICAgICAgICAgICAgICAgIGZyYW1lLmhlaWdodCxcbiAgICAgICAgICAgICAgICAoKGNoaWxkLmFuY2hvci54KSAqICgtZnJhbWUud2lkdGgpICsgMC41KSB8IDAsXG4gICAgICAgICAgICAgICAgKChjaGlsZC5hbmNob3IueSkgKiAoLWZyYW1lLmhlaWdodCkgKyAwLjUpIHwgMCxcbiAgICAgICAgICAgICAgICBmcmFtZS53aWR0aCxcbiAgICAgICAgICAgICAgICBmcmFtZS5oZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICpcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIHBpeGkgdmVyc2lvbiFcbiAqIEFsc28gYSB0aGFua3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL2JjaGV2YWxpZXIgZm9yIHR3ZWFraW5nIHRoZSB0aW50IGFuZCBhbHBoYSBzbyB0aGF0IHRoZXkgbm93IHNoYXJlIDQgYnl0ZXMgb24gdGhlIHZlcnRleCBidWZmZXJcbiAqXG4gKiBIZWF2aWx5IGluc3BpcmVkIGJ5IExpYkdEWCdzIFBhcnRpY2xlQnVmZmVyOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi9tYXN0ZXIvZ2R4L3NyYy9jb20vYmFkbG9naWMvZ2R4L2dyYXBoaWNzL2cyZC9QYXJ0aWNsZUJ1ZmZlci5qYXZhXG4gKi9cblxuLyoqXG4gKlxuICogQGNsYXNzXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHRoaXMgc3ByaXRlIGJhdGNoIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gUGFydGljbGVCdWZmZXIoZ2wsIHByb3BlcnRpZXMsIHNpemUpXG57XG4gICAgLyoqXG4gICAgICogdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0U2l6ZSA9IDI7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudmVydEJ5dGVTaXplID0gdGhpcy52ZXJ0U2l6ZSAqIDQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGltYWdlcyBpbiB0aGUgU3ByaXRlQmF0Y2ggYmVmb3JlIGl0IGZsdXNoZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zaXplID0gc2l6ZTtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqXG4gICAgICogQG1lbWJlciB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5keW5hbWljUHJvcGVydGllcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRpY1Byb3BlcnRpZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG5cbiAgICAgICAgaWYocHJvcGVydHkuZHluYW1pYylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGljU3RyaWRlID0gMDtcbiAgICB0aGlzLnN0YXRpY0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5zdGF0aWNEYXRhID0gbnVsbDtcblxuICAgIHRoaXMuZHluYW1pY1N0cmlkZSA9IDA7XG4gICAgdGhpcy5keW5hbWljQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmR5bmFtaWNEYXRhID0gbnVsbDtcblxuICAgIHRoaXMuaW5pdEJ1ZmZlcnMoKTtcblxufVxuXG5QYXJ0aWNsZUJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJ0aWNsZUJ1ZmZlcjtcbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGVCdWZmZXI7XG5cbi8qKlxuICogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiAqL1xuUGFydGljbGVCdWZmZXIucHJvdG90eXBlLmluaXRCdWZmZXJzID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBpO1xuICAgIHZhciBwcm9wZXJ0eTtcblxuICAgIHZhciBkeW5hbWljT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmR5bmFtaWNTdHJpZGUgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBwcm9wZXJ0eSA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV07XG5cbiAgICAgICAgcHJvcGVydHkub2Zmc2V0ID0gZHluYW1pY09mZnNldDtcbiAgICAgICAgZHluYW1pY09mZnNldCArPSBwcm9wZXJ0eS5zaXplO1xuICAgICAgICB0aGlzLmR5bmFtaWNTdHJpZGUgKz0gcHJvcGVydHkuc2l6ZTtcbiAgICB9XG5cbiAgICB0aGlzLmR5bmFtaWNEYXRhID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5zaXplICogdGhpcy5keW5hbWljU3RyaWRlICogNCk7XG4gICAgdGhpcy5keW5hbWljQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5keW5hbWljQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5keW5hbWljRGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcblxuXG4gICAgLy8gc3RhdGljIC8vXG4gICAgdmFyIHN0YXRpY09mZnNldCA9IDA7XG4gICAgdGhpcy5zdGF0aWNTdHJpZGUgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc3RhdGljUHJvcGVydGllcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHByb3BlcnR5ID0gdGhpcy5zdGF0aWNQcm9wZXJ0aWVzW2ldO1xuXG4gICAgICAgIHByb3BlcnR5Lm9mZnNldCA9IHN0YXRpY09mZnNldDtcbiAgICAgICAgc3RhdGljT2Zmc2V0ICs9IHByb3BlcnR5LnNpemU7XG4gICAgICAgIHRoaXMuc3RhdGljU3RyaWRlICs9IHByb3BlcnR5LnNpemU7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0aWNEYXRhID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5zaXplICogdGhpcy5zdGF0aWNTdHJpZGUgKiA0KTtcbiAgICB0aGlzLnN0YXRpY0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuc3RhdGljQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5zdGF0aWNEYXRhLCBnbC5EWU5BTUlDX0RSQVcpO1xuXG59O1xuXG5QYXJ0aWNsZUJ1ZmZlci5wcm90b3R5cGUudXBsb2FkRHluYW1pYyA9IGZ1bmN0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV07XG4gICAgICAgIHByb3BlcnR5LnVwbG9hZEZ1bmN0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIHRoaXMuZHluYW1pY0RhdGEsIHRoaXMuZHluYW1pY1N0cmlkZSwgcHJvcGVydHkub2Zmc2V0KTtcbiAgICB9XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5keW5hbWljQnVmZmVyKTtcbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy5keW5hbWljRGF0YSk7XG59O1xuXG5QYXJ0aWNsZUJ1ZmZlci5wcm90b3R5cGUudXBsb2FkU3RhdGljID0gZnVuY3Rpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnN0YXRpY1Byb3BlcnRpZXNbaV07XG4gICAgICAgIHByb3BlcnR5LnVwbG9hZEZ1bmN0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIHRoaXMuc3RhdGljRGF0YSwgdGhpcy5zdGF0aWNTdHJpZGUsIHByb3BlcnR5Lm9mZnNldCk7XG4gICAgfVxuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuc3RhdGljQnVmZmVyKTtcbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy5zdGF0aWNEYXRhKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgbmV3IHNwcml0ZSBiYXRjaC5cbiAqXG4gKi9cblBhcnRpY2xlQnVmZmVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBpLCBwcm9wZXJ0eTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmR5bmFtaWNCdWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBwcm9wZXJ0eSA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV07XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocHJvcGVydHkuYXR0cmlidXRlLCBwcm9wZXJ0eS5zaXplLCBnbC5GTE9BVCwgZmFsc2UsIHRoaXMuZHluYW1pY1N0cmlkZSAqIDQsIHByb3BlcnR5Lm9mZnNldCAqIDQpO1xuICAgIH1cblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnN0YXRpY0J1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgcHJvcGVydHkgPSB0aGlzLnN0YXRpY1Byb3BlcnRpZXNbaV07XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocHJvcGVydHkuYXR0cmlidXRlLCBwcm9wZXJ0eS5zaXplLCBnbC5GTE9BVCwgZmFsc2UsIHRoaXMuc3RhdGljU3RyaWRlICogNCwgcHJvcGVydHkub2Zmc2V0ICogNCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgU3ByaXRlQmF0Y2guXG4gKlxuICovXG5QYXJ0aWNsZUJ1ZmZlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy9UT0RPIGltcGxlbWVudCB0aGlzIDopIHRvIGJ1c3kgbWFraW5nIHRoZSBmdW4gYml0cy4uXG59O1xuIiwidmFyIE9iamVjdFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vLi4vcmVuZGVyZXJzL3dlYmdsL3V0aWxzL09iamVjdFJlbmRlcmVyJyksXG4gICAgV2ViR0xSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy93ZWJnbC9XZWJHTFJlbmRlcmVyJyksXG4gICAgUGFydGljbGVTaGFkZXIgPSByZXF1aXJlKCcuL1BhcnRpY2xlU2hhZGVyJyksXG4gICAgUGFydGljbGVCdWZmZXIgPSByZXF1aXJlKCcuL1BhcnRpY2xlQnVmZmVyJyksXG4gICAgbWF0aCAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbWF0aCcpO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICpcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIHBpeGkgdmVyc2lvbiFcbiAqIEFsc28gYSB0aGFua3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL2JjaGV2YWxpZXIgZm9yIHR3ZWFraW5nIHRoZSB0aW50IGFuZCBhbHBoYSBzbyB0aGF0IHRoZXkgbm93IHNoYXJlIDQgYnl0ZXMgb24gdGhlIHZlcnRleCBidWZmZXJcbiAqXG4gKiBIZWF2aWx5IGluc3BpcmVkIGJ5IExpYkdEWCdzIFBhcnRpY2xlUmVuZGVyZXI6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbGliZ2R4L2xpYmdkeC9ibG9iL21hc3Rlci9nZHgvc3JjL2NvbS9iYWRsb2dpYy9nZHgvZ3JhcGhpY3MvZzJkL1BhcnRpY2xlUmVuZGVyZXIuamF2YVxuICovXG5cbi8qKlxuICpcbiAqIEBjbGFzc1xuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gcmVuZGVyZXIge1dlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIHNwcml0ZSBiYXRjaCB3b3JrcyBmb3IuXG4gKi9cbmZ1bmN0aW9uIFBhcnRpY2xlUmVuZGVyZXIocmVuZGVyZXIpXG57XG4gICAgT2JqZWN0UmVuZGVyZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaW1hZ2VzIGluIHRoZSBQYXJ0aWNsZSBiZWZvcmUgaXQgZmx1c2hlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNpemUgPSAxNTAwMDsvL0NPTlNULlNQUklURV9CQVRDSF9TSVpFOyAvLyAyMDAwIGlzIGEgbmljZSBiYWxhbmNlIGJldHdlZW4gbW9iaWxlIC8gZGVza3RvcFxuXG4gICAgdmFyIG51bUluZGljZXMgPSB0aGlzLnNpemUgKiA2O1xuXG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgaW5kaWNlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7VWludDE2QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KG51bUluZGljZXMpO1xuXG4gICAgZm9yICh2YXIgaT0wLCBqPTA7IGkgPCBudW1JbmRpY2VzOyBpICs9IDYsIGogKz0gNClcbiAgICB7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMF0gPSBqICsgMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAxXSA9IGogKyAxO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDJdID0gaiArIDI7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgM10gPSBqICsgMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA0XSA9IGogKyAyO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDVdID0gaiArIDM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgc2hhZGVyIHRoYXQgaXMgdXNlZCBpZiBhIHNwcml0ZSBkb2Vzbid0IGhhdmUgYSBtb3JlIHNwZWNpZmljIG9uZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1NoYWRlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG5cbiAgICB0aGlzLnRlbXBNYXRyaXggPSBuZXcgbWF0aC5NYXRyaXgoKTtcblxuXG5cblxufVxuXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlKTtcblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGljbGVSZW5kZXJlcjtcbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGVSZW5kZXJlcjtcblxuV2ViR0xSZW5kZXJlci5yZWdpc3RlclBsdWdpbigncGFydGljbGUnLCBQYXJ0aWNsZVJlbmRlcmVyKTtcblxuLyoqXG4gKiBXaGVuIHRoZXJlIGlzIGEgV2ViR0wgY29udGV4dCBjaGFuZ2VcbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqL1xuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgLy8gc2V0dXAgZGVmYXVsdCBzaGFkZXJcbiAgICB0aGlzLnNoYWRlciA9IG5ldyBQYXJ0aWNsZVNoYWRlcih0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIpO1xuXG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgLy8gNjU1MzUgaXMgbWF4IGluZGV4LCBzbyA2NTUzNSAvIDYgPSAxMDkyMi5cblxuICAgIC8vdXBsb2FkIHRoZSBpbmRleCBkYXRhXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG5cblxuICAgIHRoaXMucHJvcGVydGllcyA9IFtcbiAgICAvL3ZlcnRpY2VzRGF0YVxuICAgIHtcbiAgICAgICAgYXR0cmlidXRlOnRoaXMuc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLFxuICAgICAgICBkeW5hbWljOmZhbHNlLFxuICAgICAgICBzaXplOjIsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOnRoaXMudXBsb2FkVmVydGljZXMsXG4gICAgICAgIG9mZnNldDowXG4gICAgfSxcbiAgICAvLyBwb3NpdGlvbkRhdGFcbiAgICB7XG4gICAgICAgIGF0dHJpYnV0ZTp0aGlzLnNoYWRlci5hdHRyaWJ1dGVzLmFQb3NpdGlvbkNvb3JkLFxuICAgICAgICBkeW5hbWljOnRydWUsXG4gICAgICAgIHNpemU6MixcbiAgICAgICAgdXBsb2FkRnVuY3Rpb246dGhpcy51cGxvYWRQb3NpdGlvbixcbiAgICAgICAgb2Zmc2V0OjBcbiAgICB9LFxuICAgIC8vIHJvdGF0aW9uRGF0YVxuICAgIHtcbiAgICAgICAgYXR0cmlidXRlOnRoaXMuc2hhZGVyLmF0dHJpYnV0ZXMuYVJvdGF0aW9uLFxuICAgICAgICBkeW5hbWljOmZhbHNlLFxuICAgICAgICBzaXplOjEsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOnRoaXMudXBsb2FkUm90YXRpb24sXG4gICAgICAgIG9mZnNldDowXG4gICAgfSxcbiAgICAvL3UgdnNEYXRhXG4gICAge1xuICAgICAgICBhdHRyaWJ1dGU6dGhpcy5zaGFkZXIuYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLFxuICAgICAgICBkeW5hbWljOmZhbHNlLFxuICAgICAgICBzaXplOjIsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOnRoaXMudXBsb2FkVXZzLFxuICAgICAgICBvZmZzZXQ6MFxuICAgIH0sXG4gICAgLy8gYWxwaGFEYXRhXG4gICAge1xuICAgICAgICBhdHRyaWJ1dGU6dGhpcy5zaGFkZXIuYXR0cmlidXRlcy5hQ29sb3IsXG4gICAgICAgIGR5bmFtaWM6ZmFsc2UsXG4gICAgICAgIHNpemU6MSxcbiAgICAgICAgdXBsb2FkRnVuY3Rpb246dGhpcy51cGxvYWRBbHBoYSxcbiAgICAgICAgb2Zmc2V0OjBcbiAgICB9XTtcblxufTtcblxuLyoqXG4gKiBTdGFydHMgYSBuZXcgc3ByaXRlIGJhdGNoLlxuICpcbiAqL1xuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAvLyBiaW5kIHRoZSBtYWluIHRleHR1cmVcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblxuICAgIC8vIGJpbmQgdGhlIGJ1ZmZlcnNcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuXG4gICAgdmFyIHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuXG4gICAgdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnNldFNoYWRlcihzaGFkZXIpO1xufTtcblxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIHNwcml0ZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGNvbnRhaW5lciB7Q29udGFpbmVyfFNwcml0ZX0gdGhlIHNwcml0ZSB0byByZW5kZXIgdXNpbmcgdGhpcyBQYXJ0aWNsZVJlbmRlcmVyXG4gKi9cblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICggY29udGFpbmVyIClcbntcbiAgICB2YXIgY2hpbGRyZW4gPSBjb250YWluZXIuY2hpbGRyZW4sXG4gICAgICAgIHRvdGFsQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgIG1heFNpemUgPSBjb250YWluZXIuX3NpemU7XG5cbiAgICBpZih0b3RhbENoaWxkcmVuID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmKHRvdGFsQ2hpbGRyZW4gPiBtYXhTaXplKVxuICAgIHtcbiAgICAgICAgdG90YWxDaGlsZHJlbiA9IG1heFNpemU7XG4gICAgfVxuXG4gICAgaWYoIWNvbnRhaW5lci5fYnVmZmVycylcbiAgICB7XG4gICAgICAgIGNvbnRhaW5lci5fYnVmZmVycyA9IHRoaXMuZ2VuZXJhdGVCdWZmZXJzKCBjb250YWluZXIgKTtcbiAgICB9XG5cblxuXG4gICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxuICAgIC8vdGhpcy5yZW5kZXJlci5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZShzcHJpdGUuYmxlbmRNb2RlKTtcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgdmFyIG0gPSAgY29udGFpbmVyLndvcmxkVHJhbnNmb3JtLmNvcHkoIHRoaXMudGVtcE1hdHJpeCApO1xuICAgIG0ucHJlcGVuZCggdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXggKTtcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgbS50b0FycmF5KHRydWUpKTtcblxuICAgIC8vIGlmIHRoaXMgdmFyaWFibGUgaXMgdHJ1ZSB0aGVuIHdlIHdpbGwgdXBsb2FkIHRoZSBzdGF0aWMgY29udGVudHMgYXMgd2VsbCBhcyB0aGUgZHluYW1pYyBjb250ZW5zXG4gICAgdmFyIHVwbG9hZFN0YXRpYyA9IGNvbnRhaW5lci5fdXBkYXRlU3RhdGljO1xuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSB0ZXh0dXJlIGlzIGJvdW5kLi5cbiAgICB2YXIgYmFzZVRleHR1cmUgPSBjaGlsZHJlblswXS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcblxuICAgIGlmICghYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKVxuICAgIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVUZXh0dXJlKGJhc2VUZXh0dXJlKTtcbiAgICAgICAgaWYoIXRoaXMucHJvcGVydGllc1swXS5keW5hbWljIHx8ICF0aGlzLnByb3BlcnRpZXNbM10uZHluYW1pYylcbiAgICAgICAge1xuICAgICAgICAgICAgdXBsb2FkU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBiYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pO1xuICAgIH1cblxuICAgIC8vIG5vdyBsZXRzIHVwbG9hZCBhbmQgcmVuZGVyIHRoZSBidWZmZXJzLi5cbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbENoaWxkcmVuOyBpKz10aGlzLnNpemUpXG4gICAge1xuICAgICAgICAgdmFyIGFtb3VudCA9ICggdG90YWxDaGlsZHJlbiAtIGkpO1xuICAgICAgICBpZihhbW91bnQgPiB0aGlzLnNpemUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFtb3VudCA9IHRoaXMuc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidWZmZXIgPSBjb250YWluZXIuX2J1ZmZlcnNbaisrXTtcblxuICAgICAgICAvLyB3ZSBhbHdheXMgdXBsb2FkIHRoZSBkeW5hbWljXG4gICAgICAgIGJ1ZmZlci51cGxvYWREeW5hbWljKGNoaWxkcmVuLCBpLCBhbW91bnQpO1xuXG4gICAgICAgIC8vIHdlIG9ubHkgdXBsb2FkIHRoZSBzdGF0aWMgY29udGVudCB3aGVuIHdlIGhhdmUgdG8hXG4gICAgICAgIGlmKHVwbG9hZFN0YXRpYylcbiAgICAgICAge1xuICAgICAgICAgICAgYnVmZmVyLnVwbG9hZFN0YXRpYyhjaGlsZHJlbiwgaSwgYW1vdW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJpbmQgdGhlIGJ1ZmZlclxuICAgICAgICBidWZmZXIuYmluZCggdGhpcy5zaGFkZXIgKTtcblxuICAgICAgICAgLy8gbm93IGRyYXcgdGhvc2Ugc3Vja2FzIVxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBhbW91bnQgKiA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZHJhd0NvdW50Kys7XG4gICAgfVxuXG4gICAgY29udGFpbmVyLl91cGRhdGVTdGF0aWMgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBvbmUgcGFydGljbGUgYnVmZmVyIGZvciBlYWNoIGNoaWxkIGluIHRoZSBjb250YWluZXIgd2Ugd2FudCB0byByZW5kZXIgYW5kIHVwZGF0ZXMgaW50ZXJuYWwgcHJvcGVydGllc1xuICpcbiAqIEBwYXJhbSBjb250YWluZXIge0NvbnRhaW5lcnxTcHJpdGV9IHRoZSBzcHJpdGUgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxuICovXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZUJ1ZmZlcnMgPSBmdW5jdGlvbiAoIGNvbnRhaW5lciApXG57XG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbCxcbiAgICAgICAgYnVmZmVycyA9IFtdLFxuICAgICAgICBzaXplID0gY29udGFpbmVyLl9zaXplLFxuICAgICAgICBpO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBwcm9wZXJ0aWVzIHRvIG1hdGNoIHRoZSBzdGF0ZSBvZiB0aGUgY29udGFpbmVyLi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29udGFpbmVyLl9wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW2ldLmR5bmFtaWMgPSBjb250YWluZXIuX3Byb3BlcnRpZXNbaV07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkgKz0gdGhpcy5zaXplKVxuICAgIHtcbiAgICAgICAgYnVmZmVycy5wdXNoKCBuZXcgUGFydGljbGVCdWZmZXIoZ2wsICB0aGlzLnByb3BlcnRpZXMsIHRoaXMuc2l6ZSwgdGhpcy5zaGFkZXIpICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcnM7XG59O1xuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSBjaGlsZHJlbiB7QXJyYXl9IHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXG4gKiBAcGFyYW0gc3RhcnRJbmRleCB7bnVtYmVyfSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAqIEBwYXJhbSBhbW91bnQge251bWJlcn0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciB2ZXJ0aWNlcyB1cGxvYWRlZFxuICogQHBhcmFtIGFycmF5IHtBcnJheX1cbiAqIEBwYXJhbSBzdHJpZGUge251bWJlcn1cbiAqIEBwYXJhbSBvZmZzZXQge251bWJlcn1cbiAqL1xuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUudXBsb2FkVmVydGljZXMgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KVxue1xuICAgIHZhciBzcHJpdGUsXG4gICAgICAgIHRleHR1cmUsXG4gICAgICAgIHRyaW0sXG4gICAgICAgIHN4LFxuICAgICAgICBzeSxcbiAgICAgICAgdzAsIHcxLCBoMCwgaDE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG5cbiAgICAgICAgc3ByaXRlID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldO1xuICAgICAgICB0ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xuICAgICAgICBzeCA9IHNwcml0ZS5zY2FsZS54O1xuICAgICAgICBzeSA9IHNwcml0ZS5zY2FsZS55O1xuXG4gICAgICAgIGlmICh0ZXh0dXJlLnRyaW0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZCB0aGVuIHdlIG5lZWQgdG8gYWRkIHRoZSBleHRyYSBzcGFjZSBiZWZvcmUgdHJhbnNmb3JtaW5nIHRoZSBzcHJpdGUgY29vcmRzLi5cbiAgICAgICAgICAgIHRyaW0gPSB0ZXh0dXJlLnRyaW07XG5cbiAgICAgICAgICAgIHcxID0gdHJpbS54IC0gc3ByaXRlLmFuY2hvci54ICogdHJpbS53aWR0aDtcbiAgICAgICAgICAgIHcwID0gdzEgKyB0ZXh0dXJlLmNyb3Aud2lkdGg7XG5cbiAgICAgICAgICAgIGgxID0gdHJpbS55IC0gc3ByaXRlLmFuY2hvci55ICogdHJpbS5oZWlnaHQ7XG4gICAgICAgICAgICBoMCA9IGgxICsgdGV4dHVyZS5jcm9wLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHcwID0gKHRleHR1cmUuX2ZyYW1lLndpZHRoICkgKiAoMS1zcHJpdGUuYW5jaG9yLngpO1xuICAgICAgICAgICAgdzEgPSAodGV4dHVyZS5fZnJhbWUud2lkdGggKSAqIC1zcHJpdGUuYW5jaG9yLng7XG5cbiAgICAgICAgICAgIGgwID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ICogKDEtc3ByaXRlLmFuY2hvci55KTtcbiAgICAgICAgICAgIGgxID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ICogLXNwcml0ZS5hbmNob3IueTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W29mZnNldF0gPSB3MSAqIHN4O1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IGgxICogc3k7XG5cbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHcwICogc3g7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gaDEgKiBzeTtcblxuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHcwICogc3g7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDIgKyAxXSA9IGgwICogc3k7XG5cbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSB3MSAqIHN4O1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzICsgMV0gPSBoMCAqIHN5O1xuXG4gICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgIH1cblxufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIGNoaWxkcmVuIHtBcnJheX0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcbiAqIEBwYXJhbSBzdGFydEluZGV4IHtudW1iZXJ9IHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICogQHBhcmFtIGFtb3VudCB7bnVtYmVyfSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHBvc2l0aW9ucyB1cGxvYWRlZFxuICogQHBhcmFtIGFycmF5IHtBcnJheX1cbiAqIEBwYXJhbSBzdHJpZGUge251bWJlcn1cbiAqIEBwYXJhbSBvZmZzZXQge251bWJlcn1cbiAqL1xuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUudXBsb2FkUG9zaXRpb24gPSBmdW5jdGlvbiAoY2hpbGRyZW4sc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpXG57XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBzcHJpdGVQb3NpdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5wb3NpdGlvbjtcblxuICAgICAgICBhcnJheVtvZmZzZXRdID0gc3ByaXRlUG9zaXRpb24ueDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xuXG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IHNwcml0ZVBvc2l0aW9uLnk7XG5cbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMl0gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xuXG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gc3ByaXRlUG9zaXRpb24ueDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcblxuICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICB9XG5cbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBjaGlsZHJlbiB7QXJyYXl9IHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXG4gKiBAcGFyYW0gc3RhcnRJbmRleCB7bnVtYmVyfSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAqIEBwYXJhbSBhbW91bnQge251bWJlcn0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciByb3RhdGlvbiB1cGxvYWRlZFxuICogQHBhcmFtIGFycmF5IHtBcnJheX1cbiAqIEBwYXJhbSBzdHJpZGUge251bWJlcn1cbiAqIEBwYXJhbSBvZmZzZXQge251bWJlcn1cbiAqL1xuUGFydGljbGVSZW5kZXJlci5wcm90b3R5cGUudXBsb2FkUm90YXRpb24gPSBmdW5jdGlvbiAoY2hpbGRyZW4sc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpXG57XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBzcHJpdGVSb3RhdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5yb3RhdGlvbjtcblxuXG4gICAgICAgIGFycmF5W29mZnNldF0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHNwcml0ZVJvdGF0aW9uO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHNwcml0ZVJvdGF0aW9uO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHNwcml0ZVJvdGF0aW9uO1xuXG4gICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgIH1cbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBjaGlsZHJlbiB7QXJyYXl9IHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXG4gKiBAcGFyYW0gc3RhcnRJbmRleCB7bnVtYmVyfSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAqIEBwYXJhbSBhbW91bnQge251bWJlcn0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciBVdnMgdXBsb2FkZWRcbiAqIEBwYXJhbSBhcnJheSB7QXJyYXl9XG4gKiBAcGFyYW0gc3RyaWRlIHtudW1iZXJ9XG4gKiBAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9XG4gKi9cblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLnVwbG9hZFV2cyA9IGZ1bmN0aW9uIChjaGlsZHJlbixzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldClcbntcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHRleHR1cmVVdnMgPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0uX3RleHR1cmUuX3V2cztcblxuICAgICAgICBpZiAodGV4dHVyZVV2cylcbiAgICAgICAge1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IHRleHR1cmVVdnMueDA7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IHRleHR1cmVVdnMueTA7XG5cbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSB0ZXh0dXJlVXZzLngxO1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSB0ZXh0dXJlVXZzLnkxO1xuXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHRleHR1cmVVdnMueDI7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSB0ZXh0dXJlVXZzLnkyO1xuXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHRleHR1cmVVdnMueDM7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzICsgMV0gPSB0ZXh0dXJlVXZzLnkzO1xuXG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vVE9ETyB5b3Uga25vdyB0aGlzIGNhbiBiZSBlYXNpZXIhXG4gICAgICAgICAgICBhcnJheVtvZmZzZXRdID0gMDtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gMDtcblxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IDA7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IDA7XG5cbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gMDtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDIgKyAxXSA9IDA7XG5cbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gMDtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDMgKyAxXSA9IDA7XG5cbiAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIGNoaWxkcmVuIHtBcnJheX0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcbiAqIEBwYXJhbSBzdGFydEluZGV4IHtudW1iZXJ9IHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICogQHBhcmFtIGFtb3VudCB7bnVtYmVyfSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIGFscGhhIHVwbG9hZGVkXG4gKiBAcGFyYW0gYXJyYXkge0FycmF5fVxuICogQHBhcmFtIHN0cmlkZSB7bnVtYmVyfVxuICogQHBhcmFtIG9mZnNldCB7bnVtYmVyfVxuICovXG5QYXJ0aWNsZVJlbmRlcmVyLnByb3RvdHlwZS51cGxvYWRBbHBoYSA9IGZ1bmN0aW9uIChjaGlsZHJlbixzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldClcbntcbiAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKylcbiAgICAge1xuICAgICAgICB2YXIgc3ByaXRlQWxwaGEgPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0uYWxwaGE7XG5cbiAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IHNwcml0ZUFscGhhO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gc3ByaXRlQWxwaGE7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gc3ByaXRlQWxwaGE7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gc3ByaXRlQWxwaGE7XG5cbiAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBQYXJ0aWNsZS5cbiAqXG4gKi9cblBhcnRpY2xlUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuXG4gICAgdGhpcy5zaGFkZXIuZGVzdHJveSgpO1xuXG4gICAgLy9UT0RPIGltcGxlbWVudCB0aGlzIVxufTtcbiIsInZhciBUZXh0dXJlU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vcmVuZGVyZXJzL3dlYmdsL3NoYWRlcnMvVGV4dHVyZVNoYWRlcicpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgVGV4dHVyZVNoYWRlclxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSBzaGFkZXJNYW5hZ2VyIHtTaGFkZXJNYW5hZ2VyfSBUaGUgd2ViZ2wgc2hhZGVyIG1hbmFnZXIgdGhpcyBzaGFkZXIgd29ya3MgZm9yLlxuICovXG5mdW5jdGlvbiBQYXJ0aWNsZVNoYWRlcihzaGFkZXJNYW5hZ2VyKVxue1xuICAgIFRleHR1cmVTaGFkZXIuY2FsbCh0aGlzLFxuICAgICAgICBzaGFkZXJNYW5hZ2VyLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFtcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFDb2xvcjsnLFxuXG4gICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uQ29vcmQ7JyxcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhU2NhbGU7JyxcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYVJvdGF0aW9uOycsXG5cbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsnLFxuXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHZDb2xvcjsnLFxuXG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpeycsXG4gICAgICAgICAgICAnICAgdmVjMiB2ID0gYVZlcnRleFBvc2l0aW9uOycsXG5cbiAgICAgICAgICAgICcgICB2LnggPSAoYVZlcnRleFBvc2l0aW9uLngpICogY29zKGFSb3RhdGlvbikgLSAoYVZlcnRleFBvc2l0aW9uLnkpICogc2luKGFSb3RhdGlvbik7JyxcbiAgICAgICAgICAgICcgICB2LnkgPSAoYVZlcnRleFBvc2l0aW9uLngpICogc2luKGFSb3RhdGlvbikgKyAoYVZlcnRleFBvc2l0aW9uLnkpICogY29zKGFSb3RhdGlvbik7JyxcbiAgICAgICAgICAgICcgICB2ID0gdiArIGFQb3NpdGlvbkNvb3JkOycsXG5cbiAgICAgICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHYsIDEuMCkpLnh5LCAwLjAsIDEuMCk7JyxcblxuICAgICAgICAgICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4gICAgICAgICAgICAnICAgdkNvbG9yID0gYUNvbG9yOycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgLy8gaGVsbG9cbiAgICAgICAgIFtcbiAgICAgICAgICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxuXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHZDb2xvcjsnLFxuXG4gICAgICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcblxuICAgICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxuICAgICAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3IgOycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGN1c3RvbSBhdHRyaWJ1dGVzXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFQb3NpdGlvbkNvb3JkOiAwLFxuICAgICAgICAgICAvLyBhU2NhbGU6ICAgICAgICAgMCxcbiAgICAgICAgICAgIGFSb3RhdGlvbjogICAgICAwXG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gVEVNUCBIQUNLXG5cbn1cblxuUGFydGljbGVTaGFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUZXh0dXJlU2hhZGVyLnByb3RvdHlwZSk7XG5QYXJ0aWNsZVNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJ0aWNsZVNoYWRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJ0aWNsZVNoYWRlcjtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyksXG4gICAgbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKSxcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpLkV2ZW50RW1pdHRlcjtcblxuLyoqXG4gKiBUaGUgQ2FudmFzUmVuZGVyZXIgZHJhd3MgdGhlIHNjZW5lIGFuZCBhbGwgaXRzIGNvbnRlbnQgb250byBhIDJkIGNhbnZhcy4gVGhpcyByZW5kZXJlciBzaG91bGQgYmUgdXNlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCB3ZWJHTC5cbiAqIERvbid0IGZvcmdldCB0byBhZGQgdGhlIENhbnZhc1JlbmRlcmVyLnZpZXcgdG8geW91ciBET00gb3IgeW91IHdpbGwgbm90IHNlZSBhbnl0aGluZyA6KVxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSBzeXN0ZW0ge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHN5c3RlbSB0aGlzIHJlbmRlcmVyIGlzIGZvci5cbiAqIEBwYXJhbSBbd2lkdGg9ODAwXSB7bnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIGNhbnZhcyB2aWV3XG4gKiBAcGFyYW0gW2hlaWdodD02MDBdIHtudW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyB2aWV3XG4gKiBAcGFyYW0gW29wdGlvbnNdIHtvYmplY3R9IFRoZSBvcHRpb25hbCByZW5kZXJlciBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gW29wdGlvbnMudmlld10ge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY2FudmFzIHRvIHVzZSBhcyBhIHZpZXcsIG9wdGlvbmFsXG4gKiBAcGFyYW0gW29wdGlvbnMudHJhbnNwYXJlbnQ9ZmFsc2VdIHtib29sZWFufSBJZiB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnQsIGRlZmF1bHQgZmFsc2VcbiAqIEBwYXJhbSBbb3B0aW9ucy5hdXRvUmVzaXplPWZhbHNlXSB7Ym9vbGVhbn0gSWYgdGhlIHJlbmRlciB2aWV3IGlzIGF1dG9tYXRpY2FsbHkgcmVzaXplZCwgZGVmYXVsdCBmYWxzZVxuICogQHBhcmFtIFtvcHRpb25zLmFudGlhbGlhcz1mYWxzZV0ge2Jvb2xlYW59IHNldHMgYW50aWFsaWFzIChvbmx5IGFwcGxpY2FibGUgaW4gY2hyb21lIGF0IHRoZSBtb21lbnQpXG4gKiBAcGFyYW0gW29wdGlvbnMucmVzb2x1dGlvbj0xXSB7bnVtYmVyfSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyZXIgcmV0aW5hIHdvdWxkIGJlIDJcbiAqIEBwYXJhbSBbb3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcj10cnVlXSB7Ym9vbGVhbn0gVGhpcyBzZXRzIGlmIHRoZSBDYW52YXNSZW5kZXJlciB3aWxsIGNsZWFyIHRoZSBjYW52YXMgb3JcbiAqICAgICAgbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLlxuICovXG5mdW5jdGlvbiBTeXN0ZW1SZW5kZXJlcihzeXN0ZW0sIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpXG57XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB1dGlscy5zYXlIZWxsbyhzeXN0ZW0pO1xuXG4gICAgLy8gcHJlcGFyZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBpIGluIENPTlNULkRFRkFVTFRfUkVOREVSX09QVElPTlMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1tpXSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1tpXSA9IENPTlNULkRFRkFVTFRfUkVOREVSX09QVElPTlNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgb3B0aW9ucyA9IENPTlNULkRFRkFVTFRfUkVOREVSX09QVElPTlM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHJlbmRlcmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UkVOREVSRVJfVFlQRX1cbiAgICAgKiBAZGVmYXVsdCBDT05ULlJFTkRFUkVSX1RZUEUuVU5LTk9XTlxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IENPTlNULlJFTkRFUkVSX1RZUEUuVU5LTk9XTjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCA4MDBcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgODAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIHZpZXdcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCA2MDBcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCA2MDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHRvXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXcgPSBvcHRpb25zLnZpZXcgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVuZGVyIHZpZXcgaXMgdHJhbnNwYXJlbnRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy50cmFuc3BhcmVudCA9IG9wdGlvbnMudHJhbnNwYXJlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZW5kZXIgdmlldyBzaG91bGQgYmUgcmVzaXplZCBhdXRvbWF0aWNhbGx5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IG9wdGlvbnMuYXV0b1Jlc2l6ZSB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRyYWNrcyB0aGUgYmxlbmQgbW9kZXMgdXNlZnVsIGZvciB0aGlzIHJlbmRlcmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7b2JqZWN0PHN0cmluZywgbWl4ZWQ+fVxuICAgICAqL1xuICAgIHRoaXMuYmxlbmRNb2RlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIHByZXNlcnZlRHJhd2luZ0J1ZmZlciBmbGFnIGFmZmVjdHMgd2hldGhlciBvciBub3QgdGhlIGNvbnRlbnRzIG9mIHRoZSBzdGVuY2lsIGJ1ZmZlciBpcyByZXRhaW5lZCBhZnRlciByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHNldHMgaWYgdGhlIENhbnZhc1JlbmRlcmVyIHdpbGwgY2xlYXIgdGhlIGNhbnZhcyBvciBub3QgYmVmb3JlIHRoZSBuZXcgcmVuZGVyIHBhc3MuXG4gICAgICogSWYgdGhlIHNjZW5lIGlzIE5PVCB0cmFuc3BhcmVudCBQaXhpIHdpbGwgdXNlIGEgY2FudmFzIHNpemVkIGZpbGxSZWN0IG9wZXJhdGlvbiBldmVyeSBmcmFtZSB0byBzZXQgdGhlIGNhbnZhcyBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgICAqIElmIHRoZSBzY2VuZSBpcyB0cmFuc3BhcmVudCBQaXhpIHdpbGwgdXNlIGNsZWFyUmVjdCB0byBjbGVhciB0aGUgY2FudmFzIGV2ZXJ5IGZyYW1lLlxuICAgICAqIERpc2FibGUgdGhpcyBieSBzZXR0aW5nIHRoaXMgdG8gZmFsc2UuIEZvciBleGFtcGxlIGlmIHlvdXIgZ2FtZSBoYXMgYSBjYW52YXMgZmlsbGluZyBiYWNrZ3JvdW5kIGltYWdlIHlvdSBvZnRlbiBkb24ndCBuZWVkIHRoaXMgc2V0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSBvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3IgYXMgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSAweDAwMDAwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFzIGFuIFtSLCBHLCBCXSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiID0gWzAsIDAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3IgYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JTdHJpbmcgPSAnIzAwMDAwMCc7XG5cbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yIHx8IHRoaXMuX2JhY2tncm91bmRDb2xvcjsgLy8gcnVuIGJnIGNvbG9yIHNldHRlclxuXG4gICAgLyoqXG4gICAgICogVGhpcyB0ZW1wb3JhcnkgZGlzcGxheSBvYmplY3QgdXNlZCBhcyB0aGUgcGFyZW50IG9mIHRoZSBjdXJyZW50bHkgYmVpbmcgcmVuZGVyZWQgaXRlbVxuICAgICAqIEBtZW1iZXIge0Rpc3BsYXlPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IHt3b3JsZFRyYW5zZm9ybTpuZXcgbWF0aC5NYXRyaXgoKSwgd29ybGRBbHBoYToxLCBjaGlsZHJlbjpbXX07XG5cbiAgICAvL1xuICAgIHRoaXMuX2xhc3RPYmplY3RSZW5kZXJlZCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xufVxuXG4vLyBjb25zdHJ1Y3RvclxuU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblN5c3RlbVJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5c3RlbVJlbmRlcmVyO1xubW9kdWxlLmV4cG9ydHMgPSBTeXN0ZW1SZW5kZXJlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3IgdG8gZmlsbCBpZiBub3QgdHJhbnNwYXJlbnRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgU3lzdGVtUmVuZGVyZXIjXG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yOlxuICAgIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclN0cmluZyA9IHV0aWxzLmhleDJzdHJpbmcodmFsKTtcbiAgICAgICAgICAgIHV0aWxzLmhleDJyZ2IodmFsLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2IpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogUmVzaXplcyB0aGUgY2FudmFzIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gKlxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IHRoZSBuZXcgd2lkdGggb2YgdGhlIGNhbnZhcyB2aWV3XG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjYW52YXMgdmlld1xuICovXG5TeXN0ZW1SZW5kZXJlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGggKiB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLnJlc29sdXRpb247XG5cbiAgICB0aGlzLnZpZXcud2lkdGggPSB0aGlzLndpZHRoO1xuICAgIHRoaXMudmlldy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgIGlmICh0aGlzLmF1dG9SZXNpemUpXG4gICAge1xuICAgICAgICB0aGlzLnZpZXcuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoIC8gdGhpcy5yZXNvbHV0aW9uICsgJ3B4JztcbiAgICAgICAgdGhpcy52aWV3LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uICsgJ3B4JztcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgZXZlcnl0aGluZyBmcm9tIHRoZSByZW5kZXJlciBhbmQgb3B0aW9uYWxseSByZW1vdmVzIHRoZSBDYW52YXMgRE9NIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIFtyZW1vdmVWaWV3PWZhbHNlXSB7Ym9vbGVhbn0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICovXG5TeXN0ZW1SZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmVWaWV3KSB7XG4gICAgaWYgKHJlbW92ZVZpZXcgJiYgdGhpcy52aWV3LnBhcmVudClcbiAgICB7XG4gICAgICAgIHRoaXMudmlldy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy52aWV3KTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSBDT05TVC5SRU5ERVJFUl9UWVBFLlVOS05PV047XG5cbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG5cbiAgICB0aGlzLnZpZXcgPSBudWxsO1xuXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gMDtcblxuICAgIHRoaXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcblxuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5ibGVuZE1vZGVzID0gbnVsbDtcblxuICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gMDtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2IgPSBudWxsO1xuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclN0cmluZyA9IG51bGw7XG59O1xuIiwidmFyIFN5c3RlbVJlbmRlcmVyID0gcmVxdWlyZSgnLi4vU3lzdGVtUmVuZGVyZXInKSxcbiAgICBDYW52YXNNYXNrTWFuYWdlciA9IHJlcXVpcmUoJy4vdXRpbHMvQ2FudmFzTWFza01hbmFnZXInKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyksXG4gICAgbWF0aCA9IHJlcXVpcmUoJy4uLy4uL21hdGgnKSxcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogVGhlIENhbnZhc1JlbmRlcmVyIGRyYXdzIHRoZSBzY2VuZSBhbmQgYWxsIGl0cyBjb250ZW50IG9udG8gYSAyZCBjYW52YXMuIFRoaXMgcmVuZGVyZXIgc2hvdWxkIGJlIHVzZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgd2ViR0wuXG4gKiBEb24ndCBmb3JnZXQgdG8gYWRkIHRoZSBDYW52YXNSZW5kZXJlci52aWV3IHRvIHlvdXIgRE9NIG9yIHlvdSB3aWxsIG5vdCBzZWUgYW55dGhpbmcgOilcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXh0ZW5kcyBTeXN0ZW1SZW5kZXJlclxuICogQHBhcmFtIFt3aWR0aD04MDBdIHtudW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSBbaGVpZ2h0PTYwMF0ge251bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSBbb3B0aW9uc10ge29iamVjdH0gVGhlIG9wdGlvbmFsIHJlbmRlcmVyIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBbb3B0aW9ucy52aWV3XSB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWxcbiAqIEBwYXJhbSBbb3B0aW9ucy50cmFuc3BhcmVudD1mYWxzZV0ge2Jvb2xlYW59IElmIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudCwgZGVmYXVsdCBmYWxzZVxuICogQHBhcmFtIFtvcHRpb25zLmF1dG9SZXNpemU9ZmFsc2VdIHtib29sZWFufSBJZiB0aGUgcmVuZGVyIHZpZXcgaXMgYXV0b21hdGljYWxseSByZXNpemVkLCBkZWZhdWx0IGZhbHNlXG4gKiBAcGFyYW0gW29wdGlvbnMuYW50aWFsaWFzPWZhbHNlXSB7Ym9vbGVhbn0gc2V0cyBhbnRpYWxpYXMgKG9ubHkgYXBwbGljYWJsZSBpbiBjaHJvbWUgYXQgdGhlIG1vbWVudClcbiAqIEBwYXJhbSBbb3B0aW9ucy5yZXNvbHV0aW9uPTFdIHtudW1iZXJ9IHRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXJlciByZXRpbmEgd291bGQgYmUgMlxuICogQHBhcmFtIFtvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyPXRydWVdIHtib29sZWFufSBUaGlzIHNldHMgaWYgdGhlIENhbnZhc1JlbmRlcmVyIHdpbGwgY2xlYXIgdGhlIGNhbnZhcyBvclxuICogICAgICBub3QgYmVmb3JlIHRoZSBuZXcgcmVuZGVyIHBhc3MuXG4gKi9cbmZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpXG57XG4gICAgU3lzdGVtUmVuZGVyZXIuY2FsbCh0aGlzLCAnQ2FudmFzJywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnR5cGUgPSBDT05TVC5SRU5ERVJFUl9UWVBFLkNBTlZBUztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgMmQgY29udGV4dCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gd2l0aC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLnZpZXcuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiB0aGlzLnRyYW5zcGFyZW50IH0pO1xuXG4gICAgLyoqXG4gICAgICogQm9vbGVhbiBmbGFnIGNvbnRyb2xsaW5nIGNhbnZhcyByZWZyZXNoLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlZnJlc2ggPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSW5zdGFuY2Ugb2YgYSBDYW52YXNNYXNrTWFuYWdlciwgaGFuZGxlcyBtYXNraW5nIHdoZW4gdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0NhbnZhc01hc2tNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgQ2FudmFzTWFza01hbmFnZXIoKTtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUgUGl4aSB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICAgICAqIEhhbmR5IGZvciBjcmlzcCBwaXhlbCBhcnQgYW5kIHNwZWVkIG9uIGxlZ2FjeSBkZXZpY2VzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJvdW5kUGl4ZWxzID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUcmFja3MgdGhlIGFjdGl2ZSBzY2FsZSBtb2RlIGZvciB0aGlzIHJlbmRlcmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7U0NBTEVfTU9ERX1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRTY2FsZU1vZGUgPSBDT05TVC5TQ0FMRV9NT0RFUy5ERUZBVUxUO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2tzIHRoZSBhY3RpdmUgYmxlbmQgbW9kZSBmb3IgdGhpcyByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1NDQUxFX01PREV9XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gQ09OU1QuQkxFTkRfTU9ERVMuTk9STUFMO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbnZhcyBwcm9wZXJ0eSB1c2VkIHRvIHNldCB0aGUgY2FudmFzIHNtb290aGluZyBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNtb290aFByb3BlcnR5ID0gJ2ltYWdlU21vb3RoaW5nRW5hYmxlZCc7XG5cbiAgICBpZiAoIXRoaXMuY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zbW9vdGhQcm9wZXJ0eSA9ICd3ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc21vb3RoUHJvcGVydHkgPSAnbW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRleHQub0ltYWdlU21vb3RoaW5nRW5hYmxlZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zbW9vdGhQcm9wZXJ0eSA9ICdvSW1hZ2VTbW9vdGhpbmdFbmFibGVkJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc21vb3RoUHJvcGVydHkgPSAnbXNJbWFnZVNtb290aGluZ0VuYWJsZWQnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbml0UGx1Z2lucygpO1xuXG4gICAgdGhpcy5fbWFwQmxlbmRNb2RlcygpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyB0ZW1wb3JhcnkgZGlzcGxheSBvYmplY3QgdXNlZCBhcyB0aGUgcGFyZW50IG9mIHRoZSBjdXJyZW50bHkgYmVpbmcgcmVuZGVyZWQgaXRlbVxuICAgICAqXG4gICAgICogQG1lbWJlciB7RGlzcGxheU9iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0ge1xuICAgICAgICB3b3JsZFRyYW5zZm9ybTogbmV3IG1hdGguTWF0cml4KCksXG4gICAgICAgIHdvcmxkQWxwaGE6IDFcbiAgICB9O1xuXG5cbiAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbn1cblxuLy8gY29uc3RydWN0b3JcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlKTtcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1JlbmRlcmVyO1xubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNSZW5kZXJlcjtcbnV0aWxzLnBsdWdpblRhcmdldC5taXhpbihDYW52YXNSZW5kZXJlcik7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHRvIHRoaXMgY2FudmFzIHZpZXdcbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHtEaXNwbGF5T2JqZWN0fSB0aGUgb2JqZWN0IHRvIGJlIHJlbmRlcmVkXG4gKi9cbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAob2JqZWN0KVxue1xuICAgIHZhciBjYWNoZVBhcmVudCA9IG9iamVjdC5wYXJlbnQ7XG5cbiAgICB0aGlzLl9sYXN0T2JqZWN0UmVuZGVyZWQgPSBvYmplY3Q7XG5cbiAgICBvYmplY3QucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHNjZW5lIGdyYXBoXG4gICAgb2JqZWN0LnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgb2JqZWN0LnBhcmVudCA9IGNhY2hlUGFyZW50O1xuXG4gICAgdGhpcy5jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG5cbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSBDT05TVC5CTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgdGhpcy5jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5OT1JNQUxdO1xuXG4gICAgaWYgKG5hdmlnYXRvci5pc0NvY29vbkpTICYmIHRoaXMudmlldy5zY3JlZW5jYW52YXMpXG4gICAge1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIpXG4gICAge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BhcmVudClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fYmFja2dyb3VuZENvbG9yU3RyaW5nO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGggLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlckRpc3BsYXlPYmplY3Qob2JqZWN0LCB0aGlzLmNvbnRleHQpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgYW5kIG9wdGlvbmFsbHkgcmVtb3ZlcyB0aGUgQ2FudmFzIERPTSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSBbcmVtb3ZlVmlldz1mYWxzZV0ge2Jvb2xlYW59IFJlbW92ZXMgdGhlIENhbnZhcyBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAqL1xuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAocmVtb3ZlVmlldylcbntcbiAgICB0aGlzLmRlc3Ryb3lQbHVnaW5zKCk7XG5cbiAgICAvLyBjYWxsIHRoZSBiYXNlIGRlc3Ryb3lcbiAgICBTeXN0ZW1SZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMsIHJlbW92ZVZpZXcpO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgIHRoaXMucmVmcmVzaCA9IHRydWU7XG5cbiAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbnVsbDtcblxuICAgIHRoaXMucm91bmRQaXhlbHMgPSBmYWxzZTtcblxuICAgIHRoaXMuY3VycmVudFNjYWxlTW9kZSA9IDA7XG4gICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gMDtcblxuICAgIHRoaXMuc21vb3RoUHJvcGVydHkgPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIGEgZGlzcGxheSBvYmplY3RcbiAqXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7RGlzcGxheU9iamVjdH0gVGhlIGRpc3BsYXlPYmplY3QgdG8gcmVuZGVyXG4gKiBAcHJpdmF0ZVxuICovXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRGlzcGxheU9iamVjdCA9IGZ1bmN0aW9uIChkaXNwbGF5T2JqZWN0LCBjb250ZXh0KVxue1xuICAgIHZhciB0ZW1wQ29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgZGlzcGxheU9iamVjdC5yZW5kZXJDYW52YXModGhpcyk7XG4gICAgdGhpcy5jb250ZXh0ID0gdGVtcENvbnRleHQ7XG59O1xuXG4vKipcbiAqIE1hcHMgUGl4aSBibGVuZCBtb2RlcyB0byBjYW52YXMgYmxlbmQgbW9kZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLl9tYXBCbGVuZE1vZGVzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMuYmxlbmRNb2RlcylcbiAgICB7XG4gICAgICAgIHRoaXMuYmxlbmRNb2RlcyA9IHt9O1xuXG4gICAgICAgIGlmICh1dGlscy5jYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5OT1JNQUxdICAgICAgICA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuQUREXSAgICAgICAgICAgPSAnbGlnaHRlcic7IC8vSVMgVEhJUyBPSz8/P1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk1VTFRJUExZXSAgICAgID0gJ211bHRpcGx5JztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5TQ1JFRU5dICAgICAgICA9ICdzY3JlZW4nO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk9WRVJMQVldICAgICAgID0gJ292ZXJsYXknO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkRBUktFTl0gICAgICAgID0gJ2Rhcmtlbic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuTElHSFRFTl0gICAgICAgPSAnbGlnaHRlbic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuQ09MT1JfRE9ER0VdICAgPSAnY29sb3ItZG9kZ2UnO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkNPTE9SX0JVUk5dICAgID0gJ2NvbG9yLWJ1cm4nO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkhBUkRfTElHSFRdICAgID0gJ2hhcmQtbGlnaHQnO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLlNPRlRfTElHSFRdICAgID0gJ3NvZnQtbGlnaHQnO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkRJRkZFUkVOQ0VdICAgID0gJ2RpZmZlcmVuY2UnO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkVYQ0xVU0lPTl0gICAgID0gJ2V4Y2x1c2lvbic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuSFVFXSAgICAgICAgICAgPSAnaHVlJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5TQVRVUkFUSU9OXSAgICA9ICdzYXR1cmF0aW9uJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5DT0xPUl0gICAgICAgICA9ICdjb2xvcic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuTFVNSU5PU0lUWV0gICAgPSAnbHVtaW5vc2l0eSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY29vbCBuZXcgYmxlbmQgbW9kZXMgaW4gY2FudmFzICdjb3VnaCcgaWUgJ2NvdWdoJ1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk5PUk1BTF0gICAgICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5BRERdICAgICAgICAgICA9ICdsaWdodGVyJzsgLy9JUyBUSElTIE9LPz8/XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuTVVMVElQTFldICAgICAgPSAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLlNDUkVFTl0gICAgICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5PVkVSTEFZXSAgICAgICA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuREFSS0VOXSAgICAgICAgPSAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkxJR0hURU5dICAgICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5DT0xPUl9ET0RHRV0gICA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuQ09MT1JfQlVSTl0gICAgPSAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkhBUkRfTElHSFRdICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5TT0ZUX0xJR0hUXSAgICA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuRElGRkVSRU5DRV0gICAgPSAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkVYQ0xVU0lPTl0gICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5IVUVdICAgICAgICAgICA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuU0FUVVJBVElPTl0gICAgPSAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkNPTE9SXSAgICAgICAgID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5MVU1JTk9TSVRZXSAgICA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgQ2FudmFzIGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNpemUuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IHRoZSB3aWR0aCBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgY2FudmFzXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBoZWlnaHQgZm9yIHRoZSBuZXdseSBjcmVhdGVkIGNhbnZhc1xuICovXG5mdW5jdGlvbiBDYW52YXNCdWZmZXIod2lkdGgsIGhlaWdodClcbntcbiAgICAvKipcbiAgICAgKiBUaGUgQ2FudmFzIG9iamVjdCB0aGF0IGJlbG9uZ3MgdG8gdGhpcyBDYW52YXNCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgLyoqXG4gICAgICogQSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgb2JqZWN0IHJlcHJlc2VudGluZyBhIHR3by1kaW1lbnNpb25hbCByZW5kZXJpbmcgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG59XG5cbkNhbnZhc0J1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNCdWZmZXI7XG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc0J1ZmZlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2FudmFzQnVmZmVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIGJ1ZmZlciBpbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIENhbnZhc0J1ZmZlciNcbiAgICAgKi9cbiAgICB3aWR0aDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHZhbDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIGJ1ZmZlciBpbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIENhbnZhc0J1ZmZlciNcbiAgICAgKi9cbiAgICBoZWlnaHQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIENsZWFycyB0aGUgY2FudmFzIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhlIENhbnZhc0J1ZmZlciBjbGFzcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5DYW52YXNCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogUmVzaXplcyB0aGUgY2FudmFzIHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodC5cbiAqXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgY2FudmFzXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAqL1xuQ2FudmFzQnVmZmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcbntcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhpcyBjYW52YXMuXG4gKlxuICovXG5DYW52YXNCdWZmZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xufTtcbiIsInZhciBDT05TVCA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogQSBzZXQgb2YgZnVuY3Rpb25zIHVzZWQgYnkgdGhlIGNhbnZhcyByZW5kZXJlciB0byBkcmF3IHRoZSBwcmltaXRpdmUgZ3JhcGhpY3MgZGF0YS5cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbnZhciBDYW52YXNHcmFwaGljcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qXG4gKiBSZW5kZXJzIGEgR3JhcGhpY3Mgb2JqZWN0IHRvIGEgY2FudmFzLlxuICpcbiAqIEBwYXJhbSBncmFwaGljcyB7R3JhcGhpY3N9IHRoZSBhY3R1YWwgZ3JhcGhpY3Mgb2JqZWN0IHRvIHJlbmRlclxuICogQHBhcmFtIGNvbnRleHQge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gdGhlIDJkIGRyYXdpbmcgbWV0aG9kIG9mIHRoZSBjYW52YXNcbiAqL1xuQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3MgPSBmdW5jdGlvbiAoZ3JhcGhpY3MsIGNvbnRleHQpXG57XG4gICAgdmFyIHdvcmxkQWxwaGEgPSBncmFwaGljcy53b3JsZEFscGhhO1xuXG4gICAgaWYgKGdyYXBoaWNzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVHcmFwaGljc1RpbnQoZ3JhcGhpY3MpO1xuICAgICAgICBncmFwaGljcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljcy5ncmFwaGljc0RhdGFbaV07XG4gICAgICAgIHZhciBzaGFwZSA9IGRhdGEuc2hhcGU7XG5cbiAgICAgICAgdmFyIGZpbGxDb2xvciA9IGRhdGEuX2ZpbGxUaW50O1xuICAgICAgICB2YXIgbGluZUNvbG9yID0gZGF0YS5fbGluZVRpbnQ7XG5cbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBkYXRhLmxpbmVXaWR0aDtcblxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUE9MWSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcblxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqPTE7IGogPCBwb2ludHMubGVuZ3RoLzI7IGorKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbaiAqIDJdLCBwb2ludHNbaiAqIDIgKyAxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaGFwZS5jbG9zZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnQgYXJlIHRoZSBzYW1lIGNsb3NlIHRoZSBwYXRoIC0gbXVjaCBuZWF0ZXIgOilcbiAgICAgICAgICAgIGlmIChwb2ludHNbMF0gPT09IHBvaW50c1twb2ludHMubGVuZ3RoLTJdICYmIHBvaW50c1sxXSA9PT0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoIGZpbGxDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmxpbmVXaWR0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArICggbGluZUNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUkVDVClcbiAgICAgICAge1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5maWxsQ29sb3IgfHwgZGF0YS5maWxsQ29sb3IgPT09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhICogd29ybGRBbHBoYTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBmaWxsQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdChzaGFwZS54LCBzaGFwZS55LCBzaGFwZS53aWR0aCwgc2hhcGUuaGVpZ2h0KTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEubGluZVdpZHRoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmxpbmVBbHBoYSAqIHdvcmxkQWxwaGE7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBsaW5lQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLkNJUkMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE8gLSBuZWVkIHRvIGJlIFVuZGVmaW5lZCFcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYyhzaGFwZS54LCBzaGFwZS55LCBzaGFwZS5yYWRpdXMsMCwyKk1hdGguUEkpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoIGZpbGxDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmxpbmVXaWR0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArICggbGluZUNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuRUxJUClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gZWxsaXBzZSBjb2RlIHRha2VuIGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xuXG4gICAgICAgICAgICB2YXIgdyA9IHNoYXBlLndpZHRoICogMjtcbiAgICAgICAgICAgIHZhciBoID0gc2hhcGUuaGVpZ2h0ICogMjtcblxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54IC0gdy8yO1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55IC0gaC8yO1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICB2YXIga2FwcGEgPSAwLjU1MjI4NDgsXG4gICAgICAgICAgICAgICAgb3ggPSAodyAvIDIpICoga2FwcGEsIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgICAgICAgICAgICAgICBveSA9IChoIC8gMikgKiBrYXBwYSwgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICAgICAgICAgICAgICB4ZSA9IHggKyB3LCAgICAgICAgICAgLy8geC1lbmRcbiAgICAgICAgICAgICAgICB5ZSA9IHkgKyBoLCAgICAgICAgICAgLy8geS1lbmRcbiAgICAgICAgICAgICAgICB4bSA9IHggKyB3IC8gMiwgICAgICAgLy8geC1taWRkbGVcbiAgICAgICAgICAgICAgICB5bSA9IHkgKyBoIC8gMjsgICAgICAgLy8geS1taWRkbGVcblxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeW0pO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcblxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoIGZpbGxDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLmxpbmVXaWR0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnIycgKyAoJzAwMDAwJyArICggbGluZUNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUlJFQylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJ4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciByeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gc2hhcGUucmFkaXVzO1xuXG4gICAgICAgICAgICB2YXIgbWF4UmFkaXVzID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyIHwgMDtcbiAgICAgICAgICAgIHJhZGl1cyA9IHJhZGl1cyA+IG1heFJhZGl1cyA/IG1heFJhZGl1cyA6IHJhZGl1cztcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHJ4LCByeSArIHJhZGl1cyk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCwgcnkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSArIGhlaWdodCwgcnggKyByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4ICsgd2lkdGggLSByYWRpdXMsIHJ5ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSArIGhlaWdodCwgcnggKyB3aWR0aCwgcnkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyB3aWR0aCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4ICsgd2lkdGgsIHJ5LCByeCArIHdpZHRoIC0gcmFkaXVzLCByeSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHJhZGl1cywgcnkpO1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHJ4LCByeSwgcngsIHJ5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmZpbGxDb2xvciB8fCBkYXRhLmZpbGxDb2xvciA9PT0gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGEgKiB3b3JsZEFscGhhO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoIGZpbGxDb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEubGluZVdpZHRoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBkYXRhLmxpbmVBbHBoYSAqIHdvcmxkQWxwaGE7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBsaW5lQ29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qXG4gKiBSZW5kZXJzIGEgZ3JhcGhpY3MgbWFza1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge0dyYXBoaWNzfSB0aGUgZ3JhcGhpY3Mgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgbWFza1xuICogQHBhcmFtIGNvbnRleHQge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gdGhlIGNvbnRleHQgMmQgbWV0aG9kIG9mIHRoZSBjYW52YXNcbiAqL1xuQ2FudmFzR3JhcGhpY3MucmVuZGVyR3JhcGhpY3NNYXNrID0gZnVuY3Rpb24gKGdyYXBoaWNzLCBjb250ZXh0KVxue1xuICAgIHZhciBsZW4gPSBncmFwaGljcy5ncmFwaGljc0RhdGEubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA9PT0gMClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgICB2YXIgc2hhcGUgPSBkYXRhLnNoYXBlO1xuXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09IENPTlNULlNIQVBFUy5QT0xZKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG5cbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaj0xOyBqIDwgcG9pbnRzLmxlbmd0aC8yOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2ogKiAyXSwgcG9pbnRzW2ogKiAyICsgMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnQgYXJlIHRoZSBzYW1lIGNsb3NlIHRoZSBwYXRoIC0gbXVjaCBuZWF0ZXIgOilcbiAgICAgICAgICAgIGlmIChwb2ludHNbMF0gPT09IHBvaW50c1twb2ludHMubGVuZ3RoLTJdICYmIHBvaW50c1sxXSA9PT0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLlJFQ1QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVjdChzaGFwZS54LCBzaGFwZS55LCBzaGFwZS53aWR0aCwgc2hhcGUuaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuQ0lSQylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gVE9ETyAtIG5lZWQgdG8gYmUgVW5kZWZpbmVkIVxuICAgICAgICAgICAgY29udGV4dC5hcmMoc2hhcGUueCwgc2hhcGUueSwgc2hhcGUucmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gQ09OU1QuU0hBUEVTLkVMSVApXG4gICAgICAgIHtcblxuICAgICAgICAgICAgLy8gZWxsaXBzZSBjb2RlIHRha2VuIGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xuXG4gICAgICAgICAgICB2YXIgdyA9IHNoYXBlLndpZHRoICogMjtcbiAgICAgICAgICAgIHZhciBoID0gc2hhcGUuaGVpZ2h0ICogMjtcblxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54IC0gdy8yO1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55IC0gaC8yO1xuXG4gICAgICAgICAgICB2YXIga2FwcGEgPSAwLjU1MjI4NDgsXG4gICAgICAgICAgICAgICAgb3ggPSAodyAvIDIpICoga2FwcGEsIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgICAgICAgICAgICAgICBveSA9IChoIC8gMikgKiBrYXBwYSwgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgdmVydGljYWxcbiAgICAgICAgICAgICAgICB4ZSA9IHggKyB3LCAgICAgICAgICAgLy8geC1lbmRcbiAgICAgICAgICAgICAgICB5ZSA9IHkgKyBoLCAgICAgICAgICAgLy8geS1lbmRcbiAgICAgICAgICAgICAgICB4bSA9IHggKyB3IC8gMiwgICAgICAgLy8geC1taWRkbGVcbiAgICAgICAgICAgICAgICB5bSA9IHkgKyBoIC8gMjsgICAgICAgLy8geS1taWRkbGVcblxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeW0pO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBDT05TVC5TSEFQRVMuUlJFQylcbiAgICAgICAge1xuXG4gICAgICAgICAgICB2YXIgcnggPSBzaGFwZS54O1xuICAgICAgICAgICAgdmFyIHJ5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBzaGFwZS5yYWRpdXM7XG5cbiAgICAgICAgICAgIHZhciBtYXhSYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDIgfCAwO1xuICAgICAgICAgICAgcmFkaXVzID0gcmFkaXVzID4gbWF4UmFkaXVzID8gbWF4UmFkaXVzIDogcmFkaXVzO1xuXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhyeCwgcnkgKyByYWRpdXMpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocngsIHJ5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCwgcnkgKyBoZWlnaHQsIHJ4ICsgcmFkaXVzLCByeSArIGhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyeCArIHdpZHRoIC0gcmFkaXVzLCByeSArIGhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocnggKyB3aWR0aCwgcnkgKyBoZWlnaHQsIHJ4ICsgd2lkdGgsIHJ5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHJ4ICsgd2lkdGgsIHJ5ICsgcmFkaXVzKTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCArIHdpZHRoLCByeSwgcnggKyB3aWR0aCAtIHJhZGl1cywgcnkpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocnggKyByYWRpdXMsIHJ5KTtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyeCwgcnksIHJ4LCByeSArIHJhZGl1cyk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLypcbiAqIFVwZGF0ZXMgdGhlIHRpbnQgb2YgYSBncmFwaGljcyBvYmplY3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdyYXBoaWNzIHtHcmFwaGljc30gdGhlIGdyYXBoaWNzIHRoYXQgd2lsbCBoYXZlIGl0cyB0aW50IHVwZGF0ZWRcbiAqIFxuICovXG5DYW52YXNHcmFwaGljcy51cGRhdGVHcmFwaGljc1RpbnQgPSBmdW5jdGlvbiAoZ3JhcGhpY3MpXG57XG4gICAgaWYgKGdyYXBoaWNzLnRpbnQgPT09IDB4RkZGRkZGKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0aW50UiA9IChncmFwaGljcy50aW50ID4+IDE2ICYgMHhGRikgLyAyNTU7XG4gICAgdmFyIHRpbnRHID0gKGdyYXBoaWNzLnRpbnQgPj4gOCAmIDB4RkYpIC8gMjU1O1xuICAgIHZhciB0aW50QiA9IChncmFwaGljcy50aW50ICYgMHhGRikvIDI1NTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljcy5ncmFwaGljc0RhdGFbaV07XG5cbiAgICAgICAgdmFyIGZpbGxDb2xvciA9IGRhdGEuZmlsbENvbG9yIHwgMDtcbiAgICAgICAgdmFyIGxpbmVDb2xvciA9IGRhdGEubGluZUNvbG9yIHwgMDtcblxuICAgICAgICAvKlxuICAgICAgICB2YXIgY29sb3JSID0gKGZpbGxDb2xvciA+PiAxNiAmIDB4RkYpIC8gMjU1O1xuICAgICAgICB2YXIgY29sb3JHID0gKGZpbGxDb2xvciA+PiA4ICYgMHhGRikgLyAyNTU7XG4gICAgICAgIHZhciBjb2xvckIgPSAoZmlsbENvbG9yICYgMHhGRikgLyAyNTU7XG5cbiAgICAgICAgY29sb3JSICo9IHRpbnRSO1xuICAgICAgICBjb2xvckcgKj0gdGludEc7XG4gICAgICAgIGNvbG9yQiAqPSB0aW50QjtcblxuICAgICAgICBmaWxsQ29sb3IgPSAoKGNvbG9yUioyNTUgPDwgMTYpICsgKGNvbG9yRyoyNTUgPDwgOCkgKyBjb2xvckIqMjU1KTtcblxuICAgICAgICBjb2xvclIgPSAobGluZUNvbG9yID4+IDE2ICYgMHhGRikgLyAyNTU7XG4gICAgICAgIGNvbG9yRyA9IChsaW5lQ29sb3IgPj4gOCAmIDB4RkYpIC8gMjU1O1xuICAgICAgICBjb2xvckIgPSAobGluZUNvbG9yICYgMHhGRikgLyAyNTU7XG5cbiAgICAgICAgY29sb3JSICo9IHRpbnRSO1xuICAgICAgICBjb2xvckcgKj0gdGludEc7XG4gICAgICAgIGNvbG9yQiAqPSB0aW50QjtcblxuICAgICAgICBsaW5lQ29sb3IgPSAoKGNvbG9yUioyNTUgPDwgMTYpICsgKGNvbG9yRyoyNTUgPDwgOCkgKyBjb2xvckIqMjU1KTtcbiAgICAgICAgKi9cblxuICAgICAgICAvLyBzdXBlciBpbmxpbmUgY29zIGltIGFuIG9wdGltaXphdGlvbiBOQVpJIDopXG4gICAgICAgIGRhdGEuX2ZpbGxUaW50ID0gKCgoZmlsbENvbG9yID4+IDE2ICYgMHhGRikgLyAyNTUgKiB0aW50UioyNTUgPDwgMTYpICsgKChmaWxsQ29sb3IgPj4gOCAmIDB4RkYpIC8gMjU1ICogdGludEcqMjU1IDw8IDgpICsgIChmaWxsQ29sb3IgJiAweEZGKSAvIDI1NSAqIHRpbnRCKjI1NSk7XG4gICAgICAgIGRhdGEuX2xpbmVUaW50ID0gKCgobGluZUNvbG9yID4+IDE2ICYgMHhGRikgLyAyNTUgKiB0aW50UioyNTUgPDwgMTYpICsgKChsaW5lQ29sb3IgPj4gOCAmIDB4RkYpIC8gMjU1ICogdGludEcqMjU1IDw8IDgpICsgIChsaW5lQ29sb3IgJiAweEZGKSAvIDI1NSAqIHRpbnRCKjI1NSk7XG5cbiAgICB9XG59O1xuXG4iLCJ2YXIgQ2FudmFzR3JhcGhpY3MgPSByZXF1aXJlKCcuL0NhbnZhc0dyYXBoaWNzJyk7XG5cbi8qKlxuICogQSBzZXQgb2YgZnVuY3Rpb25zIHVzZWQgdG8gaGFuZGxlIG1hc2tpbmcuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5mdW5jdGlvbiBDYW52YXNNYXNrTWFuYWdlcigpXG57fVxuXG5DYW52YXNNYXNrTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNNYXNrTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzTWFza01hbmFnZXI7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgYWRkcyBpdCB0byB0aGUgY3VycmVudCBzdGFjayBvZiBtYXNrcy5cbiAqXG4gKiBAcGFyYW0gbWFza0RhdGEge29iamVjdH0gdGhlIG1hc2tEYXRhIHRoYXQgd2lsbCBiZSBwdXNoZWRcbiAqIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcnxDYW52YXNSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIGNvbnRleHQgdG8gdXNlLlxuICovXG5DYW52YXNNYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaE1hc2sgPSBmdW5jdGlvbiAobWFza0RhdGEsIHJlbmRlcmVyKVxue1xuXG4gICAgcmVuZGVyZXIuY29udGV4dC5zYXZlKCk7XG5cbiAgICB2YXIgY2FjaGVBbHBoYSA9IG1hc2tEYXRhLmFscGhhO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBtYXNrRGF0YS53b3JsZFRyYW5zZm9ybTtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG5cbiAgICByZW5kZXJlci5jb250ZXh0LnNldFRyYW5zZm9ybShcbiAgICAgICAgdHJhbnNmb3JtLmEgKiByZXNvbHV0aW9uLFxuICAgICAgICB0cmFuc2Zvcm0uYiAqIHJlc29sdXRpb24sXG4gICAgICAgIHRyYW5zZm9ybS5jICogcmVzb2x1dGlvbixcbiAgICAgICAgdHJhbnNmb3JtLmQgKiByZXNvbHV0aW9uLFxuICAgICAgICB0cmFuc2Zvcm0udHggKiByZXNvbHV0aW9uLFxuICAgICAgICB0cmFuc2Zvcm0udHkgKiByZXNvbHV0aW9uXG4gICAgKTtcblxuICAgIC8vVE9ETyBzdXBvcnQgc3ByaXRlIGFscGhhIG1hc2tzPz9cbiAgICAvL2xvdHMgb2YgZWZmb3J0IHJlcXVpcmVkLiBJZiBkZW1hbmQgaXMgZ3JlYXQgZW5vdWdoLi5cbiAgICBpZighbWFza0RhdGEudGV4dHVyZSlcbiAgICB7XG4gICAgICAgIENhbnZhc0dyYXBoaWNzLnJlbmRlckdyYXBoaWNzTWFzayhtYXNrRGF0YSwgcmVuZGVyZXIuY29udGV4dCk7XG4gICAgICAgIHJlbmRlcmVyLmNvbnRleHQuY2xpcCgpO1xuICAgIH1cblxuICAgIG1hc2tEYXRhLndvcmxkQWxwaGEgPSBjYWNoZUFscGhhO1xufTtcblxuLyoqXG4gKiBSZXN0b3JlcyB0aGUgY3VycmVudCBkcmF3aW5nIGNvbnRleHQgdG8gdGhlIHN0YXRlIGl0IHdhcyBiZWZvcmUgdGhlIG1hc2sgd2FzIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtIHJlbmRlcmVyIHtXZWJHTFJlbmRlcmVyfENhbnZhc1JlbmRlcmVyfSBUaGUgcmVuZGVyZXIgY29udGV4dCB0byB1c2UuXG4gKi9cbkNhbnZhc01hc2tNYW5hZ2VyLnByb3RvdHlwZS5wb3BNYXNrID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIHJlbmRlcmVyLmNvbnRleHQucmVzdG9yZSgpO1xufTtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVXRpbGl0eSBtZXRob2RzIGZvciBTcHJpdGUvVGV4dHVyZSB0aW50aW5nLlxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xudmFyIENhbnZhc1RpbnRlciA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogQmFzaWNhbGx5IHRoaXMgbWV0aG9kIGp1c3QgbmVlZHMgYSBzcHJpdGUgYW5kIGEgY29sb3IgYW5kIHRpbnRzIHRoZSBzcHJpdGUgd2l0aCB0aGUgZ2l2ZW4gY29sb3IuXG4gKlxuICogQHBhcmFtIHNwcml0ZSB7U3ByaXRlfSB0aGUgc3ByaXRlIHRvIHRpbnRcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXG4gKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gVGhlIHRpbnRlZCBjYW52YXNcbiAqL1xuQ2FudmFzVGludGVyLmdldFRpbnRlZFRleHR1cmUgPSBmdW5jdGlvbiAoc3ByaXRlLCBjb2xvcilcbntcbiAgICB2YXIgdGV4dHVyZSA9IHNwcml0ZS50ZXh0dXJlO1xuXG4gICAgY29sb3IgPSBDYW52YXNUaW50ZXIucm91bmRDb2xvcihjb2xvcik7XG5cbiAgICB2YXIgc3RyaW5nQ29sb3IgPSAnIycgKyAoJzAwMDAwJyArICggY29sb3IgfCAwKS50b1N0cmluZygxNikpLnN1YnN0cigtNik7XG5cbiAgICB0ZXh0dXJlLnRpbnRDYWNoZSA9IHRleHR1cmUudGludENhY2hlIHx8IHt9O1xuXG4gICAgaWYgKHRleHR1cmUudGludENhY2hlW3N0cmluZ0NvbG9yXSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl07XG4gICAgfVxuXG4gICAgIC8vIGNsb25lIHRleHR1cmUuLlxuICAgIHZhciBjYW52YXMgPSBDYW52YXNUaW50ZXIuY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgLy9DYW52YXNUaW50ZXIudGludFdpdGhQZXJQaXhlbCh0ZXh0dXJlLCBzdHJpbmdDb2xvciwgY2FudmFzKTtcbiAgICBDYW52YXNUaW50ZXIudGludE1ldGhvZCh0ZXh0dXJlLCBjb2xvciwgY2FudmFzKTtcblxuICAgIGlmIChDYW52YXNUaW50ZXIuY29udmVydFRpbnRUb0ltYWdlKVxuICAgIHtcbiAgICAgICAgLy8gaXMgdGhpcyBiZXR0ZXI/XG4gICAgICAgIHZhciB0aW50SW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgdGludEltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoKTtcblxuICAgICAgICB0ZXh0dXJlLnRpbnRDYWNoZVtzdHJpbmdDb2xvcl0gPSB0aW50SW1hZ2U7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRleHR1cmUudGludENhY2hlW3N0cmluZ0NvbG9yXSA9IGNhbnZhcztcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBjb252ZXJ0aW5nIHRoZSB0ZXh0dXJlIHRvIGFuIGltYWdlIHRoZW4gd2UgbmVlZCB0byBsb3NlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhc1xuICAgICAgICBDYW52YXNUaW50ZXIuY2FudmFzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FudmFzO1xufTtcblxuLyoqXG4gKiBUaW50IGEgdGV4dHVyZSB1c2luZyB0aGUgJ211bHRpcGx5JyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IHRoZSB0ZXh0dXJlIHRvIHRpbnRcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3IgdG8gdXNlIHRvIHRpbnQgdGhlIHNwcml0ZSB3aXRoXG4gKiBAcGFyYW0gY2FudmFzIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGN1cnJlbnQgY2FudmFzXG4gKi9cbkNhbnZhc1RpbnRlci50aW50V2l0aE11bHRpcGx5ID0gZnVuY3Rpb24gKHRleHR1cmUsIGNvbG9yLCBjYW52YXMpXG57XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXG4gICAgdmFyIGNyb3AgPSB0ZXh0dXJlLmNyb3A7XG5cbiAgICBjYW52YXMud2lkdGggPSBjcm9wLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjcm9wLmhlaWdodDtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMnICsgKCcwMDAwMCcgKyAoIGNvbG9yIHwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpO1xuXG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjcm9wLndpZHRoLCBjcm9wLmhlaWdodCk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgIGNyb3AueCxcbiAgICAgICAgY3JvcC55LFxuICAgICAgICBjcm9wLndpZHRoLFxuICAgICAgICBjcm9wLmhlaWdodCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgY3JvcC53aWR0aCxcbiAgICAgICAgY3JvcC5oZWlnaHRcbiAgICApO1xuXG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tYXRvcCc7XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgIGNyb3AueCxcbiAgICAgICAgY3JvcC55LFxuICAgICAgICBjcm9wLndpZHRoLFxuICAgICAgICBjcm9wLmhlaWdodCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgY3JvcC53aWR0aCxcbiAgICAgICAgY3JvcC5oZWlnaHRcbiAgICApO1xufTtcblxuLyoqXG4gKiBUaW50IGEgdGV4dHVyZSB1c2luZyB0aGUgJ292ZXJsYXknIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gdGhlIHRleHR1cmUgdG8gdGludFxuICogQHBhcmFtIGNvbG9yIHtudW1iZXJ9IHRoZSBjb2xvciB0byB1c2UgdG8gdGludCB0aGUgc3ByaXRlIHdpdGhcbiAqIEBwYXJhbSBjYW52YXMge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY3VycmVudCBjYW52YXNcbiAqL1xuQ2FudmFzVGludGVyLnRpbnRXaXRoT3ZlcmxheSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBjb2xvciwgY2FudmFzKVxue1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblxuICAgIHZhciBjcm9wID0gdGV4dHVyZS5jcm9wO1xuXG4gICAgY2FudmFzLndpZHRoID0gY3JvcC53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY3JvcC5oZWlnaHQ7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjJyArICgnMDAwMDAnICsgKCBjb2xvciB8IDApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC02KTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0KTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWF0b3AnO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZSxcbiAgICAgICAgY3JvcC54LFxuICAgICAgICBjcm9wLnksXG4gICAgICAgIGNyb3Aud2lkdGgsXG4gICAgICAgIGNyb3AuaGVpZ2h0LFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBjcm9wLndpZHRoLFxuICAgICAgICBjcm9wLmhlaWdodFxuICAgICk7XG5cbiAgICAvLyBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5Jztcbn07XG5cbi8qKlxuICogVGludCBhIHRleHR1cmUgcGl4ZWwgcGVyIHBpeGVsLlxuICpcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSB0aGUgdGV4dHVyZSB0byB0aW50XG4gKiBAcGFyYW0gY29sb3Ige251bWJlcn0gdGhlIGNvbG9yIHRvIHVzZSB0byB0aW50IHRoZSBzcHJpdGUgd2l0aFxuICogQHBhcmFtIGNhbnZhcyB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjdXJyZW50IGNhbnZhc1xuICovXG5DYW52YXNUaW50ZXIudGludFdpdGhQZXJQaXhlbCA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBjb2xvciwgY2FudmFzKVxue1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblxuICAgIHZhciBjcm9wID0gdGV4dHVyZS5jcm9wO1xuXG4gICAgY2FudmFzLndpZHRoID0gY3JvcC53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY3JvcC5oZWlnaHQ7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgIGNyb3AueCxcbiAgICAgICAgY3JvcC55LFxuICAgICAgICBjcm9wLndpZHRoLFxuICAgICAgICBjcm9wLmhlaWdodCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgY3JvcC53aWR0aCxcbiAgICAgICAgY3JvcC5oZWlnaHRcbiAgICApO1xuXG4gICAgdmFyIHJnYlZhbHVlcyA9IHV0aWxzLmhleDJyZ2IoY29sb3IpO1xuICAgIHZhciByID0gcmdiVmFsdWVzWzBdLCBnID0gcmdiVmFsdWVzWzFdLCBiID0gcmdiVmFsdWVzWzJdO1xuXG4gICAgdmFyIHBpeGVsRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNyb3Aud2lkdGgsIGNyb3AuaGVpZ2h0KTtcblxuICAgIHZhciBwaXhlbHMgPSBwaXhlbERhdGEuZGF0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGl4ZWxzLmxlbmd0aDsgaSArPSA0KVxuICAgIHtcbiAgICAgICAgcGl4ZWxzW2krMF0gKj0gcjtcbiAgICAgICAgcGl4ZWxzW2krMV0gKj0gZztcbiAgICAgICAgcGl4ZWxzW2krMl0gKj0gYjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShwaXhlbERhdGEsIDAsIDApO1xufTtcblxuLyoqXG4gKiBSb3VuZHMgdGhlIHNwZWNpZmllZCBjb2xvciBhY2NvcmRpbmcgdG8gdGhlIENhbnZhc1RpbnRlci5jYWNoZVN0ZXBzUGVyQ29sb3JDaGFubmVsLlxuICpcbiAqIEBwYXJhbSBjb2xvciB7bnVtYmVyfSB0aGUgY29sb3IgdG8gcm91bmQsIHNob3VsZCBiZSBhIGhleCBjb2xvclxuICovXG5DYW52YXNUaW50ZXIucm91bmRDb2xvciA9IGZ1bmN0aW9uIChjb2xvcilcbntcbiAgICB2YXIgc3RlcCA9IENhbnZhc1RpbnRlci5jYWNoZVN0ZXBzUGVyQ29sb3JDaGFubmVsO1xuXG4gICAgdmFyIHJnYlZhbHVlcyA9IHV0aWxzLmhleDJyZ2IoY29sb3IpO1xuXG4gICAgcmdiVmFsdWVzWzBdID0gTWF0aC5taW4oMjU1LCAocmdiVmFsdWVzWzBdIC8gc3RlcCkgKiBzdGVwKTtcbiAgICByZ2JWYWx1ZXNbMV0gPSBNYXRoLm1pbigyNTUsIChyZ2JWYWx1ZXNbMV0gLyBzdGVwKSAqIHN0ZXApO1xuICAgIHJnYlZhbHVlc1syXSA9IE1hdGgubWluKDI1NSwgKHJnYlZhbHVlc1syXSAvIHN0ZXApICogc3RlcCk7XG5cbiAgICByZXR1cm4gdXRpbHMucmdiMmhleChyZ2JWYWx1ZXMpO1xufTtcblxuLyoqXG4gKiBOdW1iZXIgb2Ygc3RlcHMgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgY2FwIHdoZW4gcm91bmRpbmcgY29sb3JzLlxuICpcbiAqIEBtZW1iZXJcbiAqL1xuQ2FudmFzVGludGVyLmNhY2hlU3RlcHNQZXJDb2xvckNoYW5uZWwgPSA4O1xuXG4vKipcbiAqIFRpbnQgY2FjaGUgYm9vbGVhbiBmbGFnLlxuICpcbiAqIEBtZW1iZXJcbiAqL1xuQ2FudmFzVGludGVyLmNvbnZlcnRUaW50VG9JbWFnZSA9IGZhbHNlO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBDYW52YXMgQmxlbmRNb2RlcyBhcmUgc3VwcG9ydGVkLCBjb25zZXF1ZW50bHkgdGhlIGFiaWxpdHkgdG8gdGludCB1c2luZyB0aGUgbXVsdGlwbHkgbWV0aG9kLlxuICpcbiAqIEBtZW1iZXJcbiAqL1xuQ2FudmFzVGludGVyLmNhblVzZU11bHRpcGx5ID0gdXRpbHMuY2FuVXNlTmV3Q2FudmFzQmxlbmRNb2RlcygpO1xuXG4vKipcbiAqIFRoZSB0aW50aW5nIG1ldGhvZCB0aGF0IHdpbGwgYmUgdXNlZC5cbiAqXG4gKi9cbkNhbnZhc1RpbnRlci50aW50TWV0aG9kID0gQ2FudmFzVGludGVyLmNhblVzZU11bHRpcGx5ID8gQ2FudmFzVGludGVyLnRpbnRXaXRoTXVsdGlwbHkgOiAgQ2FudmFzVGludGVyLnRpbnRXaXRoUGVyUGl4ZWw7XG4iLCJ2YXIgU3lzdGVtUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9TeXN0ZW1SZW5kZXJlcicpLFxuICAgIFNoYWRlck1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXJzL1NoYWRlck1hbmFnZXInKSxcbiAgICBNYXNrTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcnMvTWFza01hbmFnZXInKSxcbiAgICBTdGVuY2lsTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcnMvU3RlbmNpbE1hbmFnZXInKSxcbiAgICBGaWx0ZXJNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy9GaWx0ZXJNYW5hZ2VyJyksXG4gICAgQmxlbmRNb2RlTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcnMvQmxlbmRNb2RlTWFuYWdlcicpLFxuICAgIFJlbmRlclRhcmdldCA9IHJlcXVpcmUoJy4vdXRpbHMvUmVuZGVyVGFyZ2V0JyksXG4gICAgT2JqZWN0UmVuZGVyZXIgPSByZXF1aXJlKCcuL3V0aWxzL09iamVjdFJlbmRlcmVyJyksXG4gICAgRlhBQUZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVycy9GWEFBRmlsdGVyJyksXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpLFxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vY29uc3QnKTtcblxuLyoqXG4gKiBUaGUgV2ViR0xSZW5kZXJlciBkcmF3cyB0aGUgc2NlbmUgYW5kIGFsbCBpdHMgY29udGVudCBvbnRvIGEgd2ViR0wgZW5hYmxlZCBjYW52YXMuIFRoaXMgcmVuZGVyZXJcbiAqIHNob3VsZCBiZSB1c2VkIGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgd2ViR0wuIFRoaXMgUmVuZGVyIHdvcmtzIGJ5IGF1dG9tYXRpY2FsbHkgbWFuYWdpbmcgd2ViR0xCYXRjaHMuXG4gKiBTbyBubyBuZWVkIGZvciBTcHJpdGUgQmF0Y2hlcyBvciBTcHJpdGUgQ2xvdWRzLlxuICogRG9uJ3QgZm9yZ2V0IHRvIGFkZCB0aGUgdmlldyB0byB5b3VyIERPTSBvciB5b3Ugd2lsbCBub3Qgc2VlIGFueXRoaW5nIDopXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgU3lzdGVtUmVuZGVyZXJcbiAqIEBwYXJhbSBbd2lkdGg9MF0ge251bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgdmlld1xuICogQHBhcmFtIFtoZWlnaHQ9MF0ge251bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIHZpZXdcbiAqIEBwYXJhbSBbb3B0aW9uc10ge29iamVjdH0gVGhlIG9wdGlvbmFsIHJlbmRlcmVyIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBbb3B0aW9ucy52aWV3XSB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjYW52YXMgdG8gdXNlIGFzIGEgdmlldywgb3B0aW9uYWxcbiAqIEBwYXJhbSBbb3B0aW9ucy50cmFuc3BhcmVudD1mYWxzZV0ge2Jvb2xlYW59IElmIHRoZSByZW5kZXIgdmlldyBpcyB0cmFuc3BhcmVudCwgZGVmYXVsdCBmYWxzZVxuICogQHBhcmFtIFtvcHRpb25zLmF1dG9SZXNpemU9ZmFsc2VdIHtib29sZWFufSBJZiB0aGUgcmVuZGVyIHZpZXcgaXMgYXV0b21hdGljYWxseSByZXNpemVkLCBkZWZhdWx0IGZhbHNlXG4gKiBAcGFyYW0gW29wdGlvbnMuYW50aWFsaWFzPWZhbHNlXSB7Ym9vbGVhbn0gc2V0cyBhbnRpYWxpYXMuIElmIG5vdCBhdmFpbGFibGUgbmF0aXZlbHkgdGhlbiBGWEFBIGFudGlhbGlhc2luZyBpcyB1c2VkXG4gKiBAcGFyYW0gW29wdGlvbnMuZm9yY2VGWEFBPWZhbHNlXSB7Ym9vbGVhbn0gZm9yY2VzIEZYQUEgYW50aWFsaWFzaW5nIHRvIGJlIHVzZWQgb3ZlciBuYXRpdmUuIEZYQUEgaXMgZmFzdGVyLCBidXQgbWF5IG5vdCBhbHdheXMgbG9rIGFzIGdyZWF0XG4gKiBAcGFyYW0gW29wdGlvbnMucmVzb2x1dGlvbj0xXSB7bnVtYmVyfSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyZXIgcmV0aW5hIHdvdWxkIGJlIDJcbiAqIEBwYXJhbSBbb3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcj10cnVlXSB7Ym9vbGVhbn0gVGhpcyBzZXRzIGlmIHRoZSBDYW52YXNSZW5kZXJlciB3aWxsIGNsZWFyIHRoZSBjYW52YXMgb3JcbiAqICAgICAgbm90IGJlZm9yZSB0aGUgbmV3IHJlbmRlciBwYXNzLlxuICogQHBhcmFtIFtvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZV0ge2Jvb2xlYW59IGVuYWJsZXMgZHJhd2luZyBidWZmZXIgcHJlc2VydmF0aW9uLCBlbmFibGUgdGhpcyBpZlxuICogICAgICB5b3UgbmVlZCB0byBjYWxsIHRvRGF0YVVybCBvbiB0aGUgd2ViZ2wgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gV2ViR0xSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKVxue1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgU3lzdGVtUmVuZGVyZXIuY2FsbCh0aGlzLCAnV2ViR0wnLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgcmVuZGVyZXIgYXMgYSBzdGFuZGFyZGlzZWQgY29uc3RcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IENPTlNULlJFTkRFUkVSX1RZUEUuV0VCR0w7XG5cbiAgICB0aGlzLmhhbmRsZUNvbnRleHRMb3N0ID0gdGhpcy5oYW5kbGVDb250ZXh0TG9zdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkID0gdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMudmlldy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCwgZmFsc2UpO1xuICAgIHRoaXMudmlldy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLCBmYWxzZSk7XG5cbiAgICAvL1RPRE8gcG9zc2liaWxpdHkgdG8gZm9yY2UgRlhBQSBhcyBpdCBtYXkgb2ZmZXIgYmV0dGVyIHBlcmZvcm1hbmNlP1xuICAgIC8qKlxuICAgICAqIERvZXMgaXQgdXNlIEZYQUEgP1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3VzZUZYQUEgPSAhIW9wdGlvbnMuZm9yY2VGWEFBICYmIG9wdGlvbnMuYW50aWFsaWFzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ4YWEgZmlsdGVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtGWEFBRmlsdGVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fRlhBQUZpbHRlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgaW4gdG8gY3JlYXRlIGEgbmV3IHdlYmdsIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jb250ZXh0T3B0aW9ucyA9IHtcbiAgICAgICAgYWxwaGE6IHRoaXMudHJhbnNwYXJlbnQsXG4gICAgICAgIGFudGlhbGlhczogb3B0aW9ucy5hbnRpYWxpYXMsXG4gICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdGhpcy50cmFuc3BhcmVudCAmJiB0aGlzLnRyYW5zcGFyZW50ICE9PSAnbm90TXVsdGlwbGllZCcsXG4gICAgICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXJcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ291bnRlciBmb3IgdGhlIG51bWJlciBvZiBkcmF3cyBtYWRlIGVhY2ggZnJhbWVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRyYXdDb3VudCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBEZWFscyB3aXRoIG1hbmFnaW5nIHRoZSBzaGFkZXIgcHJvZ3JhbXMgYW5kIHRoZWlyIGF0dHJpYnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtTaGFkZXJNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuc2hhZGVyTWFuYWdlciA9IG5ldyBTaGFkZXJNYW5hZ2VyKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogTWFuYWdlcyB0aGUgbWFza3MgdXNpbmcgdGhlIHN0ZW5jaWwgYnVmZmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7TWFza01hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBNYXNrTWFuYWdlcih0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZXMgdGhlIHN0ZW5jaWwgYnVmZmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7U3RlbmNpbE1hbmFnZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdGVuY2lsTWFuYWdlciA9IG5ldyBTdGVuY2lsTWFuYWdlcih0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZXMgdGhlIGZpbHRlcnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtGaWx0ZXJNYW5hZ2VyfVxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IG5ldyBGaWx0ZXJNYW5hZ2VyKHRoaXMpO1xuXG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIHRoZSBibGVuZE1vZGVzXG4gICAgICogQG1lbWJlciB7QmxlbmRNb2RlTWFuYWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJsZW5kTW9kZU1hbmFnZXIgPSBuZXcgQmxlbmRNb2RlTWFuYWdlcih0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBjdXJyZW50IHJlbmRlciB0YXJnZXRcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50UmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIG9iamVjdCByZW5kZXJlciBAYWx2aW5cbiAgICAgKiBAbWVtYmVyIHtPYmplY3RSZW5kZXJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IG5ldyBPYmplY3RSZW5kZXJlcih0aGlzKTtcblxuICAgIHRoaXMuaW5pdFBsdWdpbnMoKTtcblxuICAgICAvLyBpbml0aWFsaXplIHRoZSBjb250ZXh0IHNvIGl0IGlzIHJlYWR5IGZvciB0aGUgbWFuYWdlcnMuXG4gICAgdGhpcy5faW5pdENvbnRleHQoKTtcblxuICAgIC8vIG1hcCBzb21lIHdlYkdMIGJsZW5kIG1vZGVzLi5cbiAgICB0aGlzLl9tYXBCbGVuZE1vZGVzKCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiByZW5kZXIgdGFyZ2V0c1xuICAgICAqIEBtZW1iZXIge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0U3RhY2sgPSBbXTtcbn1cblxuLy8gY29uc3RydWN0b3JcbldlYkdMUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTeXN0ZW1SZW5kZXJlci5wcm90b3R5cGUpO1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXZWJHTFJlbmRlcmVyO1xubW9kdWxlLmV4cG9ydHMgPSBXZWJHTFJlbmRlcmVyO1xudXRpbHMucGx1Z2luVGFyZ2V0Lm1peGluKFdlYkdMUmVuZGVyZXIpO1xuXG5XZWJHTFJlbmRlcmVyLmdsQ29udGV4dElkID0gMDtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBXZWJHTCBjb250ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5faW5pdENvbnRleHQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBnbCA9IHRoaXMudmlldy5nZXRDb250ZXh0KCd3ZWJnbCcsIHRoaXMuX2NvbnRleHRPcHRpb25zKSB8fCB0aGlzLnZpZXcuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgdGhpcy5fY29udGV4dE9wdGlvbnMpO1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIGlmICghZ2wpXG4gICAge1xuICAgICAgICAvLyBmYWlsLCBub3QgYWJsZSB0byBnZXQgYSBjb250ZXh0XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgd2ViR0wuIFRyeSB1c2luZyB0aGUgY2FudmFzIHJlbmRlcmVyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5nbENvbnRleHRJZCA9IFdlYkdMUmVuZGVyZXIuZ2xDb250ZXh0SWQrKztcbiAgICBnbC5pZCA9IHRoaXMuZ2xDb250ZXh0SWQ7XG4gICAgZ2wucmVuZGVyZXIgPSB0aGlzO1xuXG4gICAgLy8gc2V0IHVwIHRoZSBkZWZhdWx0IHBpeGkgc2V0dGluZ3MuLlxuICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG5cbiAgICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBSZW5kZXJUYXJnZXQodGhpcy5nbCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIG51bGwsIHRoaXMucmVzb2x1dGlvbiwgdHJ1ZSk7XG5cbiAgICB0aGlzLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRhcmdldCk7XG5cbiAgICB0aGlzLmVtaXQoJ2NvbnRleHQnLCBnbCk7XG5cbiAgICAvLyBzZXR1cCB0aGUgd2lkdGgvaGVpZ2h0IHByb3BlcnRpZXMgYW5kIGdsIHZpZXdwb3J0XG4gICAgdGhpcy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgaWYoIXRoaXMuX3VzZUZYQUEpXG4gICAge1xuICAgICAgICB0aGlzLl91c2VGWEFBID0gKCB0aGlzLl9jb250ZXh0T3B0aW9ucy5hbnRpYWxpYXMgJiYgISBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpLmFudGlhbGlhcyApO1xuICAgIH1cblxuXG4gICAgaWYodGhpcy5fdXNlRlhBQSlcbiAgICB7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oJ0ZYQUEgYW50aWFsaWFzaW5nIGJlaW5nIHVzZWQgaW5zdGVhZCBvZiBuYXRpdmUgYW50aWFsaWFzaW5nJyk7XG4gICAgICAgIHRoaXMuX0ZYQUFGaWx0ZXIgPSBbbmV3IEZYQUFGaWx0ZXIoKV07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdG8gaXRzIHdlYkdMIHZpZXdcbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHtEaXNwbGF5T2JqZWN0fSB0aGUgb2JqZWN0IHRvIGJlIHJlbmRlcmVkXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChvYmplY3QpXG57XG4gICAgLy8gbm8gcG9pbnQgcmVuZGVyaW5nIGlmIG91ciBjb250ZXh0IGhhcyBiZWVuIGJsb3duIHVwIVxuICAgIGlmICh0aGlzLmdsLmlzQ29udGV4dExvc3QoKSlcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0T2JqZWN0UmVuZGVyZWQgPSBvYmplY3Q7XG5cbiAgICBpZih0aGlzLl91c2VGWEFBKVxuICAgIHtcbiAgICAgICAgdGhpcy5fRlhBQUZpbHRlclswXS51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLnggPSB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLl9GWEFBRmlsdGVyWzBdLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUueSA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBvYmplY3QuZmlsdGVyQXJlYSA9IHRoaXMucmVuZGVyVGFyZ2V0LnNpemU7XG4gICAgICAgIG9iamVjdC5maWx0ZXJzID0gdGhpcy5fRlhBQUZpbHRlcjtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVQYXJlbnQgPSBvYmplY3QucGFyZW50O1xuICAgIG9iamVjdC5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcblxuICAgIC8vIHVwZGF0ZSB0aGUgc2NlbmUgZ3JhcGhcbiAgICBvYmplY3QudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICBvYmplY3QucGFyZW50ID0gY2FjaGVQYXJlbnQ7XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gbWFrZSBzdXJlIHdlIGFyZSBib3VuZCB0byB0aGUgbWFpbiBmcmFtZSBidWZmZXJcbiAgICB0aGlzLnNldFJlbmRlclRhcmdldCh0aGlzLnJlbmRlclRhcmdldCk7XG5cbiAgICBpZiAodGhpcy5jbGVhckJlZm9yZVJlbmRlcilcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zcGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuY2xlYXJDb2xvcih0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2JbMF0sIHRoaXMuX2JhY2tncm91bmRDb2xvclJnYlsxXSwgdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiWzJdLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyRGlzcGxheU9iamVjdChvYmplY3QsIHRoaXMucmVuZGVyVGFyZ2V0KTsvL3RoaXMucHJvamVjdGlvbik7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBEaXNwbGF5IE9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7RGlzcGxheU9iamVjdH0gVGhlIERpc3BsYXlPYmplY3QgdG8gcmVuZGVyXG4gKiBAcGFyYW0gcmVuZGVyVGFyZ2V0IHtSZW5kZXJUYXJnZXR9IFRoZSByZW5kZXIgdGFyZ2V0IHRvIHVzZSB0byByZW5kZXIgdGhpcyBkaXNwbGF5IG9iamVjdFxuICpcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRGlzcGxheU9iamVjdCA9IGZ1bmN0aW9uIChkaXNwbGF5T2JqZWN0LCByZW5kZXJUYXJnZXQsIGNsZWFyKS8vcHJvamVjdGlvbiwgYnVmZmVyKVxue1xuICAgIC8vIFRPRE8gaXMgdGhpcyBuZWVkZWQuLi5cbiAgICAvL3RoaXMuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoQ09OU1QuQkxFTkRfTU9ERVMuTk9STUFMKTtcbiAgICB0aGlzLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuXG4gICAgaWYoY2xlYXIpXG4gICAge1xuICAgICAgICByZW5kZXJUYXJnZXQuY2xlYXIoKTtcbiAgICB9XG5cbiAgICAvLyBzdGFydCB0aGUgZmlsdGVyIG1hbmFnZXJcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIuc2V0RmlsdGVyU3RhY2soIHJlbmRlclRhcmdldC5maWx0ZXJTdGFjayApO1xuXG4gICAgLy8gcmVuZGVyIHRoZSBzY2VuZSFcbiAgICBkaXNwbGF5T2JqZWN0LnJlbmRlcldlYkdMKHRoaXMpO1xuXG4gICAgLy8gZmluaXNoIHRoZSBjdXJyZW50IHJlbmRlcmVyLi5cbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHRvIHRoZSBvbmUgZ2l2ZW4gaW4gcGFyYW1ldGVyXG4gKlxuICogQHBhcmFtIG9iamVjdFJlbmRlcmVyIHtPYmplY3R9IFRPRE8gQGFsdmluXG4gKlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRPYmplY3RSZW5kZXJlciA9IGZ1bmN0aW9uIChvYmplY3RSZW5kZXJlcilcbntcbiAgICBpZiAodGhpcy5jdXJyZW50UmVuZGVyZXIgPT09IG9iamVjdFJlbmRlcmVyKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLnN0b3AoKTtcbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IG9iamVjdFJlbmRlcmVyO1xuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIGN1cnJlbnQgcmVuZGVyIHRhcmdldCB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxuICpcbiAqIEBwYXJhbSByZW5kZXJUYXJnZXQge1JlbmRlclRhcmdldH0gdGhlIG5ldyByZW5kZXIgdGFyZ2V0XG4gKlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAocmVuZGVyVGFyZ2V0KVxue1xuICAgIGlmKCB0aGlzLmN1cnJlbnRSZW5kZXJUYXJnZXQgPT09IHJlbmRlclRhcmdldClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVE9ETyAtIG1heWJlIGRvd24gdGhlIGxpbmUgdGhpcyBzaG91bGQgYmUgYSBwdXNoIHBvcyB0aGluZz8gTGVhdmluZyBmb3Igbm93IHRob3VnaC5cbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgdGhpcy5jdXJyZW50UmVuZGVyVGFyZ2V0LmFjdGl2YXRlKCk7XG4gICAgdGhpcy5zdGVuY2lsTWFuYWdlci5zZXRNYXNrU3RhY2soIHJlbmRlclRhcmdldC5zdGVuY2lsTWFza1N0YWNrICk7XG59O1xuXG5cbi8qKlxuICogUmVzaXplcyB0aGUgd2ViR0wgdmlldyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gKlxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IHRoZSBuZXcgd2lkdGggb2YgdGhlIHdlYkdMIHZpZXdcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIHdlYkdMIHZpZXdcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXG57XG4gICAgU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLnJlc2l6ZS5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAvLyBjb25zb2xlLmxvZyh3aWR0aClcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZih0aGlzLmN1cnJlbnRSZW5kZXJUYXJnZXQgPT09IHRoaXMucmVuZGVyVGFyZ2V0KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQuYWN0aXZhdGUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYW5kL29yIENyZWF0ZXMgYSBXZWJHTCB0ZXh0dXJlIGZvciB0aGUgcmVuZGVyZXIncyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB0ZXh0dXJlIHtCYXNlVGV4dHVyZXxUZXh0dXJlfSB0aGUgdGV4dHVyZSB0byB1cGRhdGVcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlKVxue1xuICAgIHRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlIHx8IHRleHR1cmU7XG5cbiAgICBpZiAoIXRleHR1cmUuaGFzTG9hZGVkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBpZiAoIXRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKVxuICAgIHtcbiAgICAgICAgdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0gPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIHRleHR1cmUub24oJ3VwZGF0ZScsIHRoaXMudXBkYXRlVGV4dHVyZSwgdGhpcyk7XG4gICAgICAgIHRleHR1cmUub24oJ2Rpc3Bvc2UnLCB0aGlzLmRlc3Ryb3lUZXh0dXJlLCB0aGlzKTtcbiAgICB9XG5cblxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcblxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBsaWVkQWxwaGEpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZS5zb3VyY2UpO1xuXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBDT05TVC5TQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcblxuXG4gICAgaWYgKHRleHR1cmUubWlwbWFwICYmIHRleHR1cmUuaXNQb3dlck9mVHdvKVxuICAgIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBDT05TVC5TQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiA6IGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBDT05TVC5TQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICB9XG5cbiAgICBpZiAoIXRleHR1cmUuaXNQb3dlck9mVHdvKVxuICAgIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5SRVBFQVQpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xuICAgIH1cblxuICAgIHJldHVybiAgdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF07XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgdGhlIHRleHR1cmUgZnJvbSBXZWJHTFxuICpcbiAqIEBwYXJhbSB0ZXh0dXJlIHtCYXNlVGV4dHVyZXxUZXh0dXJlfSB0aGUgdGV4dHVyZSB0byBkZXN0cm95XG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3lUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUpXG57XG4gICAgdGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmUgfHwgdGV4dHVyZTtcblxuICAgIGlmICghdGV4dHVyZS5oYXNMb2FkZWQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5nbC5pZF0pXG4gICAge1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLmdsLmlkXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgbG9zdCB3ZWJnbCBjb250ZXh0XG4gKlxuICogQHBhcmFtIGV2ZW50IHtFdmVudH1cbiAqIEBwcml2YXRlXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZUNvbnRleHRMb3N0ID0gZnVuY3Rpb24gKGV2ZW50KVxue1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSByZXN0b3JlZCB3ZWJnbCBjb250ZXh0XG4gKlxuICogQHBhcmFtIGV2ZW50IHtFdmVudH1cbiAqIEBwcml2YXRlXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5faW5pdENvbnRleHQoKTtcblxuICAgIC8vIGVtcHR5IGFsbCB0aGUgb2xkIGdsIHRleHR1cmVzIGFzIHRoZXkgYXJlIHVzZWxlc3Mgbm93XG4gICAgZm9yICh2YXIga2V5IGluIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGUpXG4gICAge1xuICAgICAgICB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW2tleV0uX2dsVGV4dHVyZXMubGVuZ3RoID0gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgZXZlcnl0aGluZyBmcm9tIHRoZSByZW5kZXJlciAoZXZlbnQgbGlzdGVuZXJzLCBzcHJpdGViYXRjaCwgZXRjLi4uKVxuICpcbiAqIEBwYXJhbSBbcmVtb3ZlVmlldz1mYWxzZV0ge2Jvb2xlYW59IFJlbW92ZXMgdGhlIENhbnZhcyBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmVWaWV3KVxue1xuICAgIHRoaXMuZGVzdHJveVBsdWdpbnMoKTtcblxuICAgIC8vIHJlbW92ZSBsaXN0ZW5lcnNcbiAgICB0aGlzLnZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuaGFuZGxlQ29udGV4dExvc3QpO1xuICAgIHRoaXMudmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkKTtcblxuICAgIC8vIGNhbGwgYmFzZSBkZXN0cm95XG4gICAgU3lzdGVtUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCByZW1vdmVWaWV3KTtcblxuICAgIHRoaXMudXVpZCA9IDA7XG5cbiAgICAvLyBkZXN0cm95IHRoZSBtYW5hZ2Vyc1xuICAgIHRoaXMuc2hhZGVyTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5tYXNrTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5zdGVuY2lsTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuc2hhZGVyTWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5tYXNrTWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLmJsZW5kTW9kZU1hbmFnZXIgPSBudWxsO1xuXG4gICAgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCA9IG51bGw7XG4gICAgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQgPSBudWxsO1xuXG4gICAgdGhpcy5fY29udGV4dE9wdGlvbnMgPSBudWxsO1xuXG4gICAgdGhpcy5kcmF3Q291bnQgPSAwO1xuXG4gICAgdGhpcy5nbCA9IG51bGw7XG59O1xuXG4vKipcbiAqIE1hcHMgUGl4aSBibGVuZCBtb2RlcyB0byBXZWJHTCBibGVuZCBtb2Rlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5fbWFwQmxlbmRNb2RlcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGlmICghdGhpcy5ibGVuZE1vZGVzKVxuICAgIHtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzID0ge307XG5cbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLk5PUk1BTF0gICAgICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5BRERdICAgICAgICAgICA9IFtnbC5TUkNfQUxQSEEsIGdsLkRTVF9BTFBIQV07XG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5NVUxUSVBMWV0gICAgICA9IFtnbC5EU1RfQ09MT1IsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuU0NSRUVOXSAgICAgICAgPSBbZ2wuU1JDX0FMUEhBLCBnbC5PTkVdO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuT1ZFUkxBWV0gICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkRBUktFTl0gICAgICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5MSUdIVEVOXSAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuQ09MT1JfRE9ER0VdICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkNPTE9SX0JVUk5dICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5IQVJEX0xJR0hUXSAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuU09GVF9MSUdIVF0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLkRJRkZFUkVOQ0VdICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5FWENMVVNJT05dICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuSFVFXSAgICAgICAgICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzW0NPTlNULkJMRU5EX01PREVTLlNBVFVSQVRJT05dICAgID0gW2dsLk9ORSwgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIHRoaXMuYmxlbmRNb2Rlc1tDT05TVC5CTEVORF9NT0RFUy5DT0xPUl0gICAgICAgICA9IFtnbC5PTkUsICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXNbQ09OU1QuQkxFTkRfTU9ERVMuTFVNSU5PU0lUWV0gICAgPSBbZ2wuT05FLCAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICB9XG59O1xuIiwidmFyIERlZmF1bHRTaGFkZXIgPSByZXF1aXJlKCcuLi9zaGFkZXJzL1RleHR1cmVTaGFkZXInKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBjcmVhdGluZyBhIFBJWEkgZmlsdGVyLiBDdXJyZW50bHkgb25seSBXZWJHTCBzdXBwb3J0cyBmaWx0ZXJzLlxuICogSWYgeW91IHdhbnQgdG8gbWFrZSBhIGN1c3RvbSBmaWx0ZXIgdGhpcyBzaG91bGQgYmUgeW91ciBiYXNlIGNsYXNzLlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSB2ZXJ0ZXhTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gZnJhZ21lbnRTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSB1bmlmb3JtcyB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdW5pZm9ybXMgZm9yIHRoaXMgZmlsdGVyLlxuICovXG5mdW5jdGlvbiBBYnN0cmFjdEZpbHRlcih2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCB1bmlmb3JtcylcbntcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHNoYWRlcnNcbiAgICAgKiBAbWVtYmVyIHtTaGFkZXJbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2hhZGVycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dHJhIHBhZGRpbmcgdGhhdCB0aGUgZmlsdGVyIG1pZ2h0IG5lZWRcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wYWRkaW5nID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1bmlmb3JtcyBhcyBhbiBvYmplY3RcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnVuaWZvcm1zID0gdW5pZm9ybXMgfHwge307XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb2RlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyXG4gICAgICogQG1lbWJlciB7c3RyaW5nW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleFNyYyA9IHZlcnRleFNyYyB8fCBEZWZhdWx0U2hhZGVyLmRlZmF1bHRWZXJ0ZXhTcmM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29kZSBvZiB0aGUgZnJhbWVudCBzaGFkZXJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmdbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYyB8fCBEZWZhdWx0U2hhZGVyLmRlZmF1bHRGcmFnbWVudFNyYztcblxuICAgIC8vVE9ETyBhIHJlbWluZGVyIC0gd291bGQgYmUgY29vbCB0byBoYXZlIGxvd2VyIHJlcyBmaWx0ZXJzIGFzIHRoaXMgd291bGQgZ2l2ZSBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5cbiAgICAvL3R5cGVvZiBmcmFnbWVudFNyYyA9PT0gJ3N0cmluZycgPyBmcmFnbWVudFNyYy5zcGxpdCgnJykgOiAoZnJhZ21lbnRTcmMgfHwgW10pO1xuXG59XG5cbkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFic3RyYWN0RmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdEZpbHRlcjtcblxuLypcbiAqIEdyYWJzIGEgc2hhZGVyIGZyb20gdGhlIGN1cnJlbnQgcmVuZGVyZXJcbiAqIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHRvIHJldHJpZXZlIHRoZSBzaGFkZXIgZnJvbVxuICpcbiAqL1xuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlLmdldFNoYWRlciA9IGZ1bmN0aW9uIChyZW5kZXJlcilcbntcbiAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcblxuICAgIHZhciBzaGFkZXIgPSB0aGlzLnNoYWRlcnNbZ2wuaWRdO1xuXG4gICAgaWYgKCFzaGFkZXIpXG4gICAge1xuICAgICAgICBzaGFkZXIgPSBuZXcgRGVmYXVsdFNoYWRlcihyZW5kZXJlci5zaGFkZXJNYW5hZ2VyLFxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhTcmMsXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50U3JjLFxuICAgICAgICAgICAgdGhpcy51bmlmb3JtcyxcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1xuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc2hhZGVyc1tnbC5pZF0gPSBzaGFkZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlcjtcbn07XG5cbi8qXG4gKiBBcHBsaWVzIHRoZSBmaWx0ZXJcbiAqIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHRvIHJldHJpZXZlIHRoZSBmaWx0ZXIgZnJvbVxuICogQHBhcmFtIGlucHV0IHtSZW5kZXJUYXJnZXR9XG4gKiBAcGFyYW0gb3V0cHV0IHtSZW5kZXJUYXJnZXR9XG4gKiBAcGFyYW0gY2xlYXIge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHdlIHdhbnQgdG8gY2xlYXIgdGhlIG91dHB1dFRhcmdldFxuICovXG5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKVxue1xuICAgIHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcihyZW5kZXJlcik7XG5cbiAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xufTtcblxuLyoqXG4gKiBTeW5jcyBhIHVuaWZvcm0gYmV0d2VlbiB0aGUgY2xhc3Mgb2JqZWN0IGFuZCB0aGUgc2hhZGVycy5cbiAqXG4gKi9cbkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZS5zeW5jVW5pZm9ybSA9IGZ1bmN0aW9uICh1bmlmb3JtKVxue1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5zaGFkZXJzLmxlbmd0aDsgaSA8IGo7ICsraSlcbiAgICB7XG4gICAgICAgIHRoaXMuc2hhZGVyc1tpXS5zeW5jVW5pZm9ybSh1bmlmb3JtKTtcbiAgICB9XG59O1xuXG4vKlxuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGZyYW1lQnVmZmVyKVxue1xuICAgIC8vIFRPRE8gOilcbn07XG4qL1xuIiwidmFyIEFic3RyYWN0RmlsdGVyID0gcmVxdWlyZSgnLi9BYnN0cmFjdEZpbHRlcicpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqXG4gKiBCYXNpYyBGWEFBIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uIHRoZSBjb2RlIG9uIGdlZWtzM2QuY29tIHdpdGggdGhlXG4gKiBtb2RpZmljYXRpb24gdGhhdCB0aGUgdGV4dHVyZTJETG9kIHN0dWZmIHdhcyByZW1vdmVkIHNpbmNlIGl0J3NcbiAqIHVuc3VwcG9ydGVkIGJ5IFdlYkdMLlxuICpcbiAqIC0tXG4gKiBGcm9tOlxuICogaHR0cHM6Ly9naXRodWIuY29tL21pdHN1aGlrby93ZWJnbC1tZWluY3JhZnRcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICpcbiAqL1xuZnVuY3Rpb24gRlhBQUZpbHRlcigpXG57XG4gICAgQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFwiXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudmFyeWluZyB2ZWMyIHZSZXNvbHV0aW9uO1xcblxcbi8vdGV4Y29vcmRzIGNvbXB1dGVkIGluIHZlcnRleCBzdGVwXFxuLy90byBhdm9pZCBkZXBlbmRlbnQgdGV4dHVyZSByZWFkc1xcbnZhcnlpbmcgdmVjMiB2X3JnYk5XO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk5FO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNXO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNFO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk07XFxuXFxuXFxudm9pZCB0ZXhjb29yZHModmVjMiBmcmFnQ29vcmQsIHZlYzIgcmVzb2x1dGlvbixcXG4gICAgICAgICAgICBvdXQgdmVjMiB2X3JnYk5XLCBvdXQgdmVjMiB2X3JnYk5FLFxcbiAgICAgICAgICAgIG91dCB2ZWMyIHZfcmdiU1csIG91dCB2ZWMyIHZfcmdiU0UsXFxuICAgICAgICAgICAgb3V0IHZlYzIgdl9yZ2JNKSB7XFxuICAgIHZlYzIgaW52ZXJzZVZQID0gMS4wIC8gcmVzb2x1dGlvbi54eTtcXG4gICAgdl9yZ2JOVyA9IChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIC0xLjApKSAqIGludmVyc2VWUDtcXG4gICAgdl9yZ2JORSA9IChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgLTEuMCkpICogaW52ZXJzZVZQO1xcbiAgICB2X3JnYlNXID0gKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgMS4wKSkgKiBpbnZlcnNlVlA7XFxuICAgIHZfcmdiU0UgPSAoZnJhZ0Nvb3JkICsgdmVjMigxLjAsIDEuMCkpICogaW52ZXJzZVZQO1xcbiAgICB2X3JnYk0gPSB2ZWMyKGZyYWdDb29yZCAqIGludmVyc2VWUCk7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKXtcXG4gICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG4gICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG4gICB2Q29sb3IgPSB2ZWM0KGFDb2xvci5yZ2IgKiBhQ29sb3IuYSwgYUNvbG9yLmEpO1xcbiAgIHZSZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcXG5cXG4gICAvL2NvbXB1dGUgdGhlIHRleHR1cmUgY29vcmRzIGFuZCBzZW5kIHRoZW0gdG8gdmFyeWluZ3NcXG4gICB0ZXhjb29yZHMoYVRleHR1cmVDb29yZCAqIHJlc29sdXRpb24sIHJlc29sdXRpb24sIHZfcmdiTlcsIHZfcmdiTkUsIHZfcmdiU1csIHZfcmdiU0UsIHZfcmdiTSk7XFxufVxcblwiLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbG93cCBmbG9hdDtcXG5cXG5cXG4vKipcXG5CYXNpYyBGWEFBIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uIHRoZSBjb2RlIG9uIGdlZWtzM2QuY29tIHdpdGggdGhlXFxubW9kaWZpY2F0aW9uIHRoYXQgdGhlIHRleHR1cmUyRExvZCBzdHVmZiB3YXMgcmVtb3ZlZCBzaW5jZSBpdCdzXFxudW5zdXBwb3J0ZWQgYnkgV2ViR0wuXFxuXFxuLS1cXG5cXG5Gcm9tOlxcbmh0dHBzOi8vZ2l0aHViLmNvbS9taXRzdWhpa28vd2ViZ2wtbWVpbmNyYWZ0XFxuXFxuQ29weXJpZ2h0IChjKSAyMDExIGJ5IEFybWluIFJvbmFjaGVyLlxcblxcblNvbWUgcmlnaHRzIHJlc2VydmVkLlxcblxcblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxcbm1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcXG5tZXQ6XFxuXFxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcXG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXFxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxcbiAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXFxuICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXFxuICAgICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcblxcbiAgICAqIFRoZSBuYW1lcyBvZiB0aGUgY29udHJpYnV0b3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yXFxuICAgICAgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXFxuICAgICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxcblxcblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcXG5cXFwiQVMgSVNcXFwiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxcbkxJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxcbkEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXFxuT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXFxuU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxcbkxJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxcbkRBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxcblRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcXG5PRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxcbiovXFxuXFxuI2lmbmRlZiBGWEFBX1JFRFVDRV9NSU5cXG4gICAgI2RlZmluZSBGWEFBX1JFRFVDRV9NSU4gICAoMS4wLyAxMjguMClcXG4jZW5kaWZcXG4jaWZuZGVmIEZYQUFfUkVEVUNFX01VTFxcbiAgICAjZGVmaW5lIEZYQUFfUkVEVUNFX01VTCAgICgxLjAgLyA4LjApXFxuI2VuZGlmXFxuI2lmbmRlZiBGWEFBX1NQQU5fTUFYXFxuICAgICNkZWZpbmUgRlhBQV9TUEFOX01BWCAgICAgOC4wXFxuI2VuZGlmXFxuXFxuLy9vcHRpbWl6ZWQgdmVyc2lvbiBmb3IgbW9iaWxlLCB3aGVyZSBkZXBlbmRlbnRcXG4vL3RleHR1cmUgcmVhZHMgY2FuIGJlIGEgYm90dGxlbmVja1xcbnZlYzQgZnhhYShzYW1wbGVyMkQgdGV4LCB2ZWMyIGZyYWdDb29yZCwgdmVjMiByZXNvbHV0aW9uLFxcbiAgICAgICAgICAgIHZlYzIgdl9yZ2JOVywgdmVjMiB2X3JnYk5FLFxcbiAgICAgICAgICAgIHZlYzIgdl9yZ2JTVywgdmVjMiB2X3JnYlNFLFxcbiAgICAgICAgICAgIHZlYzIgdl9yZ2JNKSB7XFxuICAgIHZlYzQgY29sb3I7XFxuICAgIG1lZGl1bXAgdmVjMiBpbnZlcnNlVlAgPSB2ZWMyKDEuMCAvIHJlc29sdXRpb24ueCwgMS4wIC8gcmVzb2x1dGlvbi55KTtcXG4gICAgdmVjMyByZ2JOVyA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiTlcpLnh5ejtcXG4gICAgdmVjMyByZ2JORSA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiTkUpLnh5ejtcXG4gICAgdmVjMyByZ2JTVyA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiU1cpLnh5ejtcXG4gICAgdmVjMyByZ2JTRSA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiU0UpLnh5ejtcXG4gICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiTSk7XFxuICAgIHZlYzMgcmdiTSAgPSB0ZXhDb2xvci54eXo7XFxuICAgIHZlYzMgbHVtYSA9IHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCk7XFxuICAgIGZsb2F0IGx1bWFOVyA9IGRvdChyZ2JOVywgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFORSA9IGRvdChyZ2JORSwgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFTVyA9IGRvdChyZ2JTVywgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFTRSA9IGRvdChyZ2JTRSwgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFNICA9IGRvdChyZ2JNLCAgbHVtYSk7XFxuICAgIGZsb2F0IGx1bWFNaW4gPSBtaW4obHVtYU0sIG1pbihtaW4obHVtYU5XLCBsdW1hTkUpLCBtaW4obHVtYVNXLCBsdW1hU0UpKSk7XFxuICAgIGZsb2F0IGx1bWFNYXggPSBtYXgobHVtYU0sIG1heChtYXgobHVtYU5XLCBsdW1hTkUpLCBtYXgobHVtYVNXLCBsdW1hU0UpKSk7XFxuXFxuICAgIG1lZGl1bXAgdmVjMiBkaXI7XFxuICAgIGRpci54ID0gLSgobHVtYU5XICsgbHVtYU5FKSAtIChsdW1hU1cgKyBsdW1hU0UpKTtcXG4gICAgZGlyLnkgPSAgKChsdW1hTlcgKyBsdW1hU1cpIC0gKGx1bWFORSArIGx1bWFTRSkpO1xcblxcbiAgICBmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoKGx1bWFOVyArIGx1bWFORSArIGx1bWFTVyArIGx1bWFTRSkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKDAuMjUgKiBGWEFBX1JFRFVDRV9NVUwpLCBGWEFBX1JFRFVDRV9NSU4pO1xcblxcbiAgICBmbG9hdCByY3BEaXJNaW4gPSAxLjAgLyAobWluKGFicyhkaXIueCksIGFicyhkaXIueSkpICsgZGlyUmVkdWNlKTtcXG4gICAgZGlyID0gbWluKHZlYzIoRlhBQV9TUEFOX01BWCwgRlhBQV9TUEFOX01BWCksXFxuICAgICAgICAgICAgICBtYXgodmVjMigtRlhBQV9TUEFOX01BWCwgLUZYQUFfU1BBTl9NQVgpLFxcbiAgICAgICAgICAgICAgZGlyICogcmNwRGlyTWluKSkgKiBpbnZlcnNlVlA7XFxuXFxuICAgIHZlYzMgcmdiQSA9IDAuNSAqIChcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqICgxLjAgLyAzLjAgLSAwLjUpKS54eXogK1xcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogKDIuMCAvIDMuMCAtIDAuNSkpLnh5eik7XFxuICAgIHZlYzMgcmdiQiA9IHJnYkEgKiAwLjUgKyAwLjI1ICogKFxcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogLTAuNSkueHl6ICtcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqIDAuNSkueHl6KTtcXG5cXG4gICAgZmxvYXQgbHVtYUIgPSBkb3QocmdiQiwgbHVtYSk7XFxuICAgIGlmICgobHVtYUIgPCBsdW1hTWluKSB8fCAobHVtYUIgPiBsdW1hTWF4KSlcXG4gICAgICAgIGNvbG9yID0gdmVjNChyZ2JBLCB0ZXhDb2xvci5hKTtcXG4gICAgZWxzZVxcbiAgICAgICAgY29sb3IgPSB2ZWM0KHJnYkIsIHRleENvbG9yLmEpO1xcbiAgICByZXR1cm4gY29sb3I7XFxufVxcblxcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyB2ZWMyIHZSZXNvbHV0aW9uO1xcblxcbi8vdGV4Y29vcmRzIGNvbXB1dGVkIGluIHZlcnRleCBzdGVwXFxuLy90byBhdm9pZCBkZXBlbmRlbnQgdGV4dHVyZSByZWFkc1xcbnZhcnlpbmcgdmVjMiB2X3JnYk5XO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk5FO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNXO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNFO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk07XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxuXFxudm9pZCBtYWluKHZvaWQpe1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBmeGFhKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICogdlJlc29sdXRpb24sIHZSZXNvbHV0aW9uLCB2X3JnYk5XLCB2X3JnYk5FLCB2X3JnYlNXLCB2X3JnYlNFLCB2X3JnYk0pO1xcblxcbn1cXG5cIixcbiAgICAgICAgLy8gdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzb2x1dGlvbjogeyB0eXBlOiAndjInLCB2YWx1ZTogeyB4OiAxLCB5OiAxIH0gfVxuICAgICAgICB9XG4gICAgKTtcblxufVxuXG5GWEFBRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbkZYQUFGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRlhBQUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gRlhBQUZpbHRlcjtcblxuRlhBQUZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQpXG57XG4gICAgdmFyIGZpbHRlck1hbmFnZXIgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyO1xuXG4gICAgdmFyIHNoYWRlciA9IHRoaXMuZ2V0U2hhZGVyKCByZW5kZXJlciApO1xuICAgICAvLyBkcmF3IHRoZSBmaWx0ZXIuLi5cbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCk7XG59O1xuIiwidmFyIEFic3RyYWN0RmlsdGVyID0gcmVxdWlyZSgnLi9BYnN0cmFjdEZpbHRlcicpLFxuICAgIG1hdGggPSAgcmVxdWlyZSgnLi4vLi4vLi4vbWF0aCcpO1xuXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8qKlxuICogVGhlIFNwcml0ZU1hc2tGaWx0ZXIgY2xhc3NcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHNwcml0ZSB7U3ByaXRlfSB0aGUgdGFyZ2V0IHNwcml0ZVxuICovXG5mdW5jdGlvbiBTcHJpdGVNYXNrRmlsdGVyKHNwcml0ZSlcbntcbiAgICB2YXIgbWFza01hdHJpeCA9IG5ldyBtYXRoLk1hdHJpeCgpO1xuXG4gICAgQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgb3RoZXJNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZNYXNrQ29vcmQ7XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG4gICAgdk1hc2tDb29yZCA9ICggb3RoZXJNYXRyaXggKiB2ZWMzKCBhVGV4dHVyZUNvb3JkLCAxLjApICApLnh5O1xcbiAgICB2Q29sb3IgPSB2ZWM0KGFDb2xvci5yZ2IgKiBhQ29sb3IuYSwgYUNvbG9yLmEpO1xcbn1cXG5cIixcbiAgICAgICAgXCJwcmVjaXNpb24gbG93cCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdk1hc2tDb29yZDtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gZmxvYXQgYWxwaGE7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWFzaztcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIC8vIGNoZWNrIGNsaXAhIHRoaXMgd2lsbCBzdG9wIHRoZSBtYXNrIGJsZWVkaW5nIG91dCBmcm9tIHRoZSBlZGdlc1xcbiAgICB2ZWMyIHRleHQgPSBhYnMoIHZNYXNrQ29vcmQgLSAwLjUgKTtcXG4gICAgdGV4dCA9IHN0ZXAoMC41LCB0ZXh0KTtcXG4gICAgZmxvYXQgY2xpcCA9IDEuMCAtIG1heCh0ZXh0LnksIHRleHQueCk7XFxuICAgIHZlYzQgb3JpZ2luYWwgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICB2ZWM0IG1hc2t5ID0gdGV4dHVyZTJEKG1hc2ssIHZNYXNrQ29vcmQpO1xcbiAgICBvcmlnaW5hbCAqPSAobWFza3kuciAqIG1hc2t5LmEgKiBhbHBoYSAqIGNsaXApO1xcbiAgICBnbF9GcmFnQ29sb3IgPSBvcmlnaW5hbDtcXG59XFxuXCIsXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1hc2s6ICAgICAgICAgICB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogc3ByaXRlLl90ZXh0dXJlIH0sXG4gICAgICAgICAgICBhbHBoYTogICAgICAgICAgeyB0eXBlOiAnZicsIHZhbHVlOiAxfSxcbiAgICAgICAgICAgIG90aGVyTWF0cml4OiAgICB7IHR5cGU6ICdtYXQzJywgdmFsdWU6IG1hc2tNYXRyaXgudG9BcnJheSh0cnVlKSB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5tYXNrU3ByaXRlID0gc3ByaXRlO1xuICAgIHRoaXMubWFza01hdHJpeCA9IG1hc2tNYXRyaXg7XG59XG5cblNwcml0ZU1hc2tGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuU3ByaXRlTWFza0ZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcHJpdGVNYXNrRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVNYXNrRmlsdGVyO1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGZpbHRlciA/IEBhbHZpblxuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn0gQSByZWZlcmVuY2UgdG8gdGhlIFdlYkdMIHJlbmRlcmVyXG4gKiBAcGFyYW0gaW5wdXQge1JlbmRlclRhcmdldH1cbiAqIEBwYXJhbSBvdXRwdXQge1JlbmRlclRhcmdldH1cbiAqL1xuU3ByaXRlTWFza0ZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQpXG57XG4gICAgdmFyIGZpbHRlck1hbmFnZXIgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyO1xuXG4gICAgdGhpcy51bmlmb3Jtcy5tYXNrLnZhbHVlID0gdGhpcy5tYXNrU3ByaXRlLl90ZXh0dXJlO1xuXG4gICAgZmlsdGVyTWFuYWdlci5jYWxjdWxhdGVNYXBwZWRNYXRyaXgoaW5wdXQuZnJhbWUsIHRoaXMubWFza1Nwcml0ZSwgdGhpcy5tYXNrTWF0cml4KTtcblxuICAgIHRoaXMudW5pZm9ybXMub3RoZXJNYXRyaXgudmFsdWUgPSB0aGlzLm1hc2tNYXRyaXgudG9BcnJheSh0cnVlKTtcbiAgICB0aGlzLnVuaWZvcm1zLmFscGhhLnZhbHVlID0gdGhpcy5tYXNrU3ByaXRlLndvcmxkQWxwaGE7XG5cbiAgICB2YXIgc2hhZGVyID0gdGhpcy5nZXRTaGFkZXIocmVuZGVyZXIpO1xuICAgICAvLyBkcmF3IHRoZSBmaWx0ZXIuLi5cbiAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCk7XG59O1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNwcml0ZU1hc2tGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmUgdXNlZCBmb3IgdGhlIGRpc3BsYWNlbWVudCBtYXAuIE11c3QgYmUgcG93ZXIgb2YgMiBzaXplZCB0ZXh0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7VGV4dHVyZX1cbiAgICAgKiBAbWVtYmVyb2YgU3ByaXRlTWFza0ZpbHRlciNcbiAgICAgKi9cbiAgICBtYXA6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXNrLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXNrLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG9mZnNldCB1c2VkIHRvIG1vdmUgdGhlIGRpc3BsYWNlbWVudCBtYXAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQb2ludH1cbiAgICAgKiBAbWVtYmVyb2YgU3ByaXRlTWFza0ZpbHRlciNcbiAgICAgKi9cbiAgICBvZmZzZXQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm9mZnNldC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5vZmZzZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwidmFyIFdlYkdMTWFuYWdlciA9IHJlcXVpcmUoJy4vV2ViR0xNYW5hZ2VyJyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQGV4dGVuZHMgV2ViR2xNYW5hZ2VyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1dlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxuICovXG5mdW5jdGlvbiBCbGVuZE1vZGVNYW5hZ2VyKHJlbmRlcmVyKVxue1xuICAgIFdlYkdMTWFuYWdlci5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRCbGVuZE1vZGUgPSA5OTk5OTtcbn1cblxuQmxlbmRNb2RlTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdlYkdMTWFuYWdlci5wcm90b3R5cGUpO1xuQmxlbmRNb2RlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbGVuZE1vZGVNYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBCbGVuZE1vZGVNYW5hZ2VyO1xuXG4vKipcbiAqIFNldHMtdXAgdGhlIGdpdmVuIGJsZW5kTW9kZSBmcm9tIFdlYkdMJ3MgcG9pbnQgb2Ygdmlldy5cbiAqXG4gKiBAcGFyYW0gYmxlbmRNb2RlIHtudW1iZXJ9IHRoZSBibGVuZE1vZGUsIHNob3VsZCBiZSBhIFBpeGkgY29uc3QsIHN1Y2ggYXMgQmxlbmRNb2Rlcy5BRERcbiAqL1xuQmxlbmRNb2RlTWFuYWdlci5wcm90b3R5cGUuc2V0QmxlbmRNb2RlID0gZnVuY3Rpb24gKGJsZW5kTW9kZSlcbntcbiAgICBpZiAodGhpcy5jdXJyZW50QmxlbmRNb2RlID09PSBibGVuZE1vZGUpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50QmxlbmRNb2RlID0gYmxlbmRNb2RlO1xuXG4gICAgdmFyIG1vZGUgPSB0aGlzLnJlbmRlcmVyLmJsZW5kTW9kZXNbdGhpcy5jdXJyZW50QmxlbmRNb2RlXTtcbiAgICB0aGlzLnJlbmRlcmVyLmdsLmJsZW5kRnVuYyhtb2RlWzBdLCBtb2RlWzFdKTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcbiIsInZhciBXZWJHTE1hbmFnZXIgPSByZXF1aXJlKCcuL1dlYkdMTWFuYWdlcicpLFxuICAgIFJlbmRlclRhcmdldCA9IHJlcXVpcmUoJy4uL3V0aWxzL1JlbmRlclRhcmdldCcpLFxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vY29uc3QnKSxcbiAgICBRdWFkID0gcmVxdWlyZSgnLi4vdXRpbHMvUXVhZCcpLFxuICAgIG1hdGggPSAgcmVxdWlyZSgnLi4vLi4vLi4vbWF0aCcpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBleHRlbmRzIFdlYkdMTWFuYWdlclxuICogQHBhcmFtIHJlbmRlcmVyIHtXZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gRmlsdGVyTWFuYWdlcihyZW5kZXJlcilcbntcbiAgICBXZWJHTE1hbmFnZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHthbnlbXX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlclN0YWNrID0gW107XG5cbiAgICB0aGlzLmZpbHRlclN0YWNrLnB1c2goe1xuICAgICAgICByZW5kZXJUYXJnZXQ6cmVuZGVyZXIuY3VycmVudFJlbmRlclRhcmdldCxcbiAgICAgICAgZmlsdGVyOltdLFxuICAgICAgICBib3VuZHM6bnVsbFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7YW55W119XG4gICAgICovXG4gICAgdGhpcy50ZXh0dXJlUG9vbCA9IFtdO1xuXG4gICAgLy8gbGlzdGVuIGZvciBjb250ZXh0IGFuZCB1cGRhdGUgbmVjZXNzYXJ5IGJ1ZmZlcnNcbiAgICAvL1RPRE8gbWFrZSB0aGlzIGR5bmFtaWMhXG4gICAgLy9UT0RPIHRlc3QgdGhpcyBvdXQgYnkgZm9yY2VzIHBvd2VyIG9mIHR3bz9cbiAgICB0aGlzLnRleHR1cmVTaXplID0gbmV3IG1hdGguUmVjdGFuZ2xlKCAwLCAwLCByZW5kZXJlci53aWR0aCwgcmVuZGVyZXIuaGVpZ2h0ICk7XG5cbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IG51bGw7XG59XG5cbkZpbHRlck1hbmFnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXZWJHTE1hbmFnZXIucHJvdG90eXBlKTtcbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmlsdGVyTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyTWFuYWdlcjtcblxuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZXJlIGlzIGEgV2ViR0wgY29udGV4dCBjaGFuZ2UuXG4gKlxuICovXG5GaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5vbkNvbnRleHRDaGFuZ2UgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMudGV4dHVyZVBvb2wubGVuZ3RoID0gMDtcblxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgdGhpcy5xdWFkID0gbmV3IFF1YWQoZ2wpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1dlYkdMUmVuZGVyZXJ9XG4gKiBAcGFyYW0gYnVmZmVyIHtBcnJheUJ1ZmZlcn1cbiAqL1xuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuc2V0RmlsdGVyU3RhY2sgPSBmdW5jdGlvbiAoIGZpbHRlclN0YWNrIClcbntcbiAgICB0aGlzLmZpbHRlclN0YWNrID0gZmlsdGVyU3RhY2s7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGZpbHRlciBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suXG4gKlxuICogQHBhcmFtIGZpbHRlckJsb2NrIHtvYmplY3R9IHRoZSBmaWx0ZXIgdGhhdCB3aWxsIGJlIHB1c2hlZCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2tcbiAqL1xuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUucHVzaEZpbHRlciA9IGZ1bmN0aW9uICh0YXJnZXQsIGZpbHRlcnMpXG57XG4gICAgLy8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIG9iamVjdC4uXG4gICAgdmFyIGJvdW5kcyA9IHRhcmdldC5maWx0ZXJBcmVhIHx8IHRhcmdldC5nZXRCb3VuZHMoKTtcbiAgICAvL2JvdW5kcyA9IGJvdW5kcy5jbG9uZSgpO1xuXG4gICAgLy8gcm91bmQgb2ZmIHRoZSByZWN0YW5nbGUgdG8gZ2V0IGEgbmljZSBzbW9vb29vb290aCBmaWx0ZXIgOilcbiAgICBib3VuZHMueCA9IGJvdW5kcy54IHwgMDtcbiAgICBib3VuZHMueSA9IGJvdW5kcy55IHwgMDtcbiAgICBib3VuZHMud2lkdGggPSBib3VuZHMud2lkdGggfCAwO1xuICAgIGJvdW5kcy5oZWlnaHQgPSBib3VuZHMuaGVpZ2h0IHwgMDtcblxuXG4gICAgLy8gcGFkZGluZyFcbiAgICB2YXIgcGFkZGluZyA9IGZpbHRlcnNbMF0ucGFkZGluZyB8IDA7XG4gICAgYm91bmRzLnggLT0gcGFkZGluZztcbiAgICBib3VuZHMueSAtPSBwYWRkaW5nO1xuICAgIGJvdW5kcy53aWR0aCArPSBwYWRkaW5nICogMjtcbiAgICBib3VuZHMuaGVpZ2h0ICs9IHBhZGRpbmcgKiAyO1xuXG5cbiAgICBpZih0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQudHJhbnNmb3JtKVxuICAgIHtcbiAgICAgICAgLy9UT0RPIHRoaXMgd2lsbCBicmVhayBpZiB0aGUgcmVuZGVyVGV4dHVyZSB0cmFuc2Zvcm0gaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBhIHRyYW5zbGF0aW9uLlxuICAgICAgICAvL1dpbGwgbmVlZCB0byB0YWtlIHRoZSBmdWxsIG1hdHJpeCB0cmFuc2Zvcm0gaW50byBhY291bnQuLlxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnRyYW5zZm9ybTtcblxuICAgICAgICBib3VuZHMueCArPSB0cmFuc2Zvcm0udHg7XG4gICAgICAgIGJvdW5kcy55ICs9IHRyYW5zZm9ybS50eTtcblxuICAgICAgICB0aGlzLmNhcEZpbHRlckFyZWEoIGJvdW5kcyApO1xuXG4gICAgICAgIGJvdW5kcy54IC09IHRyYW5zZm9ybS50eDtcbiAgICAgICAgYm91bmRzLnkgLT0gdHJhbnNmb3JtLnR5O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICAgdGhpcy5jYXBGaWx0ZXJBcmVhKCBib3VuZHMgKTtcbiAgICB9XG5cbiAgICBpZihib3VuZHMud2lkdGggPiAwICYmIGJvdW5kcy5oZWlnaHQgPiAwKVxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSBib3VuZHM7XG5cbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmdldFJlbmRlclRhcmdldCgpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRleHR1cmUpO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSB0ZXh0dXJlLi5cbiAgICAgICAgdGV4dHVyZS5jbGVhcigpO1xuXG4gICAgICAgIC8vIFRPRE8gZ2V0IHJpZCBvZiBvYmplY3QgY3JlYXRpb24hXG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2sucHVzaCh7XG4gICAgICAgICAgICByZW5kZXJUYXJnZXQ6IHRleHR1cmUsXG4gICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcnNcbiAgICAgICAgfSk7XG5cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy8gcHVzaCBzb210aGluZyBvbiB0byB0aGUgc3RhY2sgdGhhdCBpcyBlbXB0eVxuICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnB1c2goe1xuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXJzXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBsYXN0IGZpbHRlciBmcm9tIHRoZSBmaWx0ZXIgc3RhY2sgYW5kIHJldHVybnMgaXQuXG4gKlxuICovXG5GaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5wb3BGaWx0ZXIgPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBmaWx0ZXJEYXRhID0gdGhpcy5maWx0ZXJTdGFjay5wb3AoKTtcbiAgICB2YXIgcHJldmlvdXNGaWx0ZXJEYXRhID0gdGhpcy5maWx0ZXJTdGFja1t0aGlzLmZpbHRlclN0YWNrLmxlbmd0aC0xXTtcblxuICAgIHZhciBpbnB1dCA9IGZpbHRlckRhdGEucmVuZGVyVGFyZ2V0O1xuXG4gICAgLy8gaWYgdGhlIHJlbmRlclRhcmdldCBpcyBudWxsIHRoZW4gd2UgZG9uJ3QgYXBwbHkgdGhlIGZpbHRlciBhcyBpdHMgb2Zmc2NyZWVuXG4gICAgaWYoIWZpbHRlckRhdGEucmVuZGVyVGFyZ2V0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSBwcmV2aW91c0ZpbHRlckRhdGEucmVuZGVyVGFyZ2V0O1xuXG4gICAgLy8gdXNlIHByb2dyYW1cbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG5cbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGlucHV0LmZyYW1lO1xuXG4gICAgdGhpcy5xdWFkLm1hcCh0aGlzLnRleHR1cmVTaXplLCBpbnB1dC5mcmFtZSk7XG5cblxuICAgIC8vIFRPRE8uLiB0aGlzIHByb2JhYmx5IG9ubHkgbmVlZHMgdG8gYmUgZG9uZSBvbmNlIVxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnF1YWQudmVydGV4QnVmZmVyKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLnF1YWQuaW5kZXhCdWZmZXIpO1xuXG4gICAgdmFyIGZpbHRlcnMgPSBmaWx0ZXJEYXRhLmZpbHRlcjtcblxuICAgIC8vIGFzc3VtaW5nIGFsbCBmaWx0ZXJzIGZvbGxvdyB0aGUgY29ycmVjdCBmb3JtYXQ/P1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLmRlZmF1bHRTaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIuZGVmYXVsdFNoYWRlci5hdHRyaWJ1dGVzLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMiAqIDQgKiA0KTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5kZWZhdWx0U2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCA0LCBnbC5GTE9BVCwgZmFsc2UsIDAsIDQgKiA0ICogNCk7XG5cbiAgICAvLyByZXN0b3JlIHRoZSBub3JtYWwgYmxlbmRtb2RlIVxuICAgIHRoaXMucmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoQ09OU1QuQkxFTkRfTU9ERVMuTk9STUFMKTtcblxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSlcbiAgICB7XG4gICAgICAgIC8vIFRPRE8gKGNlbmdsZXIpIC0gVGhlcmUgaGFzIHRvIGJlIGEgYmV0dGVyIHdheSB0aGVuIHNldHRpbmcgdGhpcyBlYWNoIHRpbWU/XG4gICAgICAgIGlmIChmaWx0ZXJzWzBdLnVuaWZvcm1zLmRpbWVuc2lvbnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZpbHRlcnNbMF0udW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVswXSA9IHRoaXMucmVuZGVyZXIud2lkdGg7XG4gICAgICAgICAgICBmaWx0ZXJzWzBdLnVuaWZvcm1zLmRpbWVuc2lvbnMudmFsdWVbMV0gPSB0aGlzLnJlbmRlcmVyLmhlaWdodDtcbiAgICAgICAgICAgIGZpbHRlcnNbMF0udW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVsyXSA9IHRoaXMucXVhZC52ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgIGZpbHRlcnNbMF0udW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVszXSA9IHRoaXMucXVhZC52ZXJ0aWNlc1s1XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlcnNbMF0uYXBwbHlGaWx0ZXIoIHRoaXMucmVuZGVyZXIsIGlucHV0LCBvdXRwdXQgKTtcbiAgICAgICAgdGhpcy5yZXR1cm5SZW5kZXJUYXJnZXQoIGlucHV0ICk7XG5cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIGZsaXBUZXh0dXJlID0gaW5wdXQ7XG4gICAgICAgIHZhciBmbG9wVGV4dHVyZSA9IHRoaXMuZ2V0UmVuZGVyVGFyZ2V0KHRydWUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGgtMTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gZmlsdGVyc1tpXTtcblxuICAgICAgICAgICAgLy8gVE9ETyAoY2VuZ2xlcikgLSBUaGVyZSBoYXMgdG8gYmUgYSBiZXR0ZXIgd2F5IHRoZW4gc2V0dGluZyB0aGlzIGVhY2ggdGltZT9cbiAgICAgICAgICAgIGlmIChmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVswXSA9IHRoaXMucmVuZGVyZXIud2lkdGg7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnVuaWZvcm1zLmRpbWVuc2lvbnMudmFsdWVbMV0gPSB0aGlzLnJlbmRlcmVyLmhlaWdodDtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVsyXSA9IHRoaXMucXVhZC52ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudW5pZm9ybXMuZGltZW5zaW9ucy52YWx1ZVszXSA9IHRoaXMucXVhZC52ZXJ0aWNlc1s1XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsdGVyLmFwcGx5RmlsdGVyKCB0aGlzLnJlbmRlcmVyLCBmbGlwVGV4dHVyZSwgZmxvcFRleHR1cmUgKTtcblxuICAgICAgICAgICAgdmFyIHRlbXAgPSBmbGlwVGV4dHVyZTtcbiAgICAgICAgICAgIGZsaXBUZXh0dXJlID0gZmxvcFRleHR1cmU7XG4gICAgICAgICAgICBmbG9wVGV4dHVyZSA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBmaWx0ZXJzW2ZpbHRlcnMubGVuZ3RoLTFdLmFwcGx5RmlsdGVyKCB0aGlzLnJlbmRlcmVyLCBmbGlwVGV4dHVyZSwgb3V0cHV0ICk7XG5cbiAgICAgICAgdGhpcy5yZXR1cm5SZW5kZXJUYXJnZXQoIGZsaXBUZXh0dXJlICk7XG4gICAgICAgIHRoaXMucmV0dXJuUmVuZGVyVGFyZ2V0KCBmbG9wVGV4dHVyZSApO1xuICAgIH1cblxuICAgIHJldHVybiBmaWx0ZXJEYXRhLmZpbHRlcjtcbn07XG5cbi8qKlxuICogR3JhYnMgYW4gcmVuZGVyIHRhcmdldCBmcm9tIHRoZSBpbnRlcm5hbCBwb29sXG4gKlxuICogQHBhcmFtIGNsZWFyIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB3ZSBuZWVkIHRvIGNsZWFyIHRoZSBSZW5kZXJUYXJnZXRcbiAqIEByZXR1cm4ge1JlbmRlclRhcmdldH1cbiAqL1xuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuZ2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCBjbGVhciApXG57XG4gICAgdmFyIHJlbmRlclRhcmdldCA9IHRoaXMudGV4dHVyZVBvb2wucG9wKCkgfHwgbmV3IFJlbmRlclRhcmdldCh0aGlzLnJlbmRlcmVyLmdsLCB0aGlzLnRleHR1cmVTaXplLndpZHRoLCB0aGlzLnRleHR1cmVTaXplLmhlaWdodCwgQ09OU1QuU0NBTEVfTU9ERVMuTElORUFSLCB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb24gKiBDT05TVC5GSUxURVJfUkVTT0xVVElPTik7XG4gICAgcmVuZGVyVGFyZ2V0LmZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG5cbiAgICBpZiAoY2xlYXIpXG4gICAge1xuICAgICAgICByZW5kZXJUYXJnZXQuY2xlYXIodHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlclRhcmdldDtcbn07XG5cbi8qXG4gKiBSZXR1cm5zIGEgUmVuZGVyVGFyZ2V0IHRvIHRoZSBpbnRlcm5hbCBwb29sXG4gKiBAcGFyYW0gcmVuZGVyVGFyZ2V0IHtSZW5kZXJUYXJnZXR9IFRoZSBSZW5kZXJUYXJnZXQgd2Ugd2FudCB0byByZXR1cm4gdG8gdGhlIHBvb2xcbiAqL1xuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUucmV0dXJuUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKHJlbmRlclRhcmdldClcbntcbiAgICB0aGlzLnRleHR1cmVQb29sLnB1c2goIHJlbmRlclRhcmdldCApO1xufTtcblxuLypcbiAqIEFwcGxpZXMgdGhlIGZpbHRlclxuICogQHBhcmFtIHNoYWRlciB7U2hhZGVyfSBUaGUgc2hhZGVyIHRvIHVwbG9hZFxuICogQHBhcmFtIGlucHV0VGFyZ2V0IHtSZW5kZXJUYXJnZXR9XG4gKiBAcGFyYW0gb3V0cHV0VGFyZ2V0IHtSZW5kZXJUYXJnZXR9XG4gKiBAcGFyYW0gY2xlYXIge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHdlIHdhbnQgdG8gY2xlYXIgdGhlIG91dHB1dFRhcmdldFxuICovXG5GaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChzaGFkZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyKVxue1xuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldFJlbmRlclRhcmdldChvdXRwdXRUYXJnZXQpO1xuXG4gICAgaWYgKGNsZWFyKVxuICAgIHtcbiAgICAgICAgb3V0cHV0VGFyZ2V0LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBzaGFkZXJcbiAgICB0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIuc2V0U2hhZGVyKHNoYWRlcik7XG5cbiAgICAvLyBUT0RPIChjZW5nbGVyKSAtIENhbiB0aGlzIGJlIGNhY2hlZCBhbmQgbm90IGB0b0FycmF5YGVkIGVhY2ggZnJhbWU/XG4gICAgc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgudmFsdWUgPSB0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpO1xuXG4gICAgLy9UT0RPIGNhbiB0aGlzIGJlIG9wdGltaXNlZD9cbiAgICBzaGFkZXIuc3luY1VuaWZvcm1zKCk7XG4vKlxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYVRleHR1cmVDb29yZCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAyICogNCAqIDQpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCA0LCBnbC5GTE9BVCwgZmFsc2UsIDAsIDQgKiA0ICogNCk7XG4qL1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgaW5wdXRUYXJnZXQudGV4dHVyZSk7XG5cbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xufTtcblxuLypcbiAqIENhbGN1bGF0ZXMgdGhlIG1hcHBlZCBtYXRyaXhcbiAqIEBwYXJhbSBmaWx0ZXJBcmVhIHtSZWN0YW5nbGV9IFRoZSBmaWx0ZXIgYXJlYVxuICogQHBhcmFtIHNwcml0ZSB7U3ByaXRlfSB0aGUgdGFyZ2V0IHNwcml0ZVxuICogQHBhcmFtIG91dHB1dE1hdHJpeCB7TWF0cml4fSBAYWx2aW5cbiAqL1xuLy8gVE9ETyBwbGF5aW5nIGFyb3VuZCBoZXJlLi4gdGhpcyBpcyB0ZW1wb3JhcnkgLSAod2lsbCBlbmQgdXAgaW4gdGhlIHNoYWRlcilcbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLmNhbGN1bGF0ZU1hcHBlZE1hdHJpeCA9IGZ1bmN0aW9uIChmaWx0ZXJBcmVhLCBzcHJpdGUsIG91dHB1dE1hdHJpeClcbntcbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBzcHJpdGUud29ybGRUcmFuc2Zvcm0uY29weShtYXRoLk1hdHJpeC5URU1QX01BVFJJWCksXG4gICAgdGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcblxuICAgIHZhciBtYXBwZWRNYXRyaXggPSBvdXRwdXRNYXRyaXguaWRlbnRpdHkoKTtcblxuICAgIC8vIHNjYWxlLi5cbiAgICB2YXIgcmF0aW8gPSB0aGlzLnRleHR1cmVTaXplLmhlaWdodCAvIHRoaXMudGV4dHVyZVNpemUud2lkdGg7XG5cbiAgICBtYXBwZWRNYXRyaXgudHJhbnNsYXRlKGZpbHRlckFyZWEueCAvIHRoaXMudGV4dHVyZVNpemUud2lkdGgsIGZpbHRlckFyZWEueSAvIHRoaXMudGV4dHVyZVNpemUuaGVpZ2h0ICk7XG5cbiAgICBtYXBwZWRNYXRyaXguc2NhbGUoMSAsIHJhdGlvKTtcblxuICAgIHZhciB0cmFuc2xhdGVTY2FsZVggPSAodGhpcy50ZXh0dXJlU2l6ZS53aWR0aCAvIHRleHR1cmUud2lkdGgpO1xuICAgIHZhciB0cmFuc2xhdGVTY2FsZVkgPSAodGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQgLyB0ZXh0dXJlLmhlaWdodCk7XG5cbiAgICB3b3JsZFRyYW5zZm9ybS50eCAvPSB0ZXh0dXJlLndpZHRoICogdHJhbnNsYXRlU2NhbGVYO1xuICAgIHdvcmxkVHJhbnNmb3JtLnR5IC89IHRleHR1cmUud2lkdGggKiB0cmFuc2xhdGVTY2FsZVg7XG5cbiAgICB3b3JsZFRyYW5zZm9ybS5pbnZlcnQoKTtcblxuICAgIG1hcHBlZE1hdHJpeC5wcmVwZW5kKHdvcmxkVHJhbnNmb3JtKTtcblxuICAgIC8vIGFwcGx5IGludmVyc2Ugc2NhbGUuLlxuICAgIG1hcHBlZE1hdHJpeC5zY2FsZSgxICwgMS9yYXRpbyk7XG5cbiAgICBtYXBwZWRNYXRyaXguc2NhbGUoIHRyYW5zbGF0ZVNjYWxlWCAsIHRyYW5zbGF0ZVNjYWxlWSApO1xuXG4gICAgbWFwcGVkTWF0cml4LnRyYW5zbGF0ZShzcHJpdGUuYW5jaG9yLngsIHNwcml0ZS5hbmNob3IueSk7XG5cbiAgICByZXR1cm4gbWFwcGVkTWF0cml4O1xuXG4gICAgLy8gS2VlcGluZyB0aGUgb3JnaW5hbCBhcyBhIHJlbWluZGVyIHRvIG1lIG9uIGhvdyB0aGlzIHdvcmtzIVxuICAgIC8vXG4gICAgLy8gdmFyIG0gPSBuZXcgbWF0aC5NYXRyaXgoKTtcblxuICAgIC8vIC8vIHNjYWxlLi5cbiAgICAvLyB2YXIgcmF0aW8gPSB0aGlzLnRleHR1cmVTaXplLmhlaWdodCAvIHRoaXMudGV4dHVyZVNpemUud2lkdGg7XG5cbiAgICAvLyBtLnRyYW5zbGF0ZShmaWx0ZXJBcmVhLnggLyB0aGlzLnRleHR1cmVTaXplLndpZHRoLCBmaWx0ZXJBcmVhLnkgLyB0aGlzLnRleHR1cmVTaXplLmhlaWdodCk7XG5cblxuICAgIC8vIG0uc2NhbGUoMSAsIHJhdGlvKTtcblxuXG4gICAgLy8gdmFyIHRyYW5zZm9ybSA9IHd0LmNsb25lKCk7XG5cbiAgICAvLyB2YXIgdHJhbnNsYXRlU2NhbGVYID0gKHRoaXMudGV4dHVyZVNpemUud2lkdGggLyA2MjApO1xuICAgIC8vIHZhciB0cmFuc2xhdGVTY2FsZVkgPSAodGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQgLyAzODApO1xuXG4gICAgLy8gdHJhbnNmb3JtLnR4IC89IDYyMCAqIHRyYW5zbGF0ZVNjYWxlWDtcbiAgICAvLyB0cmFuc2Zvcm0udHkgLz0gNjIwICogdHJhbnNsYXRlU2NhbGVYO1xuXG4gICAgLy8gdHJhbnNmb3JtLmludmVydCgpO1xuXG4gICAgLy8gdHJhbnNmb3JtLmFwcGVuZChtKTtcblxuICAgIC8vIC8vIGFwcGx5IGludmVyc2Ugc2NhbGUuLlxuICAgIC8vIHRyYW5zZm9ybS5zY2FsZSgxICwgMS9yYXRpbyk7XG5cbiAgICAvLyB0cmFuc2Zvcm0uc2NhbGUoIHRyYW5zbGF0ZVNjYWxlWCAsIHRyYW5zbGF0ZVNjYWxlWSApO1xuXG4gICAgLy8gcmV0dXJuIHRyYW5zZm9ybTtcbn07XG5cbi8qXG4gKiBDb25zdHJhaW5zIHRoZSBmaWx0ZXIgYXJlYSB0byB0aGUgdGV4dHVyZSBzaXplXG4gKiBAcGFyYW0gZmlsdGVyQXJlYSB7UmVjdGFuZ2xlfSBUaGUgZmlsdGVyIGFyZWEgd2Ugd2FudCB0byBjYXBcbiAqL1xuRmlsdGVyTWFuYWdlci5wcm90b3R5cGUuY2FwRmlsdGVyQXJlYSA9IGZ1bmN0aW9uIChmaWx0ZXJBcmVhKVxue1xuICAgIGlmIChmaWx0ZXJBcmVhLnggPCAwKVxuICAgIHtcbiAgICAgICAgZmlsdGVyQXJlYS53aWR0aCArPSBmaWx0ZXJBcmVhLng7XG4gICAgICAgIGZpbHRlckFyZWEueCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlckFyZWEueSA8IDApXG4gICAge1xuICAgICAgICBmaWx0ZXJBcmVhLmhlaWdodCArPSBmaWx0ZXJBcmVhLnk7XG4gICAgICAgIGZpbHRlckFyZWEueSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCBmaWx0ZXJBcmVhLnggKyBmaWx0ZXJBcmVhLndpZHRoID4gdGhpcy50ZXh0dXJlU2l6ZS53aWR0aCApXG4gICAge1xuICAgICAgICBmaWx0ZXJBcmVhLndpZHRoID0gdGhpcy50ZXh0dXJlU2l6ZS53aWR0aCAtIGZpbHRlckFyZWEueDtcbiAgICB9XG5cbiAgICBpZiAoIGZpbHRlckFyZWEueSArIGZpbHRlckFyZWEuaGVpZ2h0ID4gdGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQgKVxuICAgIHtcbiAgICAgICAgZmlsdGVyQXJlYS5oZWlnaHQgPSB0aGlzLnRleHR1cmVTaXplLmhlaWdodCAtIGZpbHRlckFyZWEueTtcbiAgICB9XG59O1xuXG4vKlxuICogUmVzaXplcyBhbGwgdGhlIHJlbmRlciB0YXJnZXRzIGluIHRoZSBwb29sXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIG5ldyB3aWR0aFxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSB0aGUgbmV3IGhlaWdodFxuICovXG5GaWx0ZXJNYW5hZ2VyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKVxue1xuICAgIHRoaXMudGV4dHVyZVNpemUud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLnRleHR1cmVTaXplLmhlaWdodCA9IGhlaWdodDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZXh0dXJlUG9vbC5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMudGV4dHVyZVBvb2xbaV0ucmVzaXplKCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgZmlsdGVyIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIGZpbHRlciBzdGFjay5cbiAqXG4gKi9cbkZpbHRlck1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBudWxsO1xuICAgIHRoaXMub2Zmc2V0WSA9IDA7XG5cbiAgICAvLyBkZXN0cm95IHRleHR1cmVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRleHR1cmVQb29sLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlUG9vbFtpXS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0dXJlUG9vbCA9IG51bGw7XG59O1xuIiwidmFyIFdlYkdMTWFuYWdlciA9IHJlcXVpcmUoJy4vV2ViR0xNYW5hZ2VyJyksXG4gICAgQWxwaGFNYXNrRmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVycy9TcHJpdGVNYXNrRmlsdGVyJyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHJlbmRlcmVyIHtXZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gTWFza01hbmFnZXIocmVuZGVyZXIpXG57XG4gICAgV2ViR0xNYW5hZ2VyLmNhbGwodGhpcywgcmVuZGVyZXIpO1xuXG4gICAgdGhpcy5zdGVuY2lsU3RhY2sgPSBbXTtcbiAgICB0aGlzLnJldmVyc2UgPSB0cnVlO1xuICAgIHRoaXMuY291bnQgPSAwO1xuXG4gICAgdGhpcy5hbHBoYU1hc2tQb29sID0gW107XG59XG5cbk1hc2tNYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV2ViR0xNYW5hZ2VyLnByb3RvdHlwZSk7XG5NYXNrTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXNrTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gTWFza01hbmFnZXI7XG5cbi8qKlxuICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suXG4gKlxuICogQHBhcmFtIGdyYXBoaWNzIHtHcmFwaGljc31cbiAqIEBwYXJhbSB3ZWJHTERhdGEge2FueVtdfVxuICovXG5NYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaE1hc2sgPSBmdW5jdGlvbiAodGFyZ2V0LCBtYXNrRGF0YSlcbntcbiAgICBpZiAobWFza0RhdGEudGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHRoaXMucHVzaFNwcml0ZU1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMucHVzaFN0ZW5jaWxNYXNrKHRhcmdldCwgbWFza0RhdGEpO1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBsYXN0IG1hc2sgZnJvbSB0aGUgbWFzayBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4gKlxuICogQHBhcmFtIHRhcmdldCB7UmVuZGVyVGFyZ2V0fVxuICogQHBhcmFtIG1hc2tEYXRhIHthbnlbXX1cbiAqL1xuTWFza01hbmFnZXIucHJvdG90eXBlLnBvcE1hc2sgPSBmdW5jdGlvbiAodGFyZ2V0LCBtYXNrRGF0YSlcbntcbiAgICBpZiAobWFza0RhdGEudGV4dHVyZSlcbiAgICB7XG4gICAgICAgIHRoaXMucG9wU3ByaXRlTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5wb3BTdGVuY2lsTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQge1JlbmRlclRhcmdldH1cbiAqIEBwYXJhbSBtYXNrRGF0YSB7YW55W119XG4gKi9cbk1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wdXNoU3ByaXRlTWFzayA9IGZ1bmN0aW9uICh0YXJnZXQsIG1hc2tEYXRhKVxue1xuICAgIHZhciBhbHBoYU1hc2tGaWx0ZXIgPSB0aGlzLmFscGhhTWFza1Bvb2wucG9wKCk7XG5cbiAgICBpZiAoIWFscGhhTWFza0ZpbHRlcilcbiAgICB7XG4gICAgICAgIGFscGhhTWFza0ZpbHRlciA9IFtuZXcgQWxwaGFNYXNrRmlsdGVyKG1hc2tEYXRhKV07XG4gICAgfVxuXG4gICAgYWxwaGFNYXNrRmlsdGVyWzBdLm1hc2tTcHJpdGUgPSBtYXNrRGF0YTtcbiAgICB0aGlzLnJlbmRlcmVyLmZpbHRlck1hbmFnZXIucHVzaEZpbHRlcih0YXJnZXQsIGFscGhhTWFza0ZpbHRlcik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGxhc3QgZmlsdGVyIGZyb20gdGhlIGZpbHRlciBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4gKlxuICovXG5NYXNrTWFuYWdlci5wcm90b3R5cGUucG9wU3ByaXRlTWFzayA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGZpbHRlcnMgPSB0aGlzLnJlbmRlcmVyLmZpbHRlck1hbmFnZXIucG9wRmlsdGVyKCk7XG5cbiAgICB0aGlzLmFscGhhTWFza1Bvb2wucHVzaChmaWx0ZXJzKTtcbn07XG5cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IHtSZW5kZXJUYXJnZXR9XG4gKiBAcGFyYW0gbWFza0RhdGEge2FueVtdfVxuICovXG5NYXNrTWFuYWdlci5wcm90b3R5cGUucHVzaFN0ZW5jaWxNYXNrID0gZnVuY3Rpb24gKHRhcmdldCwgbWFza0RhdGEpXG57XG4gICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsTWFuYWdlci5wdXNoTWFzayhtYXNrRGF0YSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGxhc3QgZmlsdGVyIGZyb20gdGhlIGZpbHRlciBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4gKiBAcGFyYW0gdGFyZ2V0IHtSZW5kZXJUYXJnZXR9XG4gKiBAcGFyYW0gbWFza0RhdGEge2FueVtdfVxuICovXG5NYXNrTWFuYWdlci5wcm90b3R5cGUucG9wU3RlbmNpbE1hc2sgPSBmdW5jdGlvbiAodGFyZ2V0LCBtYXNrRGF0YSlcbntcbiAgICB0aGlzLnJlbmRlcmVyLnN0ZW5jaWxNYW5hZ2VyLnBvcE1hc2sobWFza0RhdGEpO1xufTtcblxuIiwidmFyIFdlYkdMTWFuYWdlciA9IHJlcXVpcmUoJy4vV2ViR0xNYW5hZ2VyJyksXG4gICAgVGV4dHVyZVNoYWRlciA9IHJlcXVpcmUoJy4uL3NoYWRlcnMvVGV4dHVyZVNoYWRlcicpLFxuICAgIENvbXBsZXhQcmltaXRpdmVTaGFkZXIgPSByZXF1aXJlKCcuLi9zaGFkZXJzL0NvbXBsZXhQcmltaXRpdmVTaGFkZXInKSxcbiAgICBQcmltaXRpdmVTaGFkZXIgPSByZXF1aXJlKCcuLi9zaGFkZXJzL1ByaW1pdGl2ZVNoYWRlcicpLFxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXh0ZW5kcyBXZWJHTE1hbmFnZXJcbiAqIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHRoaXMgbWFuYWdlciB3b3JrcyBmb3IuXG4gKi9cbmZ1bmN0aW9uIFNoYWRlck1hbmFnZXIocmVuZGVyZXIpXG57XG4gICAgV2ViR0xNYW5hZ2VyLmNhbGwodGhpcywgcmVuZGVyZXIpO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4QXR0aWJzID0gMTA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHthbnlbXX1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYlN0YXRlID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHthbnlbXX1cbiAgICAgKi9cbiAgICB0aGlzLnRlbXBBdHRyaWJTdGF0ZSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1heEF0dGliczsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5hdHRyaWJTdGF0ZVtpXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2FueVtdfVxuICAgICAqL1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2N1cnJlbnRJZCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7U2hhZGVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50U2hhZGVyID0gbnVsbDtcblxuLy8gICAgdGhpcy5pbml0UGx1Z2lucygpO1xufVxuXG5TaGFkZXJNYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV2ViR0xNYW5hZ2VyLnByb3RvdHlwZSk7XG5TaGFkZXJNYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYWRlck1hbmFnZXI7XG51dGlscy5wbHVnaW5UYXJnZXQubWl4aW4oU2hhZGVyTWFuYWdlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhZGVyTWFuYWdlcjtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGVyZSBpcyBhIFdlYkdMIGNvbnRleHQgY2hhbmdlLlxuICpcbiAqL1xuU2hhZGVyTWFuYWdlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmluaXRQbHVnaW5zKCk7XG5cbiAgICAvLyBUT0RPIC0gV2h5IGFyZSB0aGVzZSBub3QgcGx1Z2lucz8gV2UgY2FuJ3QgZGVjb3VwbGUgcHJpbWl0aXZlcyB1bmxlc3MgdGhleSBhcmUuLi4uXG4gICAgdGhpcy5kZWZhdWx0U2hhZGVyID0gbmV3IFRleHR1cmVTaGFkZXIodGhpcyk7XG4gICAgdGhpcy5wcmltaXRpdmVTaGFkZXIgPSBuZXcgUHJpbWl0aXZlU2hhZGVyKHRoaXMpO1xuICAgIHRoaXMuY29tcGxleFByaW1pdGl2ZVNoYWRlciA9IG5ldyBDb21wbGV4UHJpbWl0aXZlU2hhZGVyKHRoaXMpO1xufTtcblxuLyoqXG4gKiBUYWtlcyB0aGUgYXR0cmlidXRlcyBnaXZlbiBpbiBwYXJhbWV0ZXJzIGFuZCB1cGxvYWRzIHRoZW0uXG4gKlxuICogQHBhcmFtIGF0dHJpYnMge0FycmF5fSBhdHRyaWJzXG4gKi9cblNoYWRlck1hbmFnZXIucHJvdG90eXBlLnNldEF0dHJpYnMgPSBmdW5jdGlvbiAoYXR0cmlicylcbntcbiAgICAvLyByZXNldCB0ZW1wIHN0YXRlXG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50ZW1wQXR0cmliU3RhdGUubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLnRlbXBBdHRyaWJTdGF0ZVtpXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgbmV3IGF0dHJpYnNcbiAgICBmb3IgKHZhciBhIGluIGF0dHJpYnMpXG4gICAge1xuICAgICAgICB0aGlzLnRlbXBBdHRyaWJTdGF0ZVthdHRyaWJzW2FdXSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmF0dHJpYlN0YXRlLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmliU3RhdGVbaV0gIT09IHRoaXMudGVtcEF0dHJpYlN0YXRlW2ldKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYlN0YXRlW2ldID0gdGhpcy50ZW1wQXR0cmliU3RhdGVbaV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJpYlN0YXRlW2ldKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCBzaGFkZXIuXG4gKlxuICogQHBhcmFtIHNoYWRlciB7U2hhZGVyfSB0aGUgc2hhZGVyIHRvIHVwbG9hZFxuICovXG5TaGFkZXJNYW5hZ2VyLnByb3RvdHlwZS5zZXRTaGFkZXIgPSBmdW5jdGlvbiAoc2hhZGVyKVxue1xuICAgIGlmICh0aGlzLl9jdXJyZW50SWQgPT09IHNoYWRlci51dWlkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRJZCA9IHNoYWRlci51dWlkO1xuXG4gICAgdGhpcy5jdXJyZW50U2hhZGVyID0gc2hhZGVyO1xuXG4gICAgdGhpcy5yZW5kZXJlci5nbC51c2VQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcbiAgICB0aGlzLnNldEF0dHJpYnMoc2hhZGVyLmF0dHJpYnV0ZXMpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgb2JqZWN0LlxuICpcbiAqL1xuU2hhZGVyTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgV2ViR0xNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmRlc3Ryb3lQbHVnaW5zKCk7XG5cbiAgICB0aGlzLmF0dHJpYlN0YXRlID0gbnVsbDtcblxuICAgIHRoaXMudGVtcEF0dHJpYlN0YXRlID0gbnVsbDtcbn07XG4iLCJ2YXIgV2ViR0xNYW5hZ2VyID0gcmVxdWlyZSgnLi9XZWJHTE1hbmFnZXInKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHJlbmRlcmVyIHtXZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gV2ViR0xNYXNrTWFuYWdlcihyZW5kZXJlcilcbntcbiAgICBXZWJHTE1hbmFnZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XG4gICAgdGhpcy5zdGVuY2lsTWFza1N0YWNrID0gbnVsbDtcbn1cblxuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdlYkdMTWFuYWdlci5wcm90b3R5cGUpO1xuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXZWJHTE1hc2tNYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBXZWJHTE1hc2tNYW5hZ2VyO1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIG1hc2sgc3RhY2sgdGhhdCBpcyB1c2VkIGJ5IHRoaXMgbWFuYWdlclxuICogQHBhcmFtIHN0ZW5jaWxNYXNrU3RhY2sge1N0ZW5jaWxNYXNrU3RhY2t9IFRoZSBtYXNrIHN0YWNrIFxuICpcbiAqL1xuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUuc2V0TWFza1N0YWNrID0gZnVuY3Rpb24gKCBzdGVuY2lsTWFza1N0YWNrIClcbntcbiAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBzdGVuY2lsTWFza1N0YWNrO1xuXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgIGlmIChzdGVuY2lsTWFza1N0YWNrLnN0ZW5jaWxTdGFjay5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suIEBhbHZpblxuICogXG4gKiBAcGFyYW0gZ3JhcGhpY3Mge0dyYXBoaWNzfVxuICogQHBhcmFtIHdlYkdMRGF0YSB7YW55W119XG4gKi9cbldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLnB1c2hTdGVuY2lsID0gZnVuY3Rpb24gKGdyYXBoaWNzLCB3ZWJHTERhdGEpXG57XG4gICAgdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LmF0dGFjaFN0ZW5jaWxCdWZmZXIoKTtcblxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2wsXG4gICAgICAgIHNtcyA9IHRoaXMuc3RlbmNpbE1hc2tTdGFjaztcblxuICAgIHRoaXMuYmluZEdyYXBoaWNzKGdyYXBoaWNzLCB3ZWJHTERhdGEsIHRoaXMucmVuZGVyZXIpO1xuXG4gICAgaWYgKHNtcy5zdGVuY2lsU3RhY2subGVuZ3RoID09PSAwKVxuICAgIHtcbiAgICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG4gICAgICAgIHNtcy5yZXZlcnNlID0gdHJ1ZTtcbiAgICAgICAgc21zLmNvdW50ID0gMDtcbiAgICB9XG5cbiAgICBzbXMuc3RlbmNpbFN0YWNrLnB1c2god2ViR0xEYXRhKTtcblxuICAgIHZhciBsZXZlbCA9IHNtcy5jb3VudDtcblxuICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5BTFdBWVMsMCwweEZGKTtcbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOVkVSVCk7XG5cbiAgICAvLyBkcmF3IHRoZSB0cmlhbmdsZSBzdHJpcCFcblxuICAgIGlmICh3ZWJHTERhdGEubW9kZSA9PT0gMSlcbiAgICB7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9GQU4sICB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGggLSA0LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG4gICAgICAgIGlmIChzbXMucmV2ZXJzZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4RkYgLSBsZXZlbCwgMHhGRik7XG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLkRFQ1IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwsIDB4RkYpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5JTkNSKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRyYXcgYSBxdWFkIHRvIGluY3JlbWVudC4uXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9GQU4sIDQsIGdsLlVOU0lHTkVEX1NIT1JULCAoIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCAtIDQgKSAqIDIgKTtcblxuICAgICAgICBpZiAoc21zLnJldmVyc2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLDB4RkYtKGxldmVsKzEpLCAweEZGKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsKzEsIDB4RkYpO1xuICAgICAgICB9XG5cbiAgICAgICAgc21zLnJldmVyc2UgPSAhc21zLnJldmVyc2U7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGlmICghc21zLnJldmVyc2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweEZGIC0gbGV2ZWwsIDB4RkYpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5ERUNSKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsLCAweEZGKTtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuSU5DUik7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVfU1RSSVAsICB3ZWJHTERhdGEuaW5kaWNlcy5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cbiAgICAgICAgaWYgKCFzbXMucmV2ZXJzZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsMHhGRi0obGV2ZWwrMSksIDB4RkYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwrMSwgMHhGRik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5LRUVQKTtcblxuICAgIHNtcy5jb3VudCsrO1xufTtcblxuLyoqXG4gKiBUT0RPIHRoaXMgZG9lcyBub3QgYmVsb25nIGhlcmUhXG4gKlxuICogQHBhcmFtIGdyYXBoaWNzIHtHcmFwaGljc31cbiAqIEBwYXJhbSB3ZWJHTERhdGEge0FycmF5fVxuICovXG5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5iaW5kR3JhcGhpY3MgPSBmdW5jdGlvbiAoZ3JhcGhpY3MsIHdlYkdMRGF0YSlcbntcbiAgICAvL2lmICh0aGlzLl9jdXJyZW50R3JhcGhpY3MgPT09IGdyYXBoaWNzKXJldHVybjtcbiAgICB0aGlzLl9jdXJyZW50R3JhcGhpY3MgPSBncmFwaGljcztcblxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAgLy8gYmluZCB0aGUgZ3JhcGhpY3Mgb2JqZWN0Li5cbiAgICB2YXIgc2hhZGVyOy8vID0gdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnBsdWdpbnMucHJpbWl0aXZlU2hhZGVyO1xuXG4gICAgaWYgKHdlYkdMRGF0YS5tb2RlID09PSAxKVxuICAgIHtcbiAgICAgICAgc2hhZGVyID0gdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLmNvbXBsZXhQcmltaXRpdmVTaGFkZXI7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnNldFNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4Ll9sb2NhdGlvbiwgZmFsc2UsIGdyYXBoaWNzLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgudG9BcnJheSh0cnVlKSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTNmdihzaGFkZXIudW5pZm9ybXMudGludC5fbG9jYXRpb24sIHV0aWxzLmhleDJyZ2IoZ3JhcGhpY3MudGludCkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyLnVuaWZvcm1zLmNvbG9yLl9sb2NhdGlvbiwgd2ViR0xEYXRhLmNvbG9yKTtcblxuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVuaWZvcm1zLmFscGhhLl9sb2NhdGlvbiwgZ3JhcGhpY3Mud29ybGRBbHBoYSk7XG5cbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHdlYkdMRGF0YS5idWZmZXIpO1xuXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiAyLCAwKTtcblxuXG4gICAgICAgIC8vIG5vdyBkbyB0aGUgcmVzdC4uXG4gICAgICAgIC8vIHNldCB0aGUgaW5kZXggYnVmZmVyIVxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB3ZWJHTERhdGEuaW5kZXhCdWZmZXIpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICAvL3RoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5hY3RpdmF0ZVByaW1pdGl2ZVNoYWRlcigpO1xuICAgICAgICBzaGFkZXIgPSB0aGlzLnJlbmRlcmVyLnNoYWRlck1hbmFnZXIucHJpbWl0aXZlU2hhZGVyO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoIHNoYWRlciApO1xuXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4Ll9sb2NhdGlvbiwgZmFsc2UsIGdyYXBoaWNzLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgudG9BcnJheSh0cnVlKSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTNmdihzaGFkZXIudW5pZm9ybXMudGludC5fbG9jYXRpb24sIHV0aWxzLmhleDJyZ2IoZ3JhcGhpY3MudGludCkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybXMuYWxwaGEuX2xvY2F0aW9uLCBncmFwaGljcy53b3JsZEFscGhhKTtcblxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgd2ViR0xEYXRhLmJ1ZmZlcik7XG5cbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIDYsIDApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hdHRyaWJ1dGVzLmFDb2xvciwgNCwgZ2wuRkxPQVQsIGZhbHNlLDQgKiA2LCAyICogNCk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBpbmRleCBidWZmZXIhXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHdlYkdMRGF0YS5pbmRleEJ1ZmZlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUT0RPIEBhbHZpblxuICogQHBhcmFtIGdyYXBoaWNzIHtHcmFwaGljc31cbiAqIEBwYXJhbSB3ZWJHTERhdGEge0FycmF5fVxuICovXG5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wb3BTdGVuY2lsID0gZnVuY3Rpb24gKGdyYXBoaWNzLCB3ZWJHTERhdGEpXG57XG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbCxcbiAgICAgICAgc21zID0gdGhpcy5zdGVuY2lsTWFza1N0YWNrO1xuXG4gICAgc21zLnN0ZW5jaWxTdGFjay5wb3AoKTtcblxuICAgIHNtcy5jb3VudC0tO1xuXG4gICAgaWYgKHNtcy5zdGVuY2lsU3RhY2subGVuZ3RoID09PSAwKVxuICAgIHtcbiAgICAgICAgLy8gdGhlIHN0YWNrIGlzIGVtcHR5IVxuICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcblxuICAgICAgICB2YXIgbGV2ZWwgPSBzbXMuY291bnQ7XG5cbiAgICAgICAgdGhpcy5iaW5kR3JhcGhpY3MoZ3JhcGhpY3MsIHdlYkdMRGF0YSwgdGhpcy5yZW5kZXJlcik7XG5cbiAgICAgICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICBpZiAod2ViR0xEYXRhLm1vZGUgPT09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNtcy5yZXZlcnNlID0gIXNtcy5yZXZlcnNlO1xuXG4gICAgICAgICAgICBpZiAoc21zLnJldmVyc2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4RkYgLSAobGV2ZWwrMSksIDB4RkYpO1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuSU5DUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsbGV2ZWwrMSwgMHhGRik7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5ERUNSKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZHJhdyBhIHF1YWQgdG8gaW5jcmVtZW50Li5cbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9GQU4sIDQsIGdsLlVOU0lHTkVEX1NIT1JULCAoIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCAtIDQgKSAqIDIgKTtcblxuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuQUxXQVlTLDAsMHhGRik7XG4gICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOVkVSVCk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgdGhlIHRyaWFuZ2xlIHN0cmlwIVxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFX0ZBTiwgIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCAtIDQsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cbiAgICAgICAgICAgIGlmICghc21zLnJldmVyc2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsMHhGRi0obGV2ZWwpLCAweEZGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCxsZXZlbCwgMHhGRik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAvLyAgY29uc29sZS5sb2coXCI8PD4+XCIpXG4gICAgICAgICAgICBpZiAoIXNtcy5yZXZlcnNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweEZGIC0gKGxldmVsKzEpLCAweEZGKTtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCxnbC5LRUVQLGdsLklOQ1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsKzEsIDB4RkYpO1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLGdsLktFRVAsZ2wuREVDUik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRV9TVFJJUCwgIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgICAgICAgICAgaWYgKCFzbXMucmV2ZXJzZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwweEZGLShsZXZlbCksIDB4RkYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLGxldmVsLCAweEZGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsZ2wuS0VFUCxnbC5LRUVQKTtcblxuXG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgbWFzayBzdGFjay5cbiAqXG4gKi9cbldlYkdMTWFza01hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIFdlYkdMTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5zdGVuY2lsTWFza1N0YWNrLnN0ZW5jaWxTdGFjayA9IG51bGw7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxuICpcbiAqIEBwYXJhbSBtYXNrRGF0YSB7YW55W119IFRoZSBtYXNrIGRhdGEgc3RydWN0dXJlIHRvIHVzZVxuICovXG5XZWJHTE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wdXNoTWFzayA9IGZ1bmN0aW9uIChtYXNrRGF0YSlcbntcblxuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlcih0aGlzLnJlbmRlcmVyLnBsdWdpbnMuZ3JhcGhpY3MpO1xuXG4gICAgaWYgKG1hc2tEYXRhLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5wbHVnaW5zLmdyYXBoaWNzLnVwZGF0ZUdyYXBoaWNzKG1hc2tEYXRhLCB0aGlzLnJlbmRlcmVyLmdsKTtcbiAgICB9XG5cbiAgICBpZiAoIW1hc2tEYXRhLl93ZWJHTFt0aGlzLnJlbmRlcmVyLmdsLmlkXS5kYXRhLmxlbmd0aClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnB1c2hTdGVuY2lsKG1hc2tEYXRhLCBtYXNrRGF0YS5fd2ViR0xbdGhpcy5yZW5kZXJlci5nbC5pZF0uZGF0YVswXSwgdGhpcy5yZW5kZXJlcik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGxhc3QgZmlsdGVyIGZyb20gdGhlIGZpbHRlciBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4gKlxuICogQHBhcmFtIG1hc2tEYXRhIHthbnlbXX1cbiAqL1xuV2ViR0xNYXNrTWFuYWdlci5wcm90b3R5cGUucG9wTWFzayA9IGZ1bmN0aW9uIChtYXNrRGF0YSlcbntcbiAgICB0aGlzLnJlbmRlcmVyLnNldE9iamVjdFJlbmRlcmVyKHRoaXMucmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcyk7XG5cbiAgICB0aGlzLnBvcFN0ZW5jaWwobWFza0RhdGEsIG1hc2tEYXRhLl93ZWJHTFt0aGlzLnJlbmRlcmVyLmdsLmlkXS5kYXRhWzBdLCB0aGlzLnJlbmRlcmVyKTtcbn07XG5cbiIsIi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHJlbmRlcmVyIHtXZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgdGhpcyBtYW5hZ2VyIHdvcmtzIGZvci5cbiAqL1xuZnVuY3Rpb24gV2ViR0xNYW5hZ2VyKHJlbmRlcmVyKVxue1xuICAgIC8qKlxuICAgICAqIFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cbiAgICB0aGlzLnJlbmRlcmVyLm9uKCdjb250ZXh0JywgdGhpcy5vbkNvbnRleHRDaGFuZ2UsIHRoaXMpO1xufVxuXG5XZWJHTE1hbmFnZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2ViR0xNYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMgPSBXZWJHTE1hbmFnZXI7XG5cbi8qKlxuICogR2VuZXJpYyBtZXRob2QgY2FsbGVkIHdoZW4gdGhlcmUgaXMgYSBXZWJHTCBjb250ZXh0IGNoYW5nZS5cbiAqXG4gKi9cbldlYkdMTWFuYWdlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24gKClcbntcblx0Ly8gZG8gc29tZSBjb2RlcyBpbml0IVxufTtcblxuLyoqXG4gKiBHZW5lcmljIGRlc3Ryb3kgbWV0aG9kcyB0byBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdWJjbGFzc1xuICpcbiAqL1xuV2ViR0xNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLnJlbmRlcmVyLm9mZignY29udGV4dCcsIHRoaXMub25Db250ZXh0Q2hhbmdlKTtcblxuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xufTtcbiIsInZhciBTaGFkZXIgPSByZXF1aXJlKCcuL1NoYWRlcicpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBleHRlbmRzIFNoYWRlclxuICogQHBhcmFtIHNoYWRlck1hbmFnZXIge1NoYWRlck1hbmFnZXJ9IFRoZSB3ZWJnbCBzaGFkZXIgbWFuYWdlciB0aGlzIHNoYWRlciB3b3JrcyBmb3IuXG4gKi9cbmZ1bmN0aW9uIENvbXBsZXhQcmltaXRpdmVTaGFkZXIoc2hhZGVyTWFuYWdlcilcbntcbiAgICBTaGFkZXIuY2FsbCh0aGlzLFxuICAgICAgICBzaGFkZXJNYW5hZ2VyLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFtcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcblxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OycsXG5cbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgdGludDsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGE7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzMgY29sb3I7JyxcblxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxuICAgICAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7JyxcbiAgICAgICAgICAgICcgICB2Q29sb3IgPSB2ZWM0KGNvbG9yICogYWxwaGEgKiB0aW50LCBhbHBoYSk7JywvL1wiICogdmVjNCh0aW50ICogYWxwaGEsIGFscGhhKTsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBbXG4gICAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcblxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxuICAgICAgICAgICAgJyAgIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICB0aW50OiAgIHsgdHlwZTogJzNmJywgdmFsdWU6IFswLCAwLCAwXSB9LFxuICAgICAgICAgICAgYWxwaGE6ICB7IHR5cGU6ICcxZicsIHZhbHVlOiAwIH0sXG4gICAgICAgICAgICBjb2xvcjogIHsgdHlwZTogJzNmJywgdmFsdWU6IFswLDAsMF0gfSxcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiB7IHR5cGU6ICdtYXQzJywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoOSkgfSxcbiAgICAgICAgICAgIHByb2plY3Rpb25NYXRyaXg6IHsgdHlwZTogJ21hdDMnLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg5KSB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGF0dHJpYnV0ZXNcbiAgICAgICAge1xuICAgICAgICAgICAgYVZlcnRleFBvc2l0aW9uOjBcbiAgICAgICAgfVxuICAgICk7XG59XG5cbkNvbXBsZXhQcmltaXRpdmVTaGFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaGFkZXIucHJvdG90eXBlKTtcbkNvbXBsZXhQcmltaXRpdmVTaGFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tcGxleFByaW1pdGl2ZVNoYWRlcjtcbm1vZHVsZS5leHBvcnRzID0gQ29tcGxleFByaW1pdGl2ZVNoYWRlcjtcbiIsInZhciBTaGFkZXIgPSByZXF1aXJlKCcuL1NoYWRlcicpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBleHRlbmRzIFNoYWRlclxuICogQHBhcmFtIHNoYWRlck1hbmFnZXIge1NoYWRlck1hbmFnZXJ9IFRoZSB3ZWJnbCBzaGFkZXIgbWFuYWdlciB0aGlzIHNoYWRlciB3b3JrcyBmb3IuXG4gKi9cbmZ1bmN0aW9uIFByaW1pdGl2ZVNoYWRlcihzaGFkZXJNYW5hZ2VyKVxue1xuICAgIFNoYWRlci5jYWxsKHRoaXMsXG4gICAgICAgIHNoYWRlck1hbmFnZXIsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgW1xuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWM0IGFDb2xvcjsnLFxuXG4gICAgICAgICAgICAndW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4OycsXG4gICAgICAgICAgICAndW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7JyxcblxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGE7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGZsaXBZOycsXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMzIHRpbnQ7JyxcblxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxuICAgICAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7JyxcbiAgICAgICAgICAgICcgICB2Q29sb3IgPSBhQ29sb3IgKiB2ZWM0KHRpbnQgKiBhbHBoYSwgYWxwaGEpOycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFtcbiAgICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuXG4gICAgICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuXG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpeycsXG4gICAgICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yOycsXG4gICAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpbnQ6ICAgeyB0eXBlOiAnM2YnLCB2YWx1ZTogWzAsIDAsIDBdIH0sXG4gICAgICAgICAgICBhbHBoYTogIHsgdHlwZTogJzFmJywgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiB7IHR5cGU6ICdtYXQzJywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoOSkgfSxcbiAgICAgICAgICAgIHByb2plY3Rpb25NYXRyaXg6IHsgdHlwZTogJ21hdDMnLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg5KSB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGN1c3RvbSBhdHRyaWJ1dGVzXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFWZXJ0ZXhQb3NpdGlvbjowLFxuICAgICAgICAgICAgYUNvbG9yOjBcbiAgICAgICAgfVxuICAgICk7XG59XG5cblByaW1pdGl2ZVNoYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNoYWRlci5wcm90b3R5cGUpO1xuUHJpbWl0aXZlU2hhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByaW1pdGl2ZVNoYWRlcjtcbm1vZHVsZS5leHBvcnRzID0gUHJpbWl0aXZlU2hhZGVyO1xuIiwiLypnbG9iYWwgY29uc29sZSAqL1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gc2hhZGVyTWFuYWdlciB7U2hhZGVyTWFuYWdlcn0gVGhlIHdlYmdsIHNoYWRlciBtYW5hZ2VyIHRoaXMgc2hhZGVyIHdvcmtzIGZvci5cbiAqIEBwYXJhbSBbdmVydGV4U3JjXSB7c3RyaW5nfSBUaGUgc291cmNlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICogQHBhcmFtIFtmcmFnbWVudFNyY10ge3N0cmluZ30gVGhlIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICogQHBhcmFtIFt1bmlmb3Jtc10ge29iamVjdH0gVW5pZm9ybXMgZm9yIHRoaXMgc2hhZGVyLlxuICogQHBhcmFtIFthdHRyaWJ1dGVzXSB7b2JqZWN0fSBBdHRyaWJ1dGVzIGZvciB0aGlzIHNoYWRlci5cbiAqL1xuZnVuY3Rpb24gU2hhZGVyKHNoYWRlck1hbmFnZXIsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIHVuaWZvcm1zLCBhdHRyaWJ1dGVzKVxue1xuICAgIGlmICghdmVydGV4U3JjIHx8ICFmcmFnbWVudFNyYylcbiAgICB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpeGkuanMgRXJyb3IuIFNoYWRlciByZXF1aXJlcyB2ZXJ0ZXhTcmMgYW5kIGZyYWdtZW50U3JjJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgaWRcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy51dWlkID0gdXRpbHMudXVpZCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBzaGFkZXJNYW5hZ2VyLnJlbmRlcmVyLmdsO1xuXG4gICAgLy9UT0RPIG1heWJlIHdlIHNob3VsZCBwYXNzIHJlbmRlcmVyIHJhdGhlciB0aGFuIHNoYWRlciBtYW5nZXI/PyBmb29kIGZvciB0aG91Z2h0Li5cbiAgICB0aGlzLnNoYWRlck1hbmFnZXIgPSBzaGFkZXJNYW5hZ2VyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFdlYkdMIHByb2dyYW0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFByb2dyYW19XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1bmlmb3JtcyBhcyBhbiBvYmplY3RcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnVuaWZvcm1zID0gdW5pZm9ybXMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXR0cmlidXRlcyBhcyBhbiBvYmplY3RcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgdGV4dHVyZSBjb3VudGVyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50ZXh0dXJlQ291bnQgPSAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRleCBzaGFkZXIgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4U3JjID0gdmVydGV4U3JjO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWdtZW50IHNoYWRlciBhcyBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjO1xuXG4gICAgdGhpcy5pbml0KCk7XG59XG5cblNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFNoYWRlcjtcblxuLypcbiAqIENyZWF0ZXMgdGhlIHNoYWRlciBhbmQgdXNlcyBpdFxuICpcbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmNvbXBpbGUoKTtcblxuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuXG4gICAgdGhpcy5jYWNoZVVuaWZvcm1Mb2NhdGlvbnMoT2JqZWN0LmtleXModGhpcy51bmlmb3JtcykpO1xuICAgIHRoaXMuY2FjaGVBdHRyaWJ1dGVMb2NhdGlvbnMoT2JqZWN0LmtleXModGhpcy5hdHRyaWJ1dGVzKSk7XG59O1xuXG4vKlxuICogQ2FjaGVzIHRoZSBsb2NhdGlvbnMgb2YgdGhlIHVuaWZvcm0gZm9yIHJldXNlXG4gKiBAcGFyYW0ga2V5cyB7c3RyaW5nfSB0aGUgdW5pZm9ybXMgdG8gY2FjaGVcbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5jYWNoZVVuaWZvcm1Mb2NhdGlvbnMgPSBmdW5jdGlvbiAoa2V5cylcbntcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAge1xuICAgICAgICB0aGlzLnVuaWZvcm1zW2tleXNbaV1dLl9sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwga2V5c1tpXSk7XG4gICAgfVxufTtcblxuLypcbiAqIENhY2hlcyB0aGUgbG9jYXRpb25zIG9mIHRoZSBhdHRyaWJ1dGUgZm9yIHJldXNlXG4gKiBAcGFyYW0ga2V5cyB7c3RyaW5nfSB0aGUgYXR0cmlidXRlcyB0byBjYWNoZVxuICovXG5TaGFkZXIucHJvdG90eXBlLmNhY2hlQXR0cmlidXRlTG9jYXRpb25zID0gZnVuY3Rpb24gKGtleXMpXG57XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2tleXNbaV1dID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIGtleXNbaV0pO1xuICAgIH1cblxuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgaXMgbmVlZGVkIGFueW1vcmUuLi5cblxuICAgIC8vIEJlZ2luIHdvcnN0IGhhY2sgZXZhIC8vXG5cbiAgICAvLyBXSFk/Pz8gT05MWSBvbiBteSBjaHJvbWUgcGl4ZWwgdGhlIGxpbmUgYWJvdmUgcmV0dXJucyAtMSB3aGVuIHVzaW5nIGZpbHRlcnM/XG4gICAgLy8gbWF5YmUgaXRzIHNvbWV0aGluZyB0byBkbyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBnbCBjb250ZXh0LlxuICAgIC8vIEknbSBjb252aW5jZWQgdGhpcyBpcyBhIGJ1ZyBpbiB0aGUgY2hyb21lIGJyb3dzZXIgYXMgdGhlcmUgaXMgTk8gcmVhc29uIHdoeSB0aGlzIHNob3VsZCBiZSByZXR1cm5pbmcgLTEgZXNwZWNpYWxseSBhcyBpdCBvbmx5IG1hbmlmZXN0cyBvbiBteSBjaHJvbWUgcGl4ZWxcbiAgICAvLyBJZiB0aGVyZXMgYW55IHdlYkdMIHBlb3BsZSB0aGF0IGtub3cgd2h5IGNvdWxkIGhhcHBlbiBwbGVhc2UgaGVscCA6KVxuICAgIC8vIGlmICh0aGlzLmF0dHJpYnV0ZXMuYUNvbG9yID09PSAtMSl7XG4gICAgLy8gICAgIHRoaXMuYXR0cmlidXRlcy5hQ29sb3IgPSAyO1xuICAgIC8vIH1cblxuICAgIC8vIEVuZCB3b3JzdCBoYWNrIGV2YSAvL1xufTtcblxuLypcbiAqIEF0dGFjaGVzIHRoZSBzaGFkZXJzIGFuZCBjcmVhdGVzIHRoZSBwcm9ncmFtXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19XG4gKi9cblNoYWRlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHZhciBnbFZlcnRTaGFkZXIgPSB0aGlzLl9nbENvbXBpbGUoZ2wuVkVSVEVYX1NIQURFUiwgdGhpcy52ZXJ0ZXhTcmMpO1xuICAgIHZhciBnbEZyYWdTaGFkZXIgPSB0aGlzLl9nbENvbXBpbGUoZ2wuRlJBR01FTlRfU0hBREVSLCB0aGlzLmZyYWdtZW50U3JjKTtcblxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGdsVmVydFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGdsRnJhZ1NoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAvLyBpZiBsaW5raW5nIGZhaWxzLCB0aGVuIGxvZyBhbmQgY2xlYW51cFxuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpXG4gICAge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdQaXhpLmpzIEVycm9yOiBDb3VsZCBub3QgaW5pdGlhbGl6ZSBzaGFkZXIuJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTKSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dsLmdldEVycm9yKCknLCBnbC5nZXRFcnJvcigpKTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHByb2dyYW0gaW5mbyBsb2csIGxvZyBpdFxuICAgICAgICBpZiAoZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkgIT09ICcnKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BpeGkuanMgV2FybmluZzogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKScsIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGNsZWFuIHVwIHNvbWUgc2hhZGVyc1xuICAgIGdsLmRlbGV0ZVNoYWRlcihnbFZlcnRTaGFkZXIpO1xuICAgIGdsLmRlbGV0ZVNoYWRlcihnbEZyYWdTaGFkZXIpO1xuXG4gICAgcmV0dXJuICh0aGlzLnByb2dyYW0gPSBwcm9ncmFtKTtcbn07XG5cbi8qXG5TaGFkZXIucHJvdG90eXBlLmJ1aWxkU3luYyA9IGZ1bmN0aW9uICgpXG57XG4gICAvLyB2YXIgc3RyID0gXCJcIlxuXG4gICAvLyBzdHIgPSAgXCJTaGFkZXIucHJvdG90eXBlLnN5bmNVbmlmb3JtcyA9IGZ1bmN0aW9uKClcIjtcbiAgIC8vIHN0ciArPSBcIntcXG5cIjtcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnVuaWZvcm1zKVxuICAgIHtcbiAgICAgICAgdmFyIHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW2tleV07XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuaWZvcm0udmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFVuaWZvcm0odW5pZm9ybSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZyggbWFrZVByb3BTZXR0ZXIoIGtleSwgXCIgYmxvb3BcIiwgdW5pZm9ybS50eXBlICkgIClcbiAgLy8gICAgICBPYmplY3QuZGVmXG4gICAgICAgIC8vICAgIGxvY2F0aW9uID0gdW5pZm9ybS5fbG9jYXRpb24sXG4gICAgICAgICAgLy8gIHZhbHVlID0gdW5pZm9ybS52YWx1ZSxcbiAgICAgICAgICAgIC8vaSwgaWw7XG5cbiAgICAvLyAgICBzdHIgKz0gXCJnbC51bmlmb3JtMWkodGhpcy51bmlmb3Jtcy5cIisga2V5ICtcIi5fbG9jYXRpb24sIHRoaXMudW5pZm9ybXMuXCIgKyBrZXkgKyBcIi52YWx1ZSApO1xcblwiXG5cbiAgICB9XG5cbn0qL1xuXG4vKipcbiogQWRkcyBhIG5ldyB1bmlmb3JtXG4qXG4qIEBwYXJhbSB1bmlmb3JtIHtPYmplY3R9IHRoZSBuZXcgdW5pZm9ybSB0byBhdHRhY2hcbiovXG5TaGFkZXIucHJvdG90eXBlLnN5bmNVbmlmb3JtID0gZnVuY3Rpb24gKHVuaWZvcm0pXG57XG4gICAgdmFyIGxvY2F0aW9uID0gdW5pZm9ybS5fbG9jYXRpb24sXG4gICAgICAgIHZhbHVlID0gdW5pZm9ybS52YWx1ZSxcbiAgICAgICAgZ2wgPSB0aGlzLmdsLFxuICAgICAgICBpLCBpbDtcblxuICAgIHN3aXRjaCAodW5pZm9ybS50eXBlKVxuICAgIHtcbiAgICAgICAgLy8gc2luZ2xlIGludCB2YWx1ZVxuICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgY2FzZSAnMWknOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBzaW5nbGUgZmxvYXQgdmFsdWVcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgIGNhc2UgJzFmJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gRmxvYXQzMkFycmF5KDIpIG9yIEpTIEFycnJheVxuICAgICAgICBjYXNlICcyZic6XG4gICAgICAgICAgICBnbC51bmlmb3JtMmYobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBGbG9hdDMyQXJyYXkoMykgb3IgSlMgQXJycmF5XG4gICAgICAgIGNhc2UgJzNmJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZihsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBGbG9hdDMyQXJyYXkoNCkgb3IgSlMgQXJycmF5XG4gICAgICAgIGNhc2UgJzRmJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm00Zihsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSwgdmFsdWVbM10pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gYSAyRCBQb2ludCBvYmplY3RcbiAgICAgICAgY2FzZSAndjInOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIGEgM0QgUG9pbnQgb2JqZWN0XG4gICAgICAgIGNhc2UgJ3YzJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZihsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBhIDREIFBvaW50IG9iamVjdFxuICAgICAgICBjYXNlICd2NCc6XG4gICAgICAgICAgICBnbC51bmlmb3JtNGYobG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnosIHZhbHVlLncpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gSW50MzJBcnJheSBvciBKUyBBcnJheVxuICAgICAgICBjYXNlICcxaXYnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gSW50MzJBcnJheSBvciBKUyBBcnJheVxuICAgICAgICBjYXNlICcyaXYnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gSW50MzJBcnJheSBvciBKUyBBcnJheVxuICAgICAgICBjYXNlICczaXYnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gSW50MzJBcnJheSBvciBKUyBBcnJheVxuICAgICAgICBjYXNlICc0aXYnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTRpdihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gRmxvYXQzMkFycmF5IG9yIEpTIEFycmF5XG4gICAgICAgIGNhc2UgJzFmdic6XG4gICAgICAgICAgICBnbC51bmlmb3JtMWZ2KGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBGbG9hdDMyQXJyYXkgb3IgSlMgQXJyYXlcbiAgICAgICAgY2FzZSAnMmZ2JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZnYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSBvciBKUyBBcnJheVxuICAgICAgICBjYXNlICczZnYnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gRmxvYXQzMkFycmF5IG9yIEpTIEFycmF5XG4gICAgICAgIGNhc2UgJzRmdic6XG4gICAgICAgICAgICBnbC51bmlmb3JtNGZ2KGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBGbG9hdDMyQXJyYXkgb3IgSlMgQXJyYXlcbiAgICAgICAgY2FzZSAnbTInOlxuICAgICAgICBjYXNlICdtYXQyJzpcbiAgICAgICAgY2FzZSAnTWF0cml4MmZ2JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYobG9jYXRpb24sIHVuaWZvcm0udHJhbnNwb3NlLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBGbG9hdDMyQXJyYXkgb3IgSlMgQXJyYXlcbiAgICAgICAgY2FzZSAnbTMnOlxuICAgICAgICBjYXNlICdtYXQzJzpcbiAgICAgICAgY2FzZSAnTWF0cml4M2Z2JzpcblxuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgdW5pZm9ybS50cmFuc3Bvc2UsIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSBvciBKUyBBcnJheVxuICAgICAgICBjYXNlICdtNCc6XG4gICAgICAgIGNhc2UgJ21hdDQnOlxuICAgICAgICBjYXNlICdNYXRyaXg0ZnYnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgdW5pZm9ybS50cmFuc3Bvc2UsIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIGEgQ29sb3IgVmFsdWVcbiAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHV0aWxzLmhleDJyZ2IodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC51bmlmb3JtM2YobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyAoSlMgb3IgdHlwZWQgYXJyYXkpXG4gICAgICAgIGNhc2UgJ2l2MSc6XG4gICAgICAgICAgICBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBmbGF0IGFycmF5IG9mIGludGVnZXJzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXG4gICAgICAgIGNhc2UgJ2l2JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIChKUyBvciB0eXBlZCBhcnJheSlcbiAgICAgICAgY2FzZSAnZnYxJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXG4gICAgICAgIGNhc2UgJ2Z2JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIGFycmF5IG9mIDJEIFBvaW50IG9iamVjdHNcbiAgICAgICAgY2FzZSAndjJ2JzpcbiAgICAgICAgICAgIGlmICghdW5pZm9ybS5fYXJyYXkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyArK2kpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbaSAqIDJdICAgICAgID0gdmFsdWVbaV0ueDtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVtpICogMiArIDFdICAgPSB2YWx1ZVtpXS55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBhcnJheSBvZiAzRCBQb2ludCBvYmplY3RzXG4gICAgICAgIGNhc2UgJ3Yzdic6XG4gICAgICAgICAgICBpZiAoIXVuaWZvcm0uX2FycmF5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgzICogdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgKytpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5W2kgKiAzXSAgICAgICA9IHZhbHVlW2ldLng7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbaSAqIDMgKyAxXSAgID0gdmFsdWVbaV0ueTtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVtpICogMyArIDJdICAgPSB2YWx1ZVtpXS56O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHVuaWZvcm0uX2FycmF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIGFycmF5IG9mIDREIFBvaW50IG9iamVjdHNcbiAgICAgICAgY2FzZSAndjR2JzpcbiAgICAgICAgICAgIGlmICghdW5pZm9ybS5fYXJyYXkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDQgKiB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyArK2kpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbaSAqIDRdICAgICAgID0gdmFsdWVbaV0ueDtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLl9hcnJheVtpICogNCArIDFdICAgPSB2YWx1ZVtpXS55O1xuICAgICAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5W2kgKiA0ICsgMl0gICA9IHZhbHVlW2ldLno7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbaSAqIDQgKyAzXSAgID0gdmFsdWVbaV0udztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC51bmlmb3JtNGZ2KGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBQSVhJLlRleHR1cmVcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgIGNhc2UgJ3NhbXBsZXIyRCc6XG5cbiAgICAgICAgICAgIGlmICghdW5pZm9ybS52YWx1ZSB8fCAhdW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZS5oYXNMb2FkZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFjdGl2YXRlIHRoaXMgdGV4dHVyZVxuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbFsnVEVYVFVSRScgKyB0aGlzLnRleHR1cmVDb3VudF0pO1xuXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHVuaWZvcm0udmFsdWUuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdO1xuXG4gICAgICAgICAgICBpZiAoIXRleHR1cmUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0U2FtcGxlcjJEKHVuaWZvcm0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiaW5kIHRoZSB0ZXh0dXJlXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgICAgICAgLy8gc2V0IHVuaWZvcm0gdG8gdGV4dHVyZSBpbmRleFxuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm0uX2xvY2F0aW9uLCB0aGlzLnRleHR1cmVDb3VudCk7XG5cbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBuZXh0IHRleHR1cmUgaWRcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUNvdW50Kys7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BpeGkuanMgU2hhZGVyIFdhcm5pbmc6IFVua25vd24gdW5pZm9ybSB0eXBlOiAnICsgdW5pZm9ybS50eXBlKTtcbiAgICB9XG59O1xuXG4vKlxuICogVXBkYXRlcyB0aGUgc2hhZGVyIHVuaWZvcm0gdmFsdWVzLlxuICovXG5TaGFkZXIucHJvdG90eXBlLnN5bmNVbmlmb3JtcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy50ZXh0dXJlQ291bnQgPSAxO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMudW5pZm9ybXMpXG4gICAge1xuICAgICAgICB0aGlzLnN5bmNVbmlmb3JtKHRoaXMudW5pZm9ybXNba2V5XSk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEluaXRpYWxpc2VzIGEgU2FtcGxlcjJEIHVuaWZvcm0gKHdoaWNoIG1heSBvbmx5IGJlIGF2YWlsYWJsZSBsYXRlciBvbiBhZnRlciBpbml0VW5pZm9ybXMgb25jZSB0aGUgdGV4dHVyZSBoYXMgbG9hZGVkKVxuICpcbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5pbml0U2FtcGxlcjJEID0gZnVuY3Rpb24gKHVuaWZvcm0pXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHZhciB0ZXh0dXJlID0gdW5pZm9ybS52YWx1ZS5iYXNlVGV4dHVyZTtcblxuICAgIGlmKCF0ZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cblxuXG4gICAgaWYgKHVuaWZvcm0udGV4dHVyZURhdGEpXG4gICAge1xuXG4gICAgICAgIC8vVE9ETyBtb3ZlIHRoaXMuLi5cbiAgICAgICAgdmFyIGRhdGEgPSB1bmlmb3JtLnRleHR1cmVEYXRhO1xuXG4gICAgICAgIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcblxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleHR1cmUucHJlbXVsdGlwbGllZEFscGhhKTtcbiAgICAgICAgLy8gR0xUZXh0dXJlID0gbWFnIGxpbmVhciwgbWluIGxpbmVhcl9taXBtYXBfbGluZWFyLCB3cmFwIHJlcGVhdCArIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuICAgICAgICAvLyBHTFRleHR1cmVMaW5lYXIgPSBtYWcvbWluIGxpbmVhciwgd3JhcCBjbGFtcFxuICAgICAgICAvLyBHTFRleHR1cmVOZWFyZXN0UmVwZWF0ID0gbWFnL21pbiBORUFSRVNULCB3cmFwIHJlcGVhdFxuICAgICAgICAvLyBHTFRleHR1cmVOZWFyZXN0ID0gbWFnL21pbiBuZWFyZXN0LCB3cmFwIGNsYW1wXG4gICAgICAgIC8vIEF1ZGlvVGV4dHVyZSA9IHdoYXRldmVyICsgbHVtaW5hbmNlICsgd2lkdGggNTEyLCBoZWlnaHQgMiwgYm9yZGVyIDBcbiAgICAgICAgLy8gS2V5VGV4dHVyZSA9IHdoYXRldmVyICsgbHVtaW5hbmNlICsgd2lkdGggMjU2LCBoZWlnaHQgMiwgYm9yZGVyIDBcblxuICAgICAgICAvLyAgbWFnRmlsdGVyIGNhbiBiZTogZ2wuTElORUFSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiBvciBnbC5ORUFSRVNUXG4gICAgICAgIC8vICB3cmFwUy9UIGNhbiBiZTogZ2wuQ0xBTVBfVE9fRURHRSBvciBnbC5SRVBFQVRcblxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGRhdGEubHVtaW5hbmNlID8gZ2wuTFVNSU5BTkNFIDogZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZS5zb3VyY2UpO1xuXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBkYXRhLm1hZ0ZpbHRlciA/IGRhdGEubWFnRmlsdGVyIDogZ2wuTElORUFSICk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBkYXRhLndyYXBTID8gZGF0YS53cmFwUyA6IGdsLkNMQU1QX1RPX0VER0UgKTtcblxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBkYXRhLndyYXBTID8gZGF0YS53cmFwUyA6IGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBkYXRhLndyYXBUID8gZGF0YS53cmFwVCA6IGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLnNoYWRlck1hbmFnZXIucmVuZGVyZXIudXBkYXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBzaGFkZXIuXG4gKlxuICovXG5TaGFkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuXG4gICAgdGhpcy5nbCA9IG51bGw7XG4gICAgdGhpcy51bmlmb3JtcyA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcblxuICAgIHRoaXMudmVydGV4U3JjID0gbnVsbDtcbiAgICB0aGlzLmZyYWdtZW50U3JjID0gbnVsbDtcbn07XG5cblNoYWRlci5wcm90b3R5cGUuX2dsQ29tcGlsZSA9IGZ1bmN0aW9uICh0eXBlLCBzcmMpXG57XG4gICAgdmFyIHNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuXG4gICAgdGhpcy5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgaWYgKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xufTtcbiIsInZhciBTaGFkZXIgPSByZXF1aXJlKCcuL1NoYWRlcicpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqIEBleHRlbmRzIFNoYWRlclxuICogQHBhcmFtIHNoYWRlck1hbmFnZXIge1NoYWRlck1hbmFnZXJ9IFRoZSB3ZWJnbCBzaGFkZXIgbWFuYWdlciB0aGlzIHNoYWRlciB3b3JrcyBmb3IuXG4gKiBAcGFyYW0gW3ZlcnRleFNyY10ge3N0cmluZ30gVGhlIHNvdXJjZSBvZiB0aGUgdmVydGV4IHNoYWRlci5cbiAqIEBwYXJhbSBbZnJhZ21lbnRTcmNdIHtzdHJpbmd9IFRoZSBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAqIEBwYXJhbSBbY3VzdG9tVW5pZm9ybXNdIHtvYmplY3R9IEN1c3RvbSB1bmlmb3JtcyB0byB1c2UgdG8gYXVnbWVudCB0aGUgYnVpbHQtaW4gb25lcy5cbiAqIEBwYXJhbSBbZnJhZ21lbnRTcmNdIHtzdHJpbmd9IFRoZSBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAqL1xuZnVuY3Rpb24gVGV4dHVyZVNoYWRlcihzaGFkZXJNYW5hZ2VyLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBjdXN0b21Vbmlmb3JtcywgY3VzdG9tQXR0cmlidXRlcylcbntcbiAgICB2YXIgdW5pZm9ybXMgPSB7XG5cbiAgICAgICAgdVNhbXBsZXI6ICAgICAgICAgICB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogMCB9LFxuICAgICAgICBwcm9qZWN0aW9uTWF0cml4OiAgIHsgdHlwZTogJ21hdDMnLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSgxLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAxLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAxKSB9XG4gICAgfTtcblxuICAgIGlmIChjdXN0b21Vbmlmb3JtcylcbiAgICB7XG4gICAgICAgIGZvciAodmFyIHUgaW4gY3VzdG9tVW5pZm9ybXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVuaWZvcm1zW3VdID0gY3VzdG9tVW5pZm9ybXNbdV07XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICAgICBhVmVydGV4UG9zaXRpb246ICAgIDAsXG4gICAgICAgIGFUZXh0dXJlQ29vcmQ6ICAgICAgMCxcbiAgICAgICAgYUNvbG9yOiAgICAgICAgICAgICAwXG4gICAgfTtcblxuICAgIGlmIChjdXN0b21BdHRyaWJ1dGVzKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgYSBpbiBjdXN0b21BdHRyaWJ1dGVzKVxuICAgICAgICB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW2FdID0gY3VzdG9tQXR0cmlidXRlc1thXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgICAqIEBtZW1iZXIge0FycmF5fVxuICAgICAqL1xuICAgIHZlcnRleFNyYyA9IHZlcnRleFNyYyB8fCBUZXh0dXJlU2hhZGVyLmRlZmF1bHRWZXJ0ZXhTcmM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgICAqIEBtZW1iZXIge0FycmF5fVxuICAgICAqL1xuICAgIGZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMgfHwgVGV4dHVyZVNoYWRlci5kZWZhdWx0RnJhZ21lbnRTcmM7XG5cbiAgICBTaGFkZXIuY2FsbCh0aGlzLCBzaGFkZXJNYW5hZ2VyLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCB1bmlmb3JtcywgYXR0cmlidXRlcyk7XG59XG5cbi8vIGNvbnN0cnVjdG9yXG5UZXh0dXJlU2hhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2hhZGVyLnByb3RvdHlwZSk7XG5UZXh0dXJlU2hhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHR1cmVTaGFkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVTaGFkZXI7XG5cblRleHR1cmVTaGFkZXIuZGVmYXVsdFZlcnRleFNyYyA9IFtcbiAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcbiAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsXG4gICAgJ2F0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7JyxcbiAgICAnYXR0cmlidXRlIHZlYzQgYUNvbG9yOycsXG5cbiAgICAndW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7JyxcblxuICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAndm9pZCBtYWluKHZvaWQpeycsXG4gICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOycsXG4gICAgJyAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkOycsXG4gICAgJyAgIHZDb2xvciA9IHZlYzQoYUNvbG9yLnJnYiAqIGFDb2xvci5hLCBhQ29sb3IuYSk7JyxcbiAgICAnfSdcbl0uam9pbignXFxuJyk7XG5cblRleHR1cmVTaGFkZXIuZGVmYXVsdEZyYWdtZW50U3JjID0gW1xuICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxuXG4gICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuXG4gICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxuICAgICcgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yIDsnLFxuICAgICd9J1xuXS5qb2luKCdcXG4nKTtcbiIsInZhciBXZWJHTE1hbmFnZXIgPSByZXF1aXJlKCcuLi9tYW5hZ2Vycy9XZWJHTE1hbmFnZXInKTtcblxuLyoqXG4gKiBCYXNlIGZvciBhIGNvbW1vbiBvYmplY3QgcmVuZGVyZXIgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHN5c3RlbSByZW5kZXJlciBwbHVnaW4uXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBXZWJHTE1hbmFnZXJcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gcmVuZGVyZXIge1dlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIG9iamVjdCByZW5kZXJlciB3b3JrcyBmb3IuXG4gKi9cbmZ1bmN0aW9uIE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyKVxue1xuICAgIFdlYkdMTWFuYWdlci5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcbn1cblxuXG5PYmplY3RSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdlYkdMTWFuYWdlci5wcm90b3R5cGUpO1xuT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2JqZWN0UmVuZGVyZXI7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdFJlbmRlcmVyO1xuXG4vKipcbiAqIFN0YXJ0cyB0aGUgcmVuZGVyZXIgYW5kIHNldHMgdGhlIHNoYWRlclxuICpcbiAqL1xuT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBzZXQgdGhlIHNoYWRlci4uXG59O1xuXG4vKipcbiAqIFN0b3BzIHRoZSByZW5kZXJlclxuICpcbiAqL1xuT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogZmx1c2hlc1xuICpcbiAqL1xuT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBmbHVzaCFcbn07XG5cbi8qKlxuICogUmVuZGVycyBhbiBvYmplY3RcbiAqXG4gKi9cbk9iamVjdFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAob2JqZWN0KSAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG57XG4gICAgLy8gcmVuZGVyIHRoZSBvYmplY3Rcbn07XG4iLCIvKipcbiAqIEhlbHBlciBjbGFzcyB0byBjcmVhdGUgYSBxdWFkXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGdsIGNvbnRleHQgZm9yIHRoaXMgcXVhZCB0byB1c2UuXG4gKi9cbmZ1bmN0aW9uIFF1YWQoZ2wpXG57XG4gICAgLypcbiAgICAgKiB0aGUgY3VycmVudCBXZWJHTCBkcmF3aW5nIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbi8vICAgIHRoaXMudGV4dHVyZXMgPSBuZXcgVGV4dHVyZVV2cygpO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgdmVydGljZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIDAsMCxcbiAgICAgICAgMjAwLDAsXG4gICAgICAgIDIwMCwyMDAsXG4gICAgICAgIDAsMjAwXG4gICAgXSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgVXZzIG9mIHRoZSBxdWFkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XG4gICAgICovXG4gICAgdGhpcy51dnMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgMCwwLFxuICAgICAgICAxLDAsXG4gICAgICAgIDEsMSxcbiAgICAgICAgMCwxXG4gICAgXSk7XG5cbi8vICAgIHZhciB3aGl0ZSA9ICgweEZGRkZGRiA+PiAxNikgKyAoMHhGRkZGRkYgJiAweGZmMDApICsgKCgweEZGRkZGRiAmIDB4ZmYpIDw8IDE2KSArICgxICogMjU1IDw8IDI0KTtcbiAgICAvL1RPRE8gY29udmVydCB0aGlzIHRvIGEgMzIgdW5zaWduZWQgaW50IGFycmF5XG4gICAgLyoqXG4gICAgICogVGhlIGNvbG9yIGNvbXBvbmVudHMgb2YgdGhlIHRyaWFuZ2xlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgIDEsMSwxLDEsXG4gICAgICAgIDEsMSwxLDEsXG4gICAgICAgIDEsMSwxLDEsXG4gICAgICAgIDEsMSwxLDFcbiAgICBdKTtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7VWludDE2QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzXG4gICAgICovXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFtcbiAgICAgICAgMCwgMSwgMiwgMCwgMywgMlxuICAgIF0pO1xuXG4gICAgLypcbiAgICAgKiBAbWVtYmVyIHtXZWJHTEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXJcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgLypcbiAgICAgKiBAbWVtYmVyIHtXZWJHTEJ1ZmZlcn0gVGhlIGluZGV4IGJ1ZmZlclxuICAgICAqL1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsICg4ICsgOCArIDE2KSAqIDQsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIHRoaXMudXBsb2FkKCk7XG59XG5cblF1YWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUXVhZDtcblxuLyoqXG4gKiBNYXBzIHR3byBSZWN0YW5nbGUgdG8gdGhlIHF1YWRcbiAqIEBwYXJhbSByZWN0IHtSZWN0YW5nbGV9IHRoZSBmaXJzdCByZWN0YW5nbGVcbiAqIEBwYXJhbSByZWN0MiB7UmVjdGFuZ2xlfSB0aGUgc2Vjb25kIHJlY3RhbmdsZVxuICovXG5RdWFkLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihyZWN0LCByZWN0MilcbntcbiAgICB2YXIgeCA9IDA7IC8vcmVjdDIueCAvIHJlY3Qud2lkdGg7XG4gICAgdmFyIHkgPSAwOyAvL3JlY3QyLnkgLyByZWN0LmhlaWdodDtcblxuICAgIHRoaXMudXZzWzBdID0geDtcbiAgICB0aGlzLnV2c1sxXSA9IHk7XG5cbiAgICB0aGlzLnV2c1syXSA9IHggKyByZWN0Mi53aWR0aCAvIHJlY3Qud2lkdGg7XG4gICAgdGhpcy51dnNbM10gPSB5O1xuXG4gICAgdGhpcy51dnNbNF0gPSB4ICsgcmVjdDIud2lkdGggLyByZWN0LndpZHRoO1xuICAgIHRoaXMudXZzWzVdID0geSArIHJlY3QyLmhlaWdodCAvIHJlY3QuaGVpZ2h0O1xuXG4gICAgdGhpcy51dnNbNl0gPSB4O1xuICAgIHRoaXMudXZzWzddID0geSArIHJlY3QyLmhlaWdodCAvIHJlY3QuaGVpZ2h0O1xuXG4gICAgLy8vIC0tLS0tXG4gICAgeCA9IHJlY3QyLng7XG4gICAgeSA9IHJlY3QyLnk7XG5cbiAgICB0aGlzLnZlcnRpY2VzWzBdID0geDtcbiAgICB0aGlzLnZlcnRpY2VzWzFdID0geTtcblxuICAgIHRoaXMudmVydGljZXNbMl0gPSB4ICsgcmVjdDIud2lkdGg7XG4gICAgdGhpcy52ZXJ0aWNlc1szXSA9IHk7XG5cbiAgICB0aGlzLnZlcnRpY2VzWzRdID0geCArIHJlY3QyLndpZHRoO1xuICAgIHRoaXMudmVydGljZXNbNV0gPSB5ICsgcmVjdDIuaGVpZ2h0O1xuXG4gICAgdGhpcy52ZXJ0aWNlc1s2XSA9IHg7XG4gICAgdGhpcy52ZXJ0aWNlc1s3XSA9IHkgKyByZWN0Mi5oZWlnaHQ7XG5cbiAgICB0aGlzLnVwbG9hZCgpO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgYnVmZmVyIGFuZCB1cGxvYWRzIHRoZSBkYXRhXG4gKi9cblF1YWQucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gVE9ETyBjb3VsZCBwcm9iYWJseSBiZSBwdXNoZWQgaW50byBvbmUgdXBsb2FkIVxuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIgKTtcblxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLnZlcnRpY2VzKTtcblxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCA4ICogNCwgdGhpcy51dnMpO1xuXG4gICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsICg4ICsgOCkgKiA0LCB0aGlzLmNvbG9ycyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1YWQ7XG5cblxuIiwidmFyIG1hdGggPSByZXF1aXJlKCcuLi8uLi8uLi9tYXRoJyksXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpLFxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vLi4vLi4vY29uc3QnKSxcbiAgICAvL1N0ZW5jaWxNYW5hZ2VyID0gcmVxdWlyZSgnLi4vbWFuYWdlcnMvU3RlbmNpbE1hbmFnZXInKSxcbiAgICBTdGVuY2lsTWFza1N0YWNrID0gcmVxdWlyZSgnLi9TdGVuY2lsTWFza1N0YWNrJyk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIGhvcml6b250YWwgcmFuZ2Ugb2YgdGhlIGZpbHRlclxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSB0aGUgdmVydGljYWwgcmFuZ2Ugb2YgdGhlIGZpbHRlclxuICogQHBhcmFtIHNjYWxlTW9kZSB7bnVtYmVyfSBTZWUge3sjY3Jvc3NMaW5rIFwiUElYSS9zY2FsZU1vZGVzOnByb3BlcnR5XCJ9fVBJWEkuc2NhbGVNb2Rlc3t7L2Nyb3NzTGlua319IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqIEBwYXJhbSByZXNvbHV0aW9uIHtudW1iZXJ9IHRoZSBjdXJyZW50IHJlc29sdXRpb25cbiAqIEBwYXJhbSByb290IHtib29sZWFufSBXaGV0aGVyIHRoaXMgb2JqZWN0IGlzIHRoZSByb290IGVsZW1lbnQgb3Igbm90XG4gKi9cbnZhciBSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uLCByb290KVxue1xuICAgIC8vVE9ETyBSZXNvbHV0aW9uIGNvdWxkIGdvIGhlcmUgKCBlZyBsb3cgcmVzIGJsdXJzIClcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvLyBuZXh0IHRpbWUgdG8gY3JlYXRlIGEgZnJhbWUgYnVmZmVyIGFuZCB0ZXh0dXJlXG5cbiAgICAvKipcbiAgICAgKiBBIGZyYW1lIGJ1ZmZlclxuICAgICAqIEBtZW1iZXIge1dlYkdMRnJhbWVCdWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZUJ1ZmZlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtUZXh0dXJlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgb2JqZWN0IGFzIGEgcmVjdGFuZ2xlXG4gICAgICogQG1lbWJlciB7UmVjdGFuZ2xlfVxuICAgICAqL1xuICAgIHRoaXMuc2l6ZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHJlc29sdXRpb25cbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBDT05TVC5SRVNPTFVUSU9OO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByb2plY3Rpb24gbWF0cml4XG4gICAgICogQG1lbWJlciB7TWF0cml4fVxuICAgICAqL1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBtYXRoLk1hdHJpeCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCdzIHRyYW5zZm9ybVxuICAgICAqIEBtZW1iZXIge01hdHJpeH1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1JlY3RhbmdsZX1cbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGVuY2lsIGJ1ZmZlciBzdG9yZXMgbWFza2luZyBkYXRhIGZvciB0aGUgcmVuZGVyIHRhcmdldFxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyQnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RlbmNpbEJ1ZmZlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIHRoZSBzdGVuY2lsIG1hc2tzXG4gICAgICogQG1lbWJlciB7U3RlbmNpbE1hc2tTdGFja31cbiAgICAgKi9cbiAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBuZXcgU3RlbmNpbE1hc2tTdGFjaygpO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIGZpbHRlciBkYXRhIGZvciB0aGUgcmVuZGVyIHRhcmdldFxuICAgICAqIEBtZW1iZXIge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlclRhcmdldDp0aGlzLFxuICAgICAgICAgICAgZmlsdGVyOltdLFxuICAgICAgICAgICAgYm91bmRzOnRoaXMuc2l6ZVxuICAgICAgICB9XG4gICAgXTtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIHNjYWxlIG1vZGVcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgQ09OU1QuU0NBTEVfTU9ERVMuREVGQVVMVFxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlIHx8IENPTlNULlNDQUxFX01PREVTLkRFRkFVTFQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgb2JqZWN0IGlzIHRoZSByb290IGVsZW1lbnQgb3Igbm90XG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgaWYgKCF0aGlzLnJvb3QpXG4gICAge1xuICAgICAgIC8vIHRoaXMuZmxpcFkgPSB0cnVlO1xuICAgICAgICB0aGlzLmZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgQSBmcmFtZSBidWZmZXIgbmVlZHMgYSB0YXJnZXQgdG8gcmVuZGVyIHRvLi5cbiAgICAgICAgICAgIGNyZWF0ZSBhIHRleHR1cmUgYW5kIGJpbmQgaXQgYXR0YWNoIGl0IHRvIHRoZSBmcmFtZWJ1ZmZlci4uXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCAgdGhpcy50ZXh0dXJlKTtcblxuICAgICAgICAvLyBzZXQgdGhlIHNjYWxlIHByb3BlcnRpZXMgb2YgdGhlIHRleHR1cmUuLlxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgc2NhbGVNb2RlID09PSBDT05TVC5TQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHNjYWxlTW9kZSA9PT0gQ09OU1QuU0NBTEVfTU9ERVMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG5cbiAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSB0ZXh0dXJlIGlzIGEgcG93ZXIgb2YgdHdvIVxuICAgICAgICB2YXIgaXNQb3dlck9mVHdvID0gdXRpbHMuaXNQb3dlck9mVHdvKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vVE9ETyBmb3IgOTklIG9mIHVzZSBjYXNlcyBpZiBhIHRleHR1cmUgaXMgcG93ZXIgb2YgdHdvIHdlIHNob3VsZCB0aWxlIHRoZSB0ZXh0dXJlLi4uXG4gICAgICAgICBpZiAoIWlzUG93ZXJPZlR3bylcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcblxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLlJFUEVBVCk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIgKTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUsIDApO1xuICAgIH1cblxuXG4gICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG59O1xuXG5SZW5kZXJUYXJnZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVuZGVyVGFyZ2V0O1xubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJUYXJnZXQ7XG5cbi8qKlxuKiBDbGVhcnMgdGhlIGZpbHRlciB0ZXh0dXJlLlxuKlxuKi9cblJlbmRlclRhcmdldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihiaW5kKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgaWYoYmluZClcbiAgICB7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlcik7XG4gICAgfVxuXG4gICAgZ2wuY2xlYXJDb2xvcigwLDAsMCwwKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbn07XG5cbi8qKlxuKiBCaW5kcyB0aGUgc3RlbmNpbCBidWZmZXIuXG4qXG4qL1xuUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5hdHRhY2hTdGVuY2lsQnVmZmVyID0gZnVuY3Rpb24oKVxue1xuXG4gICAgaWYgKCB0aGlzLnN0ZW5jaWxCdWZmZXIgKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qXG4gICAgICAgIFRoZSBzdGVuY2lsIGJ1ZmZlciBpcyB1c2VkIGZvciBtYXNraW5nIGluIHBpeGlcbiAgICAgICAgbGV0cyBjcmVhdGUgb25lIGFuZCB0aGVuIGFkZCBhdHRhY2ggaXQgdG8gdGhlIGZyYW1lYnVmZmVyLi5cbiAgICAgKi9cbiAgICBpZiAoIXRoaXMucm9vdClcbiAgICB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgdGhpcy5zdGVuY2lsQnVmZmVyID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnN0ZW5jaWxCdWZmZXIpO1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHRoaXMuc3RlbmNpbEJ1ZmZlcik7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCAgdGhpcy5zaXplLndpZHRoICogdGhpcy5yZXNvbHV0aW9uICAsIHRoaXMuc2l6ZS5oZWlnaHQgKiB0aGlzLnJlc29sdXRpb24gKTtcbiAgICB9XG59O1xuXG4vKipcbiogQmluZHMgdGhlIGJ1ZmZlcnMgYW5kIGluaXRpYWxpc2VzIHRoZSB2aWV3cG9ydC5cbipcbiovXG5SZW5kZXJUYXJnZXQucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oKVxue1xuICAgIC8vVE9PRCByZWZhY3RvciB1c2FnZSBvZiBmcmFtZS4uXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlcik7XG5cbiAgICB2YXIgcHJvamVjdGlvbkZyYW1lID0gdGhpcy5mcmFtZSB8fCB0aGlzLnNpemU7XG5cbiAgICAvLyBUT0RPIGFkZCBhIGRpcnR5IGZsYWcgdG8gdGhpcyBvZiBhIHNldHRlciBmb3IgdGhlIGZyYW1lP1xuICAgIHRoaXMuY2FsY3VsYXRlUHJvamVjdGlvbiggcHJvamVjdGlvbkZyYW1lICk7XG5cbiAgICBpZih0aGlzLnRyYW5zZm9ybSlcbiAgICB7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5hcHBlbmQodGhpcy50cmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIGdsLnZpZXdwb3J0KDAsMCwgcHJvamVjdGlvbkZyYW1lLndpZHRoICogdGhpcy5yZXNvbHV0aW9uLCBwcm9qZWN0aW9uRnJhbWUuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKTtcbn07XG5cbi8qKlxuKiBVcGRhdGVzIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCBiYXNlZCBvbiBhIHByb2plY3Rpb24gZnJhbWUgKHdoaWNoIGlzIGEgcmVjdGFuZ2xlKVxuKlxuKi9cblJlbmRlclRhcmdldC5wcm90b3R5cGUuY2FsY3VsYXRlUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCBwcm9qZWN0aW9uRnJhbWUgKVxue1xuICAgIHZhciBwbSA9IHRoaXMucHJvamVjdGlvbk1hdHJpeDtcblxuICAgIHBtLmlkZW50aXR5KCk7XG5cbiAgICBpZiAoIXRoaXMucm9vdClcbiAgICB7XG4gICAgICAgIHBtLmEgPSAxIC8gcHJvamVjdGlvbkZyYW1lLndpZHRoKjI7XG4gICAgICAgIHBtLmQgPSAxIC8gcHJvamVjdGlvbkZyYW1lLmhlaWdodCoyO1xuXG4gICAgICAgIHBtLnR4ID0gLTEgLSBwcm9qZWN0aW9uRnJhbWUueCAqIHBtLmE7XG4gICAgICAgIHBtLnR5ID0gLTEgLSBwcm9qZWN0aW9uRnJhbWUueSAqIHBtLmQ7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHBtLmEgPSAxIC8gcHJvamVjdGlvbkZyYW1lLndpZHRoKjI7XG4gICAgICAgIHBtLmQgPSAtMSAvIHByb2plY3Rpb25GcmFtZS5oZWlnaHQqMjtcblxuICAgICAgICBwbS50eCA9IC0xIC0gcHJvamVjdGlvbkZyYW1lLnggKiBwbS5hO1xuICAgICAgICBwbS50eSA9IDEgLSBwcm9qZWN0aW9uRnJhbWUueSAqIHBtLmQ7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIFJlc2l6ZXMgdGhlIHRleHR1cmUgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gKlxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSBuZXcgd2lkdGggb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAqL1xuUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KVxue1xuICAgIHdpZHRoID0gd2lkdGggfCAwO1xuICAgIGhlaWdodCA9IGhlaWdodCB8IDA7XG5cbiAgICBpZiAodGhpcy5zaXplLndpZHRoID09PSB3aWR0aCAmJiB0aGlzLnNpemUuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2l6ZS53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuc2l6ZS5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICBpZiAoIXRoaXMucm9vdClcbiAgICB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgIHRoaXMudGV4dHVyZSk7XG5cbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAgd2lkdGggKiB0aGlzLnJlc29sdXRpb24sIGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbiAsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0ZW5jaWxCdWZmZXIgKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHN0ZW5jaWwgYnVmZmVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnN0ZW5jaWxCdWZmZXIpO1xuICAgICAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUwsICB3aWR0aCAqIHRoaXMucmVzb2x1dGlvbiwgaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvamVjdGlvbkZyYW1lID0gdGhpcy5mcmFtZSB8fCB0aGlzLnNpemU7XG5cbiAgICB0aGlzLmNhbGN1bGF0ZVByb2plY3Rpb24oIHByb2plY3Rpb25GcmFtZSApO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgcmVuZGVyIHRhcmdldC5cbiAqXG4gKi9cblJlbmRlclRhcmdldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKCB0aGlzLmZyYW1lQnVmZmVyICk7XG4gICAgZ2wuZGVsZXRlVGV4dHVyZSggdGhpcy50ZXh0dXJlICk7XG5cbiAgICB0aGlzLmZyYW1lQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xufTtcbiIsIi8qKlxuICogR2VuZXJpYyBNYXNrIFN0YWNrIGRhdGEgc3RydWN0dXJlXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gcmVuZGVyZXIge1dlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIG1hbmFnZXIgd29ya3MgZm9yLlxuICovXG5mdW5jdGlvbiBTdGVuY2lsTWFza1N0YWNrKClcbntcblx0LyoqXG4gICAgICogVGhlIGFjdHVhbCBzdGFja1xuICAgICAqXG4gICAgICogQG1lbWJlciB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zdGVuY2lsU3RhY2sgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRPRE8gQGFsdmluXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmV2ZXJzZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjb3VudFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY291bnQgPSAwO1xufVxuXG5TdGVuY2lsTWFza1N0YWNrLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0ZW5jaWxNYXNrU3RhY2s7XG5tb2R1bGUuZXhwb3J0cyA9IFN0ZW5jaWxNYXNrU3RhY2s7XG4iLCJ2YXIgbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKSxcbiAgICBUZXh0dXJlID0gcmVxdWlyZSgnLi4vdGV4dHVyZXMvVGV4dHVyZScpLFxuICAgIENvbnRhaW5lciA9IHJlcXVpcmUoJy4uL2Rpc3BsYXkvQ29udGFpbmVyJyksXG4gICAgQ2FudmFzVGludGVyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXJzL2NhbnZhcy91dGlscy9DYW52YXNUaW50ZXInKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyksXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHRlbXBQb2ludCA9IG5ldyBtYXRoLlBvaW50KCk7XG5cbi8qKlxuICogVGhlIFNwcml0ZSBvYmplY3QgaXMgdGhlIGJhc2UgZm9yIGFsbCB0ZXh0dXJlZCBvYmplY3RzIHRoYXQgYXJlIHJlbmRlcmVkIHRvIHRoZSBzY3JlZW5cbiAqXG4gKiBBIHNwcml0ZSBjYW4gYmUgY3JlYXRlZCBkaXJlY3RseSBmcm9tIGFuIGltYWdlIGxpa2UgdGhpczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZS5mcm9tSW1hZ2UoJ2Fzc2V0cy9pbWFnZS5wbmcnKTtcbiAqIGBgYFxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgQ29udGFpbmVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSB0ZXh0dXJlIGZvciB0aGlzIHNwcml0ZVxuICovXG5mdW5jdGlvbiBTcHJpdGUodGV4dHVyZSlcbntcbiAgICBDb250YWluZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmNob3Igc2V0cyB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIDAsMCB0aGlzIG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdFxuICAgICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byAwLjUsMC41IG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIGNlbnRlcmVkXG4gICAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIDEsMSB3b3VsZCBtZWFuIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIHBvaW50IHdpbGwgYmUgdGhlIGJvdHRvbSByaWdodCBjb3JuZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BvaW50fVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yID0gbmV3IG1hdGguUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIHRoYXQgdGhlIHNwcml0ZSBpcyB1c2luZ1xuICAgICAqXG4gICAgICogQG1lbWJlciB7VGV4dHVyZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUgKHRoaXMgaXMgaW5pdGlhbGx5IHNldCBieSB0aGUgdGV4dHVyZSlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3dpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSAodGhpcyBpcyBpbml0aWFsbHkgc2V0IGJ5IHRoZSB0ZXh0dXJlKVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faGVpZ2h0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gVGhpcyBpcyBhIGhleCB2YWx1ZS4gQSB2YWx1ZSBvZiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgWzB4RkZGRkZGXVxuICAgICAqL1xuICAgIHRoaXMudGludCA9IDB4RkZGRkZGO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBBcHBseSBhIHZhbHVlIG9mIGJsZW5kTW9kZXMuTk9STUFMIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IENPTlNULkJMRU5EX01PREVTLk5PUk1BTDtcbiAgICAgKi9cbiAgICB0aGlzLmJsZW5kTW9kZSA9IENPTlNULkJMRU5EX01PREVTLk5PUk1BTDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFkZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBzcHJpdGUuIFNldCB0byBudWxsIHRvIHJlbW92ZSBhIGN1cnJlbnQgc2hhZGVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7QWJzdHJhY3RGaWx0ZXJ9XG4gICAgICovXG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgY2FjaGVkIHZhbHVlIG9mIHRoZSB0aW50LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IFsweEZGRkZGRl1cbiAgICAgKi9cbiAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcblxuICAgIC8vIGNhbGwgdGV4dHVyZSBzZXR0ZXJcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlIHx8IFRleHR1cmUuRU1QVFk7XG59XG5cbi8vIGNvbnN0cnVjdG9yXG5TcHJpdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb250YWluZXIucHJvdG90eXBlKTtcblNwcml0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcHJpdGU7XG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3ByaXRlLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICAgICAqXG4gICAgICogQG1lbWJlclxuICAgICAqIEBtZW1iZXJvZiBTcHJpdGUjXG4gICAgICovXG4gICAgd2lkdGg6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS54ICogdGhpcy50ZXh0dXJlLl9mcmFtZS53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueCA9IHZhbHVlIC8gdGhpcy50ZXh0dXJlLl9mcmFtZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICAgICAqXG4gICAgICogQG1lbWJlclxuICAgICAqIEBtZW1iZXJvZiBTcHJpdGUjXG4gICAgICovXG4gICAgaGVpZ2h0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICB0aGlzLnNjYWxlLnkgKiB0aGlzLnRleHR1cmUuX2ZyYW1lLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IHZhbHVlIC8gdGhpcy50ZXh0dXJlLl9mcmFtZS5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyXG4gICAgICogQG1lbWJlcm9mIFNwcml0ZSNcbiAgICAgKi9cbiAgICB0ZXh0dXJlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICB0aGlzLl90ZXh0dXJlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUgPT09IHZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRUaW50ID0gMHhGRkZGRkY7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciB0aGUgdGV4dHVyZSB0byBsb2FkXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vbmNlKCd1cGRhdGUnLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFdoZW4gdGhlIHRleHR1cmUgaXMgdXBkYXRlZCwgdGhpcyBldmVudCB3aWxsIGZpcmUgdG8gdXBkYXRlIHRoZSBzY2FsZSBhbmQgZnJhbWVcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5TcHJpdGUucHJvdG90eXBlLl9vblRleHR1cmVVcGRhdGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIHNvIGlmIF93aWR0aCBpcyAwIHRoZW4gd2lkdGggd2FzIG5vdCBzZXQuLlxuICAgIGlmICh0aGlzLl93aWR0aClcbiAgICB7XG4gICAgICAgIHRoaXMuc2NhbGUueCA9IHRoaXMuX3dpZHRoIC8gdGhpcy50ZXh0dXJlLmZyYW1lLndpZHRoO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9oZWlnaHQpXG4gICAge1xuICAgICAgICB0aGlzLnNjYWxlLnkgPSB0aGlzLl9oZWlnaHQgLyB0aGlzLnRleHR1cmUuZnJhbWUuaGVpZ2h0O1xuICAgIH1cbn07XG5cbi8qKlxuKlxuKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4qXG4qIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn1cbiogQHByaXZhdGVcbiovXG5TcHJpdGUucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIChyZW5kZXJlcilcbntcbiAgICByZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zLnNwcml0ZSk7XG4gICAgcmVuZGVyZXIucGx1Z2lucy5zcHJpdGUucmVuZGVyKHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIFNwcml0ZSBhcyBhIHJlY3RhbmdsZS4gVGhlIGJvdW5kcyBjYWxjdWxhdGlvbiB0YWtlcyB0aGUgd29ybGRUcmFuc2Zvcm0gaW50byBhY2NvdW50LlxuICpcbiAqIEBwYXJhbSBtYXRyaXgge01hdHJpeH0gdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgc3ByaXRlXG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICovXG5TcHJpdGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChtYXRyaXgpXG57XG4gICAgaWYoIXRoaXMuX2N1cnJlbnRCb3VuZHMpXG4gICAge1xuXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX3RleHR1cmUuX2ZyYW1lLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fdGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xuXG4gICAgICAgIHZhciB3MCA9IHdpZHRoICogKDEtdGhpcy5hbmNob3IueCk7XG4gICAgICAgIHZhciB3MSA9IHdpZHRoICogLXRoaXMuYW5jaG9yLng7XG5cbiAgICAgICAgdmFyIGgwID0gaGVpZ2h0ICogKDEtdGhpcy5hbmNob3IueSk7XG4gICAgICAgIHZhciBoMSA9IGhlaWdodCAqIC10aGlzLmFuY2hvci55O1xuXG4gICAgICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IG1hdHJpeCB8fCB0aGlzLndvcmxkVHJhbnNmb3JtIDtcblxuICAgICAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7XG4gICAgICAgIHZhciBiID0gd29ybGRUcmFuc2Zvcm0uYjtcbiAgICAgICAgdmFyIGMgPSB3b3JsZFRyYW5zZm9ybS5jO1xuICAgICAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7XG4gICAgICAgIHZhciB0eCA9IHdvcmxkVHJhbnNmb3JtLnR4O1xuICAgICAgICB2YXIgdHkgPSB3b3JsZFRyYW5zZm9ybS50eTtcblxuICAgICAgICB2YXIgbWluWCxcbiAgICAgICAgICAgIG1heFgsXG4gICAgICAgICAgICBtaW5ZLFxuICAgICAgICAgICAgbWF4WTtcblxuXG4gICAgICAgIGlmIChiID09PSAwICYmIGMgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHNjYWxlIG1heSBiZSBuZWdhdGl2ZSFcbiAgICAgICAgICAgIGlmIChhIDwgMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhICo9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZCA8IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZCAqPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGVyZSBpcyBubyByb3RhdGlvbiBnb2luZyBvbiByaWdodD8gUklHSFQ/XG4gICAgICAgICAgICAvLyBpZiB0aGF0cyB0aGUgY2FzZSB0aGVuIHdlIGNhbiBhdm9pZCBjaGVja2luZyB0aGUgYm91bmQgdmFsdWVzISB5YXlcbiAgICAgICAgICAgIG1pblggPSBhICogdzEgKyB0eDtcbiAgICAgICAgICAgIG1heFggPSBhICogdzAgKyB0eDtcbiAgICAgICAgICAgIG1pblkgPSBkICogaDEgKyB0eTtcbiAgICAgICAgICAgIG1heFkgPSBkICogaDAgKyB0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB4MSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xuICAgICAgICAgICAgdmFyIHkxID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG5cbiAgICAgICAgICAgIHZhciB4MiA9IGEgKiB3MCArIGMgKiBoMSArIHR4O1xuICAgICAgICAgICAgdmFyIHkyID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG5cbiAgICAgICAgICAgIHZhciB4MyA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgICAgICAgICAgdmFyIHkzID0gZCAqIGgwICsgYiAqIHcwICsgdHk7XG5cbiAgICAgICAgICAgIHZhciB4NCA9ICBhICogdzEgKyBjICogaDAgKyB0eDtcbiAgICAgICAgICAgIHZhciB5NCA9ICBkICogaDAgKyBiICogdzEgKyB0eTtcblxuICAgICAgICAgICAgbWluWCA9IHgxO1xuICAgICAgICAgICAgbWluWCA9IHgyIDwgbWluWCA/IHgyIDogbWluWDtcbiAgICAgICAgICAgIG1pblggPSB4MyA8IG1pblggPyB4MyA6IG1pblg7XG4gICAgICAgICAgICBtaW5YID0geDQgPCBtaW5YID8geDQgOiBtaW5YO1xuXG4gICAgICAgICAgICBtaW5ZID0geTE7XG4gICAgICAgICAgICBtaW5ZID0geTIgPCBtaW5ZID8geTIgOiBtaW5ZO1xuICAgICAgICAgICAgbWluWSA9IHkzIDwgbWluWSA/IHkzIDogbWluWTtcbiAgICAgICAgICAgIG1pblkgPSB5NCA8IG1pblkgPyB5NCA6IG1pblk7XG5cbiAgICAgICAgICAgIG1heFggPSB4MTtcbiAgICAgICAgICAgIG1heFggPSB4MiA+IG1heFggPyB4MiA6IG1heFg7XG4gICAgICAgICAgICBtYXhYID0geDMgPiBtYXhYID8geDMgOiBtYXhYO1xuICAgICAgICAgICAgbWF4WCA9IHg0ID4gbWF4WCA/IHg0IDogbWF4WDtcblxuICAgICAgICAgICAgbWF4WSA9IHkxO1xuICAgICAgICAgICAgbWF4WSA9IHkyID4gbWF4WSA/IHkyIDogbWF4WTtcbiAgICAgICAgICAgIG1heFkgPSB5MyA+IG1heFkgPyB5MyA6IG1heFk7XG4gICAgICAgICAgICBtYXhZID0geTQgPiBtYXhZID8geTQgOiBtYXhZO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIGNoaWxkcmVuXG4gICAgICAgIGlmKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgY2hpbGRCb3VuZHMgPSB0aGlzLmNvbnRhaW5lckdldEJvdW5kcygpO1xuXG4gICAgICAgICAgICB3MCA9IGNoaWxkQm91bmRzLng7XG4gICAgICAgICAgICB3MSA9IGNoaWxkQm91bmRzLnggKyBjaGlsZEJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgIGgwID0gY2hpbGRCb3VuZHMueTtcbiAgICAgICAgICAgIGgxID0gY2hpbGRCb3VuZHMueSArIGNoaWxkQm91bmRzLmhlaWdodDtcblxuICAgICAgICAgICAgbWluWCA9IChtaW5YIDwgdzApID8gbWluWCA6IHcwO1xuICAgICAgICAgICAgbWluWSA9IChtaW5ZIDwgaDApID8gbWluWSA6IGgwO1xuXG4gICAgICAgICAgICBtYXhYID0gKG1heFggPiB3MSkgPyBtYXhYIDogdzE7XG4gICAgICAgICAgICBtYXhZID0gKG1heFkgPiBoMSkgPyBtYXhZIDogaDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG4gICAgICAgIGJvdW5kcy54ID0gbWluWDtcbiAgICAgICAgYm91bmRzLndpZHRoID0gbWF4WCAtIG1pblg7XG5cbiAgICAgICAgYm91bmRzLnkgPSBtaW5ZO1xuICAgICAgICBib3VuZHMuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICAgICAgLy8gc3RvcmUgYSByZWZlcmVuY2Ugc28gdGhhdCBpZiB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGFnYWluIGluIHRoZSByZW5kZXIgY3ljbGUgd2UgZG8gbm90IGhhdmUgdG8gcmVjYWxjdWxhdGVcbiAgICAgICAgdGhpcy5fY3VycmVudEJvdW5kcyA9IGJvdW5kcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJvdW5kcztcbn07XG5cblNwcml0ZS5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX2JvdW5kcy54ID0gLXRoaXMuX3RleHR1cmUuX2ZyYW1lLndpZHRoICogdGhpcy5hbmNob3IueDtcbiAgICB0aGlzLl9ib3VuZHMueSA9IC10aGlzLl90ZXh0dXJlLl9mcmFtZS5oZWlnaHQgKiB0aGlzLmFuY2hvci55O1xuICAgIHRoaXMuX2JvdW5kcy53aWR0aCA9IHRoaXMuX3RleHR1cmUuX2ZyYW1lLndpZHRoO1xuICAgIHRoaXMuX2JvdW5kcy5oZWlnaHQgPSB0aGlzLl90ZXh0dXJlLl9mcmFtZS5oZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcbn07XG5cbi8qKlxuKiBUZXN0cyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGlzIHNwcml0ZVxuKlxuKiBAcGFyYW0gcG9pbnQge1BvaW50fSB0aGUgcG9pbnQgdG8gdGVzdFxuKiBAcmV0dXJuIHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSB0ZXN0XG4qL1xuU3ByaXRlLnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24oIHBvaW50IClcbntcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgIHRlbXBQb2ludCk7XG5cbiAgICB2YXIgd2lkdGggPSB0aGlzLl90ZXh0dXJlLl9mcmFtZS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fdGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xuICAgIHZhciB4MSA9IC13aWR0aCAqIHRoaXMuYW5jaG9yLng7XG4gICAgdmFyIHkxO1xuXG4gICAgaWYgKCB0ZW1wUG9pbnQueCA+IHgxICYmIHRlbXBQb2ludC54IDwgeDEgKyB3aWR0aCApXG4gICAge1xuICAgICAgICB5MSA9IC1oZWlnaHQgKiB0aGlzLmFuY2hvci55O1xuXG4gICAgICAgIGlmICggdGVtcFBvaW50LnkgPiB5MSAmJiB0ZW1wUG9pbnQueSA8IHkxICsgaGVpZ2h0IClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbipcbiogQHBhcmFtIHJlbmRlcmVyIHtDYW52YXNSZW5kZXJlcn0gVGhlIHJlbmRlcmVyXG4qIEBwcml2YXRlXG4qL1xuU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIGlmICh0aGlzLnRleHR1cmUuY3JvcC53aWR0aCA8PSAwIHx8IHRoaXMudGV4dHVyZS5jcm9wLmhlaWdodCA8PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJsZW5kTW9kZSAhPT0gcmVuZGVyZXIuY3VycmVudEJsZW5kTW9kZSlcbiAgICB7XG4gICAgICAgIHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUgPSB0aGlzLmJsZW5kTW9kZTtcbiAgICAgICAgcmVuZGVyZXIuY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSByZW5kZXJlci5ibGVuZE1vZGVzW3JlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGVdO1xuICAgIH1cblxuICAgIC8vICBJZ25vcmUgbnVsbCBzb3VyY2VzXG4gICAgaWYgKHRoaXMudGV4dHVyZS52YWxpZClcbiAgICB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZSxcbiAgICAgICAgICAgIHd0ID0gdGhpcy53b3JsZFRyYW5zZm9ybSxcbiAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgZHksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDtcblxuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IHRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbiAvIHJlbmRlcmVyLnJlc29sdXRpb247XG5cbiAgICAgICAgcmVuZGVyZXIuY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcblxuICAgICAgICAvLyBJZiBzbW9vdGhpbmdFbmFibGVkIGlzIHN1cHBvcnRlZCBhbmQgd2UgbmVlZCB0byBjaGFuZ2UgdGhlIHNtb290aGluZyBwcm9wZXJ0eSBmb3IgdGhpcyB0ZXh0dXJlXG4gICAgICAgIGlmIChyZW5kZXJlci5zbW9vdGhQcm9wZXJ0eSAmJiByZW5kZXJlci5jdXJyZW50U2NhbGVNb2RlICE9PSB0ZXh0dXJlLmJhc2VUZXh0dXJlLnNjYWxlTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSA9IHRleHR1cmUuYmFzZVRleHR1cmUuc2NhbGVNb2RlO1xuICAgICAgICAgICAgcmVuZGVyZXIuY29udGV4dFtyZW5kZXJlci5zbW9vdGhQcm9wZXJ0eV0gPSAocmVuZGVyZXIuY3VycmVudFNjYWxlTW9kZSA9PT0gQ09OU1QuU0NBTEVfTU9ERVMuTElORUFSKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSB0ZXh0dXJlIGlzIHRyaW1tZWQgd2Ugb2Zmc2V0IGJ5IHRoZSB0cmltIHgveSwgb3RoZXJ3aXNlIHdlIHVzZSB0aGUgZnJhbWUgZGltZW5zaW9uc1xuXG4gICAgICAgIGlmKHRleHR1cmUucm90YXRlKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIC8vIGNoZWVreSByb3RhdGlvbiFcbiAgICAgICAgICAgIHZhciBhID0gd3QuYTtcbiAgICAgICAgICAgIHZhciBiID0gd3QuYjtcblxuICAgICAgICAgICAgd3QuYSAgPSAtd3QuYztcbiAgICAgICAgICAgIHd0LmIgID0gLXd0LmQ7XG4gICAgICAgICAgICB3dC5jICA9ICBhO1xuICAgICAgICAgICAgd3QuZCAgPSAgYjtcblxuICAgICAgICAgICAgd2lkdGggPSB0ZXh0dXJlLmNyb3AuaGVpZ2h0O1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGV4dHVyZS5jcm9wLndpZHRoO1xuXG4gICAgICAgICAgICBkeCA9ICh0ZXh0dXJlLnRyaW0pID8gdGV4dHVyZS50cmltLnkgLSB0aGlzLmFuY2hvci55ICogdGV4dHVyZS50cmltLmhlaWdodCA6IHRoaXMuYW5jaG9yLnkgKiAtdGV4dHVyZS5fZnJhbWUuaGVpZ2h0O1xuICAgICAgICAgICAgZHkgPSAodGV4dHVyZS50cmltKSA/IHRleHR1cmUudHJpbS54IC0gdGhpcy5hbmNob3IueCAqIHRleHR1cmUudHJpbS53aWR0aCA6IHRoaXMuYW5jaG9yLnggKiAtdGV4dHVyZS5fZnJhbWUud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aCA9IHRleHR1cmUuY3JvcC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHRleHR1cmUuY3JvcC5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGR4ID0gKHRleHR1cmUudHJpbSkgPyB0ZXh0dXJlLnRyaW0ueCAtIHRoaXMuYW5jaG9yLnggKiB0ZXh0dXJlLnRyaW0ud2lkdGggOiB0aGlzLmFuY2hvci54ICogLXRleHR1cmUuX2ZyYW1lLndpZHRoO1xuICAgICAgICAgICAgZHkgPSAodGV4dHVyZS50cmltKSA/IHRleHR1cmUudHJpbS55IC0gdGhpcy5hbmNob3IueSAqIHRleHR1cmUudHJpbS5oZWlnaHQgOiB0aGlzLmFuY2hvci55ICogLXRleHR1cmUuX2ZyYW1lLmhlaWdodDtcbiAgICAgICAgfVxuXG5cblxuICAgICAgICAvLyBBbGxvdyBmb3IgcGl4ZWwgcm91bmRpbmdcbiAgICAgICAgaWYgKHJlbmRlcmVyLnJvdW5kUGl4ZWxzKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJlci5jb250ZXh0LnNldFRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICB3dC5hLFxuICAgICAgICAgICAgICAgIHd0LmIsXG4gICAgICAgICAgICAgICAgd3QuYyxcbiAgICAgICAgICAgICAgICB3dC5kLFxuICAgICAgICAgICAgICAgICh3dC50eCAqIHJlbmRlcmVyLnJlc29sdXRpb24pIHwgMCxcbiAgICAgICAgICAgICAgICAod3QudHkgKiByZW5kZXJlci5yZXNvbHV0aW9uKSB8IDBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGR4ID0gZHggfCAwO1xuICAgICAgICAgICAgZHkgPSBkeSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIHJlbmRlcmVyLmNvbnRleHQuc2V0VHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgIHd0LmEsXG4gICAgICAgICAgICAgICAgd3QuYixcbiAgICAgICAgICAgICAgICB3dC5jLFxuICAgICAgICAgICAgICAgIHd0LmQsXG4gICAgICAgICAgICAgICAgd3QudHggKiByZW5kZXJlci5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIHd0LnR5ICogcmVuZGVyZXIucmVzb2x1dGlvblxuICAgICAgICAgICAgKTtcblxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50aW50ICE9PSAweEZGRkZGRilcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVkVGludCAhPT0gdGhpcy50aW50KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkVGludCA9IHRoaXMudGludDtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gY2xlYW4gdXAgY2FjaGluZyAtIGhvdyB0byBjbGVhbiB1cCB0aGUgY2FjaGVzP1xuICAgICAgICAgICAgICAgIHRoaXMudGludGVkVGV4dHVyZSA9IENhbnZhc1RpbnRlci5nZXRUaW50ZWRUZXh0dXJlKHRoaXMsIHRoaXMudGludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcmVyLmNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgIHRoaXMudGludGVkVGV4dHVyZSxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgd2lkdGggKiByZXNvbHV0aW9uICogcmVuZGVyZXIucmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICBoZWlnaHQgKiByZXNvbHV0aW9uICogcmVuZGVyZXIucmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICBkeCAvIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgZHkgLyByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIHdpZHRoICogcmVuZGVyZXIucmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICBoZWlnaHQgKiByZW5kZXJlci5yZXNvbHV0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyZXIuY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5jcm9wLnggKiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIHRleHR1cmUuY3JvcC55ICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICB3aWR0aCAqIHJlc29sdXRpb24gKiByZW5kZXJlci5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIGhlaWdodCAqIHJlc29sdXRpb24gKiByZW5kZXJlci5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIGR4IC8gcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICBkeSAvIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgd2lkdGggKiByZW5kZXJlci5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIGhlaWdodCAqIHJlbmRlcmVyLnJlc29sdXRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgc3ByaXRlIGFuZCBvcHRpb25hbGx5IGl0cyB0ZXh0dXJlXG4gKlxuICogQHBhcmFtIGRlc3Ryb3lUZXh0dXJlIHtib29sZWFufSBTaG91bGQgaXQgZGVzdHJveSB0aGUgY3VycmVudCB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICogQHBhcmFtIGRlc3Ryb3lCYXNlVGV4dHVyZSB7Ym9vbGVhbn0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAqL1xuU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGRlc3Ryb3lUZXh0dXJlLCBkZXN0cm95QmFzZVRleHR1cmUpXG57XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmFuY2hvciA9IG51bGw7XG5cbiAgICBpZiAoZGVzdHJveVRleHR1cmUpXG4gICAge1xuICAgICAgICB0aGlzLl90ZXh0dXJlLmRlc3Ryb3koZGVzdHJveUJhc2VUZXh0dXJlKTtcbiAgICB9XG5cbiAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG59O1xuXG4vLyBzb21lIGhlbHBlciBmdW5jdGlvbnMuLlxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGZyb20gdGhlIFRleHR1cmVDYWNoZSBiYXNlZCBvbiB0aGUgZnJhbWVJZFxuICogVGhlIGZyYW1lIGlkcyBhcmUgY3JlYXRlZCB3aGVuIGEgVGV4dHVyZSBwYWNrZXIgZmlsZSBoYXMgYmVlbiBsb2FkZWRcbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gZnJhbWVJZCB7U3RyaW5nfSBUaGUgZnJhbWUgSWQgb2YgdGhlIHRleHR1cmUgaW4gdGhlIGNhY2hlXG4gKiBAcmV0dXJuIHtTcHJpdGV9IEEgbmV3IFNwcml0ZSB1c2luZyBhIHRleHR1cmUgZnJvbSB0aGUgdGV4dHVyZSBjYWNoZSBtYXRjaGluZyB0aGUgZnJhbWVJZFxuICogQHBhcmFtIFtjcm9zc29yaWdpbj0oYXV0byldIHtib29sZWFufSBpZiB5b3Ugd2FudCB0byBzcGVjaWZ5IHRoZSBjcm9zcy1vcmlnaW4gcGFyYW1ldGVyXG4gKiBAcGFyYW0gW3NjYWxlTW9kZT1zY2FsZU1vZGVzLkRFRkFVTFRdIHtudW1iZXJ9IGlmIHlvdSB3YW50IHRvIHNwZWNpZnkgdGhlIHNjYWxlIG1vZGUsIHNlZSB7QGxpbmsgU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqL1xuU3ByaXRlLmZyb21GcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUlkKVxue1xuICAgIHZhciB0ZXh0dXJlID0gdXRpbHMuVGV4dHVyZUNhY2hlW2ZyYW1lSWRdO1xuXG4gICAgaWYgKCF0ZXh0dXJlKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnJhbWVJZCBcIicgKyBmcmFtZUlkICsgJ1wiIGRvZXMgbm90IGV4aXN0IGluIHRoZSB0ZXh0dXJlIGNhY2hlICcgKyB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNwcml0ZSh0ZXh0dXJlKTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIHNwcml0ZSB0aGF0IHdpbGwgY29udGFpbiBhIHRleHR1cmUgYmFzZWQgb24gYW4gaW1hZ2UgdXJsXG4gKiBJZiB0aGUgaW1hZ2UgaXMgbm90IGluIHRoZSB0ZXh0dXJlIGNhY2hlIGl0IHdpbGwgYmUgbG9hZGVkXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGltYWdlSWQge1N0cmluZ30gVGhlIGltYWdlIHVybCBvZiB0aGUgdGV4dHVyZVxuICogQHJldHVybiB7U3ByaXRlfSBBIG5ldyBTcHJpdGUgdXNpbmcgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmUgY2FjaGUgbWF0Y2hpbmcgdGhlIGltYWdlIGlkXG4gKi9cblNwcml0ZS5mcm9tSW1hZ2UgPSBmdW5jdGlvbiAoaW1hZ2VJZCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSlcbntcbiAgICByZXR1cm4gbmV3IFNwcml0ZShUZXh0dXJlLmZyb21JbWFnZShpbWFnZUlkLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKSk7XG59O1xuIiwidmFyIE9iamVjdFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vLi4vcmVuZGVyZXJzL3dlYmdsL3V0aWxzL09iamVjdFJlbmRlcmVyJyksXG4gICAgV2ViR0xSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uL3JlbmRlcmVycy93ZWJnbC9XZWJHTFJlbmRlcmVyJyksXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi8uLi9jb25zdCcpO1xuXG4vKipcbiAqIEBhdXRob3IgTWF0IEdyb3Zlc1xuICpcbiAqIEJpZyB0aGFua3MgdG8gdGhlIHZlcnkgY2xldmVyIE1hdHQgRGVzTGF1cmllcnMgPG1hdHRkZXNsPiBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvXG4gKiBmb3IgY3JlYXRpbmcgdGhlIG9yaWdpbmFsIHBpeGkgdmVyc2lvbiFcbiAqIEFsc28gYSB0aGFua3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL2JjaGV2YWxpZXIgZm9yIHR3ZWFraW5nIHRoZSB0aW50IGFuZCBhbHBoYSBzbyB0aGF0IHRoZXkgbm93IHNoYXJlIDQgYnl0ZXMgb24gdGhlIHZlcnRleCBidWZmZXJcbiAqXG4gKiBIZWF2aWx5IGluc3BpcmVkIGJ5IExpYkdEWCdzIFNwcml0ZVJlbmRlcmVyOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi9tYXN0ZXIvZ2R4L3NyYy9jb20vYmFkbG9naWMvZ2R4L2dyYXBoaWNzL2cyZC9TcHJpdGVSZW5kZXJlci5qYXZhXG4gKi9cblxuLyoqXG4gKlxuICogQGNsYXNzXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBleHRlbmRzIE9iamVjdFJlbmRlcmVyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1dlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIHNwcml0ZSBiYXRjaCB3b3JrcyBmb3IuXG4gKi9cbmZ1bmN0aW9uIFNwcml0ZVJlbmRlcmVyKHJlbmRlcmVyKVxue1xuICAgIE9iamVjdFJlbmRlcmVyLmNhbGwodGhpcywgcmVuZGVyZXIpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRTaXplID0gNTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0Qnl0ZVNpemUgPSB0aGlzLnZlcnRTaXplICogNDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaW1hZ2VzIGluIHRoZSBTcHJpdGVCYXRjaCBiZWZvcmUgaXQgZmx1c2hlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNpemUgPSBDT05TVC5TUFJJVEVfQkFUQ0hfU0laRTsgLy8gMjAwMCBpcyBhIG5pY2UgYmFsYW5jZSBiZXR3ZWVuIG1vYmlsZSAvIGRlc2t0b3BcblxuICAgIC8vIHRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgaW4gb3VyIGJhdGNoXG4gICAgdmFyIG51bVZlcnRzID0gdGhpcy5zaXplICogNCAqIHRoaXMudmVydEJ5dGVTaXplO1xuICAgIC8vIHRoZSB0b3RhbCBudW1iZXIgb2YgaW5kaWNlcyBpbiBvdXIgYmF0Y2hcbiAgICB2YXIgbnVtSW5kaWNlcyA9IHRoaXMuc2l6ZSAqIDY7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgdmVydGljZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0FycmF5QnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSBuZXcgQXJyYXlCdWZmZXIobnVtVmVydHMpO1xuXG4gICAgLyoqXG4gICAgICogVmlldyBvbiB0aGUgdmVydGljZXMgYXMgYSBGbG9hdDMyQXJyYXlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0aWNlcyk7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgY29sb3IgY29tcG9uZW50c1xuICAgICAqXG4gICAgICogQG1lbWJlciB7VWludDMyQXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcnMgPSBuZXcgVWludDMyQXJyYXkodGhpcy52ZXJ0aWNlcyk7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgaW5kaWNlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7VWludDE2QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KG51bUluZGljZXMpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RJbmRleENvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGk9MCwgaj0wOyBpIDwgbnVtSW5kaWNlczsgaSArPSA2LCBqICs9IDQpXG4gICAge1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDBdID0gaiArIDA7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMV0gPSBqICsgMTtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAyXSA9IGogKyAyO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDNdID0gaiArIDA7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgNF0gPSBqICsgMjtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyA1XSA9IGogKyAzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZHJhd2luZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRCYXRjaFNpemUgPSAwO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Jhc2VUZXh0dXJlfVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudEJhc2VUZXh0dXJlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmVzID0gW107XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQG1lbWJlciB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ibGVuZE1vZGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQG1lbWJlciB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zaGFkZXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQG1lbWJlciB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zcHJpdGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzaGFkZXIgdGhhdCBpcyB1c2VkIGlmIGEgc3ByaXRlIGRvZXNuJ3QgaGF2ZSBhIG1vcmUgc3BlY2lmaWMgb25lLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7U2hhZGVyfVxuICAgICAqL1xuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcblxufVxuXG5TcHJpdGVSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdFJlbmRlcmVyLnByb3RvdHlwZSk7XG5TcHJpdGVSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcHJpdGVSZW5kZXJlcjtcbm1vZHVsZS5leHBvcnRzID0gU3ByaXRlUmVuZGVyZXI7XG5cbldlYkdMUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ3Nwcml0ZScsIFNwcml0ZVJlbmRlcmVyKTtcblxuLyoqXG4gKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICovXG5TcHJpdGVSZW5kZXJlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgLy8gc2V0dXAgZGVmYXVsdCBzaGFkZXJcbiAgICB0aGlzLnNoYWRlciA9IHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5kZWZhdWx0U2hhZGVyO1xuXG4gICAgLy8gY3JlYXRlIGEgY291cGxlIG9mIGJ1ZmZlcnNcbiAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIC8vIDY1NTM1IGlzIG1heCBpbmRleCwgc28gNjU1MzUgLyA2ID0gMTA5MjIuXG5cbiAgICAvL3VwbG9hZCB0aGUgaW5kZXggZGF0YVxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0aWNlcywgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgIHRoaXMuY3VycmVudEJsZW5kTW9kZSA9IDk5OTk5O1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzcHJpdGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBzcHJpdGUge1Nwcml0ZX0gdGhlIHNwcml0ZSB0byByZW5kZXIgd2hlbiB1c2luZyB0aGlzIHNwcml0ZWJhdGNoXG4gKi9cblNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3ByaXRlKVxue1xuICAgIHZhciB0ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xuXG4gICAgLy9UT0RPIHNldCBibGVuZCBtb2Rlcy4uXG4gICAgLy8gY2hlY2sgdGV4dHVyZS4uXG4gICAgaWYgKHRoaXMuY3VycmVudEJhdGNoU2l6ZSA+PSB0aGlzLnNpemUpXG4gICAge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHV2cyBmb3IgdGhlIHRleHR1cmVcbiAgICB2YXIgdXZzID0gdGV4dHVyZS5fdXZzO1xuXG4gICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxuICAgIGlmICghdXZzKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRPRE8gdHJpbT8/XG4gICAgdmFyIGFYID0gc3ByaXRlLmFuY2hvci54O1xuICAgIHZhciBhWSA9IHNwcml0ZS5hbmNob3IueTtcblxuICAgIHZhciB3MCwgdzEsIGgwLCBoMTtcblxuICAgIGlmICh0ZXh0dXJlLnRyaW0pXG4gICAge1xuICAgICAgICAvLyBpZiB0aGUgc3ByaXRlIGlzIHRyaW1tZWQgdGhlbiB3ZSBuZWVkIHRvIGFkZCB0aGUgZXh0cmEgc3BhY2UgYmVmb3JlIHRyYW5zZm9ybWluZyB0aGUgc3ByaXRlIGNvb3Jkcy4uXG4gICAgICAgIHZhciB0cmltID0gdGV4dHVyZS50cmltO1xuXG4gICAgICAgIHcxID0gdHJpbS54IC0gYVggKiB0cmltLndpZHRoO1xuICAgICAgICB3MCA9IHcxICsgdGV4dHVyZS5jcm9wLndpZHRoO1xuXG4gICAgICAgIGgxID0gdHJpbS55IC0gYVkgKiB0cmltLmhlaWdodDtcbiAgICAgICAgaDAgPSBoMSArIHRleHR1cmUuY3JvcC5oZWlnaHQ7XG5cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdzAgPSAodGV4dHVyZS5fZnJhbWUud2lkdGggKSAqICgxLWFYKTtcbiAgICAgICAgdzEgPSAodGV4dHVyZS5fZnJhbWUud2lkdGggKSAqIC1hWDtcblxuICAgICAgICBoMCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAqICgxLWFZKTtcbiAgICAgICAgaDEgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgKiAtYVk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5jdXJyZW50QmF0Y2hTaXplICogdGhpcy52ZXJ0Qnl0ZVNpemU7XG5cbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBzcHJpdGUud29ybGRUcmFuc2Zvcm07XG5cbiAgICB2YXIgYSA9IHdvcmxkVHJhbnNmb3JtLmE7XG4gICAgdmFyIGIgPSB3b3JsZFRyYW5zZm9ybS5iO1xuICAgIHZhciBjID0gd29ybGRUcmFuc2Zvcm0uYztcbiAgICB2YXIgZCA9IHdvcmxkVHJhbnNmb3JtLmQ7XG4gICAgdmFyIHR4ID0gd29ybGRUcmFuc2Zvcm0udHg7XG4gICAgdmFyIHR5ID0gd29ybGRUcmFuc2Zvcm0udHk7XG5cbiAgICB2YXIgY29sb3JzID0gdGhpcy5jb2xvcnM7XG4gICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMucG9zaXRpb25zO1xuXG4gICAgaWYgKHRoaXMucmVuZGVyZXIucm91bmRQaXhlbHMpXG4gICAge1xuICAgICAgICAvLyB4eVxuICAgICAgICBwb3NpdGlvbnNbaW5kZXhdID0gYSAqIHcxICsgYyAqIGgxICsgdHggfCAwO1xuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrMV0gPSBkICogaDEgKyBiICogdzEgKyB0eSB8IDA7XG5cbiAgICAgICAgLy8geHlcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzVdID0gYSAqIHcwICsgYyAqIGgxICsgdHggfCAwO1xuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrNl0gPSBkICogaDEgKyBiICogdzAgKyB0eSB8IDA7XG5cbiAgICAgICAgIC8vIHh5XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsxMF0gPSBhICogdzAgKyBjICogaDAgKyB0eCB8IDA7XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsxMV0gPSBkICogaDAgKyBiICogdzAgKyB0eSB8IDA7XG5cbiAgICAgICAgLy8geHlcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzE1XSA9IGEgKiB3MSArIGMgKiBoMCArIHR4IHwgMDtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzE2XSA9IGQgKiBoMCArIGIgKiB3MSArIHR5IHwgMDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy8geHlcbiAgICAgICAgcG9zaXRpb25zW2luZGV4XSA9IGEgKiB3MSArIGMgKiBoMSArIHR4O1xuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrMV0gPSBkICogaDEgKyBiICogdzEgKyB0eTtcblxuICAgICAgICAvLyB4eVxuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrNV0gPSBhICogdzAgKyBjICogaDEgKyB0eDtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzZdID0gZCAqIGgxICsgYiAqIHcwICsgdHk7XG5cbiAgICAgICAgIC8vIHh5XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsxMF0gPSBhICogdzAgKyBjICogaDAgKyB0eDtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzExXSA9IGQgKiBoMCArIGIgKiB3MCArIHR5O1xuXG4gICAgICAgIC8vIHh5XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsxNV0gPSBhICogdzEgKyBjICogaDAgKyB0eDtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KzE2XSA9IGQgKiBoMCArIGIgKiB3MSArIHR5O1xuICAgIH1cblxuICAgIC8vIHV2XG4gICAgcG9zaXRpb25zW2luZGV4KzJdID0gdXZzLngwO1xuICAgIHBvc2l0aW9uc1tpbmRleCszXSA9IHV2cy55MDtcblxuICAgIC8vIHV2XG4gICAgcG9zaXRpb25zW2luZGV4KzddID0gdXZzLngxO1xuICAgIHBvc2l0aW9uc1tpbmRleCs4XSA9IHV2cy55MTtcblxuICAgICAvLyB1dlxuICAgIHBvc2l0aW9uc1tpbmRleCsxMl0gPSB1dnMueDI7XG4gICAgcG9zaXRpb25zW2luZGV4KzEzXSA9IHV2cy55MjtcblxuICAgIC8vIHV2XG4gICAgcG9zaXRpb25zW2luZGV4KzE3XSA9IHV2cy54MztcbiAgICBwb3NpdGlvbnNbaW5kZXgrMThdID0gdXZzLnkzO1xuXG4gICAgLy8gY29sb3IgYW5kIGFscGhhXG4gICAgdmFyIHRpbnQgPSBzcHJpdGUudGludDtcbiAgICBjb2xvcnNbaW5kZXgrNF0gPSBjb2xvcnNbaW5kZXgrOV0gPSBjb2xvcnNbaW5kZXgrMTRdID0gY29sb3JzW2luZGV4KzE5XSA9ICh0aW50ID4+IDE2KSArICh0aW50ICYgMHhmZjAwKSArICgodGludCAmIDB4ZmYpIDw8IDE2KSArIChzcHJpdGUud29ybGRBbHBoYSAqIDI1NSA8PCAyNCk7XG5cbiAgICAvLyBpbmNyZW1lbnQgdGhlIGJhdGNoc2l6ZVxuICAgIHRoaXMuc3ByaXRlc1t0aGlzLmN1cnJlbnRCYXRjaFNpemUrK10gPSBzcHJpdGU7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGNvbnRlbnQgYW5kIGVtcHRpZXMgdGhlIGN1cnJlbnQgYmF0Y2guXG4gKlxuICovXG5TcHJpdGVSZW5kZXJlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIElmIHRoZSBiYXRjaCBpcyBsZW5ndGggMCB0aGVuIHJldHVybiBhcyB0aGVyZSBpcyBub3RoaW5nIHRvIGRyYXdcbiAgICBpZiAodGhpcy5jdXJyZW50QmF0Y2hTaXplID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgdmFyIHNoYWRlcjtcblxuICAgIC8vIHVwbG9hZCB0aGUgdmVydHMgdG8gdGhlIGJ1ZmZlclxuICAgIGlmICh0aGlzLmN1cnJlbnRCYXRjaFNpemUgPiAoIHRoaXMuc2l6ZSAqIDAuNSApIClcbiAgICB7XG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLnZlcnRpY2VzKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnBvc2l0aW9ucy5zdWJhcnJheSgwLCB0aGlzLmN1cnJlbnRCYXRjaFNpemUgKiB0aGlzLnZlcnRCeXRlU2l6ZSk7XG4gICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB2aWV3KTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFRleHR1cmUsIG5leHRCbGVuZE1vZGUsIG5leHRTaGFkZXI7XG4gICAgdmFyIGJhdGNoU2l6ZSA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gMDtcblxuICAgIHZhciBjdXJyZW50QmFzZVRleHR1cmUgPSBudWxsO1xuICAgIHZhciBjdXJyZW50QmxlbmRNb2RlID0gdGhpcy5yZW5kZXJlci5ibGVuZE1vZGVNYW5hZ2VyLmN1cnJlbnRCbGVuZE1vZGU7XG4gICAgdmFyIGN1cnJlbnRTaGFkZXIgPSBudWxsO1xuXG4gICAgdmFyIGJsZW5kU3dhcCA9IGZhbHNlO1xuICAgIHZhciBzaGFkZXJTd2FwID0gZmFsc2U7XG4gICAgdmFyIHNwcml0ZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5jdXJyZW50QmF0Y2hTaXplOyBpIDwgajsgaSsrKVxuICAgIHtcblxuICAgICAgICBzcHJpdGUgPSB0aGlzLnNwcml0ZXNbaV07XG5cbiAgICAgICAgbmV4dFRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgIG5leHRCbGVuZE1vZGUgPSBzcHJpdGUuYmxlbmRNb2RlO1xuICAgICAgICBuZXh0U2hhZGVyID0gc3ByaXRlLnNoYWRlciB8fCB0aGlzLnNoYWRlcjtcblxuICAgICAgICBibGVuZFN3YXAgPSBjdXJyZW50QmxlbmRNb2RlICE9PSBuZXh0QmxlbmRNb2RlO1xuICAgICAgICBzaGFkZXJTd2FwID0gY3VycmVudFNoYWRlciAhPT0gbmV4dFNoYWRlcjsgLy8gc2hvdWxkIEkgdXNlIHV1aWRTPz8/XG5cbiAgICAgICAgaWYgKGN1cnJlbnRCYXNlVGV4dHVyZSAhPT0gbmV4dFRleHR1cmUgfHwgYmxlbmRTd2FwIHx8IHNoYWRlclN3YXApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQmF0Y2goY3VycmVudEJhc2VUZXh0dXJlLCBiYXRjaFNpemUsIHN0YXJ0KTtcblxuICAgICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICAgICAgYmF0Y2hTaXplID0gMDtcbiAgICAgICAgICAgIGN1cnJlbnRCYXNlVGV4dHVyZSA9IG5leHRUZXh0dXJlO1xuXG4gICAgICAgICAgICBpZiAoYmxlbmRTd2FwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCbGVuZE1vZGUgPSBuZXh0QmxlbmRNb2RlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoIGN1cnJlbnRCbGVuZE1vZGUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNoYWRlclN3YXApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3VycmVudFNoYWRlciA9IG5leHRTaGFkZXI7XG5cblxuXG4gICAgICAgICAgICAgICAgc2hhZGVyID0gY3VycmVudFNoYWRlci5zaGFkZXJzID8gY3VycmVudFNoYWRlci5zaGFkZXJzW2dsLmlkXSA6IGN1cnJlbnRTaGFkZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNoYWRlcilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRlciA9IGN1cnJlbnRTaGFkZXIuZ2V0U2hhZGVyKHRoaXMucmVuZGVyZXIpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2V0IHNoYWRlciBmdW5jdGlvbj8/P1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoc2hhZGVyKTtcblxuICAgICAgICAgICAgICAgIC8vVE9ETyAtIGkgS05PVyB0aGlzIGNhbiBiZSBvcHRpbWlzZWQhIE9uY2UgdjMgaXMgc3RhYmxlIGlsIGxvb2sgYXQgdGhpcyBuZXh0Li4uXG4gICAgICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgudmFsdWUgPSB0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpO1xuICAgICAgICAgICAgICAgIC8vTWFrZSB0aGlzIGEgbGl0dGxlIG1vcmUgZHluYW1pYyAvIGludGVsbGlnZW50IVxuICAgICAgICAgICAgICAgIHNoYWRlci5zeW5jVW5pZm9ybXMoKTtcblxuICAgICAgICAgICAgICAgIC8vVE9ETyBpbnZlc3RpZ2F0ZSBzb21lIGtpbmQgb2YgdGV4dHVyZSBzdGF0ZSBtYW5hZ21lbnQ/P1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gbWFrZSBzdXJlIHRoaXMgdGV4dHVyZSBpcyB0aGUgYWN0aXZlIG9uZSBmb3IgYWxsIHRoZSBiYXRjaCBzd2Fwcy4uXG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBib3RoIHRoZWFzZSBvbmx5IG5lZWQgdG8gYmUgc2V0IGlmIHRoZXkgYXJlIGNoYW5naW5nLi5cbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHByb2plY3Rpb25cbiAgICAgICAgICAgICAgICAvL2dsLnVuaWZvcm1NYXRyaXgzZnYoc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXguX2xvY2F0aW9uLCBmYWxzZSwgdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgudG9BcnJheSh0cnVlKSk7XG5cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYmF0Y2hTaXplKys7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJCYXRjaChjdXJyZW50QmFzZVRleHR1cmUsIGJhdGNoU2l6ZSwgc3RhcnQpO1xuXG4gICAgLy8gdGhlbiByZXNldCB0aGUgYmF0Y2ghXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hTaXplID0gMDtcbn07XG5cbi8qKlxuICogRHJhd3MgdGhlIGN1cnJlbnRseSBiYXRjaGVzIHNwcml0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfVxuICogQHBhcmFtIHNpemUge251bWJlcn1cbiAqIEBwYXJhbSBzdGFydEluZGV4IHtudW1iZXJ9XG4gKi9cblNwcml0ZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJCYXRjaCA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzaXplLCBzdGFydEluZGV4KVxue1xuICAgIGlmIChzaXplID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICBpZiAoIXRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKVxuICAgIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVUZXh0dXJlKHRleHR1cmUpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICAvLyBiaW5kIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pO1xuICAgIH1cblxuICAgIC8vIG5vdyBkcmF3IHRob3NlIHN1Y2thcyFcbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBzaXplICogNiwgZ2wuVU5TSUdORURfU0hPUlQsIHN0YXJ0SW5kZXggKiA2ICogMik7XG5cbiAgICAvLyBpbmNyZW1lbnQgdGhlIGRyYXcgY291bnRcbiAgICB0aGlzLnJlbmRlcmVyLmRyYXdDb3VudCsrO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBuZXcgc3ByaXRlIGJhdGNoLlxuICpcbiAqL1xuU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgLy8gYmluZCB0aGUgbWFpbiB0ZXh0dXJlXG5cblxuICAgIC8vIGJpbmQgdGhlIGJ1ZmZlcnNcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuXG4gICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBmb3IgZWFjaCBzaGFkZXI/XG4gICAgdmFyIHN0cmlkZSA9ICB0aGlzLnZlcnRCeXRlU2l6ZTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSwgMCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5hdHRyaWJ1dGVzLmFUZXh0dXJlQ29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgc3RyaWRlLCAyICogNCk7XG5cbiAgICAvLyBjb2xvciBhdHRyaWJ1dGVzIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgdW5zaWduZWQgYnl0ZXMgYW5kIG5vcm1hbGl6ZWRcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuc2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCA0LCBnbC5VTlNJR05FRF9CWVRFLCB0cnVlLCBzdHJpZGUsIDQgKiA0KTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIFNwcml0ZUJhdGNoLlxuICpcbiAqL1xuU3ByaXRlUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMucmVuZGVyZXIuZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICB0aGlzLnJlbmRlcmVyLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyKTtcblxuICAgIHRoaXMuc2hhZGVyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuXG4gICAgdGhpcy52ZXJ0aWNlcyA9IG51bGw7XG4gICAgdGhpcy5wb3NpdGlvbnMgPSBudWxsO1xuICAgIHRoaXMuY29sb3JzID0gbnVsbDtcbiAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuXG4gICAgdGhpcy5jdXJyZW50QmFzZVRleHR1cmUgPSBudWxsO1xuXG4gICAgdGhpcy5kcmF3aW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLnRleHR1cmVzID0gbnVsbDtcbiAgICB0aGlzLmJsZW5kTW9kZXMgPSBudWxsO1xuICAgIHRoaXMuc2hhZGVycyA9IG51bGw7XG4gICAgdGhpcy5zcHJpdGVzID0gbnVsbDtcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG59O1xuIiwidmFyIFNwcml0ZSA9IHJlcXVpcmUoJy4uL3Nwcml0ZXMvU3ByaXRlJyksXG4gICAgVGV4dHVyZSA9IHJlcXVpcmUoJy4uL3RleHR1cmVzL1RleHR1cmUnKSxcbiAgICBtYXRoID0gcmVxdWlyZSgnLi4vbWF0aCcpLFxuICAgIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxuLyoqXG4gKiBBIFRleHQgT2JqZWN0IHdpbGwgY3JlYXRlIGEgbGluZSBvciBtdWx0aXBsZSBsaW5lcyBvZiB0ZXh0LiBUbyBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbicgaW4geW91ciB0ZXh0IHN0cmluZyxcbiAqIG9yIGFkZCBhIHdvcmRXcmFwIHByb3BlcnR5IHNldCB0byB0cnVlIGFuZCBhbmQgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eSB3aXRoIGEgdmFsdWUgaW4gdGhlIHN0eWxlIG9iamVjdC5cbiAqXG4gKiBBIFRleHQgY2FuIGJlIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBhIHN0cmluZyBhbmQgYSBzdHlsZSBvYmplY3RcbiAqXG4gKiBgYGBqc1xuICogdmFyIHRleHQgPSBuZXcgUElYSS5UZXh0KCdUaGlzIGlzIGEgcGl4aSB0ZXh0Jyx7Zm9udCA6ICcyNHB4IEFyaWFsJywgZmlsbCA6IDB4ZmYxMDEwLCBhbGlnbiA6ICdjZW50ZXInfSk7XG4gKiBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFNwcml0ZVxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSB0ZXh0IHtzdHJpbmd9IFRoZSBjb3B5IHRoYXQgeW91IHdvdWxkIGxpa2UgdGhlIHRleHQgdG8gZGlzcGxheVxuICogQHBhcmFtIFtzdHlsZV0ge29iamVjdH0gVGhlIHN0eWxlIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBbc3R5bGUuZm9udF0ge3N0cmluZ30gZGVmYXVsdCAnYm9sZCAyMHB4IEFyaWFsJyBUaGUgc3R5bGUgYW5kIHNpemUgb2YgdGhlIGZvbnRcbiAqIEBwYXJhbSBbc3R5bGUuZmlsbD0nYmxhY2snXSB7U3RyaW5nfE51bWJlcn0gQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IGUuZyAncmVkJywgJyMwMEZGMDAnXG4gKiBAcGFyYW0gW3N0eWxlLmFsaWduPSdsZWZ0J10ge3N0cmluZ30gQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcbiAqIEBwYXJhbSBbc3R5bGUuc3Ryb2tlXSB7U3RyaW5nfE51bWJlcn0gQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IHN0cm9rZSBlLmcgJ2JsdWUnLCAnI0ZDRkYwMCdcbiAqIEBwYXJhbSBbc3R5bGUuc3Ryb2tlVGhpY2tuZXNzPTBdIHtudW1iZXJ9IEEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgdGhpY2tuZXNzIG9mIHRoZSBzdHJva2UuIERlZmF1bHQgaXMgMCAobm8gc3Ryb2tlKVxuICogQHBhcmFtIFtzdHlsZS53b3JkV3JhcD1mYWxzZV0ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB3b3JkIHdyYXAgc2hvdWxkIGJlIHVzZWRcbiAqIEBwYXJhbSBbc3R5bGUud29yZFdyYXBXaWR0aD0xMDBdIHtudW1iZXJ9IFRoZSB3aWR0aCBhdCB3aGljaCB0ZXh0IHdpbGwgd3JhcCwgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWVcbiAqIEBwYXJhbSBbc3R5bGUubGluZUhlaWdodF0ge251bWJlcn0gVGhlIGxpbmUgaGVpZ2h0LCBhIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIHZlcnRpY2FsIHNwYWNlIHRoYXQgYSBsZXR0ZXIgdXNlc1xuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93PWZhbHNlXSB7Ym9vbGVhbn0gU2V0IGEgZHJvcCBzaGFkb3cgZm9yIHRoZSB0ZXh0XG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dDb2xvcj0nIzAwMDAwMCddIHtzdHJpbmd9IEEgZmlsbCBzdHlsZSB0byBiZSB1c2VkIG9uIHRoZSBkcm9wc2hhZG93IGUuZyAncmVkJywgJyMwMEZGMDAnXG4gKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dBbmdsZT1NYXRoLlBJLzRdIHtudW1iZXJ9IFNldCBhIGFuZ2xlIG9mIHRoZSBkcm9wIHNoYWRvd1xuICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U9NV0ge251bWJlcn0gU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93XG4gKiBAcGFyYW0gW3N0eWxlLnBhZGRpbmc9MF0ge251bWJlcn0gT2NjYXNpb25hbGx5IHNvbWUgZm9udHMgYXJlIGNyb3BwZWQuIEFkZGluZyBzb21lIHBhZGRpbmcgd2lsbCBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmdcbiAqIEBwYXJhbSBbc3R5bGUudGV4dEJhc2VsaW5lPSdhbHBoYWJldGljJ10ge3N0cmluZ30gVGhlIGJhc2VsaW5lIG9mIHRoZSB0ZXh0IHRoYXQgaXMgcmVuZGVyZWQuXG4gKiBAcGFyYW0gW3N0eWxlLmxpbmVKb2luPSdtaXRlciddIHtzdHJpbmd9IFRoZSBsaW5lSm9pbiBwcm9wZXJ0eSBzZXRzIHRoZSB0eXBlIG9mIGNvcm5lciBjcmVhdGVkLCBpdCBjYW4gcmVzb2x2ZVxuICogICAgICBzcGlrZWQgdGV4dCBpc3N1ZXMuIERlZmF1bHQgaXMgJ21pdGVyJyAoY3JlYXRlcyBhIHNoYXJwIGNvcm5lcikuXG4gKiBAcGFyYW0gW3N0eWxlLm1pdGVyTGltaXQ9MTBdIHtudW1iZXJ9IFRoZSBtaXRlciBsaW1pdCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ21pdGVyJyBsaW5lSm9pbiBtb2RlLiBUaGlzIGNhbiByZWR1Y2VcbiAqICAgICAgb3IgaW5jcmVhc2UgdGhlIHNwaWtpbmVzcyBvZiByZW5kZXJlZCB0ZXh0LlxuICovXG5mdW5jdGlvbiBUZXh0KHRleHQsIHN0eWxlLCByZXNvbHV0aW9uKVxue1xuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0aGF0IGV2ZXJ5dGhpbmcgaXMgZHJhd24gdG9cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzIDJkIGNvbnRleHQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHdpdGhcbiAgICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc29sdXRpb24gb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBDT05TVC5SRVNPTFVUSU9OO1xuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCB0ZXh0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGV4dCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3R5bGUgPSBudWxsO1xuXG4gICAgdmFyIHRleHR1cmUgPSBUZXh0dXJlLmZyb21DYW52YXModGhpcy5jYW52YXMpO1xuICAgIHRleHR1cmUudHJpbSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgpO1xuICAgIFNwcml0ZS5jYWxsKHRoaXMsIHRleHR1cmUpO1xuXG5cbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbn1cblxuLy8gY29uc3RydWN0b3JcblRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTcHJpdGUucHJvdG90eXBlKTtcblRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dDtcbm1vZHVsZS5leHBvcnRzID0gVGV4dDtcblxuVGV4dC5mb250UHJvcGVydGllc0NhY2hlID0ge307XG5UZXh0LmZvbnRQcm9wZXJ0aWVzQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5UZXh0LmZvbnRQcm9wZXJ0aWVzQ29udGV4dCA9IFRleHQuZm9udFByb3BlcnRpZXNDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGV4dC5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIFRleHQsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFRleHQjXG4gICAgICovXG4gICAgd2lkdGg6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUueCAqIHRoaXMuX3RleHR1cmUuX2ZyYW1lLndpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gdmFsdWUgLyB0aGlzLl90ZXh0dXJlLl9mcmFtZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgVGV4dCwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgVGV4dCNcbiAgICAgKi9cbiAgICBoZWlnaHQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICB0aGlzLnNjYWxlLnkgKiB0aGlzLl90ZXh0dXJlLl9mcmFtZS5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIHRoaXMuX3RleHR1cmUuX2ZyYW1lLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc3R5bGUgb2YgdGhlIHRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBbc3R5bGVdIHtvYmplY3R9IFRoZSBzdHlsZSBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIFtzdHlsZS5mb250PSdib2xkIDIwcHQgQXJpYWwnXSB7c3RyaW5nfSBUaGUgc3R5bGUgYW5kIHNpemUgb2YgdGhlIGZvbnRcbiAgICAgKiBAcGFyYW0gW3N0eWxlLmZpbGw9J2JsYWNrJ10ge29iamVjdH0gQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IGVnICdyZWQnLCAnIzAwRkYwMCdcbiAgICAgKiBAcGFyYW0gW3N0eWxlLmFsaWduPSdsZWZ0J10ge3N0cmluZ30gQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcbiAgICAgKiBAcGFyYW0gW3N0eWxlLnN0cm9rZT0nYmxhY2snXSB7c3RyaW5nfSBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlIGVnICdibHVlJywgJyNGQ0ZGMDAnXG4gICAgICogQHBhcmFtIFtzdHlsZS5zdHJva2VUaGlja25lc3M9MF0ge251bWJlcn0gQSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB0aGlja25lc3Mgb2YgdGhlIHN0cm9rZS4gRGVmYXVsdCBpcyAwIChubyBzdHJva2UpXG4gICAgICogQHBhcmFtIFtzdHlsZS53b3JkV3JhcD1mYWxzZV0ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB3b3JkIHdyYXAgc2hvdWxkIGJlIHVzZWRcbiAgICAgKiBAcGFyYW0gW3N0eWxlLndvcmRXcmFwV2lkdGg9MTAwXSB7bnVtYmVyfSBUaGUgd2lkdGggYXQgd2hpY2ggdGV4dCB3aWxsIHdyYXBcbiAgICAgKiBAcGFyYW0gW3N0eWxlLmxpbmVIZWlnaHRdIHtudW1iZXJ9IFRoZSBsaW5lIGhlaWdodCwgYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IGEgbGV0dGVyIHVzZXNcbiAgICAgKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3c9ZmFsc2VdIHtib29sZWFufSBTZXQgYSBkcm9wIHNoYWRvdyBmb3IgdGhlIHRleHRcbiAgICAgKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dDb2xvcj0nIzAwMDAwMCddIHtzdHJpbmd9IEEgZmlsbCBzdHlsZSB0byBiZSB1c2VkIG9uIHRoZSBkcm9wc2hhZG93IGUuZyAncmVkJywgJyMwMEZGMDAnXG4gICAgICogQHBhcmFtIFtzdHlsZS5kcm9wU2hhZG93QW5nbGU9TWF0aC5QSS82XSB7bnVtYmVyfSBTZXQgYSBhbmdsZSBvZiB0aGUgZHJvcCBzaGFkb3dcbiAgICAgKiBAcGFyYW0gW3N0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZT01XSB7bnVtYmVyfSBTZXQgYSBkaXN0YW5jZSBvZiB0aGUgZHJvcCBzaGFkb3dcbiAgICAgKiBAcGFyYW0gW3N0eWxlLnBhZGRpbmc9MF0ge251bWJlcn0gT2NjYXNpb25hbGx5IHNvbWUgZm9udHMgYXJlIGNyb3BwZWQuIEFkZGluZyBzb21lIHBhZGRpbmcgd2lsbCBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmdcbiAgICAgKiBAcGFyYW0gW3N0eWxlLnRleHRCYXNlbGluZT0nYWxwaGFiZXRpYyddIHtzdHJpbmd9IFRoZSBiYXNlbGluZSBvZiB0aGUgdGV4dCB0aGF0IGlzIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSBbc3R5bGUubGluZUpvaW49J21pdGVyJ10ge3N0cmluZ30gVGhlIGxpbmVKb2luIHByb3BlcnR5IHNldHMgdGhlIHR5cGUgb2YgY29ybmVyIGNyZWF0ZWQsIGl0IGNhbiByZXNvbHZlXG4gICAgICogICAgICBzcGlrZWQgdGV4dCBpc3N1ZXMuIERlZmF1bHQgaXMgJ21pdGVyJyAoY3JlYXRlcyBhIHNoYXJwIGNvcm5lcikuXG4gICAgICogQHBhcmFtIFtzdHlsZS5taXRlckxpbWl0PTEwXSB7bnVtYmVyfSBUaGUgbWl0ZXIgbGltaXQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdtaXRlcicgbGluZUpvaW4gbW9kZS4gVGhpcyBjYW4gcmVkdWNlXG4gICAgICogICAgICBvciBpbmNyZWFzZSB0aGUgc3Bpa2luZXNzIG9mIHJlbmRlcmVkIHRleHQuXG4gICAgICogQG1lbWJlcm9mIFRleHQjXG4gICAgICovXG4gICAgc3R5bGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHN0eWxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgc3R5bGUuZm9udCA9IHN0eWxlLmZvbnQgfHwgJ2JvbGQgMjBwdCBBcmlhbCc7XG4gICAgICAgICAgICBzdHlsZS5maWxsID0gc3R5bGUuZmlsbCB8fCAnYmxhY2snO1xuICAgICAgICAgICAgc3R5bGUuYWxpZ24gPSBzdHlsZS5hbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgICAgICBzdHlsZS5zdHJva2UgPSBzdHlsZS5zdHJva2UgfHwgJ2JsYWNrJzsgLy9wcm92aWRlIGEgZGVmYXVsdCwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vR29vZEJveURpZ2l0YWwvcGl4aS5qcy9pc3N1ZXMvMTM2XG4gICAgICAgICAgICBzdHlsZS5zdHJva2VUaGlja25lc3MgPSBzdHlsZS5zdHJva2VUaGlja25lc3MgfHwgMDtcbiAgICAgICAgICAgIHN0eWxlLndvcmRXcmFwID0gc3R5bGUud29yZFdyYXAgfHwgZmFsc2U7XG4gICAgICAgICAgICBzdHlsZS53b3JkV3JhcFdpZHRoID0gc3R5bGUud29yZFdyYXBXaWR0aCB8fCAxMDA7XG5cbiAgICAgICAgICAgIHN0eWxlLmRyb3BTaGFkb3cgPSBzdHlsZS5kcm9wU2hhZG93IHx8IGZhbHNlO1xuICAgICAgICAgICAgc3R5bGUuZHJvcFNoYWRvd0NvbG9yID0gc3R5bGUuZHJvcFNoYWRvd0NvbG9yIHx8ICcjMDAwMDAwJztcbiAgICAgICAgICAgIHN0eWxlLmRyb3BTaGFkb3dBbmdsZSA9IHN0eWxlLmRyb3BTaGFkb3dBbmdsZSB8fCBNYXRoLlBJIC8gNjtcbiAgICAgICAgICAgIHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSA9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSB8fCA1O1xuXG4gICAgICAgICAgICBzdHlsZS5wYWRkaW5nID0gc3R5bGUucGFkZGluZyB8fCAwO1xuXG4gICAgICAgICAgICBzdHlsZS50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmUgfHwgJ2FscGhhYmV0aWMnO1xuXG4gICAgICAgICAgICBzdHlsZS5saW5lSm9pbiA9IHN0eWxlLmxpbmVKb2luIHx8ICdtaXRlcic7XG4gICAgICAgICAgICBzdHlsZS5taXRlckxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdCB8fCAxMDtcblxuICAgICAgICAgICAgdGhpcy5fc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29weSBmb3IgdGhlIHRleHQgb2JqZWN0LiBUbyBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbicuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGV4dCB7c3RyaW5nfSBUaGUgY29weSB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSB0ZXh0IHRvIGRpc3BsYXlcbiAgICAgKiBAbWVtYmVyb2YgVGV4dCNcbiAgICAgKi9cbiAgICB0ZXh0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodGV4dCl7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC50b1N0cmluZygpIHx8ICcgJztcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0ID09PSB0ZXh0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBSZW5kZXJzIHRleHQgYW5kIHVwZGF0ZXMgaXQgd2hlbiBuZWVkZWRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5UZXh0LnByb3RvdHlwZS51cGRhdGVUZXh0ID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcbiAgICB0aGlzLmNvbnRleHQuZm9udCA9IHN0eWxlLmZvbnQ7XG5cbiAgICAvLyB3b3JkIHdyYXBcbiAgICAvLyBwcmVzZXJ2ZSBvcmlnaW5hbCB0ZXh0XG4gICAgdmFyIG91dHB1dFRleHQgPSBzdHlsZS53b3JkV3JhcCA/IHRoaXMud29yZFdyYXAodGhpcy5fdGV4dCkgOiB0aGlzLl90ZXh0O1xuXG4gICAgLy8gc3BsaXQgdGV4dCBpbnRvIGxpbmVzXG4gICAgdmFyIGxpbmVzID0gb3V0cHV0VGV4dC5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGV4dCB3aWR0aFxuICAgIHZhciBsaW5lV2lkdGhzID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XG4gICAgdmFyIG1heExpbmVXaWR0aCA9IDA7XG4gICAgdmFyIGZvbnRQcm9wZXJ0aWVzID0gdGhpcy5kZXRlcm1pbmVGb250UHJvcGVydGllcyhzdHlsZS5mb250KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGg7XG4gICAgICAgIGxpbmVXaWR0aHNbaV0gPSBsaW5lV2lkdGg7XG4gICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGluZVdpZHRoKTtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBtYXhMaW5lV2lkdGggKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpXG4gICAge1xuICAgICAgICB3aWR0aCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfVxuXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSAoIHdpZHRoICsgdGhpcy5jb250ZXh0LmxpbmVXaWR0aCApICogdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRleHQgaGVpZ2h0XG4gICAgdmFyIGxpbmVIZWlnaHQgPSB0aGlzLnN0eWxlLmxpbmVIZWlnaHQgfHwgZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XG5cbiAgICB2YXIgaGVpZ2h0ID0gbGluZUhlaWdodCAqIGxpbmVzLmxlbmd0aDtcbiAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdylcbiAgICB7XG4gICAgICAgIGhlaWdodCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfVxuXG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gKCBoZWlnaHQgKyB0aGlzLl9zdHlsZS5wYWRkaW5nICogMiApICogdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgdGhpcy5jb250ZXh0LnNjYWxlKCB0aGlzLnJlc29sdXRpb24sIHRoaXMucmVzb2x1dGlvbik7XG5cbiAgICBpZiAobmF2aWdhdG9yLmlzQ29jb29uSlMpXG4gICAge1xuICAgICAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgfVxuXG4gICAgLy90aGlzLmNvbnRleHQuZmlsbFN0eWxlPVwiI0ZGMDAwMFwiO1xuICAgIC8vdGhpcy5jb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgdGhpcy5jb250ZXh0LmZvbnQgPSBzdHlsZS5mb250O1xuICAgIHRoaXMuY29udGV4dC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICB0aGlzLmNvbnRleHQubGluZVdpZHRoID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgIHRoaXMuY29udGV4dC50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgdGhpcy5jb250ZXh0LmxpbmVKb2luID0gc3R5bGUubGluZUpvaW47XG4gICAgdGhpcy5jb250ZXh0Lm1pdGVyTGltaXQgPSBzdHlsZS5taXRlckxpbWl0O1xuXG4gICAgdmFyIGxpbmVQb3NpdGlvblg7XG4gICAgdmFyIGxpbmVQb3NpdGlvblk7XG5cbiAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdylcbiAgICB7XG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSBzdHlsZS5kcm9wU2hhZG93Q29sb3I7XG5cbiAgICAgICAgdmFyIHhTaGFkb3dPZmZzZXQgPSBNYXRoLmNvcyhzdHlsZS5kcm9wU2hhZG93QW5nbGUpICogc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgICB2YXIgeVNoYWRvd09mZnNldCA9IE1hdGguc2luKHN0eWxlLmRyb3BTaGFkb3dBbmdsZSkgKiBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblkgPSAoc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMiArIGkgKiBsaW5lSGVpZ2h0KSArIGZvbnRQcm9wZXJ0aWVzLmFzY2VudDtcblxuICAgICAgICAgICAgaWYgKHN0eWxlLmFsaWduID09PSAncmlnaHQnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSAnY2VudGVyJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldKSAvIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5maWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dChsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCArIHhTaGFkb3dPZmZzZXQsIGxpbmVQb3NpdGlvblkgKyB5U2hhZG93T2Zmc2V0ICsgdGhpcy5fc3R5bGUucGFkZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL3NldCBjYW52YXMgdGV4dCBzdHlsZXNcbiAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gc3R5bGUuZmlsbDtcblxuICAgIC8vZHJhdyBsaW5lcyBsaW5lIGJ5IGxpbmVcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBsaW5lUG9zaXRpb25YID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICAgICAgbGluZVBvc2l0aW9uWSA9IChzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyICsgaSAqIGxpbmVIZWlnaHQpICsgZm9udFByb3BlcnRpZXMuYXNjZW50O1xuXG4gICAgICAgIGlmIChzdHlsZS5hbGlnbiA9PT0gJ3JpZ2h0JylcbiAgICAgICAge1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSAnY2VudGVyJylcbiAgICAgICAge1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlLnN0cm9rZSAmJiBzdHlsZS5zdHJva2VUaGlja25lc3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJva2VUZXh0KGxpbmVzW2ldLCBsaW5lUG9zaXRpb25YLCBsaW5lUG9zaXRpb25ZICsgdGhpcy5fc3R5bGUucGFkZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3R5bGUuZmlsbClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KGxpbmVzW2ldLCBsaW5lUG9zaXRpb25YLCBsaW5lUG9zaXRpb25ZICsgdGhpcy5fc3R5bGUucGFkZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0ZXh0dXJlIHNpemUgYmFzZWQgb24gY2FudmFzIHNpemVcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5UZXh0LnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG5cbiAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZCA9IHRydWU7XG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgdGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRleHR1cmUuYmFzZVRleHR1cmUuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRleHR1cmUuY3JvcC53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGV4dHVyZS5jcm9wLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcblxuICAgIHRleHR1cmUudHJpbS54ID0gMDtcbiAgICB0ZXh0dXJlLnRyaW0ueSA9IC10aGlzLl9zdHlsZS5wYWRkaW5nO1xuXG4gICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGg7XG4gICAgdGV4dHVyZS50cmltLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAtIHRoaXMuX3N0eWxlLnBhZGRpbmcqMjtcblxuICAgIHRoaXMuX3dpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uO1xuXG4gICAgdGV4dHVyZS51cGRhdGUoKTtcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn1cbiAqL1xuVGV4dC5wcm90b3R5cGUucmVuZGVyV2ViR0wgPSBmdW5jdGlvbiAocmVuZGVyZXIpXG57XG4gICAgaWYgKHRoaXMuZGlydHkpXG4gICAge1xuICAgICAgICAvL3RoaXMucmVzb2x1dGlvbiA9IDEvL3JlbmRlcmVyLnJlc29sdXRpb247XG5cbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgfVxuXG4gICAgU3ByaXRlLnByb3RvdHlwZS5yZW5kZXJXZWJHTC5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge0NhbnZhc1JlbmRlcmVyfVxuICogQHByaXZhdGVcbiAqL1xuVGV4dC5wcm90b3R5cGUuX3JlbmRlckNhbnZhcyA9IGZ1bmN0aW9uIChyZW5kZXJlcilcbntcbiAgICBpZiAodGhpcy5kaXJ0eSlcbiAgICB7XG4gICAgIC8vICAgdGhpcy5yZXNvbHV0aW9uID0gMS8vcmVuZGVyZXIucmVzb2x1dGlvbjtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbiAgICB9XG5cbiAgICBTcHJpdGUucHJvdG90eXBlLl9yZW5kZXJDYW52YXMuY2FsbCh0aGlzLCByZW5kZXJlcik7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFzY2VudCwgZGVzY2VudCBhbmQgZm9udFNpemUgb2YgYSBnaXZlbiBmb250U3R5bGVcbiAqXG4gKiBAcGFyYW0gZm9udFN0eWxlIHtvYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5UZXh0LnByb3RvdHlwZS5kZXRlcm1pbmVGb250UHJvcGVydGllcyA9IGZ1bmN0aW9uIChmb250U3R5bGUpXG57XG4gICAgdmFyIHByb3BlcnRpZXMgPSBUZXh0LmZvbnRQcm9wZXJ0aWVzQ2FjaGVbZm9udFN0eWxlXTtcblxuICAgIGlmICghcHJvcGVydGllcylcbiAgICB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7fTtcblxuICAgICAgICB2YXIgY2FudmFzID0gVGV4dC5mb250UHJvcGVydGllc0NhbnZhcztcbiAgICAgICAgdmFyIGNvbnRleHQgPSBUZXh0LmZvbnRQcm9wZXJ0aWVzQ29udGV4dDtcblxuICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250U3R5bGU7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQoJ3xNw4lxJykud2lkdGgpO1xuICAgICAgICB2YXIgYmFzZWxpbmUgPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dCgnTScpLndpZHRoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IDIgKiBiYXNlbGluZTtcblxuICAgICAgICBiYXNlbGluZSA9IGJhc2VsaW5lICogMS40IHwgMDtcblxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjZjAwJztcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250U3R5bGU7XG5cbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMwMDAnO1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KCd8TcOJcScsIDAsIGJhc2VsaW5lKTtcblxuICAgICAgICB2YXIgaW1hZ2VkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgICAgdmFyIHBpeGVscyA9IGltYWdlZGF0YS5sZW5ndGg7XG4gICAgICAgIHZhciBsaW5lID0gd2lkdGggKiA0O1xuXG4gICAgICAgIHZhciBpLCBqO1xuXG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgc3RvcCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGFzY2VudC4gc2NhbiBmcm9tIHRvcCB0byBib3R0b20gdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJhc2VsaW5lOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsaW5lOyBqICs9IDQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqXSAhPT0gMjU1KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RvcClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZHggKz0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BlcnRpZXMuYXNjZW50ID0gYmFzZWxpbmUgLSBpO1xuXG4gICAgICAgIGlkeCA9IHBpeGVscyAtIGxpbmU7XG4gICAgICAgIHN0b3AgPSBmYWxzZTtcblxuICAgICAgICAvLyBkZXNjZW50LiBzY2FuIGZyb20gYm90dG9tIHRvIHRvcCB1bnRpbCB3ZSBmaW5kIGEgbm9uIHJlZCBwaXhlbFxuICAgICAgICBmb3IgKGkgPSBoZWlnaHQ7IGkgPiBiYXNlbGluZTsgaS0tKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGluZTsgaiArPSA0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChpbWFnZWRhdGFbaWR4ICsgal0gIT09IDI1NSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0b3ApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWR4IC09IGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wZXJ0aWVzLmRlc2NlbnQgPSBpIC0gYmFzZWxpbmU7XG4gICAgICAgIHByb3BlcnRpZXMuZm9udFNpemUgPSBwcm9wZXJ0aWVzLmFzY2VudCArIHByb3BlcnRpZXMuZGVzY2VudDtcblxuICAgICAgICBUZXh0LmZvbnRQcm9wZXJ0aWVzQ2FjaGVbZm9udFN0eWxlXSA9IHByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgbmV3bGluZXMgdG8gYSBzdHJpbmcgdG8gaGF2ZSBpdCBvcHRpbWFsbHkgZml0IGludG8gdGhlIGhvcml6b250YWxcbiAqIGJvdW5kcyBzZXQgYnkgdGhlIFRleHQgb2JqZWN0J3Mgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gdGV4dCB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuVGV4dC5wcm90b3R5cGUud29yZFdyYXAgPSBmdW5jdGlvbiAodGV4dClcbntcbiAgICAvLyBHcmVlZHkgd3JhcHBpbmcgYWxnb3JpdGhtIHRoYXQgd2lsbCB3cmFwIHdvcmRzIGFzIHRoZSBsaW5lIGdyb3dzIGxvbmdlclxuICAgIC8vIHRoYW4gaXRzIGhvcml6b250YWwgYm91bmRzLlxuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgd29yZFdyYXBXaWR0aCA9IHRoaXMuX3N0eWxlLndvcmRXcmFwV2lkdGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBzcGFjZUxlZnQgPSB3b3JkV3JhcFdpZHRoO1xuICAgICAgICB2YXIgd29yZHMgPSBsaW5lc1tpXS5zcGxpdCgnICcpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHdvcmRzLmxlbmd0aDsgaisrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgd29yZFdpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHdvcmRzW2pdKS53aWR0aDtcbiAgICAgICAgICAgIHZhciB3b3JkV2lkdGhXaXRoU3BhY2UgPSB3b3JkV2lkdGggKyB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQoJyAnKS53aWR0aDtcbiAgICAgICAgICAgIGlmIChqID09PSAwIHx8IHdvcmRXaWR0aFdpdGhTcGFjZSA+IHNwYWNlTGVmdClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHByaW50aW5nIHRoZSBuZXdsaW5lIGlmIGl0J3MgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGxpbmUgdGhhdCBpc1xuICAgICAgICAgICAgICAgIC8vIGdyZWF0ZXIgdGhhbiB0aGUgd29yZCB3cmFwIHdpZHRoLlxuICAgICAgICAgICAgICAgIGlmIChqID4gMClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdvcmRzW2pdO1xuICAgICAgICAgICAgICAgIHNwYWNlTGVmdCA9IHdvcmRXcmFwV2lkdGggLSB3b3JkV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3BhY2VMZWZ0IC09IHdvcmRXaWR0aFdpdGhTcGFjZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAnICsgd29yZHNbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA8IGxpbmVzLmxlbmd0aC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBUZXh0IGFzIGEgcmVjdGFuZ2xlLiBUaGUgYm91bmRzIGNhbGN1bGF0aW9uIHRha2VzIHRoZSB3b3JsZFRyYW5zZm9ybSBpbnRvIGFjY291bnQuXG4gKlxuICogQHBhcmFtIG1hdHJpeCB7TWF0cml4fSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSBUZXh0XG4gKiBAcmV0dXJuIHtSZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICovXG5UZXh0LnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAobWF0cml4KVxue1xuICAgIGlmICh0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNwcml0ZS5wcm90b3R5cGUuZ2V0Qm91bmRzLmNhbGwodGhpcywgbWF0cml4KTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhpcyB0ZXh0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZGVzdHJveUJhc2VUZXh0dXJlIHtib29sZWFufSB3aGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXG4gKi9cblRleHQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZGVzdHJveUJhc2VUZXh0dXJlKVxue1xuICAgIC8vIG1ha2Ugc3VyZSB0byByZXNldCB0aGUgdGhlIGNvbnRleHQgYW5kIGNhbnZhcy4uIGRvbnQgd2FudCB0aGlzIGhhbmdpbmcgYXJvdW5kIGluIG1lbW9yeSFcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuY2FudmFzID0gbnVsbDtcblxuICAgIHRoaXMuX3RleHR1cmUuZGVzdHJveShkZXN0cm95QmFzZVRleHR1cmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBkZXN0cm95QmFzZVRleHR1cmUpO1xufTtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyksXG4gICAgQ09OU1QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qKlxuICogQSB0ZXh0dXJlIHN0b3JlcyB0aGUgaW5mb3JtYXRpb24gdGhhdCByZXByZXNlbnRzIGFuIGltYWdlLiBBbGwgdGV4dHVyZXMgaGF2ZSBhIGJhc2UgdGV4dHVyZS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gc291cmNlIHtJbWFnZXxDYW52YXN9IHRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSB0ZXh0dXJlLlxuICogQHBhcmFtIFtzY2FsZU1vZGU9c2NhbGVNb2Rlcy5ERUZBVUxUXSB7bnVtYmVyfSBTZWUge0BsaW5rIFNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcGFyYW0gcmVzb2x1dGlvbiB7bnVtYmVyfSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgdGV4dHVyZSBmb3IgZGV2aWNlcyB3aXRoIGRpZmZlcmVudCBwaXhlbCByYXRpb3NcbiAqL1xuZnVuY3Rpb24gQmFzZVRleHR1cmUoc291cmNlLCBzY2FsZU1vZGUsIHJlc29sdXRpb24pXG57XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnV1aWQgPSB1dGlscy51dWlkKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgUmVzb2x1dGlvbiBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGJhc2UgdGV4dHVyZSBzZXQgd2hlbiB0aGUgaW1hZ2UgaGFzIGxvYWRlZFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBiYXNlIHRleHR1cmUgc2V0IHdoZW4gdGhlIGltYWdlIGhhcyBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDEwMDtcblxuICAgIC8vIFRPRE8gZG9jc1xuICAgIC8vIHVzZWQgdG8gc3RvcmUgdGhlIGFjdHVhbCBkaW1lbnNpb25zIG9mIHRoZSBzb3VyY2VcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHN0b3JlIHRoZSBhY3R1YWwgd2lkdGggb2YgdGhlIHNvdXJjZSBvZiB0aGlzIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnJlYWxXaWR0aCA9IDEwMDtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHN0b3JlIHRoZSBhY3R1YWwgaGVpZ2h0IG9mIHRoZSBzb3VyY2Ugb2YgdGhpcyB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5yZWFsSGVpZ2h0ID0gMTAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNjYWxlIG1vZGUgdG8gYXBwbHkgd2hlbiBzY2FsaW5nIHRoaXMgdGV4dHVyZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7e251bWJlcn19XG4gICAgICogQGRlZmF1bHQgc2NhbGVNb2Rlcy5MSU5FQVJcbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZSB8fCBDT05TVC5TQ0FMRV9NT0RFUy5ERUZBVUxUO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgb25jZSB0aGUgYmFzZSB0ZXh0dXJlIGhhcyBzdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBuZXZlciB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBmYWlscyB0byBsb2FkIG9yIGhhcyBubyB0ZXh0dXJlIGRhdGEuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMuaGFzTG9hZGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB0aGUgc291cmNlIGlzIGN1cnJlbnRseSBsb2FkaW5nLlxuICAgICAqXG4gICAgICogSWYgYW4gSW1hZ2Ugc291cmNlIGlzIGxvYWRpbmcgdGhlICdsb2FkZWQnIG9yICdlcnJvcicgZXZlbnQgd2lsbCBiZVxuICAgICAqIGRpc3BhdGNoZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGVuZHMuIEFuIHVuZGVyeWxpbmcgc291cmNlIHRoYXQgaXNcbiAgICAgKiBpbW1lZGlhdGVseS1hdmFpbGFibGUgYnlwYXNzZXMgbG9hZGluZyBlbnRpcmVseS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBzb3VyY2UgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIFRPRE86IE1ha2UgdGhpcyBhIHNldHRlciB0aGF0IGNhbGxzIGxvYWRTb3VyY2UoKTtcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0ltYWdlfENhbnZhc31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7IC8vIHNldCBpbiBsb2FkU291cmNlLCBpZiBhdCBhbGxcblxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIGlmIFJHQiBjaGFubmVscyBzaG91bGQgYmUgcHJlLW11bHRpcGxpZWQgYnkgQWxwaGEgIChXZWJHTCBvbmx5KVxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VVcmwgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2V0aGVyIG9yIG5vdCB0aGUgdGV4dHVyZSBpcyBhIHBvd2VyIG9mIHR3bywgdHJ5IHRvIHVzZSBwb3dlciBvZiB0d28gdGV4dHVyZXMgYXMgbXVjaCBhcyB5b3UgY2FuXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNQb3dlck9mVHdvID0gZmFsc2U7XG5cbiAgICAvLyB1c2VkIGZvciB3ZWJHTFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIGEgbWlwbWFwIG9mIHRoaXMgdGV4dHVyZSBuZWVkcyB0byBiZSBnZW5lcmF0ZWQuIFRoaXMgdmFsdWUgbmVlZHMgdG8gYmUgc2V0IGJlZm9yZSB0aGUgdGV4dHVyZSBpcyB1c2VkXG4gICAgICogQWxzbyB0aGUgdGV4dHVyZSBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvIHNpemUgdG8gd29ya1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm1pcG1hcCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQSBtYXAgb2YgcmVuZGVyZXIgSURzIHRvIHdlYmdsIHRleHR1cmVzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3Q8bnVtYmVyLCBXZWJHTFRleHR1cmU+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZ2xUZXh0dXJlcyA9IFtdO1xuXG4gICAgLy8gaWYgbm8gc291cmNlIHBhc3NlZCBkb24ndCB0cnkgdG8gbG9hZFxuICAgIGlmIChzb3VyY2UpXG4gICAge1xuICAgICAgICB0aGlzLmxvYWRTb3VyY2Uoc291cmNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgbm90LWltbWVkaWF0ZWx5LWF2YWlsYWJsZSBzb3VyY2UgZmluaXNoZXMgbG9hZGluZy5cbiAgICAgKlxuICAgICAqIEBldmVudCBsb2FkZWRcbiAgICAgKiBAbWVtYmVyb2YgQmFzZVRleHR1cmUjXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBhIG5vdC1pbW1lZGlhdGVseS1hdmFpbGFibGUgc291cmNlIGZhaWxzIHRvIGxvYWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgZXJyb3JcbiAgICAgKiBAbWVtYmVyb2YgQmFzZVRleHR1cmUjXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xufVxuXG5CYXNlVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuQmFzZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmFzZVRleHR1cmU7XG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VUZXh0dXJlO1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHRleHR1cmUgb24gYWxsIHRoZSB3ZWJnbCByZW5kZXJlcnMuXG4gKlxuICogQGZpcmVzIHVwZGF0ZVxuICovXG5CYXNlVGV4dHVyZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBMb2FkIGEgc291cmNlLlxuICpcbiAqIElmIHRoZSBzb3VyY2UgaXMgbm90LWltbWVkaWF0ZWx5LWF2YWlsYWJsZSwgc3VjaCBhcyBhbiBpbWFnZSB0aGF0IG5lZWRzIHRvIGJlXG4gKiBkb3dubG9hZGVkLCB0aGVuIHRoZSAnbG9hZGVkJyBvciAnZXJyb3InIGV2ZW50IHdpbGwgYmUgZGlzcGF0Y2hlZCBpbiB0aGUgZnV0dXJlXG4gKiBhbmQgYGhhc0xvYWRlZGAgd2lsbCByZW1haW4gZmFsc2UgYWZ0ZXIgdGhpcyBjYWxsLlxuICpcbiAqIFRoZSBsb2dpYyBzdGF0ZSBhZnRlciBjYWxsaW5nIGBsb2FkU291cmNlYCBkaXJlY3RseSBvciBpbmRpcmVjdGx5IChlZy4gYGZyb21JbWFnZWAsIGBuZXcgQmFzZVRleHR1cmVgKSBpczpcbiAqXG4gKiAgICAgaWYgKHRleHR1cmUuaGFzTG9hZGVkKVxuIHtcbiAqICAgICAgICAvLyB0ZXh0dXJlIHJlYWR5IGZvciB1c2VcbiAqICAgICB9IGVsc2UgaWYgKHRleHR1cmUuaXNMb2FkaW5nKVxuIHtcbiAqICAgICAgICAvLyBsaXN0ZW4gdG8gJ2xvYWRlZCcgYW5kL29yICdlcnJvcicgZXZlbnRzIG9uIHRleHR1cmVcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgIC8vIG5vdCBsb2FkaW5nLCBub3QgZ29pbmcgdG8gbG9hZCBVTkxFU1MgdGhlIHNvdXJjZSBpcyByZWxvYWRlZFxuICogICAgICAgIC8vIChpdCBtYXkgc3RpbGwgbWFrZSBzZW5zZSB0byBsaXN0ZW4gdG8gdGhlIGV2ZW50cylcbiAqICAgICB9XG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHNvdXJjZSB7SW1hZ2V8Q2FudmFzfSB0aGUgc291cmNlIG9iamVjdCBvZiB0aGUgdGV4dHVyZS5cbiAqL1xuQmFzZVRleHR1cmUucHJvdG90eXBlLmxvYWRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlKVxue1xuICAgIHZhciB3YXNMb2FkaW5nID0gdGhpcy5pc0xvYWRpbmc7XG4gICAgdGhpcy5oYXNMb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgaWYgKHdhc0xvYWRpbmcgJiYgdGhpcy5zb3VyY2UpXG4gICAge1xuICAgICAgICB0aGlzLnNvdXJjZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZS5vbmVycm9yID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgIC8vIEFwcGx5IHNvdXJjZSBpZiBsb2FkZWQuIE90aGVyd2lzZSBzZXR1cCBhcHByb3ByaWF0ZSBsb2FkaW5nIG1vbml0b3JzLlxuICAgIGlmICgodGhpcy5zb3VyY2UuY29tcGxldGUgfHwgdGhpcy5zb3VyY2UuZ2V0Q29udGV4dCkgJiYgdGhpcy5zb3VyY2Uud2lkdGggJiYgdGhpcy5zb3VyY2UuaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgdGhpcy5fc291cmNlTG9hZGVkKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFzb3VyY2UuZ2V0Q29udGV4dClcbiAgICB7XG5cbiAgICAgICAgLy8gSW1hZ2UgZmFpbCAvIG5vdCByZWFkeVxuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICBzb3VyY2Uub25sb2FkID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgc291cmNlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICBzb3VyY2Uub25lcnJvciA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICghc2NvcGUuaXNMb2FkaW5nKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NvcGUuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBzY29wZS5fc291cmNlTG9hZGVkKCk7XG5cbiAgICAgICAgICAgIHNjb3BlLmVtaXQoJ2xvYWRlZCcsIHNjb3BlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzb3VyY2Uub25lcnJvciA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNvdXJjZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgc291cmNlLm9uZXJyb3IgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoIXNjb3BlLmlzTG9hZGluZylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgc2NvcGUuZW1pdCgnZXJyb3InLCBzY29wZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGVyIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI3RoZS1pbWctZWxlbWVudFxuICAgICAgICAvLyAgIFwiVGhlIHZhbHVlIG9mIGBjb21wbGV0ZWAgY2FuIHRodXMgY2hhbmdlIHdoaWxlIGEgc2NyaXB0IGlzIGV4ZWN1dGluZy5cIlxuICAgICAgICAvLyBTbyBjb21wbGV0ZSBuZWVkcyB0byBiZSByZS1jaGVja2VkIGFmdGVyIHRoZSBjYWxsYmFja3MgaGF2ZSBiZWVuIGFkZGVkLi5cbiAgICAgICAgLy8gTk9URTogY29tcGxldGUgd2lsbCBiZSB0cnVlIGlmIHRoZSBpbWFnZSBoYXMgbm8gc3JjIHNvIGJlc3QgdG8gY2hlY2sgaWYgdGhlIHNyYyBpcyBzZXQuXG4gICAgICAgIGlmIChzb3VyY2UuY29tcGxldGUgJiYgc291cmNlLnNyYylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gLi5hbmQgaWYgd2UncmUgY29tcGxldGUgbm93LCBubyBuZWVkIGZvciBjYWxsYmFja3NcbiAgICAgICAgICAgIHNvdXJjZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgc291cmNlLm9uZXJyb3IgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoc291cmNlLndpZHRoICYmIHNvdXJjZS5oZWlnaHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlTG9hZGVkKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgcHJldmlvdXMgc3Vic2NyaWJlcnMgcG9zc2libGVcbiAgICAgICAgICAgICAgICBpZiAod2FzTG9hZGluZylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9hZGVkJywgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIElmIGFueSBwcmV2aW91cyBzdWJzY3JpYmVycyBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIGlmICh3YXNMb2FkaW5nKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogVXNlZCBpbnRlcm5hbGx5IHRvIHVwZGF0ZSB0aGUgd2lkdGgsIGhlaWdodCwgYW5kIHNvbWUgb3RoZXIgdHJhY2tpbmcgdmFycyBvbmNlXG4gKiBhIHNvdXJjZSBoYXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5CYXNlVGV4dHVyZS5wcm90b3R5cGUuX3NvdXJjZUxvYWRlZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5oYXNMb2FkZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5yZWFsV2lkdGggPSB0aGlzLnNvdXJjZS5uYXR1cmFsV2lkdGggfHwgdGhpcy5zb3VyY2Uud2lkdGg7XG4gICAgdGhpcy5yZWFsSGVpZ2h0ID0gdGhpcy5zb3VyY2UubmF0dXJhbEhlaWdodCB8fCB0aGlzLnNvdXJjZS5oZWlnaHQ7XG5cbiAgICB0aGlzLndpZHRoID0gdGhpcy5yZWFsV2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLnJlYWxIZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XG5cblxuICAgIHRoaXMuaXNQb3dlck9mVHdvID0gdXRpbHMuaXNQb3dlck9mVHdvKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgYmFzZSB0ZXh0dXJlXG4gKlxuICovXG5CYXNlVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuaW1hZ2VVcmwpXG4gICAge1xuICAgICAgICBkZWxldGUgdXRpbHMuQmFzZVRleHR1cmVDYWNoZVt0aGlzLmltYWdlVXJsXTtcbiAgICAgICAgZGVsZXRlIHV0aWxzLlRleHR1cmVDYWNoZVt0aGlzLmltYWdlVXJsXTtcblxuICAgICAgICB0aGlzLmltYWdlVXJsID0gbnVsbDtcblxuICAgICAgICBpZiAoIW5hdmlnYXRvci5pc0NvY29vbkpTKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5zcmMgPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5fcGl4aUlkKVxuICAgIHtcbiAgICAgICAgZGVsZXRlIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbdGhpcy5zb3VyY2UuX3BpeGlJZF07XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuXG4gICAgdGhpcy5kaXNwb3NlKCk7XG59O1xuXG4vKipcbiAqIEZyZWVzIHRoZSB0ZXh0dXJlIGZyb20gV2ViR0wgbWVtb3J5IHdpdGhvdXQgZGVzdHJveWluZyB0aGlzIHRleHR1cmUgb2JqZWN0LlxuICogVGhpcyBtZWFucyB5b3UgY2FuIHN0aWxsIHVzZSB0aGUgdGV4dHVyZSBsYXRlciB3aGljaCB3aWxsIHVwbG9hZCBpdCB0byBHUFVcbiAqIG1lbW9yeSBhZ2Fpbi5cbiAqXG4gKi9cbkJhc2VUZXh0dXJlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmVtaXQoJ2Rpc3Bvc2UnLCB0aGlzKTtcbn07XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgc291cmNlIGltYWdlIG9mIHRoZSB0ZXh0dXJlLlxuICogVGhlIG9yaWdpbmFsIHNvdXJjZSBtdXN0IGJlIGFuIEltYWdlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIG5ld1NyYyB7c3RyaW5nfSB0aGUgcGF0aCBvZiB0aGUgaW1hZ2VcbiAqL1xuQmFzZVRleHR1cmUucHJvdG90eXBlLnVwZGF0ZVNvdXJjZUltYWdlID0gZnVuY3Rpb24gKG5ld1NyYylcbntcbiAgICB0aGlzLnNvdXJjZS5zcmMgPSBuZXdTcmM7XG5cbiAgICB0aGlzLmxvYWRTb3VyY2UodGhpcy5zb3VyY2UpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYmFzZSB0ZXh0dXJlIGZyb20gdGhlIGdpdmVuIGltYWdlIHVybC5cbiAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIGJhc2UgdGV4dHVyZSBjYWNoZSBpdCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGxvYWRlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gaW1hZ2VVcmwge3N0cmluZ30gVGhlIGltYWdlIHVybCBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIFtjcm9zc29yaWdpbj0oYXV0byldIHtib29sZWFufSBTaG91bGQgdXNlIGFub255bW91cyBDT1JTPyBEZWZhdWx0cyB0byB0cnVlIGlmIHRoZSBVUkwgaXMgbm90IGEgZGF0YS1VUkkuXG4gKiBAcGFyYW0gW3NjYWxlTW9kZT1zY2FsZU1vZGVzLkRFRkFVTFRdIHtudW1iZXJ9IFNlZSB7QGxpbmsgU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqIEByZXR1cm4gQmFzZVRleHR1cmVcbiAqL1xuQmFzZVRleHR1cmUuZnJvbUltYWdlID0gZnVuY3Rpb24gKGltYWdlVXJsLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKVxue1xuICAgIHZhciBiYXNlVGV4dHVyZSA9IHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbaW1hZ2VVcmxdO1xuXG4gICAgaWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQgJiYgaW1hZ2VVcmwuaW5kZXhPZignZGF0YTonKSAhPT0gMClcbiAgICB7XG4gICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWJhc2VUZXh0dXJlKVxuICAgIHtcbiAgICAgICAgLy8gbmV3IEltYWdlKCkgYnJlYWtzIHRleCBsb2FkaW5nIGluIHNvbWUgdmVyc2lvbnMgb2YgQ2hyb21lLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIzODA3MVxuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTsvL2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBpZiAoY3Jvc3NvcmlnaW4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShpbWFnZSwgc2NhbGVNb2RlKTtcbiAgICAgICAgYmFzZVRleHR1cmUuaW1hZ2VVcmwgPSBpbWFnZVVybDtcblxuICAgICAgICBpbWFnZS5zcmMgPSBpbWFnZVVybDtcblxuICAgICAgICB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW2ltYWdlVXJsXSA9IGJhc2VUZXh0dXJlO1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIEAyeCBhdCB0aGUgZW5kIG9mIHRoZSB1cmwgd2UgYXJlIGdvaW5nIHRvIGFzc3VtZSBpdHMgYSBoaWdocmVzIGltYWdlXG4gICAgICAgIGJhc2VUZXh0dXJlLnJlc29sdXRpb24gPSB1dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwoaW1hZ2VVcmwpO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGJhc2UgdGV4dHVyZSBmcm9tIHRoZSBnaXZlbiBjYW52YXMgZWxlbWVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gY2FudmFzIHtDYW52YXN9IFRoZSBjYW52YXMgZWxlbWVudCBzb3VyY2Ugb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBzY2FsZU1vZGUge251bWJlcn0gU2VlIHt7I2Nyb3NzTGluayBcIlBJWEkvc2NhbGVNb2Rlczpwcm9wZXJ0eVwifX1zY2FsZU1vZGVze3svY3Jvc3NMaW5rfX0gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICogQHJldHVybiBCYXNlVGV4dHVyZVxuICovXG5CYXNlVGV4dHVyZS5mcm9tQ2FudmFzID0gZnVuY3Rpb24gKGNhbnZhcywgc2NhbGVNb2RlKVxue1xuICAgIGlmICghY2FudmFzLl9waXhpSWQpXG4gICAge1xuICAgICAgICBjYW52YXMuX3BpeGlJZCA9ICdjYW52YXNfJyArIHV0aWxzLnV1aWQoKTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZVRleHR1cmUgPSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW2NhbnZhcy5fcGl4aUlkXTtcblxuICAgIGlmICghYmFzZVRleHR1cmUpXG4gICAge1xuICAgICAgICBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShjYW52YXMsIHNjYWxlTW9kZSk7XG4gICAgICAgIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbY2FudmFzLl9waXhpSWRdID0gYmFzZVRleHR1cmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VUZXh0dXJlO1xufTtcbiIsInZhciBCYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4vQmFzZVRleHR1cmUnKSxcbiAgICBUZXh0dXJlID0gcmVxdWlyZSgnLi9UZXh0dXJlJyksXG4gICAgUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZSgnLi4vcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1JlbmRlclRhcmdldCcpLFxuICAgIEZpbHRlck1hbmFnZXIgPSByZXF1aXJlKCcuLi9yZW5kZXJlcnMvd2ViZ2wvbWFuYWdlcnMvRmlsdGVyTWFuYWdlcicpLFxuICAgIENhbnZhc0J1ZmZlciA9IHJlcXVpcmUoJy4uL3JlbmRlcmVycy9jYW52YXMvdXRpbHMvQ2FudmFzQnVmZmVyJyksXG4gICAgbWF0aCA9IHJlcXVpcmUoJy4uL21hdGgnKSxcbiAgICBDT05TVCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgdGVtcE1hdHJpeCA9IG5ldyBtYXRoLk1hdHJpeCgpO1xuXG4vKipcbiAqIEEgUmVuZGVyVGV4dHVyZSBpcyBhIHNwZWNpYWwgdGV4dHVyZSB0aGF0IGFsbG93cyBhbnkgUGl4aSBkaXNwbGF5IG9iamVjdCB0byBiZSByZW5kZXJlZCB0byBpdC5cbiAqXG4gKiBfX0hpbnRfXzogQWxsIERpc3BsYXlPYmplY3RzIChpLmUuIFNwcml0ZXMpIHRoYXQgcmVuZGVyIHRvIGEgUmVuZGVyVGV4dHVyZSBzaG91bGQgYmUgcHJlbG9hZGVkXG4gKiBvdGhlcndpc2UgYmxhY2sgcmVjdGFuZ2xlcyB3aWxsIGJlIGRyYXduIGluc3RlYWQuXG4gKlxuICogQSBSZW5kZXJUZXh0dXJlIHRha2VzIGEgc25hcHNob3Qgb2YgYW55IERpc3BsYXkgT2JqZWN0IGdpdmVuIHRvIGl0cyByZW5kZXIgbWV0aG9kLiBUaGUgcG9zaXRpb25cbiAqIGFuZCByb3RhdGlvbiBvZiB0aGUgZ2l2ZW4gRGlzcGxheSBPYmplY3RzIGlzIGlnbm9yZWQuIEZvciBleGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVuZGVyVGV4dHVyZSA9IG5ldyBQSVhJLlJlbmRlclRleHR1cmUoODAwLCA2MDApO1xuICogdmFyIHNwcml0ZSA9IFBJWEkuU3ByaXRlLmZyb21JbWFnZShcInNwaW5PYmpfMDEucG5nXCIpO1xuICpcbiAqIHNwcml0ZS5wb3NpdGlvbi54ID0gODAwLzI7XG4gKiBzcHJpdGUucG9zaXRpb24ueSA9IDYwMC8yO1xuICogc3ByaXRlLmFuY2hvci54ID0gMC41O1xuICogc3ByaXRlLmFuY2hvci55ID0gMC41O1xuICpcbiAqIHJlbmRlclRleHR1cmUucmVuZGVyKHNwcml0ZSk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgU3ByaXRlIGluIHRoaXMgY2FzZSB3aWxsIGJlIHJlbmRlcmVkIHRvIGEgcG9zaXRpb24gb2YgMCwwLiBUbyByZW5kZXIgdGhpcyBzcHJpdGUgYXQgaXRzIGFjdHVhbFxuICogcG9zaXRpb24gYSBDb250YWluZXIgc2hvdWxkIGJlIHVzZWQ6XG4gKlxuICogYGBganNcbiAqIHZhciBkb2MgPSBuZXcgQ29udGFpbmVyKCk7XG4gKlxuICogZG9jLmFkZENoaWxkKHNwcml0ZSk7XG4gKlxuICogcmVuZGVyVGV4dHVyZS5yZW5kZXIoZG9jKTsgIC8vIFJlbmRlcnMgdG8gY2VudGVyIG9mIHJlbmRlclRleHR1cmVcbiAqIGBgYFxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgVGV4dHVyZVxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBwYXJhbSByZW5kZXJlciB7Q2FudmFzUmVuZGVyZXJ8V2ViR0xSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIHVzZWQgZm9yIHRoaXMgUmVuZGVyVGV4dHVyZVxuICogQHBhcmFtIFt3aWR0aD0xMDBdIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyIHRleHR1cmVcbiAqIEBwYXJhbSBbaGVpZ2h0PTEwMF0ge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRleHR1cmVcbiAqIEBwYXJhbSBbc2NhbGVNb2RlXSB7bnVtYmVyfSBTZWUge0BsaW5rIFNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcGFyYW0gW3Jlc29sdXRpb249MV0ge251bWJlcn0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHRleHR1cmUgYmVpbmcgZ2VuZXJhdGVkXG4gKi9cbmZ1bmN0aW9uIFJlbmRlclRleHR1cmUocmVuZGVyZXIsIHdpZHRoLCBoZWlnaHQsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbilcbntcbiAgICBpZiAoIXJlbmRlcmVyKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY3JlYXRlIFJlbmRlclRleHR1cmUsIHlvdSBtdXN0IHBhc3MgYSByZW5kZXJlciBpbnRvIHRoZSBjb25zdHJ1Y3Rvci4nKTtcbiAgICB9XG5cbiAgICB3aWR0aCA9IHdpZHRoIHx8IDEwMDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgMTAwO1xuICAgIHJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IENPTlNULlJFU09MVVRJT047XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSB0ZXh0dXJlIG9iamVjdCB0aGF0IHRoaXMgdGV4dHVyZSB1c2VzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtCYXNlVGV4dHVyZX1cbiAgICAgKi9cbiAgICB2YXIgYmFzZVRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmUoKTtcbiAgICBiYXNlVGV4dHVyZS53aWR0aCA9IHdpZHRoO1xuICAgIGJhc2VUZXh0dXJlLmhlaWdodCA9IGhlaWdodDtcbiAgICBiYXNlVGV4dHVyZS5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICBiYXNlVGV4dHVyZS5zY2FsZU1vZGUgPSBzY2FsZU1vZGUgfHwgQ09OU1QuU0NBTEVfTU9ERVMuREVGQVVMVDtcbiAgICBiYXNlVGV4dHVyZS5oYXNMb2FkZWQgPSB0cnVlO1xuXG5cbiAgICBUZXh0dXJlLmNhbGwodGhpcyxcbiAgICAgICAgYmFzZVRleHR1cmUsXG4gICAgICAgIG5ldyBtYXRoLlJlY3RhbmdsZSgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICk7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSB3aXRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgUmVzb2x1dGlvbiBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7UmVjdGFuZ2xlfVxuICAgICAqL1xuICAgIC8vdGhpcy5fZnJhbWUgPSBuZXcgbWF0aC5SZWN0YW5nbGUoMCwgMCwgdGhpcy53aWR0aCAqIHRoaXMucmVzb2x1dGlvbiwgdGhpcy5oZWlnaHQgKiB0aGlzLnJlc29sdXRpb24pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgYXJlYSBvZiB0aGUgQmFzZVRleHR1cmUgaW1hZ2UgdG8gYWN0dWFsbHkgY29weSB0byB0aGUgQ2FudmFzIC8gV2ViR0wgd2hlbiByZW5kZXJpbmcsXG4gICAgICogaXJyZXNwZWN0aXZlIG9mIHRoZSBhY3R1YWwgZnJhbWUgc2l6ZSBvciBwbGFjZW1lbnQgKHdoaWNoIGNhbiBiZSBpbmZsdWVuY2VkIGJ5IHRyaW1tZWQgdGV4dHVyZSBhdGxhc2VzKVxuICAgICAqXG4gICAgICogQG1lbWJlciB7UmVjdGFuZ2xlfVxuICAgICAqL1xuICAgIC8vdGhpcy5jcm9wID0gbmV3IG1hdGguUmVjdGFuZ2xlKDAsIDAsIHRoaXMud2lkdGggKiB0aGlzLnJlc29sdXRpb24sIHRoaXMuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKTtcblxuICAgIC8qKlxuICAgICAqIERyYXcvcmVuZGVyIHRoZSBnaXZlbiBEaXNwbGF5T2JqZWN0IG9udG8gdGhlIHRleHR1cmUuXG4gICAgICpcbiAgICAgKiBUaGUgZGlzcGxheU9iamVjdCBhbmQgZGVzY2VuZGVudHMgYXJlIHRyYW5zZm9ybWVkIGR1cmluZyB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKiBJZiBgdXBkYXRlVHJhbnNmb3JtYCBpcyB0cnVlIHRoZW4gdGhlIHRyYW5zZm9ybWF0aW9ucyB3aWxsIGJlIHJlc3RvcmVkIGJlZm9yZSB0aGVcbiAgICAgKiBtZXRob2QgcmV0dXJucy4gT3RoZXJ3aXNlIGl0IGlzIHVwIHRvIHRoZSBjYWxsaW5nIGNvZGUgdG8gY29ycmVjdGx5IHVzZSBvciByZXNldFxuICAgICAqIHRoZSB0cmFuc2Zvcm1lZCBkaXNwbGF5IG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBUaGUgZGlzcGxheSBvYmplY3QgaXMgYWx3YXlzIHJlbmRlcmVkIHdpdGggYSB3b3JsZEFscGhhIHZhbHVlIG9mIDEuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0Rpc3BsYXlPYmplY3R9IFRoZSBkaXNwbGF5IG9iamVjdCB0byByZW5kZXIgdGhpcyB0ZXh0dXJlIG9uXG4gICAgICogQHBhcmFtIFttYXRyaXhdIHtNYXRyaXh9IE9wdGlvbmFsIG1hdHJpeCB0byBhcHBseSB0byB0aGUgZGlzcGxheSBvYmplY3QgYmVmb3JlIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0gW2NsZWFyPWZhbHNlXSB7Ym9vbGVhbn0gSWYgdHJ1ZSB0aGUgdGV4dHVyZSB3aWxsIGJlIGNsZWFyZWQgYmVmb3JlIHRoZSBkaXNwbGF5T2JqZWN0IGlzIGRyYXduXG4gICAgICogQHBhcmFtIFt1cGRhdGVUcmFuc2Zvcm09dHJ1ZV0ge2Jvb2xlYW59IElmIHRydWUgdGhlIGRpc3BsYXlPYmplY3QncyB3b3JsZFRyYW5zZm9ybS93b3JsZEFscGhhIGFuZCBhbGwgY2hpbGRyZW5cbiAgICAgKiAgdHJhbnNmb3JtYXRpb25zIHdpbGwgYmUgcmVzdG9yZWQuIE5vdCByZXN0b3JpbmcgdGhpcyBpbmZvcm1hdGlvbiB3aWxsIGJlIGEgbGl0dGxlIGZhc3Rlci5cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVuZGVyZXIgdGhpcyBSZW5kZXJUZXh0dXJlIHVzZXMuIEEgUmVuZGVyVGV4dHVyZSBjYW4gb25seSBiZWxvbmcgdG8gb25lIHJlbmRlcmVyIGF0IHRoZSBtb21lbnQgaWYgaXRzIHdlYkdMLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyZXJ8V2ViR0xSZW5kZXJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJlci50eXBlID09PSBDT05TVC5SRU5ERVJFUl9UWVBFLldFQkdMKVxuICAgIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgICAgICB0aGlzLnRleHR1cmVCdWZmZXIgPSBuZXcgUmVuZGVyVGFyZ2V0KGdsLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgbnVsbCwgdGhpcy5yZXNvbHV0aW9uKTsvLywgdGhpcy5iYXNlVGV4dHVyZS5zY2FsZU1vZGUpO1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2dsLmlkXSA9ICB0aGlzLnRleHR1cmVCdWZmZXIudGV4dHVyZTtcblxuICAgICAgICAvL1RPRE8gcmVmYWN0b3IgZmlsdGVyIG1hbmFnZXIuLiBhcyByZWFsbHkgaXRzIG5vIGxvbmdlciBhIG1hbmFnZXIgaWYgd2UgdXNlIGl0IGhlcmUuLlxuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBuZXcgRmlsdGVyTWFuYWdlcih0aGlzLnJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5maWx0ZXJNYW5hZ2VyLm9uQ29udGV4dENoYW5nZSgpO1xuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyV2ViR0w7XG5cbiAgICAgICAgLy8gdGhlIGNyZWF0aW9uIG9mIGEgZmlsdGVyIG1hbmFnZXIgdW5iaW5kcyB0aGUgYnVmZmVycy4uXG4gICAgICAgIHRoaXMucmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuY3VycmVudFJlbmRlclRhcmdldC5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXJDYW52YXM7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1ZmZlciA9IG5ldyBDYW52YXNCdWZmZXIodGhpcy53aWR0aCogdGhpcy5yZXNvbHV0aW9uLCB0aGlzLmhlaWdodCogdGhpcy5yZXNvbHV0aW9uKTtcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5zb3VyY2UgPSB0aGlzLnRleHR1cmVCdWZmZXIuY2FudmFzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy52YWxpZCA9IHRydWU7XG5cbiAgICB0aGlzLl91cGRhdGVVdnMoKTtcbn1cblxuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRleHR1cmUucHJvdG90eXBlKTtcblJlbmRlclRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVuZGVyVGV4dHVyZTtcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyVGV4dHVyZTtcblxuLyoqXG4gKiBSZXNpemVzIHRoZSBSZW5kZXJUZXh0dXJlLlxuICpcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSBUaGUgd2lkdGggdG8gcmVzaXplIHRvLlxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBUaGUgaGVpZ2h0IHRvIHJlc2l6ZSB0by5cbiAqIEBwYXJhbSB1cGRhdGVCYXNlIHtib29sZWFufSBTaG91bGQgdGhlIGJhc2VUZXh0dXJlLndpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIGJlIHJlc2l6ZWQgYXMgd2VsbD9cbiAqL1xuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHVwZGF0ZUJhc2UpXG57XG4gICAgaWYgKHdpZHRoID09PSB0aGlzLndpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5oZWlnaHQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy52YWxpZCA9ICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCk7XG5cbiAgICB0aGlzLndpZHRoID0gdGhpcy5fZnJhbWUud2lkdGggPSB0aGlzLmNyb3Aud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9ICB0aGlzLl9mcmFtZS5oZWlnaHQgPSB0aGlzLmNyb3AuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgaWYgKHVwZGF0ZUJhc2UpXG4gICAge1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudmFsaWQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyLnJlc2l6ZSh0aGlzLndpZHRoICogdGhpcy5yZXNvbHV0aW9uLCB0aGlzLmhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XG5cbiAgICBpZih0aGlzLmZpbHRlck1hbmFnZXIpXG4gICAge1xuICAgICAgICB0aGlzLmZpbHRlck1hbmFnZXIucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgUmVuZGVyVGV4dHVyZS5cbiAqXG4gKi9cblJlbmRlclRleHR1cmUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMudmFsaWQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyZXIudHlwZSA9PT0gQ09OU1QuUkVOREVSRVJfVFlQRS5XRUJHTClcbiAgICB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMucmVuZGVyZXIuZ2wuRlJBTUVCVUZGRVIsIHRoaXMudGV4dHVyZUJ1ZmZlci5mcmFtZUJ1ZmZlcik7XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIG1ldGhvZCBhc3NpZ25lZCB0byB0aGUgYHJlbmRlcmAgcHJvcGVydHkgaWYgdXNpbmcgYSBDYW52YXNSZW5kZXJlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0Rpc3BsYXlPYmplY3R9IFRoZSBkaXNwbGF5IG9iamVjdCB0byByZW5kZXIgdGhpcyB0ZXh0dXJlIG9uXG4gKiBAcGFyYW0gW21hdHJpeF0ge01hdHJpeH0gT3B0aW9uYWwgbWF0cml4IHRvIGFwcGx5IHRvIHRoZSBkaXNwbGF5IG9iamVjdCBiZWZvcmUgcmVuZGVyaW5nLlxuICogQHBhcmFtIFtjbGVhcj1mYWxzZV0ge2Jvb2xlYW59IElmIHRydWUgdGhlIHRleHR1cmUgd2lsbCBiZSBjbGVhcmVkIGJlZm9yZSB0aGUgZGlzcGxheU9iamVjdCBpcyBkcmF3blxuICogQHBhcmFtIFt1cGRhdGVUcmFuc2Zvcm09dHJ1ZV0ge2Jvb2xlYW59IElmIHRydWUgdGhlIGRpc3BsYXlPYmplY3QncyB3b3JsZFRyYW5zZm9ybS93b3JsZEFscGhhIGFuZCBhbGwgY2hpbGRyZW5cbiAqICB0cmFuc2Zvcm1hdGlvbnMgd2lsbCBiZSByZXN0b3JlZC4gTm90IHJlc3RvcmluZyB0aGlzIGluZm9ybWF0aW9uIHdpbGwgYmUgYSBsaXR0bGUgZmFzdGVyLlxuICovXG5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIChkaXNwbGF5T2JqZWN0LCBtYXRyaXgsIGNsZWFyLCB1cGRhdGVUcmFuc2Zvcm0pXG57XG4gICAgaWYgKCF0aGlzLnZhbGlkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgdXBkYXRlVHJhbnNmb3JtID0gKHVwZGF0ZVRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSA/IHVwZGF0ZVRyYW5zZm9ybSA6IHRydWU7Ly8hdXBkYXRlVHJhbnNmb3JtO1xuXG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyLnRyYW5zZm9ybSA9IG1hdHJpeDtcblxuXG4gICAgLy8gc2V0V29ybGQgQWxwaGEgdG8gZW5zdXJlIHRoYXQgdGhlIG9iamVjdCBpcyByZW5kZXJlciBhdCBmdWxsIG9wYWNpdHlcbiAgICBkaXNwbGF5T2JqZWN0LndvcmxkQWxwaGEgPSBkaXNwbGF5T2JqZWN0LmFscGhhO1xuXG4gICAgaWYgKHVwZGF0ZVRyYW5zZm9ybSlcbiAgICB7XG5cbiAgICAgICAgLy8gcmVzZXQgdGhlIG1hdHJpeCBvZiB0aGUgZGlzcGxhdHlPYmplY3QuLlxuICAgICAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLmlkZW50aXR5KCk7XG5cbiAgICAgICAgZGlzcGxheU9iamVjdC5jdXJyZW50Qm91bmRzID0gbnVsbDtcblxuICAgICAgICAvLyBUaW1lIHRvIHVwZGF0ZSBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoZSBkaXNwbGF5T2JqZWN0IHdpdGggdGhlIG5ldyBtYXRyaXguLlxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xuICAgICAgICB2YXIgaSwgajtcblxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZHJlbltpXS51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vVE9ETyByZW5hbWUgdGV4dHVyZUJ1ZmZlciB0byByZW5kZXJUYXJnZXQuLlxuICAgIHZhciB0ZW1wID0gIHRoaXMucmVuZGVyZXIuZmlsdGVyTWFuYWdlcjtcblxuICAgIHRoaXMucmVuZGVyZXIuZmlsdGVyTWFuYWdlciA9IHRoaXMuZmlsdGVyTWFuYWdlcjtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckRpc3BsYXlPYmplY3QoZGlzcGxheU9iamVjdCwgdGhpcy50ZXh0dXJlQnVmZmVyLCBjbGVhcik7XG5cbiAgICB0aGlzLnJlbmRlcmVyLmZpbHRlck1hbmFnZXIgPSB0ZW1wO1xufTtcblxuXG4vKipcbiAqIEludGVybmFsIG1ldGhvZCBhc3NpZ25lZCB0byB0aGUgYHJlbmRlcmAgcHJvcGVydHkgaWYgdXNpbmcgYSBDYW52YXNSZW5kZXJlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0Rpc3BsYXlPYmplY3R9IFRoZSBkaXNwbGF5IG9iamVjdCB0byByZW5kZXIgdGhpcyB0ZXh0dXJlIG9uXG4gKiBAcGFyYW0gW21hdHJpeF0ge01hdHJpeH0gT3B0aW9uYWwgbWF0cml4IHRvIGFwcGx5IHRvIHRoZSBkaXNwbGF5IG9iamVjdCBiZWZvcmUgcmVuZGVyaW5nLlxuICogQHBhcmFtIFtjbGVhcl0ge2Jvb2xlYW59IElmIHRydWUgdGhlIHRleHR1cmUgd2lsbCBiZSBjbGVhcmVkIGJlZm9yZSB0aGUgZGlzcGxheU9iamVjdCBpcyBkcmF3blxuICovXG5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5yZW5kZXJDYW52YXMgPSBmdW5jdGlvbiAoZGlzcGxheU9iamVjdCwgbWF0cml4LCBjbGVhciwgdXBkYXRlVHJhbnNmb3JtKVxue1xuICAgIGlmICghdGhpcy52YWxpZClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1cGRhdGVUcmFuc2Zvcm0gPSAhIXVwZGF0ZVRyYW5zZm9ybTtcbiAgICB2YXIgY2FjaGVkV3QgPSBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtO1xuXG4gICAgdmFyIHd0ID0gdGVtcE1hdHJpeDtcblxuICAgIHd0LmlkZW50aXR5KCk7XG5cbiAgICBpZiAobWF0cml4KVxuICAgIHtcbiAgICAgICAgd3QuYXBwZW5kKG1hdHJpeCk7XG4gICAgfVxuXG4gICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybSA9IHd0O1xuXG4gICAgLy8gc2V0V29ybGQgQWxwaGEgdG8gZW5zdXJlIHRoYXQgdGhlIG9iamVjdCBpcyByZW5kZXJlciBhdCBmdWxsIG9wYWNpdHlcbiAgICBkaXNwbGF5T2JqZWN0LndvcmxkQWxwaGEgPSAxO1xuXG4gICAgLy8gVGltZSB0byB1cGRhdGUgYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGUgZGlzcGxheU9iamVjdCB3aXRoIHRoZSBuZXcgbWF0cml4Li5cbiAgICB2YXIgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xuICAgIHZhciBpLCBqO1xuXG4gICAgZm9yIChpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSlcbiAgICB7XG4gICAgICAgIGNoaWxkcmVuW2ldLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIH1cblxuICAgIGlmIChjbGVhcilcbiAgICB7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1ZmZlci5jbGVhcigpO1xuICAgIH1cblxuICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0gPSBjYWNoZWRXdDtcblxuLy8gICAgdGhpcy50ZXh0dXJlQnVmZmVyLlxuICAgIHZhciBjb250ZXh0ID0gdGhpcy50ZXh0dXJlQnVmZmVyLmNvbnRleHQ7XG5cbiAgICB2YXIgcmVhbFJlc29sdXRpb24gPSB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb247XG5cbiAgICB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG5cbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckRpc3BsYXlPYmplY3QoZGlzcGxheU9iamVjdCwgY29udGV4dCk7XG5cbiAgICB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb24gPSByZWFsUmVzb2x1dGlvbjtcbiAvLyAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgLy8gY29udGV4dC5maWxsU3R5bGUgPVwiI0ZGMDAwMFwiXG4vLyAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIDgwMCwgNjAwKTtcblxufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAqXG4gKiBAcGFyYW0gZGVzdHJveUJhc2Uge2Jvb2xlYW59IFdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcbiAqL1xuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMsIHRydWUpO1xuXG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyLmRlc3Ryb3koKTtcblxuICAgIC8vIGRlc3Ryb3kgdGhlIGZpbHRlcm1hbmFnZXIuLlxuICAgIGlmKHRoaXMuZmlsdGVyTWFuYWdlcilcbiAgICB7XG4gICAgICAgIHRoaXMuZmlsdGVyTWFuYWdlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgSFRNTCBJbWFnZSBvZiB0aGUgdGV4dHVyZVxuICpcbiAqIEByZXR1cm4ge0ltYWdlfVxuICovXG5SZW5kZXJUZXh0dXJlLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2Uuc3JjID0gdGhpcy5nZXRCYXNlNjQoKTtcbiAgICByZXR1cm4gaW1hZ2U7XG59O1xuXG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb2YgdGhpcyB0ZXh0dXJlLiBJdCB3b3JrcyBieSBjYWxsaW5nIFJlbmRlclRleHR1cmUuZ2V0Q2FudmFzIGFuZCB0aGVuIHJ1bm5pbmcgdG9EYXRhVVJMIG9uIHRoYXQuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBBIGJhc2U2NCBlbmNvZGVkIHN0cmluZyBvZiB0aGUgdGV4dHVyZS5cbiAqL1xuUmVuZGVyVGV4dHVyZS5wcm90b3R5cGUuZ2V0QmFzZTY0ID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5nZXRDYW52YXMoKS50b0RhdGFVUkwoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIENhbnZhcyBlbGVtZW50LCByZW5kZXJzIHRoaXMgUmVuZGVyVGV4dHVyZSB0byBpdCBhbmQgdGhlbiByZXR1cm5zIGl0LlxuICpcbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBBIENhbnZhcyBlbGVtZW50IHdpdGggdGhlIHRleHR1cmUgcmVuZGVyZWQgb24uXG4gKi9cblJlbmRlclRleHR1cmUucHJvdG90eXBlLmdldENhbnZhcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMucmVuZGVyZXIudHlwZSA9PT0gQ09OU1QuUkVOREVSRVJfVFlQRS5XRUJHTClcbiAgICB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMudGV4dHVyZUJ1ZmZlci5zaXplLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy50ZXh0dXJlQnVmZmVyLnNpemUuaGVpZ2h0O1xuXG4gICAgICAgIHZhciB3ZWJHTFBpeGVscyA9IG5ldyBVaW50OEFycmF5KDQgKiB3aWR0aCAqIGhlaWdodCk7XG5cbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLnRleHR1cmVCdWZmZXIuZnJhbWVCdWZmZXIpO1xuICAgICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHdlYkdMUGl4ZWxzKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuICAgICAgICB2YXIgdGVtcENhbnZhcyA9IG5ldyBDYW52YXNCdWZmZXIod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBjYW52YXNEYXRhID0gdGVtcENhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY2FudmFzRGF0YS5kYXRhLnNldCh3ZWJHTFBpeGVscyk7XG5cbiAgICAgICAgdGVtcENhbnZhcy5jb250ZXh0LnB1dEltYWdlRGF0YShjYW52YXNEYXRhLCAwLCAwKTtcblxuICAgICAgICByZXR1cm4gdGVtcENhbnZhcy5jYW52YXM7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmVCdWZmZXIuY2FudmFzO1xuICAgIH1cbn07XG4iLCJ2YXIgQmFzZVRleHR1cmUgPSByZXF1aXJlKCcuL0Jhc2VUZXh0dXJlJyksXG4gICAgVmlkZW9CYXNlVGV4dHVyZSA9IHJlcXVpcmUoJy4vVmlkZW9CYXNlVGV4dHVyZScpLFxuICAgIFRleHR1cmVVdnMgPSByZXF1aXJlKCcuL1RleHR1cmVVdnMnKSxcbiAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJykuRXZlbnRFbWl0dGVyLFxuICAgIG1hdGggPSByZXF1aXJlKCcuLi9tYXRoJyksXG4gICAgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgdGV4dHVyZSBzdG9yZXMgdGhlIGluZm9ybWF0aW9uIHRoYXQgcmVwcmVzZW50cyBhbiBpbWFnZSBvciBwYXJ0IG9mIGFuIGltYWdlLiBJdCBjYW5ub3QgYmUgYWRkZWRcbiAqIHRvIHRoZSBkaXNwbGF5IGxpc3QgZGlyZWN0bHkuIEluc3RlYWQgdXNlIGl0IGFzIHRoZSB0ZXh0dXJlIGZvciBhIFNwcml0ZS4gSWYgbm8gZnJhbWUgaXMgcHJvdmlkZWQgdGhlbiB0aGUgd2hvbGUgaW1hZ2UgaXMgdXNlZC5cbiAqXG4gKiBZb3UgY2FuIGRpcmVjdGx5IGNyZWF0ZSBhIHRleHR1cmUgZnJvbSBhbiBpbWFnZSBhbmQgdGhlbiByZXVzZSBpdCBtdWx0aXBsZSB0aW1lcyBsaWtlIHRoaXMgOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgdGV4dHVyZSA9IFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoJ2Fzc2V0cy9pbWFnZS5wbmcnKTtcbiAqIHZhciBzcHJpdGUxID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xuICogdmFyIHNwcml0ZTIgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gKiBgYGBcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAcGFyYW0gYmFzZVRleHR1cmUge0Jhc2VUZXh0dXJlfSBUaGUgYmFzZSB0ZXh0dXJlIHNvdXJjZSB0byBjcmVhdGUgdGhlIHRleHR1cmUgZnJvbVxuICogQHBhcmFtIFtmcmFtZV0ge1JlY3RhbmdsZX0gVGhlIHJlY3RhbmdsZSBmcmFtZSBvZiB0aGUgdGV4dHVyZSB0byBzaG93XG4gKiBAcGFyYW0gW2Nyb3BdIHtSZWN0YW5nbGV9IFRoZSBhcmVhIG9mIG9yaWdpbmFsIHRleHR1cmVcbiAqIEBwYXJhbSBbdHJpbV0ge1JlY3RhbmdsZX0gVHJpbW1lZCB0ZXh0dXJlIHJlY3RhbmdsZVxuICogQHBhcmFtIFtyb3RhdGVdIHtib29sZWFufSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdGV4dHVyZSBzaG91bGQgYmUgcm90YXRlZCBieSA5MCBkZWdyZWVzICggdXNlZCBieSB0ZXh0dXJlIHBhY2tlciApXG4gKi9cbmZ1bmN0aW9uIFRleHR1cmUoYmFzZVRleHR1cmUsIGZyYW1lLCBjcm9wLCB0cmltLCByb3RhdGUpXG57XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoaXMgVGV4dHVyZSBoYXZlIGFueSBmcmFtZSBkYXRhIGFzc2lnbmVkIHRvIGl0P1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcblxuICAgIGlmICghZnJhbWUpXG4gICAge1xuICAgICAgICB0aGlzLm5vRnJhbWUgPSB0cnVlO1xuICAgICAgICBmcmFtZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZVRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlKVxuICAgIHtcbiAgICAgICAgYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICB9XG5cbiAgLy8gIGNvbnNvbGUubG9nKGZyYW1lKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Jhc2VUZXh0dXJlfVxuICAgICAqL1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZSBzcGVjaWZpZXMgdGhlIHJlZ2lvbiBvZiB0aGUgYmFzZSB0ZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1JlY3RhbmdsZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZyYW1lID0gZnJhbWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dHVyZSB0cmltIGRhdGEuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtSZWN0YW5nbGV9XG4gICAgICovXG4gICAgdGhpcy50cmltID0gdHJpbTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgd2lsbCBsZXQgdGhlIHJlbmRlcmVyIGtub3cgaWYgdGhlIHRleHR1cmUgaXMgdmFsaWQuIElmIGl0J3Mgbm90IHRoZW4gaXQgY2Fubm90IGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgbGV0IGEgcmVuZGVyZXIga25vdyB0aGF0IGEgdGV4dHVyZSBoYXMgYmVlbiB1cGRhdGVkICh1c2VkIG1haW5seSBmb3Igd2ViR0wgdXYgdXBkYXRlcylcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXF1aXJlc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIFdlYkdMIFVWIGRhdGEgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtUZXh0dXJlVXZzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdXZzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0dXJlIGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBhcmVhIG9mIHRoZSBCYXNlVGV4dHVyZSBpbWFnZSB0byBhY3R1YWxseSBjb3B5IHRvIHRoZSBDYW52YXMgLyBXZWJHTCB3aGVuIHJlbmRlcmluZyxcbiAgICAgKiBpcnJlc3BlY3RpdmUgb2YgdGhlIGFjdHVhbCBmcmFtZSBzaXplIG9yIHBsYWNlbWVudCAod2hpY2ggY2FuIGJlIGluZmx1ZW5jZWQgYnkgdHJpbW1lZCB0ZXh0dXJlIGF0bGFzZXMpXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtSZWN0YW5nbGV9XG4gICAgICovXG4gICAgdGhpcy5jcm9wID0gY3JvcCB8fCBmcmFtZTsvL25ldyBtYXRoLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0ZXh0dXJlIHNob3VsZCBiZSByb3RhdGVkIGJ5IDkwIGRlZ3JlZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0ZSA9ICEhcm90YXRlO1xuXG4gICAgaWYgKGJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLm5vRnJhbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZyYW1lID0gbmV3IG1hdGguUmVjdGFuZ2xlKDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgYmFzZVRleHR1cmUub25jZSgnbG9hZGVkJywgdGhpcy5vbkJhc2VUZXh0dXJlTG9hZGVkLCB0aGlzKTtcbiAgICB9XG59XG5cblRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dHVyZTtcbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGV4dHVyZS5wcm90b3R5cGUsIHtcbiAgICBmcmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZnJhbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lID0gZnJhbWU7XG5cbiAgICAgICAgICAgIHRoaXMubm9GcmFtZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gZnJhbWUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGZyYW1lLmhlaWdodDtcblxuXG5cbiAgICAgICAgICAgIGlmICghdGhpcy50cmltICYmICF0aGlzLnJvdGF0ZSAmJiAoZnJhbWUueCArIGZyYW1lLndpZHRoID4gdGhpcy5iYXNlVGV4dHVyZS53aWR0aCB8fCBmcmFtZS55ICsgZnJhbWUuaGVpZ2h0ID4gdGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZSBFcnJvcjogZnJhbWUgZG9lcyBub3QgZml0IGluc2lkZSB0aGUgYmFzZSBUZXh0dXJlIGRpbWVuc2lvbnMgJyArIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3RoaXMudmFsaWQgPSBmcmFtZSAmJiBmcmFtZS53aWR0aCAmJiBmcmFtZS5oZWlnaHQgJiYgdGhpcy5iYXNlVGV4dHVyZS5zb3VyY2UgJiYgdGhpcy5iYXNlVGV4dHVyZS5oYXNMb2FkZWQ7XG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gZnJhbWUgJiYgZnJhbWUud2lkdGggJiYgZnJhbWUuaGVpZ2h0ICYmIHRoaXMuYmFzZVRleHR1cmUuaGFzTG9hZGVkO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50cmltKVxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMudHJpbS53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMudHJpbS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhbWUud2lkdGggPSB0aGlzLnRyaW0ud2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gdGhpcy50cmltLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3AgPSBmcmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVV2cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogVXBkYXRlcyB0aGlzIHRleHR1cmUgb24gdGhlIGdwdS5cbiAqXG4gKi9cblRleHR1cmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5iYXNlVGV4dHVyZS51cGRhdGUoKTtcblxuXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBiYXNlIHRleHR1cmUgaXMgbG9hZGVkXG4gKlxuICogQHByaXZhdGVcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUub25CYXNlVGV4dHVyZUxvYWRlZCA9IGZ1bmN0aW9uIChiYXNlVGV4dHVyZSlcbntcbiAgICAvLyBUT0RPIHRoaXMgY29kZSBsb29rcyBjb25mdXNpbmcuLiBib28gdG8gYWJ1c2luZyBnZXR0ZXJzIGFuZCBzZXR0ZXJzcyFcbiAgICBpZiAodGhpcy5ub0ZyYW1lKVxuICAgIHtcbiAgICAgICAgdGhpcy5mcmFtZSA9IG5ldyBtYXRoLlJlY3RhbmdsZSgwLCAwLCBiYXNlVGV4dHVyZS53aWR0aCwgYmFzZVRleHR1cmUuaGVpZ2h0KTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5mcmFtZSA9IHRoaXMuX2ZyYW1lO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCggJ3VwZGF0ZScsIHRoaXMgKTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXG4gKlxuICogQHBhcmFtIGRlc3Ryb3lCYXNlIHtib29sZWFufSBXaGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZGVzdHJveUJhc2UpXG57XG4gICAgaWYgKGRlc3Ryb3lCYXNlKVxuICAgIHtcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy52YWxpZCA9IGZhbHNlO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBuZXcgVGV4dHVyZSh0aGlzLmJhc2VUZXh0dXJlLCB0aGlzLmZyYW1lLCB0aGlzLmNyb3AsIHRoaXMudHJpbSwgdGhpcy5yb3RhdGUpO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBXZWJHTCBVViBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5fdXBkYXRlVXZzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMuX3V2cylcbiAgICB7XG4gICAgICAgIHRoaXMuX3V2cyA9IG5ldyBUZXh0dXJlVXZzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXZzLnNldCh0aGlzLmNyb3AsIHRoaXMuYmFzZVRleHR1cmUsIHRoaXMucm90YXRlKTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIFRleHR1cmUgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGltYWdlIHVybC5cbiAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSAgY3JlYXRlZCBhbmQgbG9hZGVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBpbWFnZVVybCB7c3RyaW5nfSBUaGUgaW1hZ2UgdXJsIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gY3Jvc3NvcmlnaW4ge2Jvb2xlYW59IFdoZXRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgY3Jvc3NvcmlnaW5cbiAqIEBwYXJhbSBzY2FsZU1vZGUge251bWJlcn0gU2VlIHt7I2Nyb3NzTGluayBcIlBJWEkvc2NhbGVNb2Rlczpwcm9wZXJ0eVwifX1zY2FsZU1vZGVze3svY3Jvc3NMaW5rfX0gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICogQHJldHVybiB7VGV4dHVyZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxuICovXG5UZXh0dXJlLmZyb21JbWFnZSA9IGZ1bmN0aW9uIChpbWFnZVVybCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSlcbntcbiAgICB2YXIgdGV4dHVyZSA9IHV0aWxzLlRleHR1cmVDYWNoZVtpbWFnZVVybF07XG5cbiAgICBpZiAoIXRleHR1cmUpXG4gICAge1xuICAgICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUoQmFzZVRleHR1cmUuZnJvbUltYWdlKGltYWdlVXJsLCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKSk7XG4gICAgICAgIHV0aWxzLlRleHR1cmVDYWNoZVtpbWFnZVVybF0gPSB0ZXh0dXJlO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgc3ByaXRlIHRoYXQgd2lsbCBjb250YWluIGEgdGV4dHVyZSBmcm9tIHRoZSBUZXh0dXJlQ2FjaGUgYmFzZWQgb24gdGhlIGZyYW1lSWRcbiAqIFRoZSBmcmFtZSBpZHMgYXJlIGNyZWF0ZWQgd2hlbiBhIFRleHR1cmUgcGFja2VyIGZpbGUgaGFzIGJlZW4gbG9hZGVkXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGZyYW1lSWQge1N0cmluZ30gVGhlIGZyYW1lIElkIG9mIHRoZSB0ZXh0dXJlIGluIHRoZSBjYWNoZVxuICogQHJldHVybiB7VGV4dHVyZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxuICovXG5UZXh0dXJlLmZyb21GcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUlkKVxue1xuICAgIHZhciB0ZXh0dXJlID0gdXRpbHMuVGV4dHVyZUNhY2hlW2ZyYW1lSWRdO1xuXG4gICAgaWYgKCF0ZXh0dXJlKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnJhbWVJZCBcIicgKyBmcmFtZUlkICsgJ1wiIGRvZXMgbm90IGV4aXN0IGluIHRoZSB0ZXh0dXJlIGNhY2hlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVGV4dHVyZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2FudmFzIGVsZW1lbnQuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGNhbnZhcyB7Q2FudmFzfSBUaGUgY2FudmFzIGVsZW1lbnQgc291cmNlIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtudW1iZXJ9IFNlZSB7eyNjcm9zc0xpbmsgXCJQSVhJL3NjYWxlTW9kZXM6cHJvcGVydHlcIn19c2NhbGVNb2Rlc3t7L2Nyb3NzTGlua319IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqIEByZXR1cm4ge1RleHR1cmV9XG4gKi9cblRleHR1cmUuZnJvbUNhbnZhcyA9IGZ1bmN0aW9uIChjYW52YXMsIHNjYWxlTW9kZSlcbntcbiAgICByZXR1cm4gbmV3IFRleHR1cmUoQmFzZVRleHR1cmUuZnJvbUNhbnZhcyhjYW52YXMsIHNjYWxlTW9kZSkpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFRleHR1cmUgYmFzZWQgb24gdGhlIGdpdmVuIHZpZGVvIGVsZW1lbnQuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHZpZGVvIHtIVE1MVmlkZW9FbGVtZW50fVxuICogQHBhcmFtIHNjYWxlTW9kZSB7bnVtYmVyfSBTZWUge3sjY3Jvc3NMaW5rIFwiUElYSS9zY2FsZU1vZGVzOnByb3BlcnR5XCJ9fXNjYWxlTW9kZXN7ey9jcm9zc0xpbmt9fSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcmV0dXJuIHtUZXh0dXJlfSBBIFRleHR1cmVcbiAqL1xuVGV4dHVyZS5mcm9tVmlkZW8gPSBmdW5jdGlvbiAodmlkZW8sIHNjYWxlTW9kZSlcbntcbiAgICBpZiAodHlwZW9mIHZpZGVvID09PSAnc3RyaW5nJylcbiAgICB7XG4gICAgICAgIHJldHVybiBUZXh0dXJlLmZyb21WaWRlb1VybCh2aWRlbywgc2NhbGVNb2RlKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKFZpZGVvQmFzZVRleHR1cmUuZnJvbVZpZGVvKHZpZGVvLCBzY2FsZU1vZGUpKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVGV4dHVyZSBiYXNlZCBvbiB0aGUgdmlkZW8gdXJsLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB2aWRlb1VybCB7c3RyaW5nfVxuICogQHBhcmFtIHNjYWxlTW9kZSB7bnVtYmVyfSBTZWUge3tAbGluayBTQ0FMRV9NT0RFU319IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqIEByZXR1cm4ge1RleHR1cmV9IEEgVGV4dHVyZVxuICovXG5UZXh0dXJlLmZyb21WaWRlb1VybCA9IGZ1bmN0aW9uICh2aWRlb1VybCwgc2NhbGVNb2RlKVxue1xuICAgIHJldHVybiBuZXcgVGV4dHVyZShWaWRlb0Jhc2VUZXh0dXJlLmZyb21VcmwodmlkZW9VcmwsIHNjYWxlTW9kZSkpO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgdGV4dHVyZSB0byB0aGUgZ2xvYmFsIHV0aWxzLlRleHR1cmVDYWNoZS4gVGhpcyBjYWNoZSBpcyBzaGFyZWQgYWNyb3NzIHRoZSB3aG9sZSBQSVhJIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gVGhlIFRleHR1cmUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAqIEBwYXJhbSBpZCB7c3RyaW5nfSBUaGUgaWQgdGhhdCB0aGUgdGV4dHVyZSB3aWxsIGJlIHN0b3JlZCBhZ2FpbnN0LlxuICovXG5UZXh0dXJlLmFkZFRleHR1cmVUb0NhY2hlID0gZnVuY3Rpb24gKHRleHR1cmUsIGlkKVxue1xuICAgIHV0aWxzLlRleHR1cmVDYWNoZVtpZF0gPSB0ZXh0dXJlO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSB0ZXh0dXJlIGZyb20gdGhlIGdsb2JhbCB1dGlscy5UZXh0dXJlQ2FjaGUuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGlkIHtzdHJpbmd9IFRoZSBpZCBvZiB0aGUgdGV4dHVyZSB0byBiZSByZW1vdmVkXG4gKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgdGV4dHVyZSB0aGF0IHdhcyByZW1vdmVkXG4gKi9cblRleHR1cmUucmVtb3ZlVGV4dHVyZUZyb21DYWNoZSA9IGZ1bmN0aW9uIChpZClcbntcbiAgICB2YXIgdGV4dHVyZSA9IHV0aWxzLlRleHR1cmVDYWNoZVtpZF07XG5cbiAgICBkZWxldGUgdXRpbHMuVGV4dHVyZUNhY2hlW2lkXTtcbiAgICBkZWxldGUgdXRpbHMuQmFzZVRleHR1cmVDYWNoZVtpZF07XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cblRleHR1cmUuZW1wdHlUZXh0dXJlID0gbmV3IFRleHR1cmUobmV3IEJhc2VUZXh0dXJlKCkpO1xuIiwiXG4vKipcbiAqIEEgc3RhbmRhcmQgb2JqZWN0IHRvIHN0b3JlIHRoZSBVdnMgb2YgYSB0ZXh0dXJlXG4gKlxuICogQGNsYXNzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBUZXh0dXJlVXZzKClcbntcbiAgICB0aGlzLngwID0gMDtcbiAgICB0aGlzLnkwID0gMDtcblxuICAgIHRoaXMueDEgPSAwO1xuICAgIHRoaXMueTEgPSAwO1xuXG4gICAgdGhpcy54MiA9IDA7XG4gICAgdGhpcy55MiA9IDA7XG5cbiAgICB0aGlzLngzID0gMDtcbiAgICB0aGlzLnkzID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlVXZzO1xuXG4vKipcbiAqIFNldHMgdGhlIHRleHR1cmUgVXZzIGJhc2VkIG9uIHRoZSBnaXZlbiBmcmFtZSBpbmZvcm1hdGlvblxuICogQHBhcmFtIGZyYW1lIHtSZWN0YW5nbGV9XG4gKiBAcGFyYW0gYmFzZUZyYW1lIHtSZWN0YW5nbGV9XG4gKiBAcGFyYW0gcm90YXRlIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgZnJhbWUgaXMgcm90YXRlZFxuICogQHByaXZhdGVcbiAqL1xuVGV4dHVyZVV2cy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGZyYW1lLCBiYXNlRnJhbWUsIHJvdGF0ZSlcbntcbiAgICB2YXIgdHcgPSBiYXNlRnJhbWUud2lkdGg7XG4gICAgdmFyIHRoID0gYmFzZUZyYW1lLmhlaWdodDtcblxuICAgIGlmKHJvdGF0ZSlcbiAgICB7XG4gICAgICAgIHRoaXMueDAgPSAoZnJhbWUueCArIGZyYW1lLmhlaWdodCkgLyB0dztcbiAgICAgICAgdGhpcy55MCA9IGZyYW1lLnkgLyB0aDtcblxuICAgICAgICB0aGlzLngxID0gKGZyYW1lLnggKyBmcmFtZS5oZWlnaHQpIC8gdHc7XG4gICAgICAgIHRoaXMueTEgPSAoZnJhbWUueSArIGZyYW1lLndpZHRoKSAvIHRoO1xuXG4gICAgICAgIHRoaXMueDIgPSBmcmFtZS54IC8gdHc7XG4gICAgICAgIHRoaXMueTIgPSAoZnJhbWUueSArIGZyYW1lLndpZHRoKSAvIHRoO1xuXG4gICAgICAgIHRoaXMueDMgPSBmcmFtZS54IC8gdHc7XG4gICAgICAgIHRoaXMueTMgPSBmcmFtZS55IC8gdGg7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG5cbiAgICAgICAgdGhpcy54MCA9IGZyYW1lLnggLyB0dztcbiAgICAgICAgdGhpcy55MCA9IGZyYW1lLnkgLyB0aDtcblxuICAgICAgICB0aGlzLngxID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcbiAgICAgICAgdGhpcy55MSA9IGZyYW1lLnkgLyB0aDtcblxuICAgICAgICB0aGlzLngyID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcbiAgICAgICAgdGhpcy55MiA9IChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAvIHRoO1xuXG4gICAgICAgIHRoaXMueDMgPSBmcmFtZS54IC8gdHc7XG4gICAgICAgIHRoaXMueTMgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcbiAgICB9XG59O1xuIiwidmFyIEJhc2VUZXh0dXJlID0gcmVxdWlyZSgnLi9CYXNlVGV4dHVyZScpLFxuICAgIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBBIHRleHR1cmUgb2YgYSBbcGxheWluZ10gVmlkZW8uXG4gKlxuICogVmlkZW8gYmFzZSB0ZXh0dXJlcyBtaW1pYyBQaXhpIEJhc2VUZXh0dXJlLmZyb20uLi4uIG1ldGhvZCBpbiB0aGVpciBjcmVhdGlvbiBwcm9jZXNzLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgaW4gc2V2ZXJhbCB3YXlzLCBzdWNoIGFzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgdGV4dHVyZSA9IFBJWEkuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJsKCdodHRwOi8vbXlkb21haW4uY29tL3ZpZGVvLm1wNCcpO1xuICpcbiAqIHZhciB0ZXh0dXJlID0gUElYSS5WaWRlb0Jhc2VUZXh0dXJlLmZyb21VcmwoeyBzcmM6ICdodHRwOi8vbXlkb21haW4uY29tL3ZpZGVvLm1wNCcsIG1pbWU6ICd2aWRlby9tcDQnIH0pO1xuICpcbiAqIHZhciB0ZXh0dXJlID0gUElYSS5WaWRlb0Jhc2VUZXh0dXJlLmZyb21VcmxzKFsnL3ZpZGVvLndlYm0nLCAnL3ZpZGVvLm1wNCddKTtcbiAqXG4gKiB2YXIgdGV4dHVyZSA9IFBJWEkuVmlkZW9CYXNlVGV4dHVyZS5mcm9tVXJscyhbXG4gKiAgICAgeyBzcmM6ICcvdmlkZW8ud2VibScsIG1pbWU6ICd2aWRlby93ZWJtJyB9LFxuICogICAgIHsgc3JjOiAnL3ZpZGVvLm1wNCcsIG1pbWU6ICd2aWRlby9tcDQnIH1cbiAqIF0pO1xuICogYGBgXG4gKlxuICogU2VlIHRoZSBbXCJkZXVzXCIgZGVtb10oaHR0cDovL3d3dy5nb29kYm95ZGlnaXRhbC5jb20vcGl4aWpzL2V4YW1wbGVzL2RldXMvKS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEJhc2VUZXh0dXJlXG4gKiBAbWVtYmVyb2YgUElYSVxuICogQHBhcmFtIHNvdXJjZSB7SFRNTFZpZGVvRWxlbWVudH1cbiAqIEBwYXJhbSBbc2NhbGVNb2RlXSB7bnVtYmVyfSBTZWUge0BsaW5rIFNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIFZpZGVvQmFzZVRleHR1cmUoc291cmNlLCBzY2FsZU1vZGUpXG57XG4gICAgaWYgKCFzb3VyY2UpXG4gICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZpZGVvIHNvdXJjZSBlbGVtZW50IHNwZWNpZmllZC4nKTtcbiAgICB9XG5cbiAgICAvLyBob29rIGluIGhlcmUgdG8gY2hlY2sgaWYgdmlkZW8gaXMgYWxyZWFkeSBhdmFpbGFibGUuXG4gICAgLy8gQmFzZVRleHR1cmUgbG9va3MgZm9yIGEgc291cmNlLmNvbXBsZXRlIGJvb2xlYW4sIHBsdXMgd2lkdGggJiBoZWlnaHQuXG5cbiAgICBpZiAoKHNvdXJjZS5yZWFkeVN0YXRlID09PSBzb3VyY2UuSEFWRV9FTk9VR0hfREFUQSB8fCBzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRlVUVVJFX0RBVEEpICYmIHNvdXJjZS53aWR0aCAmJiBzb3VyY2UuaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgc291cmNlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBCYXNlVGV4dHVyZS5jYWxsKHRoaXMsIHNvdXJjZSwgc2NhbGVNb2RlKTtcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCB0aGUgYmFzZSB0ZXh0dXJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlIGl0c2VsZiwgc2V0IHRvIHRydWUgYnkgZGVmYXVsdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9vblVwZGF0ZSA9IHRoaXMuX29uVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DYW5QbGF5ID0gdGhpcy5fb25DYW5QbGF5LmJpbmQodGhpcyk7XG5cbiAgICBpZiAoIXNvdXJjZS5jb21wbGV0ZSlcbiAgICB7XG4gICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fb25DYW5QbGF5KTtcblxuICAgICAgICAvLyBzdGFydGVkIHBsYXlpbmcuLlxuICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigncGxheScsIHRoaXMuX29uUGxheVN0YXJ0LmJpbmQodGhpcykpO1xuICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCB0aGlzLl9vblBsYXlTdG9wLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHRoaXMuX19sb2FkZWQgPSBmYWxzZTtcbn1cblxuVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VUZXh0dXJlLnByb3RvdHlwZSk7XG5WaWRlb0Jhc2VUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZpZGVvQmFzZVRleHR1cmU7XG5tb2R1bGUuZXhwb3J0cyA9IFZpZGVvQmFzZVRleHR1cmU7XG5cbi8qKlxuICogVGhlIGludGVybmFsIHVwZGF0ZSBsb29wIG9mIHRoZSB2aWRlbyBiYXNlIHRleHR1cmUsIG9ubHkgcnVucyB3aGVuIGF1dG9VcGRhdGUgaXMgc2V0IHRvIHRydWVcbiAqIEBwcml2YXRlXG4gKi9cblZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLl9vblVwZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuYXV0b1VwZGF0ZSlcbiAgICB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fb25VcGRhdGUpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUnVucyB0aGUgdXBkYXRlIGxvb3Agd2hlbiB0aGUgdmlkZW8gaXMgcmVhZHkgdG8gcGxheVxuICogQHByaXZhdGVcbiAqL1xuVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUuX29uUGxheVN0YXJ0ID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMuYXV0b1VwZGF0ZSlcbiAgICB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fb25VcGRhdGUpO1xuICAgICAgICB0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogRmlyZWQgd2hlbiBhIHBhdXNlIGV2ZW50IGlzIHRyaWdnZXJlZCwgc3RvcHMgdGhlIHVwZGF0ZSBsb29wXG4gKiBAcHJpdmF0ZVxuICovXG5WaWRlb0Jhc2VUZXh0dXJlLnByb3RvdHlwZS5fb25QbGF5U3RvcCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5hdXRvVXBkYXRlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHZpZGVvIGlzIGxvYWRlZCBhbmQgcmVhZHkgdG8gcGxheVxuICogQHByaXZhdGVcbiAqL1xuVmlkZW9CYXNlVGV4dHVyZS5wcm90b3R5cGUuX29uQ2FuUGxheSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5oYXNMb2FkZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuc291cmNlKVxuICAgIHtcbiAgICAgICAgdGhpcy5zb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheScsIHRoaXMuX29uQ2FuUGxheSk7XG4gICAgICAgIHRoaXMuc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fb25DYW5QbGF5KTtcblxuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5zb3VyY2UudmlkZW9XaWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnNvdXJjZS52aWRlb0hlaWdodDtcblxuICAgICAgICB0aGlzLnNvdXJjZS5wbGF5KCk7XG5cbiAgICAgICAgLy8gcHJldmVudCBtdWx0aXBsZSBsb2FkZWQgZGlzcGF0Y2hlcy4uXG4gICAgICAgIGlmICghdGhpcy5fX2xvYWRlZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fX2xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2xvYWRlZCcsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAqXG4gKi9cblZpZGVvQmFzZVRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5fcGl4aUlkKVxuICAgIHtcbiAgICAgICAgdXRpbHMuQmFzZVRleHR1cmVDYWNoZVsgdGhpcy5zb3VyY2UuX3BpeGlJZCBdID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbIHRoaXMuc291cmNlLl9waXhpSWQgXTtcblxuICAgICAgICB0aGlzLnNvdXJjZS5fcGl4aUlkID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlLl9waXhpSWQ7XG4gICAgfVxuXG4gICAgQmFzZVRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogTWltaWMgUGl4aSBCYXNlVGV4dHVyZS5mcm9tLi4uLiBtZXRob2QuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHZpZGVvIHtIVE1MVmlkZW9FbGVtZW50fVxuICogQHBhcmFtIHNjYWxlTW9kZSB7bnVtYmVyfSBTZWUge0BsaW5rIFNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcmV0dXJuIHtWaWRlb0Jhc2VUZXh0dXJlfVxuICovXG5WaWRlb0Jhc2VUZXh0dXJlLmZyb21WaWRlbyA9IGZ1bmN0aW9uICh2aWRlbywgc2NhbGVNb2RlKVxue1xuICAgIGlmICghdmlkZW8uX3BpeGlJZClcbiAgICB7XG4gICAgICAgIHZpZGVvLl9waXhpSWQgPSAndmlkZW9fJyArIHV0aWxzLnV1aWQoKTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZVRleHR1cmUgPSB1dGlscy5CYXNlVGV4dHVyZUNhY2hlW3ZpZGVvLl9waXhpSWRdO1xuXG4gICAgaWYgKCFiYXNlVGV4dHVyZSlcbiAgICB7XG4gICAgICAgIGJhc2VUZXh0dXJlID0gbmV3IFZpZGVvQmFzZVRleHR1cmUodmlkZW8sIHNjYWxlTW9kZSk7XG4gICAgICAgIHV0aWxzLkJhc2VUZXh0dXJlQ2FjaGVbIHZpZGVvLl9waXhpSWQgXSA9IGJhc2VUZXh0dXJlO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBCYXNlVGV4dHVyZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gdmlkZW8gZWxlbWVudC5cbiAqIFRoaXMgQmFzZVRleHR1cmUgY2FuIHRoZW4gYmUgdXNlZCB0byBjcmVhdGUgYSB0ZXh0dXJlXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHZpZGVvU3JjIHtzdHJpbmd8b2JqZWN0fHN0cmluZ1tdfG9iamVjdFtdfSBUaGUgVVJMKHMpIGZvciB0aGUgdmlkZW8uXG4gKiBAcGFyYW0gW3ZpZGVvU3JjLnNyY10ge3N0cmluZ30gT25lIG9mIHRoZSBzb3VyY2UgdXJscyBmb3IgdGhlIHZpZGVvXG4gKiBAcGFyYW0gW3ZpZGVvU3JjLm1pbWVdIHtzdHJpbmd9IFRoZSBtaW1ldHlwZSBvZiB0aGUgdmlkZW8gKGUuZy4gJ3ZpZGVvL21wNCcpLiBJZiBub3Qgc3BlY2lmaWVkXG4gKiAgdGhlIHVybCdzIGV4dGVuc2lvbiB3aWxsIGJlIHVzZWQgYXMgdGhlIHNlY29uZCBwYXJ0IG9mIHRoZSBtaW1lIHR5cGUuXG4gKiBAcGFyYW0gc2NhbGVNb2RlIHtudW1iZXJ9IFNlZSB7QGxpbmsgU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcbiAqIEByZXR1cm4ge1ZpZGVvQmFzZVRleHR1cmV9XG4gKi9cblZpZGVvQmFzZVRleHR1cmUuZnJvbVVybCA9IGZ1bmN0aW9uICh2aWRlb1NyYywgc2NhbGVNb2RlKVxue1xuICAgIHZhciB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG5cbiAgICAvLyBhcnJheSBvZiBvYmplY3RzIG9yIHN0cmluZ3NcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2aWRlb1NyYykpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZGVvU3JjLmxlbmd0aDsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWRlby5hcHBlbmRDaGlsZChjcmVhdGVTb3VyY2UodmlkZW9TcmMuc3JjIHx8IHZpZGVvU3JjLCB2aWRlb1NyYy5taW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2luZ2xlIG9iamVjdCBvciBzdHJpbmdcbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2aWRlby5hcHBlbmRDaGlsZChjcmVhdGVTb3VyY2UodmlkZW9TcmMuc3JjIHx8IHZpZGVvU3JjLCB2aWRlb1NyYy5taW1lKSk7XG4gICAgfVxuXG4gICAgdmlkZW8ubG9hZCgpO1xuICAgIHZpZGVvLnBsYXkoKTtcblxuICAgIHJldHVybiBWaWRlb0Jhc2VUZXh0dXJlLmZyb21WaWRlbyh2aWRlbywgc2NhbGVNb2RlKTtcbn07XG5cblZpZGVvQmFzZVRleHR1cmUuZnJvbVVybHMgPSBWaWRlb0Jhc2VUZXh0dXJlLmZyb21Vcmw7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNvdXJjZShwYXRoLCB0eXBlKVxue1xuICAgIGlmICghdHlwZSlcbiAgICB7XG4gICAgICAgIHR5cGUgPSAndmlkZW8vJyArIHBhdGguc3Vic3RyKHBhdGgubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcblxuICAgIHNvdXJjZS5zcmMgPSBwYXRoO1xuICAgIHNvdXJjZS50eXBlID0gdHlwZTtcblxuICAgIHJldHVybiBzb3VyY2U7XG59XG4iLCIvL1RPRE86IEhhdmUgR3JhcGhpY3MgdXNlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9zaGFwZTJkXG4vLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL3NoYXBlMmQtdHJpYW5ndWxhdGUgaW5zdGVhZCBvZiBjdXN0b20gY29kZS5cblxuLypcbiAgICBQb2x5SyBsaWJyYXJ5XG4gICAgdXJsOiBodHRwOi8vcG9seWsuaXZhbmsubmV0XG4gICAgUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2VuY2UuXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTIgSXZhbiBLdWNraXJcblxuICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAgICBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAgICByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAgICBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICAgIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gICAgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICAgIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAgICBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAgICBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gICAgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4gICAgVGhpcyBpcyBhbiBhbWF6aW5nIGxpYiFcblxuICAgIFNsaWdodGx5IG1vZGlmaWVkIGJ5IE1hdCBHcm92ZXMgKG1hdGdyb3Zlcy5jb20pO1xuKi9cblxuLyoqXG4gKiBCYXNlZCBvbiB0aGUgUG9seWsgbGlicmFyeSBodHRwOi8vcG9seWsuaXZhbmsubmV0IHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbmNlLlxuICogVGhpcyBpcyBhbiBhbWF6aW5nIGxpYiFcbiAqIFNsaWdodGx5IG1vZGlmaWVkIGJ5IE1hdCBHcm92ZXMgKG1hdGdyb3Zlcy5jb20pO1xuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKi9cbnZhciBQb2x5SyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogVHJpYW5ndWxhdGVzIHNoYXBlcyBmb3Igd2ViR0wgZ3JhcGhpYyBmaWxscy5cbiAqXG4gKi9cblBvbHlLLlRyaWFuZ3VsYXRlID0gZnVuY3Rpb24gKHApXG57XG4gICAgdmFyIHNpZ24gPSB0cnVlO1xuXG4gICAgdmFyIG4gPSBwLmxlbmd0aCA+PiAxO1xuICAgIGlmIChuIDwgMykgcmV0dXJuIFtdO1xuXG4gICAgdmFyIHRncyA9IFtdO1xuICAgIHZhciBhdmwgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYXZsLnB1c2goaSk7XG5cbiAgICBpID0gMDtcbiAgICB2YXIgYWwgPSBuO1xuICAgIHdoaWxlIChhbCA+IDMpXG4gICAge1xuICAgICAgICB2YXIgaTAgPSBhdmxbKGkrMCklYWxdO1xuICAgICAgICB2YXIgaTEgPSBhdmxbKGkrMSklYWxdO1xuICAgICAgICB2YXIgaTIgPSBhdmxbKGkrMiklYWxdO1xuXG4gICAgICAgIHZhciBheCA9IHBbMippMF0sICBheSA9IHBbMippMCsxXTtcbiAgICAgICAgdmFyIGJ4ID0gcFsyKmkxXSwgIGJ5ID0gcFsyKmkxKzFdO1xuICAgICAgICB2YXIgY3ggPSBwWzIqaTJdLCAgY3kgPSBwWzIqaTIrMV07XG5cbiAgICAgICAgdmFyIGVhckZvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmIChQb2x5Sy5fY29udmV4KGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHNpZ24pKVxuICAgICAgICB7XG4gICAgICAgICAgICBlYXJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHZpID0gYXZsW2pdO1xuICAgICAgICAgICAgICAgIGlmICh2aSA9PT0gaTAgfHwgdmkgPT09IGkxIHx8IHZpID09PSBpMikgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoUG9seUsuX1BvaW50SW5UcmlhbmdsZShwWzIqdmldLCBwWzIqdmkrMV0sIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZWFyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVhckZvdW5kKVxuICAgICAgICB7XG4gICAgICAgICAgICB0Z3MucHVzaChpMCwgaTEsIGkyKTtcbiAgICAgICAgICAgIGF2bC5zcGxpY2UoKGkrMSklYWwsIDEpO1xuICAgICAgICAgICAgYWwtLTtcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkrKyA+IDMqYWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gZmxpcCBmbGlwIHJldmVyc2UgaXQhXG4gICAgICAgICAgICAvLyByZXNldCFcbiAgICAgICAgICAgIGlmIChzaWduKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRncyA9IFtdO1xuICAgICAgICAgICAgICAgIGF2bCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGF2bC5wdXNoKGkpO1xuXG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgYWwgPSBuO1xuXG4gICAgICAgICAgICAgICAgc2lnbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgIC8vICAgd2luZG93LmNvbnNvbGUubG9nKFwiUElYSSBXYXJuaW5nOiBzaGFwZSB0b28gY29tcGxleCB0byBmaWxsXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGdzLnB1c2goYXZsWzBdLCBhdmxbMV0sIGF2bFsyXSk7XG4gICAgcmV0dXJuIHRncztcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBwb2ludCBpcyB3aXRoaW4gYSB0cmlhbmdsZVxuICpcbiAqIEBwYXJhbSBweCB7bnVtYmVyfSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSBweSB7bnVtYmVyfSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSBheCB7bnVtYmVyfSB4IGNvb3JkaW5hdGUgb2YgdGhlIGEgcG9pbnQgb2YgdGhlIHRyaWFuZ2xlXG4gKiBAcGFyYW0gYXkge251bWJlcn0geSBjb29yZGluYXRlIG9mIHRoZSBhIHBvaW50IG9mIHRoZSB0cmlhbmdsZVxuICogQHBhcmFtIGJ4IHtudW1iZXJ9IHggY29vcmRpbmF0ZSBvZiB0aGUgYiBwb2ludCBvZiB0aGUgdHJpYW5nbGVcbiAqIEBwYXJhbSBieSB7bnVtYmVyfSB5IGNvb3JkaW5hdGUgb2YgdGhlIGIgcG9pbnQgb2YgdGhlIHRyaWFuZ2xlXG4gKiBAcGFyYW0gY3gge251bWJlcn0geCBjb29yZGluYXRlIG9mIHRoZSBjIHBvaW50IG9mIHRoZSB0cmlhbmdsZVxuICogQHBhcmFtIGN5IHtudW1iZXJ9IHkgY29vcmRpbmF0ZSBvZiB0aGUgYyBwb2ludCBvZiB0aGUgdHJpYW5nbGVcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5Qb2x5Sy5fUG9pbnRJblRyaWFuZ2xlID0gZnVuY3Rpb24gKHB4LCBweSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSlcbntcbiAgICB2YXIgdjB4ID0gY3gtYXg7XG4gICAgdmFyIHYweSA9IGN5LWF5O1xuICAgIHZhciB2MXggPSBieC1heDtcbiAgICB2YXIgdjF5ID0gYnktYXk7XG4gICAgdmFyIHYyeCA9IHB4LWF4O1xuICAgIHZhciB2MnkgPSBweS1heTtcblxuICAgIHZhciBkb3QwMCA9IHYweCp2MHgrdjB5KnYweTtcbiAgICB2YXIgZG90MDEgPSB2MHgqdjF4K3YweSp2MXk7XG4gICAgdmFyIGRvdDAyID0gdjB4KnYyeCt2MHkqdjJ5O1xuICAgIHZhciBkb3QxMSA9IHYxeCp2MXgrdjF5KnYxeTtcbiAgICB2YXIgZG90MTIgPSB2MXgqdjJ4K3YxeSp2Mnk7XG5cbiAgICB2YXIgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKTtcbiAgICB2YXIgdSA9IChkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMikgKiBpbnZEZW5vbTtcbiAgICB2YXIgdiA9IChkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMikgKiBpbnZEZW5vbTtcblxuICAgIC8vIENoZWNrIGlmIHBvaW50IGlzIGluIHRyaWFuZ2xlXG4gICAgcmV0dXJuICh1ID49IDApICYmICh2ID49IDApICYmICh1ICsgdiA8IDEpO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHNoYXBlIGlzIGNvbnZleFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5Qb2x5Sy5fY29udmV4ID0gZnVuY3Rpb24gKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHNpZ24pXG57XG4gICAgcmV0dXJuICgoYXktYnkpKihjeC1ieCkgKyAoYngtYXgpKihjeS1ieSkgPj0gMCkgPT09IHNpZ247XG59O1xuIiwidmFyIENPTlNUID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIFBJWEkudXRpbHNcbiAqL1xudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgX3VpZDogMCxcbiAgICBfc2FpZEhlbGxvOiBmYWxzZSxcblxuICAgIHBsdWdpblRhcmdldDogICByZXF1aXJlKCcuL3BsdWdpblRhcmdldCcpLFxuICAgIFBvbHlLOiAgICAgICAgICByZXF1aXJlKCcuL1BvbHlLJyksXG5cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5leHQgdXVpZFxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCB1dWlkIHRvIHVzZS5cbiAgICAgKi9cbiAgICB1dWlkOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICsrdXRpbHMuX3VpZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBoZXggY29sb3IgbnVtYmVyIHRvIGFuIFtSLCBHLCBCXSBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIGhleCB7bnVtYmVyfVxuICAgICAqIEByZXR1cm4ge251bWJlcltdfSBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIFtSLCBHLCBCXSBvZiB0aGUgY29sb3IuXG4gICAgICovXG4gICAgaGV4MnJnYjogZnVuY3Rpb24gKGhleCwgb3V0KVxuICAgIHtcbiAgICAgICAgb3V0ID0gb3V0IHx8IFtdO1xuXG4gICAgICAgIG91dFswXSA9IChoZXggPj4gMTYgJiAweEZGKSAvIDI1NTtcbiAgICAgICAgb3V0WzFdID0gKGhleCA+PiA4ICYgMHhGRikgLyAyNTU7XG4gICAgICAgIG91dFsyXSA9IChoZXggJiAweEZGKSAvIDI1NTtcblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGhleCBjb2xvciBudW1iZXIgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGV4IHtudW1iZXJ9XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIGNvbG9yLlxuICAgICAqL1xuICAgIGhleDJzdHJpbmc6IGZ1bmN0aW9uIChoZXgpXG4gICAge1xuICAgICAgICBoZXggPSBoZXgudG9TdHJpbmcoMTYpO1xuICAgICAgICBoZXggPSAnMDAwMDAwJy5zdWJzdHIoMCwgNiAtIGhleC5sZW5ndGgpICsgaGV4O1xuXG4gICAgICAgIHJldHVybiAnIycgKyBoZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgY29sb3IgYXMgYW4gW1IsIEcsIEJdIGFycmF5IHRvIGEgaGV4IG51bWJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHJnYiB7bnVtYmVyW119XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29sb3IgbnVtYmVyXG4gICAgICovXG4gICAgcmdiMmhleDogZnVuY3Rpb24gKHJnYilcbiAgICB7XG4gICAgICAgIHJldHVybiAoKHJnYlswXSoyNTUgPDwgMTYpICsgKHJnYlsxXSoyNTUgPDwgOCkgKyByZ2JbMl0qMjU1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIENhbnZhcyBCbGVuZE1vZGVzIGFyZSBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgYnJvd3NlclxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGV5IGFyZSBzdXBwb3J0ZWRcbiAgICAgKi9cbiAgICBjYW5Vc2VOZXdDYW52YXNCbGVuZE1vZGVzOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwbmdIZWFkID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVFBQUFBQkFRTUFBQUREOHAyT0FBQUFBMUJNVkVYLyc7XG4gICAgICAgIHZhciBwbmdFbmQgPSAnQUFBQUNrbEVRVlFJMTJOZ0FBQUFBZ0FCNGlHOE13QUFBQUJKUlU1RXJrSmdnZz09JztcblxuICAgICAgICB2YXIgbWFnZW50YSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBtYWdlbnRhLnNyYyA9IHBuZ0hlYWQgKyAnQVA4MDRPYTYnICsgcG5nRW5kO1xuXG4gICAgICAgIHZhciB5ZWxsb3cgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgeWVsbG93LnNyYyA9IHBuZ0hlYWQgKyAnL3dDS3h2UkYnICsgcG5nRW5kO1xuXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gNjtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDE7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbXVsdGlwbHknO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShtYWdlbnRhLCAwLCAwKTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoeWVsbG93LCAyLCAwKTtcblxuICAgICAgICB2YXIgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDIsMCwxLDEpLmRhdGE7XG5cbiAgICAgICAgcmV0dXJuIChkYXRhWzBdID09PSAyNTUgJiYgZGF0YVsxXSA9PT0gMCAmJiBkYXRhWzJdID09PSAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBudW1iZXIsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY2xvc2VzdCBudW1iZXIgdGhhdCBpcyBhIHBvd2VyIG9mIHR3b1xuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgdGFrZW4gZnJvbSBTdGFybGluZyBGcmFtZXdvcmsgYXMgaXRzIHByZXR0eSBuZWF0IDspXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbnVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgY2xvc2VzdCBudW1iZXIgdGhhdCBpcyBhIHBvd2VyIG9mIHR3b1xuICAgICAqL1xuICAgIGdldE5leHRQb3dlck9mVHdvOiBmdW5jdGlvbiAobnVtYmVyKVxuICAgIHtcbiAgICAgICAgLy8gc2VlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Bvd2VyX29mX3R3byNGYXN0X2FsZ29yaXRobV90b19jaGVja19pZl9hX3Bvc2l0aXZlX251bWJlcl9pc19hX3Bvd2VyX29mX3R3b1xuICAgICAgICBpZiAobnVtYmVyID4gMCAmJiAobnVtYmVyICYgKG51bWJlciAtIDEpKSA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAxO1xuXG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0IDwgbnVtYmVyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA8PD0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjaGVja3MgaWYgdGhlIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHQgbWFrZSBhIHBvd2VyIG9mIHR3byByZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSBoZWlnaHQge251bWJlcn1cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUG93ZXJPZlR3bzogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICByZXR1cm4gKHdpZHRoID4gMCAmJiAod2lkdGggJiAod2lkdGggLSAxKSkgPT09IDAgJiYgaGVpZ2h0ID4gMCAmJiAoaGVpZ2h0ICYgKGhlaWdodCAtIDEpKSA9PT0gMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgcmVzb2x1dGlvbiBvZiBhbiBhc3NldCBieSBsb29raW5nIGZvciB0aGUgcHJlZml4XG4gICAgICogdXNlZCBieSBzcHJpdGVzaGVldHMgYW5kIGltYWdlIHVybHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwge3N0cmluZ30gdGhlIGltYWdlIHBhdGhcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldFJlc29sdXRpb25PZlVybDogZnVuY3Rpb24gKHVybClcbiAgICB7XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gQ09OU1QuUkVUSU5BX1BSRUZJWC5leGVjKHVybCk7XG5cbiAgICAgICAgaWYgKHJlc29sdXRpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocmVzb2x1dGlvblsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9ncyBvdXQgdGhlIHZlcnNpb24gYW5kIHJlbmRlcmVyIGluZm9ybWF0aW9uIGZvciB0aGlzIHJ1bm5pbmcgaW5zdGFuY2Ugb2YgUElYSS5cbiAgICAgKiBJZiB5b3UgZG9uJ3Qgd2FudCB0byBzZWUgdGhpcyBtZXNzYWdlIHlvdSBjYW4gc2V0IGBQSVhJLnV0aWxzLl9zYWlkSGVsbG8gPSB0cnVlO2BcbiAgICAgKiBzbyB0aGUgbGlicmFyeSB0aGlua3MgaXQgYWxyZWFkeSBzYWlkIGl0LiBLZWVwIGluIG1pbmQgdGhhdCBkb2luZyB0aGF0IHdpbGwgZm9yZXZlclxuICAgICAqIG1ha2VzIHlvdSBhIGplcmsgZmFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHN0cmluZyByZW5kZXJlciB0eXBlIHRvIGxvZy5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc2F5SGVsbG86IGZ1bmN0aW9uICh0eXBlKVxuICAgIHtcbiAgICAgICAgaWYgKHV0aWxzLl9zYWlkSGVsbG8pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPiAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXG4gICAgICAgICAgICAgICAgJ1xcbiAlYyAlYyAlYyBQaXhpLmpzICcgKyBDT05TVC5WRVJTSU9OICsgJyAtIOKcsCAnICsgdHlwZSArICcg4pywICAlYyAnICsgJyAlYyAnICsgJyBodHRwOi8vd3d3LnBpeGlqcy5jb20vICAlYyAlYyDimaUlY+KZpSVj4pmlIFxcblxcbicsXG4gICAgICAgICAgICAgICAgJ2JhY2tncm91bmQ6ICNmZjY2YTU7IHBhZGRpbmc6NXB4IDA7JyxcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZDogI2ZmNjZhNTsgcGFkZGluZzo1cHggMDsnLFxuICAgICAgICAgICAgICAgICdjb2xvcjogI2ZmNjZhNTsgYmFja2dyb3VuZDogIzAzMDMwNzsgcGFkZGluZzo1cHggMDsnLFxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kOiAjZmY2NmE1OyBwYWRkaW5nOjVweCAwOycsXG4gICAgICAgICAgICAgICAgJ2JhY2tncm91bmQ6ICNmZmMzZGM7IHBhZGRpbmc6NXB4IDA7JyxcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZDogI2ZmNjZhNTsgcGFkZGluZzo1cHggMDsnLFxuICAgICAgICAgICAgICAgICdjb2xvcjogI2ZmMjQyNDsgYmFja2dyb3VuZDogI2ZmZjsgcGFkZGluZzo1cHggMDsnLFxuICAgICAgICAgICAgICAgICdjb2xvcjogI2ZmMjQyNDsgYmFja2dyb3VuZDogI2ZmZjsgcGFkZGluZzo1cHggMDsnLFxuICAgICAgICAgICAgICAgICdjb2xvcjogI2ZmMjQyNDsgYmFja2dyb3VuZDogI2ZmZjsgcGFkZGluZzo1cHggMDsnLFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpOyAvL2pzaGludCBpZ25vcmU6bGluZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdpbmRvdy5jb25zb2xlKVxuICAgICAgICB7XG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ1BpeGkuanMgJyArIENPTlNULlZFUlNJT04gKyAnIC0gJyArIHR5cGUgKyAnIC0gaHR0cDovL3d3dy5waXhpanMuY29tLycpOyAvL2pzaGludCBpZ25vcmU6bGluZVxuICAgICAgICB9XG5cbiAgICAgICAgdXRpbHMuX3NhaWRIZWxsbyA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmb3IgY2hlY2tpbmcgZm9yIHdlYmdsIHN1cHBvcnRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNXZWJHTFN1cHBvcnRlZDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IHsgc3RlbmNpbDogdHJ1ZSB9O1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxuICAgICAgICAgICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgY29udGV4dE9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBjb250ZXh0T3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHJldHVybiAhIShnbCAmJiBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpLnN0ZW5jaWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgVGV4dHVyZUNhY2hlOiB7fSxcbiAgICBCYXNlVGV4dHVyZUNhY2hlOiB7fVxufTtcbiIsIi8qKlxuICogTWl4aW5zIGZ1bmN0aW9uYWxpdHkgdG8gbWFrZSBhbiBvYmplY3QgaGF2ZSBcInBsdWdpbnNcIi5cbiAqXG4gKiBAbWl4aW5cbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAcGFyYW0gb2JqIHtvYmplY3R9IFRoZSBvYmplY3QgdG8gbWl4IGludG8uXG4gKiBAZXhhbXBsZVxuICogICAgICBmdW5jdGlvbiBNeU9iamVjdCgpIHt9XG4gKlxuICogICAgICBwbHVnaW5UYXJnZXQubWl4aW4oTXlPYmplY3QpO1xuICovXG5mdW5jdGlvbiBwbHVnaW5UYXJnZXQob2JqKVxue1xuICAgIG9iai5fX3BsdWdpbnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwbHVnaW4gdG8gYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGx1Z2luTmFtZSB7c3RyaW5nfSBUaGUgZXZlbnRzIHRoYXQgc2hvdWxkIGJlIGxpc3RlZC5cbiAgICAgKiBAcGFyYW0gY3RvciB7T2JqZWN0fSA/PyBAYWx2aW5cbiAgICAgKi9cbiAgICBvYmoucmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luTmFtZSwgY3RvcilcbiAgICB7XG4gICAgICAgIG9iai5fX3BsdWdpbnNbcGx1Z2luTmFtZV0gPSBjdG9yO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYWxsIHRoZSBwbHVnaW5zIG9mIHRoaXMgb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBvYmoucHJvdG90eXBlLmluaXRQbHVnaW5zID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucyB8fCB7fTtcblxuICAgICAgICBmb3IgKHZhciBvIGluIG9iai5fX3BsdWdpbnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tvXSA9IG5ldyAob2JqLl9fcGx1Z2luc1tvXSkodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIHBsdWdpbnMgb2YgdGhpcyBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIG9iai5wcm90b3R5cGUuZGVzdHJveVBsdWdpbnMgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgbyBpbiB0aGlzLnBsdWdpbnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tvXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnNbb10gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wbHVnaW5zID0gbnVsbDtcbiAgICB9O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIE1peGVzIGluIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBwbHVnaW5UYXJnZXQgaW50byBhbm90aGVyIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9iamVjdCB7b2JqZWN0fSBUaGUgb2JqIHRvIG1peCBpbnRvXG4gICAgICovXG4gICAgbWl4aW46IGZ1bmN0aW9uIG1peGluKG9iailcbiAgICB7XG4gICAgICAgIHBsdWdpblRhcmdldChvYmopO1xuICAgIH1cbn07XG4iLCIvKmdsb2JhbCBjb25zb2xlICovXG52YXIgY29yZSAgID0gcmVxdWlyZSgnLi9jb3JlJyksXG4gICAgbWVzaCAgID0gcmVxdWlyZSgnLi9tZXNoJyksXG4gICAgZXh0cmFzID0gcmVxdWlyZSgnLi9leHRyYXMnKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBuYW1lIFBJWEkuU3ByaXRlQmF0Y2hcbiAqIEBzZWUge0BsaW5rIFBJWEkuUGFydGljbGVDb250YWluZXJ9XG4gKiBAdGhyb3dzIHtSZWZlcmVuY2VFcnJvcn0gU3ByaXRlQmF0Y2ggZG9lcyBub3QgZXhpc3QgYW55IG1vcmUsIHBsZWFzZSB1c2UgdGhlIG5ldyBQYXJ0aWNsZUNvbnRhaW5lciBpbnN0ZWFkLlxuICovXG5jb3JlLlNwcml0ZUJhdGNoID0gZnVuY3Rpb24gKClcbntcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1Nwcml0ZUJhdGNoIGRvZXMgbm90IGV4aXN0IGFueSBtb3JlLCBwbGVhc2UgdXNlIHRoZSBuZXcgUGFydGljbGVDb250YWluZXIgaW5zdGVhZC4nKTtcbn07XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbmFtZSBQSVhJLkFzc2V0TG9hZGVyXG4gKiBAc2VlIHtAbGluayBQSVhJLmxvYWRlcnMuTG9hZGVyfVxuICogQHRocm93cyB7UmVmZXJlbmNlRXJyb3J9IFRoZSBsb2FkZXIgc3lzdGVtIHdhcyBvdmVyaGF1bGVkIGluIHBpeGkgdjMsIHBsZWFzZSBzZWUgdGhlIG5ldyBQSVhJLkxvYWRlciBjbGFzcy5cbiAqL1xuY29yZS5Bc3NldExvYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1RoZSBsb2FkZXIgc3lzdGVtIHdhcyBvdmVyaGF1bGVkIGluIHBpeGkgdjMsIHBsZWFzZSBzZWUgdGhlIG5ldyBQSVhJLkxvYWRlciBjbGFzcy4nKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvcmUsIHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIFBJWEkuU3RhZ2VcbiAgICAgKiBAc2VlIHtAbGluayBQSVhJLkNvbnRhaW5lcn1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMFxuICAgICAqL1xuICAgIFN0YWdlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdZb3UgZG8gbm90IG5lZWQgdG8gdXNlIGEgUElYSSBTdGFnZSBhbnkgbW9yZSwgeW91IGNhbiBzaW1wbHkgcmVuZGVyIGFueSBjb250YWluZXIuJyk7XG4gICAgICAgICAgICByZXR1cm4gY29yZS5Db250YWluZXI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgUElYSS5EaXNwbGF5T2JqZWN0Q29udGFpbmVyXG4gICAgICogQHNlZSB7QGxpbmsgUElYSS5Db250YWluZXJ9XG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjBcbiAgICAgKi9cbiAgICBEaXNwbGF5T2JqZWN0Q29udGFpbmVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNwbGF5T2JqZWN0Q29udGFpbmVyIGhhcyBiZWVuIHNob3J0ZW5lZCB0byBDb250YWluZXIsIHBsZWFzZSB1c2UgQ29udGFpbmVyIGZyb20gbm93IG9uLicpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcmUuQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIFBJWEkuU3RyaXBcbiAgICAgKiBAc2VlIHtAbGluayBQSVhJLm1lc2guTWVzaH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMFxuICAgICAqL1xuICAgIFN0cmlwOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgU3RyaXAgY2xhc3MgaGFzIGJlZW4gcmVuYW1lZCB0byBNZXNoLCBwbGVhc2UgdXNlIE1lc2ggZnJvbSBub3cgb24uJyk7XG4gICAgICAgICAgICByZXR1cm4gbWVzaC5NZXNoO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuLyoqXG4gKiBAbWV0aG9kXG4gKiBAbmFtZSBQSVhJLlNwcml0ZSNzZXRUZXh0dXJlXG4gKiBAc2VlIHtAbGluayBQSVhJLlNwcml0ZSN0ZXh0dXJlfVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjBcbiAqL1xuY29yZS5TcHJpdGUucHJvdG90eXBlLnNldFRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSlcbntcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIGNvbnNvbGUud2Fybignc2V0VGV4dHVyZSBpcyBub3cgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0aGUgdGV4dHVyZSBwcm9wZXJ0eSwgZS5nIDogc3ByaXRlLnRleHR1cmUgPSB0ZXh0dXJlOycpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kXG4gKiBAbmFtZSBQSVhJLmV4dHJhcy5CaXRtYXBUZXh0I3NldFRleHRcbiAqIEBzZWUge0BsaW5rIFBJWEkuQml0bWFwVGV4dCN0ZXh0fVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAzLjBcbiAqL1xuZXh0cmFzLkJpdG1hcFRleHQucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAodGV4dClcbntcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIGNvbnNvbGUud2Fybignc2V0VGV4dCBpcyBub3cgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0aGUgdGV4dCBwcm9wZXJ0eSwgZS5nIDogbXlCaXRtYXBUZXh0LnRleHQgPSBcXCdteSB0ZXh0XFwnOycpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kXG4gKiBAbmFtZSBQSVhJLlRleHQjc2V0VGV4dFxuICogQHNlZSB7QGxpbmsgUElYSS5UZXh0I3RleHR9XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMFxuICovXG5jb3JlLlRleHQucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAodGV4dClcbntcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIGNvbnNvbGUud2Fybignc2V0VGV4dCBpcyBub3cgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB0aGUgdGV4dCBwcm9wZXJ0eSwgZS5nIDogbXlUZXh0LnRleHQgPSBcXCdteSB0ZXh0XFwnOycpO1xufTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIEEgQml0bWFwVGV4dCBvYmplY3Qgd2lsbCBjcmVhdGUgYSBsaW5lIG9yIG11bHRpcGxlIGxpbmVzIG9mIHRleHQgdXNpbmcgYml0bWFwIGZvbnQuIFRvXG4gKiBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbicsICdcXHInIG9yICdcXHJcXG4nIGluIHlvdXIgc3RyaW5nLiBZb3UgY2FuIGdlbmVyYXRlIHRoZSBmbnQgZmlsZXMgdXNpbmc6XG4gKlxuICogQSBCaXRtYXBUZXh0IGNhbiBvbmx5IGJlIGNyZWF0ZWQgd2hlbiB0aGUgZm9udCBpcyBsb2FkZWRcbiAqXG4gKiBgYGBqc1xuICogLy8gaW4gdGhpcyBjYXNlIHRoZSBmb250IGlzIGluIGEgZmlsZSBjYWxsZWQgJ2Rlc3lyZWwuZm50J1xuICogdmFyIGJpdG1hcFRleHQgPSBuZXcgUElYSS5CaXRtYXBUZXh0KFwidGV4dCB1c2luZyBhIGZhbmN5IGZvbnQhXCIsIHtmb250OiBcIjM1cHggRGVzeXJlbFwiLCBhbGlnbjogXCJyaWdodFwifSk7XG4gKiBgYGBcbiAqXG4gKlxuICogaHR0cDovL3d3dy5hbmdlbGNvZGUuY29tL3Byb2R1Y3RzL2JtZm9udC8gZm9yIHdpbmRvd3Mgb3JcbiAqIGh0dHA6Ly93d3cuYm1nbHlwaC5jb20vIGZvciBtYWMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBDb250YWluZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhc1xuICogQHBhcmFtIHRleHQge3N0cmluZ30gVGhlIGNvcHkgdGhhdCB5b3Ugd291bGQgbGlrZSB0aGUgdGV4dCB0byBkaXNwbGF5XG4gKiBAcGFyYW0gc3R5bGUge29iamVjdH0gVGhlIHN0eWxlIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBzdHlsZS5mb250IHtzdHJpbmd8b2JqZWN0fSBUaGUgZm9udCBkZXNjcmlwdG9yIGZvciB0aGUgb2JqZWN0LCBjYW4gYmUgcGFzc2VkIGFzIGEgc3RyaW5nIG9mIGZvcm1cbiAqICAgICAgXCIyNHB4IEZvbnROYW1lXCIgb3IgXCJGb250TmFtZVwiIG9yIGFzIGFuIG9iamVjdCB3aXRoIGV4cGxpY2l0IG5hbWUvc2l6ZSBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIFtzdHlsZS5mb250Lm5hbWVdIHtzdHJpbmd9IFRoZSBiaXRtYXAgZm9udCBpZFxuICogQHBhcmFtIFtzdHlsZS5mb250LnNpemVdIHtudW1iZXJ9IFRoZSBzaXplIG9mIHRoZSBmb250IGluIHBpeGVscywgZS5nLiAyNFxuICogQHBhcmFtIFtzdHlsZS5hbGlnbj0nbGVmdCddIHtzdHJpbmd9IEFsaWdubWVudCBmb3IgbXVsdGlsaW5lIHRleHQgKCdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0JyksIGRvZXMgbm90IGFmZmVjdFxuICogICAgICBzaW5nbGUgbGluZSB0ZXh0XG4gKiBAcGFyYW0gW3N0eWxlLnRpbnQ9MHhGRkZGRkZdIHtudW1iZXJ9IFRoZSB0aW50IGNvbG9yXG4gKi9cbmZ1bmN0aW9uIEJpdG1hcFRleHQodGV4dCwgc3R5bGUpXG57XG4gICAgY29yZS5Db250YWluZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgb3ZlcmFsbCB0ZXh0LCBkaWZmZXJlbnQgZnJvbSBmb250U2l6ZSxcbiAgICAgKiB3aGljaCBpcyBkZWZpbmVkIGluIHRoZSBzdHlsZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cbiAgICB0aGlzLnRleHRXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBvdmVyYWxsIHRleHQsIGRpZmZlcmVudCBmcm9tIGZvbnRTaXplLFxuICAgICAqIHdoaWNoIGlzIGRlZmluZWQgaW4gdGhlIHN0eWxlIG9iamVjdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMudGV4dEhlaWdodCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBsZXR0ZXIgc3ByaXRlIHBvb2wuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtTcHJpdGVbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2dseXBocyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZvbnQgPSB7XG4gICAgICAgIHRpbnQ6IHN0eWxlLnRpbnQgIT09IHVuZGVmaW5lZCA/IHN0eWxlLnRpbnQgOiAweEZGRkZGRixcbiAgICAgICAgYWxpZ246IHN0eWxlLmFsaWduIHx8ICdsZWZ0JyxcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgc2l6ZTogMFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBjdXJyZW50IGZvbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZvbnQgPSBzdHlsZS5mb250OyAvLyBydW4gZm9udCBzZXR0ZXJcblxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGN1cnJlbnQgdGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1heCB3aWR0aCBvZiB0aGlzIGJpdG1hcCB0ZXh0IGluIHBpeGVscy4gSWYgdGhlIHRleHQgcHJvdmlkZWQgaXMgbG9uZ2VyIHRoYW4gdGhlIHZhbHVlIHByb3ZpZGVkLCBsaW5lIGJyZWFrcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQgaW4gdGhlIGxhc3Qgd2hpdGVzcGFjZS5cbiAgICAgKiBEaXNhYmxlIGJ5IHNldHRpbmcgdmFsdWUgdG8gMFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4V2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRpcnR5IHN0YXRlIG9mIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG5cbiAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbn1cblxuLy8gY29uc3RydWN0b3JcbkJpdG1hcFRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkNvbnRhaW5lci5wcm90b3R5cGUpO1xuQml0bWFwVGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCaXRtYXBUZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBCaXRtYXBUZXh0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCaXRtYXBUZXh0LnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSB0aW50IG9mIHRoZSBCaXRtYXBUZXh0IG9iamVjdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBCaXRtYXBUZXh0I1xuICAgICAqL1xuICAgIHRpbnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udC50aW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZm9udC50aW50ID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgPj0gMCkgPyB2YWx1ZSA6IDB4RkZGRkZGO1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYWxpZ25tZW50IG9mIHRoZSBCaXRtYXBUZXh0IG9iamVjdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdsZWZ0J1xuICAgICAqIEBtZW1iZXJvZiBCaXRtYXBUZXh0I1xuICAgICAqL1xuICAgIGFsaWduOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnQuYWxpZ247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9mb250LmFsaWduID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb250IGRlc2NyaXB0b3Igb2YgdGhlIEJpdG1hcFRleHQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtGb250fVxuICAgICAqIEBtZW1iZXJvZiBCaXRtYXBUZXh0I1xuICAgICAqL1xuICAgIGZvbnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnICcpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udC5uYW1lID0gdmFsdWUubGVuZ3RoID09PSAxID8gdmFsdWVbMF0gOiB2YWx1ZS5zbGljZSgxKS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udC5zaXplID0gdmFsdWUubGVuZ3RoID49IDIgPyBwYXJzZUludCh2YWx1ZVswXSwgMTApIDogQml0bWFwVGV4dC5mb250c1t0aGlzLl9mb250Lm5hbWVdLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250Lm5hbWUgPSB2YWx1ZS5uYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnQuc2l6ZSA9IHR5cGVvZiB2YWx1ZS5zaXplID09PSAnbnVtYmVyJyA/IHZhbHVlLnNpemUgOiBwYXJzZUludCh2YWx1ZS5zaXplLCAxMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IG9mIHRoZSBCaXRtYXBUZXh0IG9iamVjdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBCaXRtYXBUZXh0I1xuICAgICAqL1xuICAgIHRleHQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHQgPSB2YWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBSZW5kZXJzIHRleHQgYW5kIHVwZGF0ZXMgaXQgd2hlbiBuZWVkZWRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5CaXRtYXBUZXh0LnByb3RvdHlwZS51cGRhdGVUZXh0ID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZGF0YSA9IEJpdG1hcFRleHQuZm9udHNbdGhpcy5fZm9udC5uYW1lXTtcbiAgICB2YXIgcG9zID0gbmV3IGNvcmUubWF0aC5Qb2ludCgpO1xuICAgIHZhciBwcmV2Q2hhckNvZGUgPSBudWxsO1xuICAgIHZhciBjaGFycyA9IFtdO1xuICAgIHZhciBsYXN0TGluZVdpZHRoID0gMDtcbiAgICB2YXIgbWF4TGluZVdpZHRoID0gMDtcbiAgICB2YXIgbGluZVdpZHRocyA9IFtdO1xuICAgIHZhciBsaW5lID0gMDtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLl9mb250LnNpemUgLyBkYXRhLnNpemU7XG4gICAgdmFyIGxhc3RTcGFjZSA9IC0xO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRleHQubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgY2hhckNvZGUgPSB0aGlzLnRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgbGFzdFNwYWNlID0gLyhcXHMpLy50ZXN0KHRoaXMudGV4dC5jaGFyQXQoaSkpID8gaSA6IGxhc3RTcGFjZTtcblxuICAgICAgICBpZiAoLyg/OlxcclxcbnxcXHJ8XFxuKS8udGVzdCh0aGlzLnRleHQuY2hhckF0KGkpKSlcbiAgICAgICAge1xuICAgICAgICAgICAgbGluZVdpZHRocy5wdXNoKGxhc3RMaW5lV2lkdGgpO1xuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsYXN0TGluZVdpZHRoKTtcbiAgICAgICAgICAgIGxpbmUrKztcblxuICAgICAgICAgICAgcG9zLnggPSAwO1xuICAgICAgICAgICAgcG9zLnkgKz0gZGF0YS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RTcGFjZSAhPT0gLTEgJiYgdGhpcy5tYXhXaWR0aCA+IDAgJiYgcG9zLnggKiBzY2FsZSA+IHRoaXMubWF4V2lkdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNoYXJzLnNwbGljZShsYXN0U3BhY2UsIGkgLSBsYXN0U3BhY2UpO1xuICAgICAgICAgICAgaSA9IGxhc3RTcGFjZTtcbiAgICAgICAgICAgIGxhc3RTcGFjZSA9IC0xO1xuXG4gICAgICAgICAgICBsaW5lV2lkdGhzLnB1c2gobGFzdExpbmVXaWR0aCk7XG4gICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RMaW5lV2lkdGgpO1xuICAgICAgICAgICAgbGluZSsrO1xuXG4gICAgICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgICAgICBwb3MueSArPSBkYXRhLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBwcmV2Q2hhckNvZGUgPSBudWxsO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hhckRhdGEgPSBkYXRhLmNoYXJzW2NoYXJDb2RlXTtcblxuICAgICAgICBpZiAoIWNoYXJEYXRhKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2Q2hhckNvZGUgJiYgY2hhckRhdGEua2VybmluZ1twcmV2Q2hhckNvZGVdKVxuICAgICAgICB7XG4gICAgICAgICAgICBwb3MueCArPSBjaGFyRGF0YS5rZXJuaW5nW3ByZXZDaGFyQ29kZV07XG4gICAgICAgIH1cblxuICAgICAgICBjaGFycy5wdXNoKHt0ZXh0dXJlOmNoYXJEYXRhLnRleHR1cmUsIGxpbmU6IGxpbmUsIGNoYXJDb2RlOiBjaGFyQ29kZSwgcG9zaXRpb246IG5ldyBjb3JlLm1hdGguUG9pbnQocG9zLnggKyBjaGFyRGF0YS54T2Zmc2V0LCBwb3MueSArIGNoYXJEYXRhLnlPZmZzZXQpfSk7XG4gICAgICAgIGxhc3RMaW5lV2lkdGggPSBwb3MueCArIChjaGFyRGF0YS50ZXh0dXJlLndpZHRoICsgY2hhckRhdGEueE9mZnNldCk7XG4gICAgICAgIHBvcy54ICs9IGNoYXJEYXRhLnhBZHZhbmNlO1xuXG4gICAgICAgIHByZXZDaGFyQ29kZSA9IGNoYXJDb2RlO1xuICAgIH1cblxuICAgIGxpbmVXaWR0aHMucHVzaChsYXN0TGluZVdpZHRoKTtcbiAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RMaW5lV2lkdGgpO1xuXG4gICAgdmFyIGxpbmVBbGlnbk9mZnNldHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbGluZTsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGFsaWduT2Zmc2V0ID0gMDtcblxuICAgICAgICBpZiAodGhpcy5fZm9udC5hbGlnbiA9PT0gJ3JpZ2h0JylcbiAgICAgICAge1xuICAgICAgICAgICAgYWxpZ25PZmZzZXQgPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ZvbnQuYWxpZ24gPT09ICdjZW50ZXInKVxuICAgICAgICB7XG4gICAgICAgICAgICBhbGlnbk9mZnNldCA9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldKSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lQWxpZ25PZmZzZXRzLnB1c2goYWxpZ25PZmZzZXQpO1xuICAgIH1cblxuICAgIHZhciBsZW5DaGFycyA9IGNoYXJzLmxlbmd0aDtcbiAgICB2YXIgdGludCA9IHRoaXMudGludDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5DaGFyczsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLl9nbHlwaHNbaV07IC8vIGdldCB0aGUgbmV4dCBnbHlwaCBzcHJpdGVcblxuICAgICAgICBpZiAoYylcbiAgICAgICAge1xuICAgICAgICAgICAgYy50ZXh0dXJlID0gY2hhcnNbaV0udGV4dHVyZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGMgPSBuZXcgY29yZS5TcHJpdGUoY2hhcnNbaV0udGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLl9nbHlwaHMucHVzaChjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMucG9zaXRpb24ueCA9IChjaGFyc1tpXS5wb3NpdGlvbi54ICsgbGluZUFsaWduT2Zmc2V0c1tjaGFyc1tpXS5saW5lXSkgKiBzY2FsZTtcbiAgICAgICAgYy5wb3NpdGlvbi55ID0gY2hhcnNbaV0ucG9zaXRpb24ueSAqIHNjYWxlO1xuICAgICAgICBjLnNjYWxlLnggPSBjLnNjYWxlLnkgPSBzY2FsZTtcbiAgICAgICAgYy50aW50ID0gdGludDtcblxuICAgICAgICBpZiAoIWMucGFyZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKGMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVubmVjZXNzYXJ5IGNoaWxkcmVuLlxuICAgIGZvciAoaSA9IGxlbkNoYXJzOyBpIDwgdGhpcy5fZ2x5cGhzLmxlbmd0aDsgKytpKVxuICAgIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLl9nbHlwaHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMudGV4dFdpZHRoID0gbWF4TGluZVdpZHRoICogc2NhbGU7XG4gICAgdGhpcy50ZXh0SGVpZ2h0ID0gKHBvcy55ICsgZGF0YS5saW5lSGVpZ2h0KSAqIHNjYWxlO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB0cmFuc2Zvcm0gb2YgdGhpcyBvYmplY3RcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5CaXRtYXBUZXh0LnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLmRpcnR5KVxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRhaW5lclVwZGF0ZVRyYW5zZm9ybSgpO1xufTtcblxuQml0bWFwVGV4dC5mb250cyA9IHt9O1xuIiwidmFyIGNvcmUgICAgPSByZXF1aXJlKCcuLi9jb3JlJyksXG4gICAgVGlja2VyICA9IHJlcXVpcmUoJy4vVGlja2VyJyk7XG5cbi8qKlxuICogQSBNb3ZpZUNsaXAgaXMgYSBzaW1wbGUgd2F5IHRvIGRpc3BsYXkgYW4gYW5pbWF0aW9uIGRlcGljdGVkIGJ5IGEgbGlzdCBvZiB0ZXh0dXJlcy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGFsaWVuSW1hZ2VzID0gW1wiaW1hZ2Vfc2VxdWVuY2VfMDEucG5nXCIsXCJpbWFnZV9zZXF1ZW5jZV8wMi5wbmdcIixcImltYWdlX3NlcXVlbmNlXzAzLnBuZ1wiLFwiaW1hZ2Vfc2VxdWVuY2VfMDQucG5nXCJdO1xuICogdmFyIHRleHR1cmVBcnJheSA9IFtdO1xuICpcbiAqIGZvciAodmFyIGk9MDsgaSA8IDQ7IGkrKylcbiAqIHtcbiAqICAgICAgdmFyIHRleHR1cmUgPSBQSVhJLlRleHR1cmUuZnJvbUltYWdlKGFsaWVuSW1hZ2VzW2ldKTtcbiAqICAgICAgdGV4dHVyZUFycmF5LnB1c2godGV4dHVyZSk7XG4gKiB9O1xuICpcbiAqIHZhciBtYyA9IG5ldyBQSVhJLk1vdmllQ2xpcCh0ZXh0dXJlQXJyYXkpO1xuICogYGBgXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBTcHJpdGVcbiAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhc1xuICogQHBhcmFtIHRleHR1cmVzIHtUZXh0dXJlW119IGFuIGFycmF5IG9mIHtUZXh0dXJlfSBvYmplY3RzIHRoYXQgbWFrZSB1cCB0aGUgYW5pbWF0aW9uXG4gKi9cbmZ1bmN0aW9uIE1vdmllQ2xpcCh0ZXh0dXJlcylcbntcbiAgICBjb3JlLlNwcml0ZS5jYWxsKHRoaXMsIHRleHR1cmVzWzBdKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcnJheSBvZiB0ZXh0dXJlcyB0aGF0IG1ha2UgdXAgdGhlIGFuaW1hdGlvblxuICAgICAqXG4gICAgICogQG1lbWJlciB7VGV4dHVyZVtdfVxuICAgICAqL1xuICAgIHRoaXMuX3RleHR1cmVzID0gdGV4dHVyZXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3BlZWQgdGhhdCB0aGUgTW92aWVDbGlwIHdpbGwgcGxheSBhdC4gSGlnaGVyIGlzIGZhc3RlciwgbG93ZXIgaXMgc2xvd2VyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIG1vdmllIGNsaXAgcmVwZWF0cyBhZnRlciBwbGF5aW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5sb29wID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIE1vdmllQ2xpcCBmaW5pc2hlcyBwbGF5aW5nXG4gICAgICpcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIE1vdmllQ2xpcCNcbiAgICAgKi9cbiAgICB0aGlzLm9uQ29tcGxldGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIE1vdmllQ2xpcHMgY3VycmVudCBmcmFtZSBpbmRleCAodGhpcyBtYXkgbm90IGhhdmUgdG8gYmUgYSB3aG9sZSBudW1iZXIpXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgTW92aWVDbGlwIGlzIGN1cnJlbnRseSBwbGF5aW5nXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xufVxuXG4vLyBjb25zdHJ1Y3RvclxuTW92aWVDbGlwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5TcHJpdGUucHJvdG90eXBlKTtcbk1vdmllQ2xpcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb3ZpZUNsaXA7XG5tb2R1bGUuZXhwb3J0cyA9IE1vdmllQ2xpcDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTW92aWVDbGlwLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIHRvdGFsRnJhbWVzIGlzIHRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBNb3ZpZUNsaXAuIFRoaXMgaXMgdGhlIHNhbWUgYXMgbnVtYmVyIG9mIHRleHR1cmVzXG4gICAgICogYXNzaWduZWQgdG8gdGhlIE1vdmllQ2xpcC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJcbiAgICAgKiBAbWVtYmVyb2YgTW92aWVDbGlwI1xuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0b3RhbEZyYW1lczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgb2YgdGV4dHVyZXMgdXNlZCBmb3IgdGhpcyBNb3ZpZUNsaXBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJcbiAgICAgKiBAbWVtYmVyb2YgTW92aWVDbGlwI1xuICAgICAqXG4gICAgICovXG4gICAgdGV4dHVyZXM6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlcyA9IHZhbHVlO1xuXG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1tNYXRoLmZsb29yKHRoaXMuY3VycmVudEZyYW1lKSAlIHRoaXMuX3RleHR1cmVzLmxlbmd0aF07XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG4vKipcbiAqIFN0b3BzIHRoZSBNb3ZpZUNsaXBcbiAqXG4gKi9cbk1vdmllQ2xpcC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYoIXRoaXMucGxheWluZylcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICBUaWNrZXIub2ZmKCd0aWNrJywgdGhpcy51cGRhdGUpO1xufTtcblxuLyoqXG4gKiBQbGF5cyB0aGUgTW92aWVDbGlwXG4gKlxuICovXG5Nb3ZpZUNsaXAucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmKHRoaXMucGxheWluZylcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBsYXlpbmcgPSB0cnVlO1xuICAgIFRpY2tlci5vbigndGljaycsIHRoaXMudXBkYXRlLCB0aGlzKTtcbn07XG5cbi8qKlxuICogU3RvcHMgdGhlIE1vdmllQ2xpcCBhbmQgZ29lcyB0byBhIHNwZWNpZmljIGZyYW1lXG4gKlxuICogQHBhcmFtIGZyYW1lTnVtYmVyIHtudW1iZXJ9IGZyYW1lIGluZGV4IHRvIHN0b3AgYXRcbiAqL1xuTW92aWVDbGlwLnByb3RvdHlwZS5nb3RvQW5kU3RvcCA9IGZ1bmN0aW9uIChmcmFtZU51bWJlcilcbntcbiAgICB0aGlzLnN0b3AoKTtcblxuICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWVOdW1iZXI7XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLmZsb29yKHRoaXMuY3VycmVudEZyYW1lKTtcbiAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1tyb3VuZCAlIHRoaXMuX3RleHR1cmVzLmxlbmd0aF07XG59O1xuXG4vKipcbiAqIEdvZXMgdG8gYSBzcGVjaWZpYyBmcmFtZSBhbmQgYmVnaW5zIHBsYXlpbmcgdGhlIE1vdmllQ2xpcFxuICpcbiAqIEBwYXJhbSBmcmFtZU51bWJlciB7bnVtYmVyfSBmcmFtZSBpbmRleCB0byBzdGFydCBhdFxuICovXG5Nb3ZpZUNsaXAucHJvdG90eXBlLmdvdG9BbmRQbGF5ID0gZnVuY3Rpb24gKGZyYW1lTnVtYmVyKVxue1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWVOdW1iZXI7XG4gICAgdGhpcy5wbGF5KCk7XG59O1xuXG4vKlxuICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5Nb3ZpZUNsaXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YVRpbWUpXG57XG5cbiAgICB0aGlzLmN1cnJlbnRGcmFtZSArPSB0aGlzLmFuaW1hdGlvblNwZWVkICogZGVsdGFUaW1lO1xuXG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcih0aGlzLmN1cnJlbnRGcmFtZSk7XG5cbiAgICBpZiAoZmxvb3IgPCAwKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMubG9vcClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgKz0gdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gdGhpcy5fdGV4dHVyZXNbdGhpcy5jdXJyZW50RnJhbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5nb3RvQW5kU3RvcCgwKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmxvb3AgfHwgZmxvb3IgPCB0aGlzLl90ZXh0dXJlcy5sZW5ndGgpXG4gICAge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1tmbG9vciAlIHRoaXMuX3RleHR1cmVzLmxlbmd0aF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZsb29yID49IHRoaXMuX3RleHR1cmVzLmxlbmd0aClcbiAgICB7XG4gICAgICAgIHRoaXMuZ290b0FuZFN0b3AodGhpcy50ZXh0dXJlcy5sZW5ndGggLSAxKTtcblxuICAgICAgICBpZiAodGhpcy5vbkNvbXBsZXRlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qXG4gKiBTdG9wcyB0aGUgTW92aWVDbGlwIGFuZCBkZXN0cm95cyBpdFxuICpcbiAqL1xuTW92aWVDbGlwLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCApXG57XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgY29yZS5TcHJpdGUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQSBzaG9ydCBoYW5kIHdheSBvZiBjcmVhdGluZyBhIG1vdmllY2xpcCBmcm9tIGFuIGFycmF5IG9mIGZyYW1lIGlkc1xuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBmcmFtZXMge3N0cmluZ1tdfSB0aGUgYXJyYXkgb2YgZnJhbWVzIGlkcyB0aGUgbW92aWVjbGlwIHdpbGwgdXNlIGFzIGl0cyB0ZXh0dXJlIGZyYW1lc1xuICovXG5Nb3ZpZUNsaXAuZnJvbUZyYW1lcyA9IGZ1bmN0aW9uIChmcmFtZXMpXG57XG4gICAgdmFyIHRleHR1cmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7ICsraSlcbiAgICB7XG4gICAgICAgIHRleHR1cmVzLnB1c2gobmV3IGNvcmUuVGV4dHVyZS5mcm9tRnJhbWUoZnJhbWVzW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNb3ZpZUNsaXAodGV4dHVyZXMpO1xufTtcblxuLyoqXG4gKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGEgbW92aWVjbGlwIGZyb20gYW4gYXJyYXkgb2YgaW1hZ2UgaWRzXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGltYWdlcyB7c3RyaW5nW119IHRoZSBhcnJheSBvZiBpbWFnZSB1cmxzIHRoZSBtb3ZpZWNsaXAgd2lsbCB1c2UgYXMgaXRzIHRleHR1cmUgZnJhbWVzXG4gKi9cbk1vdmllQ2xpcC5mcm9tSW1hZ2VzID0gZnVuY3Rpb24gKGltYWdlcylcbntcbiAgICB2YXIgdGV4dHVyZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgKytpKVxuICAgIHtcbiAgICAgICAgdGV4dHVyZXMucHVzaChuZXcgY29yZS5UZXh0dXJlLmZyb21JbWFnZShpbWFnZXNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1vdmllQ2xpcCh0ZXh0dXJlcyk7XG59O1xuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qKlxuICogQSBUaWNrZXIgY2xhc3MgdGhhdCBydW5zIGFuIHVwZGF0ZSBsb29wIHRoYXQgb3RoZXIgb2JqZWN0cyBsaXN0ZW4gdG9cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhc1xuICovXG52YXIgVGlja2VyID0gZnVuY3Rpb24oKVxue1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy51cGRhdGVCaW5kID0gdGhpcy51cGRhdGUuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgdGlja2VyIHJ1bnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWx0YVRpbWVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhVGltZSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSBiZXR3ZWVuIHR3byBmcmFtZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVFbGFwc2VkID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lIGF0IHRoZSBsYXN0IGZyYW1lXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0VGltZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3BlZWRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNwZWVkID0gMTtcblxuICAgIC8vIGF1dG8gc3RhcnQgdGlja2luZyFcbiAgICB0aGlzLnN0YXJ0KCk7XG59O1xuXG5UaWNrZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblRpY2tlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaWNrZXI7XG5cbi8qKlxuICogU3RhcnRzIHRoZSB0aWNrZXIsIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3RvclxuICpcbiAqL1xuVGlja2VyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKClcbntcbiAgICBpZih0aGlzLmFjdGl2ZSlcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlQmluZCk7XG59O1xuXG4vKipcbiAqIFN0b3BzIHRoZSB0aWNrZXJcbiAqXG4gKi9cblRpY2tlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKClcbntcbiAgICBpZighdGhpcy5hY3RpdmUpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogVGhlIHVwZGF0ZSBsb29wLCBmaXJlcyB0aGUgJ3RpY2snIGV2ZW50XG4gKlxuICovXG5UaWNrZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKClcbntcbiAgICBpZih0aGlzLmFjdGl2ZSlcbiAgICB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZUJpbmQpO1xuXG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgdGltZUVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWU7XG5cbiAgICAgICAgLy8gY2FwIHRoZSB0aW1lIVxuICAgICAgICBpZih0aW1lRWxhcHNlZCA+IDEwMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGltZUVsYXBzZWQgPSAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlbHRhVGltZSA9ICh0aW1lRWxhcHNlZCAqIDAuMDYpO1xuXG4gICAgICAgIHRoaXMuZGVsdGFUaW1lICo9IHRoaXMuc3BlZWQ7XG5cbiAgICAgICAgdGhpcy5lbWl0KCd0aWNrJywgdGhpcy5kZWx0YVRpbWUpO1xuXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFRpY2tlcigpO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyksXG4gICAgLy8gYSBzcHJpdGUgdXNlIGRmb3IgcmVuZGVyaW5nIHRleHR1cmVzLi5cbiAgICB0ZW1wU3ByaXRlID0gbmV3IGNvcmUuU3ByaXRlKCksXG4gICAgdGVtcFBvaW50ID0gbmV3IGNvcmUuUG9pbnQoKSxcbiAgICB0ZW1wTWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XG5cbi8qKlxuICogQSB0aWxpbmcgc3ByaXRlIGlzIGEgZmFzdCB3YXkgb2YgcmVuZGVyaW5nIGEgdGlsaW5nIGltYWdlXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBTcHJpdGVcbiAqIEBtZW1iZXJvZiBQSVhJLmV4dHJhc1xuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IHRoZSB0ZXh0dXJlIG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gIHRoZSB3aWR0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gKi9cbmZ1bmN0aW9uIFRpbGluZ1Nwcml0ZSh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIGNvcmUuU3ByaXRlLmNhbGwodGhpcywgdGV4dHVyZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGluZyBvZiB0aGUgaW1hZ2UgdGhhdCBpcyBiZWluZyB0aWxlZFxuICAgICAqXG4gICAgICogQG1lbWJlciB7UG9pbnR9XG4gICAgICovXG4gICAgdGhpcy50aWxlU2NhbGUgPSBuZXcgY29yZS5tYXRoLlBvaW50KDEsMSk7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIGltYWdlIHRoYXQgaXMgYmVpbmcgdGlsZWRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BvaW50fVxuICAgICAqL1xuICAgIHRoaXMudGlsZVBvc2l0aW9uID0gbmV3IGNvcmUubWF0aC5Qb2ludCgwLDApO1xuXG4gICAgLy8vLy8gcHJpdmF0ZVxuXG4gICAgLyoqXG4gICAgICogVGhlIHdpdGggb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGggfHwgMTAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0IHx8IDEwMDtcblxuICAgICAvKipcbiAgICAgKiBBIHBvaW50IHRoYXQgcmVwcmVzZW50cyB0aGUgc2NhbGUgb2YgdGhlIHRleHR1cmUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQb2ludH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RpbGVTY2FsZU9mZnNldCA9IG5ldyBjb3JlLm1hdGguUG9pbnQoMSwxKTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90aWxpbmdUZXh0dXJlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVmcmVzaFRleHR1cmUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7VGV4dHVyZVV2c31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3V2cyA9IG5ldyBjb3JlLlRleHR1cmVVdnMoKTtcbn1cblxuVGlsaW5nU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5TcHJpdGUucHJvdG90eXBlKTtcblRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaWxpbmdTcHJpdGU7XG5tb2R1bGUuZXhwb3J0cyA9IFRpbGluZ1Nwcml0ZTtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWxpbmdTcHJpdGUucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFRpbGluZ1Nwcml0ZSNcbiAgICAgKi9cbiAgICB3aWR0aDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgVGlsaW5nU3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBUaWxpbmdTcHJpdGUjXG4gICAgICovXG4gICAgaGVpZ2h0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuX29uVGV4dHVyZVVwZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuO1xufTtcblxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIge1dlYkdMUmVuZGVyZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5UaWxpbmdTcHJpdGUucHJvdG90eXBlLl9yZW5kZXJXZWJHTCA9IGZ1bmN0aW9uIChyZW5kZXJlcilcbntcbiAgICBpZiAoIXRoaXMuX3RpbGluZ1RleHR1cmUgfHwgdGhpcy5fcmVmcmVzaFRleHR1cmUpXG4gICAge1xuICAgICAgICB0aGlzLmdlbmVyYXRlVGlsaW5nVGV4dHVyZShyZW5kZXJlciwgdGhpcy50ZXh0dXJlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyB0d2VhayBvdXIgdGV4dHVyZSB0ZW1wb3JhcmlseS4uXG4gICAgdmFyIHRleHR1cmUgPSB0aGlzLl90aWxpbmdUZXh0dXJlO1xuXG4gICAgaWYoIXRleHR1cmUpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICB2YXIgdXZzID0gdGhpcy5fdXZzO1xuXG4gICAgdGhpcy50aWxlUG9zaXRpb24ueCAlPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoIC8gdGhpcy5fdGlsZVNjYWxlT2Zmc2V0Lng7XG4gICAgdGhpcy50aWxlUG9zaXRpb24ueSAlPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodCAvIHRoaXMuX3RpbGVTY2FsZU9mZnNldC55O1xuXG4gICAgdmFyIG9mZnNldFggPSAgdGhpcy50aWxlUG9zaXRpb24ueC8odGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aCAvIHRoaXMuX3RpbGVTY2FsZU9mZnNldC54KTtcbiAgICB2YXIgb2Zmc2V0WSA9ICB0aGlzLnRpbGVQb3NpdGlvbi55Lyh0ZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodCAvIHRoaXMuX3RpbGVTY2FsZU9mZnNldC55KTtcblxuICAgIHZhciBzY2FsZVggPSAgKHRoaXMuX3dpZHRoIC8gdGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aCkgKiB0aGlzLl90aWxlU2NhbGVPZmZzZXQueDtcbiAgICB2YXIgc2NhbGVZID0gICh0aGlzLl9oZWlnaHQgLyB0ZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodCkgKiB0aGlzLl90aWxlU2NhbGVPZmZzZXQueTtcblxuICAgIHNjYWxlWCAvPSB0aGlzLnRpbGVTY2FsZS54O1xuICAgIHNjYWxlWSAvPSB0aGlzLnRpbGVTY2FsZS55O1xuXG4gICAgdXZzLngwID0gMCAtIG9mZnNldFg7XG4gICAgdXZzLnkwID0gMCAtIG9mZnNldFk7XG5cbiAgICB1dnMueDEgPSAoMSAqIHNjYWxlWCkgLSBvZmZzZXRYO1xuICAgIHV2cy55MSA9IDAgLSBvZmZzZXRZO1xuXG4gICAgdXZzLngyID0gKDEgKiBzY2FsZVgpIC0gb2Zmc2V0WDtcbiAgICB1dnMueTIgPSAoMSAqIHNjYWxlWSkgLSBvZmZzZXRZO1xuXG4gICAgdXZzLngzID0gMCAtIG9mZnNldFg7XG4gICAgdXZzLnkzID0gKDEgKiBzY2FsZVkpIC0gb2Zmc2V0WTtcblxuICAgIHZhciB0ZW1wVXZzID0gdGV4dHVyZS5fdXZzO1xuICAgIHZhciB0ZW1wV2lkdGggPSB0ZXh0dXJlLl9mcmFtZS53aWR0aDtcbiAgICB2YXIgdGVtcEhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodDtcblxuICAgIHRleHR1cmUuX3V2cyA9IHV2cztcbiAgICB0ZXh0dXJlLl9mcmFtZS53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICByZW5kZXJlci5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zLnNwcml0ZSk7XG4gICAgcmVuZGVyZXIucGx1Z2lucy5zcHJpdGUucmVuZGVyKHRoaXMpO1xuXG4gICAgdGV4dHVyZS5fdXZzID0gdGVtcFV2cztcbiAgICB0ZXh0dXJlLl9mcmFtZS53aWR0aCA9IHRlbXBXaWR0aDtcbiAgICB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgPSB0ZW1wSGVpZ2h0O1xuXG59O1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXG4gKlxuICogQHBhcmFtIHJlbmRlcmVyIHtDYW52YXNSZW5kZXJlcn0gYSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyByZW5kZXJlclxuICogQHByaXZhdGVcbiAqL1xuVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIHZhciBjb250ZXh0ID0gcmVuZGVyZXIuY29udGV4dDtcblxuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgIHZhciByZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbjtcblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5hICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uYiAqIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmMgKiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5kICogcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udHggKiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS50eSAqIHJlc29sdXRpb24pO1xuXG4gICAgaWYgKCF0aGlzLl9fdGlsZVBhdHRlcm4gfHwgIHRoaXMuX3JlZnJlc2hUZXh0dXJlKVxuICAgIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVRpbGluZ1RleHR1cmUoZmFsc2UpO1xuXG4gICAgICAgIGlmICh0aGlzLl90aWxpbmdUZXh0dXJlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9fdGlsZVBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4odGhpcy5fdGlsaW5nVGV4dHVyZS5iYXNlVGV4dHVyZS5zb3VyY2UsICdyZXBlYXQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGJsZW5kIG1vZGVcbiAgICBpZiAodGhpcy5ibGVuZE1vZGUgIT09IHJlbmRlcmVyLmN1cnJlbnRCbGVuZE1vZGUpXG4gICAge1xuICAgICAgICByZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlID0gdGhpcy5ibGVuZE1vZGU7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gcmVuZGVyZXIuYmxlbmRNb2Rlc1tyZW5kZXJlci5jdXJyZW50QmxlbmRNb2RlXTtcbiAgICB9XG5cbiAgICB2YXIgdGlsZVBvc2l0aW9uID0gdGhpcy50aWxlUG9zaXRpb247XG4gICAgdmFyIHRpbGVTY2FsZSA9IHRoaXMudGlsZVNjYWxlO1xuXG4gICAgdGlsZVBvc2l0aW9uLnggJT0gdGhpcy5fdGlsaW5nVGV4dHVyZS5iYXNlVGV4dHVyZS53aWR0aDtcbiAgICB0aWxlUG9zaXRpb24ueSAlPSB0aGlzLl90aWxpbmdUZXh0dXJlLmJhc2VUZXh0dXJlLmhlaWdodDtcblxuICAgIC8vIG9mZnNldCAtIG1ha2Ugc3VyZSB0byBhY2NvdW50IGZvciB0aGUgYW5jaG9yIHBvaW50Li5cbiAgICBjb250ZXh0LnNjYWxlKHRpbGVTY2FsZS54LHRpbGVTY2FsZS55KTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh0aWxlUG9zaXRpb24ueCArICh0aGlzLmFuY2hvci54ICogLXRoaXMuX3dpZHRoKSwgdGlsZVBvc2l0aW9uLnkgKyAodGhpcy5hbmNob3IueSAqIC10aGlzLl9oZWlnaHQpKTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fX3RpbGVQYXR0ZXJuO1xuXG4gICAgY29udGV4dC5maWxsUmVjdCgtdGlsZVBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgIC10aWxlUG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2lkdGggLyB0aWxlU2NhbGUueCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0IC8gdGlsZVNjYWxlLnkpO1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUoLXRpbGVQb3NpdGlvbi54ICsgKHRoaXMuYW5jaG9yLnggKiB0aGlzLl93aWR0aCksIC10aWxlUG9zaXRpb24ueSArICh0aGlzLmFuY2hvci55ICogdGhpcy5faGVpZ2h0KSk7XG4gICAgY29udGV4dC5zY2FsZSgxIC8gdGlsZVNjYWxlLngsIDEgLyB0aWxlU2NhbGUueSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIHNwcml0ZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbipcbiAqIEByZXR1cm4ge1JlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gKi9cblRpbGluZ1Nwcml0ZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gICAgdmFyIHcwID0gd2lkdGggKiAoMS10aGlzLmFuY2hvci54KTtcbiAgICB2YXIgdzEgPSB3aWR0aCAqIC10aGlzLmFuY2hvci54O1xuXG4gICAgdmFyIGgwID0gaGVpZ2h0ICogKDEtdGhpcy5hbmNob3IueSk7XG4gICAgdmFyIGgxID0gaGVpZ2h0ICogLXRoaXMuYW5jaG9yLnk7XG5cbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgdmFyIGEgPSB3b3JsZFRyYW5zZm9ybS5hO1xuICAgIHZhciBiID0gd29ybGRUcmFuc2Zvcm0uYjtcbiAgICB2YXIgYyA9IHdvcmxkVHJhbnNmb3JtLmM7XG4gICAgdmFyIGQgPSB3b3JsZFRyYW5zZm9ybS5kO1xuICAgIHZhciB0eCA9IHdvcmxkVHJhbnNmb3JtLnR4O1xuICAgIHZhciB0eSA9IHdvcmxkVHJhbnNmb3JtLnR5O1xuXG4gICAgdmFyIHgxID0gYSAqIHcxICsgYyAqIGgxICsgdHg7XG4gICAgdmFyIHkxID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG5cbiAgICB2YXIgeDIgPSBhICogdzAgKyBjICogaDEgKyB0eDtcbiAgICB2YXIgeTIgPSBkICogaDEgKyBiICogdzAgKyB0eTtcblxuICAgIHZhciB4MyA9IGEgKiB3MCArIGMgKiBoMCArIHR4O1xuICAgIHZhciB5MyA9IGQgKiBoMCArIGIgKiB3MCArIHR5O1xuXG4gICAgdmFyIHg0ID0gIGEgKiB3MSArIGMgKiBoMCArIHR4O1xuICAgIHZhciB5NCA9ICBkICogaDAgKyBiICogdzEgKyB0eTtcblxuICAgIHZhciBtaW5YLFxuICAgICAgICBtYXhYLFxuICAgICAgICBtaW5ZLFxuICAgICAgICBtYXhZO1xuXG4gICAgbWluWCA9IHgxO1xuICAgIG1pblggPSB4MiA8IG1pblggPyB4MiA6IG1pblg7XG4gICAgbWluWCA9IHgzIDwgbWluWCA/IHgzIDogbWluWDtcbiAgICBtaW5YID0geDQgPCBtaW5YID8geDQgOiBtaW5YO1xuXG4gICAgbWluWSA9IHkxO1xuICAgIG1pblkgPSB5MiA8IG1pblkgPyB5MiA6IG1pblk7XG4gICAgbWluWSA9IHkzIDwgbWluWSA/IHkzIDogbWluWTtcbiAgICBtaW5ZID0geTQgPCBtaW5ZID8geTQgOiBtaW5ZO1xuXG4gICAgbWF4WCA9IHgxO1xuICAgIG1heFggPSB4MiA+IG1heFggPyB4MiA6IG1heFg7XG4gICAgbWF4WCA9IHgzID4gbWF4WCA/IHgzIDogbWF4WDtcbiAgICBtYXhYID0geDQgPiBtYXhYID8geDQgOiBtYXhYO1xuXG4gICAgbWF4WSA9IHkxO1xuICAgIG1heFkgPSB5MiA+IG1heFkgPyB5MiA6IG1heFk7XG4gICAgbWF4WSA9IHkzID4gbWF4WSA/IHkzIDogbWF4WTtcbiAgICBtYXhZID0geTQgPiBtYXhZID8geTQgOiBtYXhZO1xuXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcblxuICAgIGJvdW5kcy54ID0gbWluWDtcbiAgICBib3VuZHMud2lkdGggPSBtYXhYIC0gbWluWDtcblxuICAgIGJvdW5kcy55ID0gbWluWTtcbiAgICBib3VuZHMuaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICAvLyBzdG9yZSBhIHJlZmVyZW5jZSBzbyB0aGF0IGlmIHRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgYWdhaW4gaW4gdGhlIHJlbmRlciBjeWNsZSB3ZSBkbyBub3QgaGF2ZSB0byByZWNhbGN1bGF0ZVxuICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBib3VuZHM7XG5cbiAgICByZXR1cm4gYm91bmRzO1xufTtcblxuLyoqXG4gKiBXaGVuIHRoZSB0ZXh0dXJlIGlzIHVwZGF0ZWQsIHRoaXMgZXZlbnQgd2lsbCBmaXJlIHRvIHVwZGF0ZSB0aGUgc2NhbGUgYW5kIGZyYW1lXG4gKlxuICogQHBhcmFtIGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5UaWxpbmdTcHJpdGUucHJvdG90eXBlLm9uVGV4dHVyZVVwZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAvLyBvdmVycmlkaW5nIHRoZSBzcHJpdGUgdmVyc2lvbiBvZiB0aGlzIVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSB0aWxpbmcgdGV4dHVyZVxuICogQHBhcmFtIHJlbmRlcmVyIHtDYW52YXNSZW5kZXJlcnxXZWJHTFJlbmRlcmVyfSBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZW5kZXJlclxuICogQHBhcmFtIHRleHR1cmUge1RleHR1cmV9IFRoZSB0ZXh0dXJlIHRvIHVzZSB0byBnZW5lcmF0ZSB0aGUgdGlsaW5nIHRleHR1cmVcbiAqIEBwYXJhbSBmb3JjZVBvd2VyT2ZUd28ge2Jvb2xlYW59IFdoZXRoZXIgd2Ugd2FudCB0byBmb3JjZSB0aGUgdGV4dHVyZSB0byBiZSBhIHBvd2VyIG9mIHR3b1xuICovXG5UaWxpbmdTcHJpdGUucHJvdG90eXBlLmdlbmVyYXRlVGlsaW5nVGV4dHVyZSA9IGZ1bmN0aW9uIChyZW5kZXJlciwgdGV4dHVyZSwgZm9yY2VQb3dlck9mVHdvKVxue1xuICAgIGlmICghdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0ZXh0dXJlID0gdGhpcy5vcmlnaW5hbFRleHR1cmUgfHwgdGhpcy5fdGV4dHVyZTtcbiAgICB2YXIgZnJhbWUgPSB0ZXh0dXJlLmZyYW1lO1xuICAgIHZhciB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0O1xuXG4gICAgLy8gIENoZWNrIHRoYXQgdGhlIGZyYW1lIGlzIHRoZSBzYW1lIHNpemUgYXMgdGhlIGJhc2UgdGV4dHVyZS5cbiAgICB2YXIgaXNGcmFtZSA9IGZyYW1lLndpZHRoICE9PSB0ZXh0dXJlLmJhc2VUZXh0dXJlLndpZHRoIHx8IGZyYW1lLmhlaWdodCAhPT0gdGV4dHVyZS5iYXNlVGV4dHVyZS5oZWlnaHQ7XG5cbiAgICBpZiAoKGZvcmNlUG93ZXJPZlR3byAmJiAhdGV4dHVyZS5iYXNlVGV4dHVyZS5pc1Bvd2VyT2ZUd28pIHx8IGlzRnJhbWUpXG4gICAge1xuICAgICAgICB0YXJnZXRXaWR0aCA9IGNvcmUudXRpbHMuZ2V0TmV4dFBvd2VyT2ZUd28oZnJhbWUud2lkdGgpO1xuICAgICAgICB0YXJnZXRIZWlnaHQgPSBjb3JlLnV0aWxzLmdldE5leHRQb3dlck9mVHdvKGZyYW1lLmhlaWdodCk7XG4gICAgICAgIHRlbXBTcHJpdGUudGV4dHVyZSA9IHRleHR1cmU7XG5cbiAgICAgICAgLy9UT0RPIG5vdCBjcmVhdGUgYSBuZXcgb25lIGVhY2ggdGltZSB5b3UgcmVmcmVzaFxuICAgICAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IG5ldyBjb3JlLlJlbmRlclRleHR1cmUocmVuZGVyZXIsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIHRleHR1cmUuYmFzZVRleHR1cmUuc2NhbGVNb2RlLCB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb24pO1xuXG4gICAgICAgIHZhciBjYWNoZWRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0O1xuXG4gICAgICAgIHZhciBtID0gdGVtcE1hdHJpeDtcbiAgICAgICAgbS5hID0gICh0YXJnZXRXaWR0aCArIDEpIC8gKGZyYW1lLndpZHRoKTtcbiAgICAgICAgbS5kID0gICAodGFyZ2V0SGVpZ2h0ICsgMSkgLyAoZnJhbWUuaGVpZ2h0KTtcblxuICAgICAgICB0ZW1wU3ByaXRlLndvcmxkVHJhbnNmb3JtLnR4IC09IDAuNTtcbiAgICAgICAgdGVtcFNwcml0ZS53b3JsZFRyYW5zZm9ybS50eSAtPSAwLjU7XG5cbiAgICAgICAgcmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XG5cbiAgICAgICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIoIHRlbXBTcHJpdGUsIG0sIHRydWUsIGZhbHNlICk7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGNhY2hlZFJlbmRlclRhcmdldCk7XG5cblxuICAgICAgICB0aGlzLl90aWxlU2NhbGVPZmZzZXQueCA9IHRhcmdldFdpZHRoIC8gZnJhbWUud2lkdGg7XG4gICAgICAgIHRoaXMuX3RpbGVTY2FsZU9mZnNldC55ID0gdGFyZ2V0SGVpZ2h0IC8gZnJhbWUuaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMuX3RpbGluZ1RleHR1cmUgPSByZW5kZXJUZXh0dXJlO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fdGlsaW5nVGV4dHVyZSAmJiB0aGlzLl90aWxpbmdUZXh0dXJlLmlzVGlsaW5nKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBkZXN0cm95IHRoZSB0aWxpbmcgdGV4dHVyZSFcbiAgICAgICAgICAgIC8vIFRPRE8gY291bGQgc3RvcmUgdGhpcyBzb21ld2hlcmU/XG4gICAgICAgICAgICB0aGlzLl90aWxpbmdUZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90aWxlU2NhbGVPZmZzZXQueCA9IDE7XG4gICAgICAgIHRoaXMuX3RpbGVTY2FsZU9mZnNldC55ID0gMTtcbiAgICAgICAgdGhpcy5fdGlsaW5nVGV4dHVyZSA9IHRleHR1cmU7XG5cbiAgICB9XG5cblxuICAgIHRoaXMuX3JlZnJlc2hUZXh0dXJlID0gZmFsc2U7XG5cbiAgICB0aGlzLm9yaWdpbmFsVGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcbiAgICB0aGlzLl90ZXh0dXJlID0gdGhpcy5fdGlsaW5nVGV4dHVyZTtcblxufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyB0aWxpbmcgc3ByaXRlXG4gKiBAcGFyYW0gcG9pbnQge1BvaW50fSB0aGUgcG9pbnQgdG8gY2hlY2tcbiAqL1xuVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24oIHBvaW50IClcbntcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgIHRlbXBQb2ludCk7XG5cbiAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgIHZhciB4MSA9IC13aWR0aCAqIHRoaXMuYW5jaG9yLng7XG4gICAgdmFyIHkxO1xuXG4gICAgaWYgKCB0ZW1wUG9pbnQueCA+IHgxICYmIHRlbXBQb2ludC54IDwgeDEgKyB3aWR0aCApXG4gICAge1xuICAgICAgICB5MSA9IC1oZWlnaHQgKiB0aGlzLmFuY2hvci55O1xuXG4gICAgICAgIGlmICggdGVtcFBvaW50LnkgPiB5MSAmJiB0ZW1wUG9pbnQueSA8IHkxICsgaGVpZ2h0IClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgdGlsaW5nIHNwcml0ZVxuICpcbiAqL1xuVGlsaW5nU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvcmUuU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnRpbGVTY2FsZSA9IG51bGw7XG4gICAgdGhpcy5fdGlsZVNjYWxlT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLnRpbGVQb3NpdGlvbiA9IG51bGw7XG5cbiAgICB0aGlzLl90aWxpbmdUZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gICAgdGhpcy5fdGlsaW5nVGV4dHVyZSA9IG51bGw7XG5cbiAgICB0aGlzLl91dnMgPSBudWxsO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgdGlsaW5nIHNwcml0ZSB0aGF0IHdpbGwgdXNlIGEgdGV4dHVyZSBmcm9tIHRoZSBUZXh0dXJlQ2FjaGUgYmFzZWQgb24gdGhlIGZyYW1lSWRcbiAqIFRoZSBmcmFtZSBpZHMgYXJlIGNyZWF0ZWQgd2hlbiBhIFRleHR1cmUgcGFja2VyIGZpbGUgaGFzIGJlZW4gbG9hZGVkXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGZyYW1lSWQge1N0cmluZ30gVGhlIGZyYW1lIElkIG9mIHRoZSB0ZXh0dXJlIGluIHRoZSBjYWNoZVxuICogQHJldHVybiB7VGlsaW5nU3ByaXRlfSBBIG5ldyBUaWxpbmdTcHJpdGUgdXNpbmcgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmUgY2FjaGUgbWF0Y2hpbmcgdGhlIGZyYW1lSWRcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSAgdGhlIHdpZHRoIG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAqL1xuVGlsaW5nU3ByaXRlLmZyb21GcmFtZSA9IGZ1bmN0aW9uIChmcmFtZUlkLHdpZHRoLGhlaWdodClcbntcbiAgICB2YXIgdGV4dHVyZSA9IGNvcmUudXRpbHMuVGV4dHVyZUNhY2hlW2ZyYW1lSWRdO1xuXG4gICAgaWYgKCF0ZXh0dXJlKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnJhbWVJZCBcIicgKyBmcmFtZUlkICsgJ1wiIGRvZXMgbm90IGV4aXN0IGluIHRoZSB0ZXh0dXJlIGNhY2hlICcgKyB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRpbGluZ1Nwcml0ZSh0ZXh0dXJlLHdpZHRoLGhlaWdodCk7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGJhc2VkIG9uIGFuIGltYWdlIHVybFxuICogSWYgdGhlIGltYWdlIGlzIG5vdCBpbiB0aGUgdGV4dHVyZSBjYWNoZSBpdCB3aWxsIGJlIGxvYWRlZFxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBpbWFnZUlkIHtTdHJpbmd9IFRoZSBpbWFnZSB1cmwgb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSAgdGhlIHdpZHRoIG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAqIEBwYXJhbSBbY3Jvc3NvcmlnaW49KGF1dG8pXSB7Ym9vbGVhbn0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgY3Jvc3Mtb3JpZ2luIHBhcmFtZXRlclxuICogQHBhcmFtIFtzY2FsZU1vZGU9c2NhbGVNb2Rlcy5ERUZBVUxUXSB7bnVtYmVyfSBpZiB5b3Ugd2FudCB0byBzcGVjaWZ5IHRoZSBzY2FsZSBtb2RlLCBzZWUge0BsaW5rIFNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gKiBAcmV0dXJuIHtUaWxpbmdTcHJpdGV9IEEgbmV3IFRpbGluZ1Nwcml0ZSB1c2luZyBhIHRleHR1cmUgZnJvbSB0aGUgdGV4dHVyZSBjYWNoZSBtYXRjaGluZyB0aGUgaW1hZ2UgaWRcbiAqL1xuVGlsaW5nU3ByaXRlLmZyb21JbWFnZSA9IGZ1bmN0aW9uIChpbWFnZUlkLCB3aWR0aCwgaGVpZ2h0LCBjcm9zc29yaWdpbiwgc2NhbGVNb2RlKVxue1xuICAgIHJldHVybiBuZXcgVGlsaW5nU3ByaXRlKGNvcmUuVGV4dHVyZS5mcm9tSW1hZ2UoaW1hZ2VJZCwgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSksd2lkdGgsaGVpZ2h0KTtcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKSxcbiAgICBEaXNwbGF5T2JqZWN0ID0gY29yZS5EaXNwbGF5T2JqZWN0LFxuICAgIF90ZW1wTWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XG5cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZUFzQml0bWFwID0gZmFsc2U7XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fb3JpZ2luYWxSZW5kZXJXZWJHTCA9IG51bGw7XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fb3JpZ2luYWxSZW5kZXJDYW52YXMgPSBudWxsO1xuXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fb3JpZ2luYWxVcGRhdGVUcmFuc2Zvcm0gPSBudWxsO1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX29yaWdpbmFsSGl0VGVzdCA9IG51bGw7XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVkU3ByaXRlID0gbnVsbDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGlzcGxheU9iamVjdC5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgdGhpcyBkaXNwbGF5IG9iamVjdCB0byBiZSBjYWNoZWQgYXMgYSBiaXRtYXAuXG4gICAgICogVGhpcyBiYXNpY2FsbHkgdGFrZXMgYSBzbmFwIHNob3Qgb2YgdGhlIGRpc3BsYXkgb2JqZWN0IGFzIGl0IGlzIGF0IHRoYXQgbW9tZW50LiBJdCBjYW4gcHJvdmlkZSBhIHBlcmZvcm1hbmNlIGJlbmVmaXQgZm9yIGNvbXBsZXggc3RhdGljIGRpc3BsYXlPYmplY3RzLlxuICAgICAqIFRvIHJlbW92ZSBzaW1wbHkgc2V0IHRoaXMgcHJvcGVydHkgdG8gJ251bGwnXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJvZiBEaXNwbGF5T2JqZWN0I1xuICAgICAqL1xuICAgIGNhY2hlQXNCaXRtYXA6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVBc0JpdG1hcDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKHRoaXMuX2NhY2hlQXNCaXRtYXAgPT09IHZhbHVlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY2FjaGVBc0JpdG1hcCA9IHZhbHVlO1xuXG4gICAgICAgICAgICBpZih2YWx1ZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFJlbmRlcldlYkdMID0gdGhpcy5yZW5kZXJXZWJHTDtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFJlbmRlckNhbnZhcyA9IHRoaXMucmVuZGVyQ2FudmFzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxVcGRhdGVUcmFuc2Zvcm0gPSB0aGlzLnVwZGF0ZVRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbEdldEJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzO1xuXG5cbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbENvbnRhaW5lc1BvaW50ID0gdGhpcy5jb250YWluc1BvaW50O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJXZWJHTCA9IHRoaXMuX3JlbmRlckNhY2hlZFdlYkdMO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fcmVuZGVyQ2FjaGVkQ2FudmFzO1xuXG5cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuX2NhY2hlZFNwcml0ZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJXZWJHTCA9IHRoaXMuX29yaWdpbmFsUmVuZGVyV2ViR0w7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9vcmlnaW5hbFJlbmRlckNhbnZhcztcbiAgICAgICAgICAgICAgICB0aGlzLmdldEJvdW5kcyA9IHRoaXMuX29yaWdpbmFsR2V0Qm91bmRzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB0aGlzLl9vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5zUG9pbnQgPSB0aGlzLl9vcmlnaW5hbENvbnRhaW5zUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8qKlxuKiBSZW5kZXJzIGEgY2FjaGVkIHZlcnNpb24gb2YgdGhlIHNwcml0ZSB3aXRoIFdlYkdMXG4qXG4qIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn0gdGhlIFdlYkdMIHJlbmRlcmVyXG4qIEBwcml2YXRlXG4qL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX3JlbmRlckNhY2hlZFdlYkdMID0gZnVuY3Rpb24ocmVuZGVyZXIpXG57XG4gICAgdGhpcy5faW5pdENhY2hlZERpc3BsYXlPYmplY3QoIHJlbmRlcmVyICk7XG5cbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcblxuICAgIHJlbmRlcmVyLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnMuc3ByaXRlKTtcbiAgICByZW5kZXJlci5wbHVnaW5zLnNwcml0ZS5yZW5kZXIoIHRoaXMuX2NhY2hlZFNwcml0ZSApO1xufTtcblxuLyoqXG4qIFByZXBhcmVzIHRoZSBXZWJHTCByZW5kZXJlciB0byBjYWNoZSB0aGUgc3ByaXRlXG4qXG4qIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn0gdGhlIFdlYkdMIHJlbmRlcmVyXG4qIEBwcml2YXRlXG4qL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24oIHJlbmRlcmVyIClcbntcbiAgICBpZih0aGlzLl9jYWNoZWRTcHJpdGUpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBmaXJzdCB3ZSBmbHVzaCBhbnl0aGluZyBsZWZ0IGluIHRoZSByZW5kZXJlciAob3RoZXJ3aXNlIGl0IHdvdWxkIGdldCByZW5kZXJlZCB0byB0aGUgY2FjaGVkIHRleHR1cmUpXG4gICAgcmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XG4gICAgLy90aGlzLmZpbHRlcnM9IFtdO1xuICAgIC8vIG5leHQgd2UgZmluZCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdW50cmFuc2Zvcm1lZCBvYmplY3RcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIGFsc28gY2FsbHMgdXBkYXRldHJhbnNmb3JtIG9uIGFsbCBpdHMgY2hpbGRyZW4gYXMgcGFydCBvZiB0aGUgbWVhc3VyaW5nLiBUaGlzIG1lYW5zIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSB0cmFuc2Zvcm0gYWdhaW4gaW4gdGhpcyBmdW5jdGlvblxuICAgIC8vIFRPRE8gcGFzcyBhbiBvYmplY3QgdG8gY2xvbmUgdG9vPyBzYXZlcyBoYXZpbmcgdG8gY3JlYXRlIGEgbmV3IG9uZSBlYWNoIHRpbWUhXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5jbG9uZSgpO1xuXG4gICAgLy8gYWRkIHNvbWUgcGFkZGluZyFcbiAgICBpZih0aGlzLl9maWx0ZXJzKVxuICAgIHtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLl9maWx0ZXJzWzBdLnBhZGRpbmc7XG4gICAgICAgIGJvdW5kcy54IC09IHBhZGRpbmc7XG4gICAgICAgIGJvdW5kcy55IC09IHBhZGRpbmc7XG5cbiAgICAgICAgYm91bmRzLndpZHRoICs9IHBhZGRpbmcgKiAyO1xuICAgICAgICBib3VuZHMuaGVpZ2h0ICs9IHBhZGRpbmcgKiAyO1xuICAgIH1cblxuICAgIC8vIGZvciBub3cgd2UgY2FjaGUgdGhlIGN1cnJlbnQgcmVuZGVyVGFyZ2V0IHRoYXQgdGhlIHdlYkdMIHJlbmRlcmVyIGlzIGN1cnJlbnRseSB1c2luZy5cbiAgICAvLyB0aGlzIGNvdWxkIGJlIG1vcmUgZWxlZ2VudC4uXG4gICAgdmFyIGNhY2hlZFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmN1cnJlbnRSZW5kZXJUYXJnZXQ7XG4gICAgLy8gV2UgYWxzbyBzdG9yZSB0aGUgZmlsdGVyIHN0YWNrIC0gSSB3aWxsIGRlZmluaXRlbHkgbG9vayB0byBjaGFuZ2UgaG93IHRoaXMgd29ya3MgYSBsaXR0bGUgbGF0ZXIgZG93biB0aGUgbGluZS5cbiAgICB2YXIgc3RhY2sgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmZpbHRlclN0YWNrO1xuXG4gICAgLy8gdGhpcyByZW5kZXJUZXh0dXJlIHdpbGwgYmUgdXNlZCB0byBzdG9yZSB0aGUgY2FjaGVkIERpc3BsYXlPYmplY3RcbiAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IG5ldyBjb3JlLlJlbmRlclRleHR1cmUocmVuZGVyZXIsIGJvdW5kcy53aWR0aCB8IDAsIGJvdW5kcy5oZWlnaHQgfCAwKTtcblxuICAgIC8vIG5lZWQgdG8gc2V0IC8vXG4gICAgdmFyIG0gPSBfdGVtcE1hdHJpeDtcblxuICAgIG0udHggPSAtYm91bmRzLng7XG4gICAgbS50eSA9IC1ib3VuZHMueTtcblxuXG5cbiAgICAvLyBzZXQgYWxsIHByb3BlcnRpZXMgdG8gdGhlcmUgb3JpZ2luYWwgc28gd2UgY2FuIHJlbmRlciB0byBhIHRleHR1cmVcbiAgICB0aGlzLnJlbmRlcldlYkdMID0gdGhpcy5fb3JpZ2luYWxSZW5kZXJXZWJHTDtcblxuICAgIHJlbmRlclRleHR1cmUucmVuZGVyKHRoaXMsIG0sIHRydWUpO1xuXG4gICAgLy8gbm93IHJlc3RvcmUgdGhlIHN0YXRlIGJlIHNldHRpbmcgdGhlIG5ldyBwcm9wZXJ0aWVzXG4gICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGNhY2hlZFJlbmRlclRhcmdldCk7XG4gICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5maWx0ZXJTdGFjayA9IHN0YWNrO1xuXG4gICAgdGhpcy5yZW5kZXJXZWJHTCAgICAgPSB0aGlzLl9yZW5kZXJDYWNoZWRXZWJHTDtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybTtcbiAgICB0aGlzLmdldEJvdW5kcyAgICAgICA9IHRoaXMuX2dldENhY2hlZEJvdW5kcztcblxuXG4gICAgLy8gY3JlYXRlIG91ciBjYWNoZWQgc3ByaXRlXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlID0gbmV3IGNvcmUuU3ByaXRlKHJlbmRlclRleHR1cmUpO1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS53b3JsZFRyYW5zZm9ybSA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFuY2hvci54ID0gLSggYm91bmRzLnggLyBib3VuZHMud2lkdGggKTtcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKCBib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQgKTtcblxuICAgIC8vIG1hcCB0aGUgaGl0IHRlc3QuLlxuICAgIHRoaXMuY29udGFpbnNQb2ludCA9IHRoaXMuX2NhY2hlZFNwcml0ZS5jb250YWluc1BvaW50LmJpbmQodGhpcy5fY2FjaGVkU3ByaXRlKTtcbn07XG5cbi8qKlxuKiBSZW5kZXJzIGEgY2FjaGVkIHZlcnNpb24gb2YgdGhlIHNwcml0ZSB3aXRoIGNhbnZhc1xuKlxuKiBAcGFyYW0gcmVuZGVyZXIge0NhbnZhc1JlbmRlcmVyfSB0aGUgQ2FudmFzIHJlbmRlcmVyXG4qIEBwcml2YXRlXG4qL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX3JlbmRlckNhY2hlZENhbnZhcyA9IGZ1bmN0aW9uKHJlbmRlcmVyKVxue1xuICAgIHRoaXMuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0Q2FudmFzKCByZW5kZXJlciApO1xuXG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLndvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG5cbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUucmVuZGVyQ2FudmFzKHJlbmRlcmVyKTtcbn07XG5cbi8vVE9ETyB0aGlzIGNhbiBiZSB0aGUgc2FtZSBhcyB0aGUgd2ViR0wgdmVyaXNvbi4uIHdpbGwgbmVlZCB0byBkbyBhIGxpdHRsZSB0d2Vha2luZyBmaXJzdCB0aG91Z2guLlxuLyoqXG4qIFByZXBhcmVzIHRoZSBDYW52YXMgcmVuZGVyZXIgdG8gY2FjaGUgdGhlIHNwcml0ZVxuKlxuKiBAcGFyYW0gcmVuZGVyZXIge0NhbnZhc1JlbmRlcmVyfSB0aGUgQ2FudmFzIHJlbmRlcmVyXG4qIEBwcml2YXRlXG4qL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0Q2FudmFzID0gZnVuY3Rpb24oIHJlbmRlcmVyIClcbntcbiAgICBpZih0aGlzLl9jYWNoZWRTcHJpdGUpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy9nZXQgYm91bmRzIGFjdHVhbGx5IHRyYW5zZm9ybXMgdGhlIG9iamVjdCBmb3IgdXMgYWxyZWFkeSFcbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuXG4gICAgdmFyIGNhY2hlZFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmNvbnRleHQ7XG5cbiAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IG5ldyBjb3JlLlJlbmRlclRleHR1cmUocmVuZGVyZXIsIGJvdW5kcy53aWR0aCB8IDAsIGJvdW5kcy5oZWlnaHQgfCAwKTtcblxuICAgIC8vIG5lZWQgdG8gc2V0IC8vXG4gICAgdmFyIG0gPSBfdGVtcE1hdHJpeDtcblxuICAgIG0udHggPSAtYm91bmRzLng7XG4gICAgbS50eSA9IC1ib3VuZHMueTtcblxuICAgIC8vIHNldCBhbGwgcHJvcGVydGllcyB0byB0aGVyZSBvcmlnaW5hbCBzbyB3ZSBjYW4gcmVuZGVyIHRvIGEgdGV4dHVyZVxuICAgIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fb3JpZ2luYWxSZW5kZXJDYW52YXM7XG5cbiAgICByZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLCBtLCB0cnVlKTtcblxuICAgIC8vIG5vdyByZXN0b3JlIHRoZSBzdGF0ZSBiZSBzZXR0aW5nIHRoZSBuZXcgcHJvcGVydGllc1xuICAgIHJlbmRlcmVyLmNvbnRleHQgPSBjYWNoZWRSZW5kZXJUYXJnZXQ7XG5cbiAgICB0aGlzLnJlbmRlckNhbnZhcyA9IHRoaXMuX3JlbmRlckNhY2hlZENhbnZhcztcbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybTtcbiAgICB0aGlzLmdldEJvdW5kcyAgPSB0aGlzLl9nZXRDYWNoZWRCb3VuZHM7XG5cblxuICAgIC8vIGNyZWF0ZSBvdXIgY2FjaGVkIHNwcml0ZVxuICAgIHRoaXMuX2NhY2hlZFNwcml0ZSA9IG5ldyBjb3JlLlNwcml0ZShyZW5kZXJUZXh0dXJlKTtcbiAgICB0aGlzLl9jYWNoZWRTcHJpdGUud29ybGRUcmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oIGJvdW5kcy54IC8gYm91bmRzLndpZHRoICk7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLSggYm91bmRzLnkgLyBib3VuZHMuaGVpZ2h0ICk7XG4gICAgdGhpcy5oaXRUZXN0ID0gdGhpcy5fY2FjaGVkU3ByaXRlLmhpdFRlc3QuYmluZCh0aGlzLl9jYWNoZWRTcHJpdGUpO1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgY2FjaGVkIHNwcml0ZVxuKlxuKiBAcHJpdmF0ZVxuKi9cbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9nZXRDYWNoZWRCb3VuZHMgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlLl9jdXJyZW50Qm91bmRzID0gbnVsbDtcblxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRTcHJpdGUuZ2V0Qm91bmRzKCk7XG59O1xuXG4vKipcbiogRGVzdHJveXMgdGhlIGNhY2hlZCBzcHJpdGUuXG4qXG4qIEBwcml2YXRlXG4qL1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuX2NhY2hlZFNwcml0ZS5fdGV4dHVyZS5kZXN0cm95KCk7XG4gICAgdGhpcy5fY2FjaGVkU3ByaXRlID0gbnVsbDtcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBUaGUgaW5zdGFuY2UgbmFtZSBvZiB0aGUgb2JqZWN0LlxuICpcbiAqIEBtZW1iZXIge3N0cmluZ31cbiAqL1xuY29yZS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5uYW1lID0gbnVsbDtcblxuLyoqXG4qIFJldHVybnMgdGhlIGRpc3BsYXkgb2JqZWN0IGluIHRoZSBjb250YWluZXJcbipcbiogQHBhcmFtIG5hbWUge3N0cmluZ30gaW5zdGFuY2UgbmFtZVxuKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fVxuKi9cbmNvcmUuQ29udGFpbmVyLnByb3RvdHlwZS5nZXRDaGlsZEJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykgXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSBcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3RcbipcbiogQHBhcmFtIHBvaW50IHtQb2ludH0gdGhlIHBvaW50IHRvIHdyaXRlIHRoZSBnbG9iYWwgdmFsdWUgdG8uIElmIG51bGwgYSBuZXcgcG9pbnQgd2lsbCBiZSByZXR1cm5lZFxuKiBAcmV0dXJuIHtQb2ludH1cbiovXG5jb3JlLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLmdldEdsb2JhbFBvc2l0aW9uID0gZnVuY3Rpb24gKHBvaW50KVxue1xuICAgIHBvaW50ID0gcG9pbnQgfHwgbmV3IGNvcmUuUG9pbnQoKTtcblxuICAgIGlmKHRoaXMucGFyZW50KVxuICAgIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgcG9pbnQueCA9IHRoaXMud29ybGRUcmFuc2Zvcm0udHg7XG4gICAgICAgIHBvaW50LnkgPSB0aGlzLndvcmxkVHJhbnNmb3JtLnR5O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBwb2ludC54ID0gdGhpcy5wb3NpdGlvbi54O1xuICAgICAgICBwb2ludC55ID0gdGhpcy5wb3NpdGlvbi55O1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludDtcbn07XG4iLCIvKipcbiAqIEBmaWxlICAgICAgICBNYWluIGV4cG9ydCBvZiB0aGUgUElYSSBleHRyYXMgbGlicmFyeVxuICogQGF1dGhvciAgICAgIE1hdCBHcm92ZXMgPG1hdEBnb29kYm95ZGlnaXRhbC5jb20+XG4gKiBAY29weXJpZ2h0ICAgMjAxMy0yMDE1IEdvb2RCb3lEaWdpdGFsXG4gKiBAbGljZW5zZSAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29kQm95RGlnaXRhbC9waXhpLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0V8TUlUIExpY2Vuc2V9XG4gKi9cblxucmVxdWlyZSgnLi9jYWNoZUFzQml0bWFwJyk7XG5yZXF1aXJlKCcuL2dldENoaWxkQnlOYW1lJyk7XG5yZXF1aXJlKCcuL2dldEdsb2JhbFBvc2l0aW9uJyk7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBQSVhJLmV4dHJhc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBUaWNrZXI6ICAgICAgICAgcmVxdWlyZSgnLi9UaWNrZXInKSxcbiAgICBNb3ZpZUNsaXA6ICAgICAgcmVxdWlyZSgnLi9Nb3ZpZUNsaXAnKSxcbiAgICBUaWxpbmdTcHJpdGU6ICAgcmVxdWlyZSgnLi9UaWxpbmdTcHJpdGUnKSxcbiAgICBCaXRtYXBUZXh0OiAgICAgcmVxdWlyZSgnLi9CaXRtYXBUZXh0JyksXG59O1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8vIFRPRE8gKGNlbmdsZXIpIC0gVGhlIFkgaXMgZmxpcHBlZCBpbiB0aGlzIHNoYWRlciBmb3Igc29tZSByZWFzb24uXG5cbi8qKlxuICogQGF1dGhvciBWaWNvIEB2aWNvY290ZWFcbiAqIG9yaWdpbmFsIHNoYWRlciA6IGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9sc3NHRGogYnkgQG1vdkFYMTNoXG4gKi9cblxuLyoqXG4gKiBBbiBBU0NJSSBmaWx0ZXIuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBBc2NpaUZpbHRlcigpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudW5pZm9ybSB2ZWM0IGRpbWVuc2lvbnM7XFxudW5pZm9ybSBmbG9hdCBwaXhlbFNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxuZmxvYXQgY2hhcmFjdGVyKGZsb2F0IG4sIHZlYzIgcClcXG57XFxuICAgIHAgPSBmbG9vcihwKnZlYzIoNC4wLCAtNC4wKSArIDIuNSk7XFxuICAgIGlmIChjbGFtcChwLngsIDAuMCwgNC4wKSA9PSBwLnggJiYgY2xhbXAocC55LCAwLjAsIDQuMCkgPT0gcC55KVxcbiAgICB7XFxuICAgICAgICBpZiAoaW50KG1vZChuL2V4cDIocC54ICsgNS4wKnAueSksIDIuMCkpID09IDEpIHJldHVybiAxLjA7XFxuICAgIH1cXG4gICAgcmV0dXJuIDAuMDtcXG59XFxuXFxudm9pZCBtYWluKClcXG57XFxuICAgIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHk7XFxuXFxuICAgIHZlYzMgY29sID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBmbG9vciggdXYgLyBwaXhlbFNpemUgKSAqIHBpeGVsU2l6ZSAvIGRpbWVuc2lvbnMueHkpLnJnYjtcXG5cXG4gICAgZmxvYXQgZ3JheSA9IChjb2wuciArIGNvbC5nICsgY29sLmIpIC8gMy4wO1xcblxcbiAgICBmbG9hdCBuID0gIDY1NTM2LjA7ICAgICAgICAgICAgIC8vIC5cXG4gICAgaWYgKGdyYXkgPiAwLjIpIG4gPSA2NTYwMC4wOyAgICAvLyA6XFxuICAgIGlmIChncmF5ID4gMC4zKSBuID0gMzMyNzcyLjA7ICAgLy8gKlxcbiAgICBpZiAoZ3JheSA+IDAuNCkgbiA9IDE1MjU1MDg2LjA7IC8vIG9cXG4gICAgaWYgKGdyYXkgPiAwLjUpIG4gPSAyMzM4NTE2NC4wOyAvLyAmXFxuICAgIGlmIChncmF5ID4gMC42KSBuID0gMTUyNTIwMTQuMDsgLy8gOFxcbiAgICBpZiAoZ3JheSA+IDAuNykgbiA9IDEzMTk5NDUyLjA7IC8vIEBcXG4gICAgaWYgKGdyYXkgPiAwLjgpIG4gPSAxMTUxMjgxMC4wOyAvLyAjXFxuXFxuICAgIHZlYzIgcCA9IG1vZCggdXYgLyAoIHBpeGVsU2l6ZSAqIDAuNSApLCAyLjApIC0gdmVjMigxLjApO1xcbiAgICBjb2wgPSBjb2wgKiBjaGFyYWN0ZXIobiwgcCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sLCAxLjApO1xcbn1cXG5cIixcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHsgdHlwZTogJzRmdicsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAwXSkgfSxcbiAgICAgICAgICAgIHBpeGVsU2l6ZTogIHsgdHlwZTogJzFmJywgdmFsdWU6IDggfVxuICAgICAgICB9XG4gICAgKTtcbn1cblxuQXNjaWlGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5Bc2NpaUZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc2NpaUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gQXNjaWlGaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFzY2lpRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBzaXplIHVzZWQgYnkgdGhlIGZpbHRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgQXNjaWlGaWx0ZXIjXG4gICAgICovXG4gICAgc2l6ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnBpeGVsU2l6ZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucGl4ZWxTaXplLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpLFxuICAgIEJsdXJYRmlsdGVyID0gcmVxdWlyZSgnLi4vYmx1ci9CbHVyWEZpbHRlcicpLFxuICAgIEJsdXJZRmlsdGVyID0gcmVxdWlyZSgnLi4vYmx1ci9CbHVyWUZpbHRlcicpO1xuXG4vKipcbiAqIFRoZSBCbG9vbUZpbHRlciBhcHBsaWVzIGEgR2F1c3NpYW4gYmx1ciB0byBhbiBvYmplY3QuXG4gKiBUaGUgc3RyZW5ndGggb2YgdGhlIGJsdXIgY2FuIGJlIHNldCBmb3IgeC0gYW5kIHktYXhpcyBzZXBhcmF0ZWx5LlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gQmxvb21GaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuYmx1clhGaWx0ZXIgPSBuZXcgQmx1clhGaWx0ZXIoKTtcbiAgICB0aGlzLmJsdXJZRmlsdGVyID0gbmV3IEJsdXJZRmlsdGVyKCk7XG5cbiAgICB0aGlzLmRlZmF1bHRGaWx0ZXIgPSBuZXcgY29yZS5BYnN0cmFjdEZpbHRlcigpO1xufVxuXG5CbG9vbUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbkJsb29tRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsb29tRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBCbG9vbUZpbHRlcjtcblxuQmxvb21GaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0KVxue1xuICAgIHZhciByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmdldFJlbmRlclRhcmdldCh0cnVlKTtcblxuICAgIC8vVE9ETyAtIGNvcHlUZXhTdWJJbWFnZTJEIGNvdWxkIGJlIHVzZWQgaGVyZT9cbiAgICB0aGlzLmRlZmF1bHRGaWx0ZXIuYXBwbHlGaWx0ZXIocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQpO1xuXG4gICAgdGhpcy5ibHVyWEZpbHRlci5hcHBseUZpbHRlcihyZW5kZXJlciwgaW5wdXQsIHJlbmRlclRhcmdldCk7XG5cbiAgICByZW5kZXJlci5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZShjb3JlLkJMRU5EX01PREVTLlNDUkVFTik7XG5cbiAgICB0aGlzLmJsdXJZRmlsdGVyLmFwcGx5RmlsdGVyKHJlbmRlcmVyLCByZW5kZXJUYXJnZXQsIG91dHB1dCk7XG5cbiAgICByZW5kZXJlci5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZShjb3JlLkJMRU5EX01PREVTLk5PUk1BTCk7XG5cbiAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLnJldHVyblJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQmxvb21GaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1clggYW5kIGJsdXJZIHByb3BlcnRpZXMgc2ltdWx0YW5lb3VzbHlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgQmxvb21GaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGJsdXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5ibHVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgdGhlIGJsdXJYIHByb3BlcnR5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEJsb29tRmlsdGVyI1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICBibHVyWDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clkgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgQmxvb21GaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGJsdXJZOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1cllGaWx0ZXIuYmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmx1cllGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKSxcbiAgICBCbHVyWEZpbHRlciA9IHJlcXVpcmUoJy4vQmx1clhGaWx0ZXInKSxcbiAgICBCbHVyWUZpbHRlciA9IHJlcXVpcmUoJy4vQmx1cllGaWx0ZXInKTtcblxuLyoqXG4gKiBUaGUgQmx1ckZpbHRlciBhcHBsaWVzIGEgR2F1c3NpYW4gYmx1ciB0byBhbiBvYmplY3QuXG4gKiBUaGUgc3RyZW5ndGggb2YgdGhlIGJsdXIgY2FuIGJlIHNldCBmb3IgeC0gYW5kIHktYXhpcyBzZXBhcmF0ZWx5LlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gQmx1ckZpbHRlcigpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5ibHVyWEZpbHRlciA9IG5ldyBCbHVyWEZpbHRlcigpO1xuICAgIHRoaXMuYmx1cllGaWx0ZXIgPSBuZXcgQmx1cllGaWx0ZXIoKTtcbn1cblxuQmx1ckZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbkJsdXJGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmx1ckZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gQmx1ckZpbHRlcjtcblxuQmx1ckZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQpXG57XG4gICAgdmFyIHJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuZ2V0UmVuZGVyVGFyZ2V0KHRydWUpO1xuXG4gICAgdGhpcy5ibHVyWEZpbHRlci5hcHBseUZpbHRlcihyZW5kZXJlciwgaW5wdXQsIHJlbmRlclRhcmdldCk7XG4gICAgdGhpcy5ibHVyWUZpbHRlci5hcHBseUZpbHRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQpO1xuXG4gICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5yZXR1cm5SZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcblxuXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCbHVyRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXJYIGFuZCBibHVyWSBwcm9wZXJ0aWVzIHNpbXVsdGFuZW91c2x5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEJsdXJGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGJsdXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5ibHVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gdmFsdWUgKiAwLjU7XG4gICAgICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB0aGlzLmJsdXJZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgcGFzc2VzIGZvciBibHVyLiBNb3JlIHBhc3NlcyBtZWFucyBoaWdoZXIgcXVhaWxpdHkgYmx1cmluZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgQmx1cllGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHBhc3Nlczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAgdGhpcy5ibHVyWEZpbHRlci5wYXNzZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLnBhc3NlcyA9IHRoaXMuYmx1cllGaWx0ZXIucGFzc2VzID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgdGhlIGJsdXJYIHByb3BlcnR5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEJsdXJGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGJsdXJYOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWSBwcm9wZXJ0eVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBCbHVyRmlsdGVyI1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICBibHVyWToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsdXJZRmlsdGVyLmJsdXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8qKlxuICogVGhlIEJsdXJYRmlsdGVyIGFwcGxpZXMgYSBob3Jpem9udGFsIEdhdXNzaWFuIGJsdXIgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gQmx1clhGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcblxcbnVuaWZvcm0gZmxvYXQgc3RyZW5ndGg7XFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG52YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbNl07XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKChhVmVydGV4UG9zaXRpb24pLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG5cXG4gICAgdkJsdXJUZXhDb29yZHNbIDBdID0gYVRleHR1cmVDb29yZCArIHZlYzIoLTAuMDEyICogc3RyZW5ndGgsIDAuMCk7XFxuICAgIHZCbHVyVGV4Q29vcmRzWyAxXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKC0wLjAwOCAqIHN0cmVuZ3RoLCAwLjApO1xcbiAgICB2Qmx1clRleENvb3Jkc1sgMl0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigtMC4wMDQgKiBzdHJlbmd0aCwgMC4wKTtcXG4gICAgdkJsdXJUZXhDb29yZHNbIDNdID0gYVRleHR1cmVDb29yZCArIHZlYzIoIDAuMDA0ICogc3RyZW5ndGgsIDAuMCk7XFxuICAgIHZCbHVyVGV4Q29vcmRzWyA0XSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKCAwLjAwOCAqIHN0cmVuZ3RoLCAwLjApO1xcbiAgICB2Qmx1clRleENvb3Jkc1sgNV0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMiggMC4wMTIgKiBzdHJlbmd0aCwgMC4wKTtcXG5cXG4gICAgdkNvbG9yID0gdmVjNChhQ29sb3IucmdiICogYUNvbG9yLmEsIGFDb2xvci5hKTtcXG59XFxuXCIsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBsb3dwIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1s2XTtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMF0pKjAuMDA0NDMxODQ4NDExOTM4MzQxO1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMV0pKjAuMDUzOTkwOTY2NTEzMTg5ODU7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAyXSkqMC4yNDE5NzA3MjQ1MTkxNDU0O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICAgICApKjAuMzk4OTQyMjgwNDAxNDMyNztcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDNdKSowLjI0MTk3MDcyNDUxOTE0NTQ7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyA0XSkqMC4wNTM5OTA5NjY1MTMxODk4NTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDVdKSowLjAwNDQzMTg0ODQxMTkzODM0MTtcXG59XFxuXCIsXG4gICAgICAgIC8vIHNldCB0aGUgdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgc3RyZW5ndGg6IHsgdHlwZTogJzFmJywgdmFsdWU6IDEgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBwYXNzZXMgZm9yIGJsdXIuIE1vcmUgcGFzc2VzIG1lYW5zIGhpZ2hlciBxdWFpbGl0eSBibHVyaW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBCbHVyWEZpbHRlciNcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5wYXNzZXMgPSAxO1xuXG4gICAgdGhpcy5zdHJlbmd0aCA9IDQ7XG59XG5cbkJsdXJYRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuQmx1clhGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmx1clhGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IEJsdXJYRmlsdGVyO1xuXG5CbHVyWEZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKVxue1xuICAgIHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcihyZW5kZXJlcik7XG5cbiAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlID0gdGhpcy5zdHJlbmd0aCAvIDQgLyB0aGlzLnBhc3NlcyAqIChpbnB1dC5mcmFtZS53aWR0aCAvIGlucHV0LnNpemUud2lkdGgpO1xuXG4gICAgaWYodGhpcy5wYXNzZXMgPT09IDEpXG4gICAge1xuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5nZXRSZW5kZXJUYXJnZXQodHJ1ZSk7XG4gICAgICAgIHZhciBmbGlwID0gaW5wdXQ7XG4gICAgICAgIHZhciBmbG9wID0gcmVuZGVyVGFyZ2V0O1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnBhc3Nlcy0xOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBmbGlwLCBmbG9wLCBjbGVhcik7XG5cbiAgICAgICAgICAgdmFyIHRlbXAgPSBmbG9wO1xuICAgICAgICAgICBmbG9wID0gZmxpcDtcbiAgICAgICAgICAgZmxpcCA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgZmxpcCwgb3V0cHV0LCBjbGVhcik7XG5cbiAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5yZXR1cm5SZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICB9XG59O1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJsdXJYRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIEJsdXJYRmlsdGVyI1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICBibHVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICB0aGlzLnN0cmVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gdmFsdWUgKiAwLjU7XG4gICAgICAgICAgICB0aGlzLnN0cmVuZ3RoID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBUaGUgQmx1cllGaWx0ZXIgYXBwbGllcyBhIGhvcml6b250YWwgR2F1c3NpYW4gYmx1ciB0byBhbiBvYmplY3QuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBCbHVyWUZpbHRlcigpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XFxuXFxudW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1s2XTtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoKGFWZXJ0ZXhQb3NpdGlvbiksIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcblxcbiAgICB2Qmx1clRleENvb3Jkc1sgMF0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigwLjAsIC0wLjAxMiAqIHN0cmVuZ3RoKTtcXG4gICAgdkJsdXJUZXhDb29yZHNbIDFdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAtMC4wMDggKiBzdHJlbmd0aCk7XFxuICAgIHZCbHVyVGV4Q29vcmRzWyAyXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgLTAuMDA0ICogc3RyZW5ndGgpO1xcbiAgICB2Qmx1clRleENvb3Jkc1sgM10gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigwLjAsICAwLjAwNCAqIHN0cmVuZ3RoKTtcXG4gICAgdkJsdXJUZXhDb29yZHNbIDRdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAgMC4wMDggKiBzdHJlbmd0aCk7XFxuICAgIHZCbHVyVGV4Q29vcmRzWyA1XSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgIDAuMDEyICogc3RyZW5ndGgpO1xcblxcbiAgIHZDb2xvciA9IHZlYzQoYUNvbG9yLnJnYiAqIGFDb2xvci5hLCBhQ29sb3IuYSk7XFxufVxcblwiLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbG93cCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbNl07XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDBdKSowLjAwNDQzMTg0ODQxMTkzODM0MTtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDFdKSowLjA1Mzk5MDk2NjUxMzE4OTg1O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMl0pKjAuMjQxOTcwNzI0NTE5MTQ1NDtcXG4gICAgZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCAgICAgKSowLjM5ODk0MjI4MDQwMTQzMjc7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAzXSkqMC4yNDE5NzA3MjQ1MTkxNDU0O1xcbiAgICBnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgNF0pKjAuMDUzOTkwOTY2NTEzMTg5ODU7XFxuICAgIGdsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyA1XSkqMC4wMDQ0MzE4NDg0MTE5MzgzNDE7XFxufVxcblwiLFxuICAgICAgICAvLyBzZXQgdGhlIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0cmVuZ3RoOiB7IHR5cGU6ICcxZicsIHZhbHVlOiAxIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IDE7XG4gICAgdGhpcy5zdHJlbmd0aCA9IDQ7XG59XG5cbkJsdXJZRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuQmx1cllGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmx1cllGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IEJsdXJZRmlsdGVyO1xuXG5CbHVyWUZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKVxue1xuICAgIHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcihyZW5kZXJlcik7XG5cbiAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlID0gdGhpcy5zdHJlbmd0aCAvIDQgLyB0aGlzLnBhc3NlcyAqIChpbnB1dC5mcmFtZS5oZWlnaHQgLyBpbnB1dC5zaXplLmhlaWdodCk7XG5cbiAgICBpZih0aGlzLnBhc3NlcyA9PT0gMSlcbiAgICB7XG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmdldFJlbmRlclRhcmdldCh0cnVlKTtcbiAgICAgICAgdmFyIGZsaXAgPSBpbnB1dDtcbiAgICAgICAgdmFyIGZsb3AgPSByZW5kZXJUYXJnZXQ7XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMucGFzc2VzLTE7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcihzaGFkZXIsIGZsaXAsIGZsb3AsIGNsZWFyKTtcblxuICAgICAgICAgICB2YXIgdGVtcCA9IGZsb3A7XG4gICAgICAgICAgIGZsb3AgPSBmbGlwO1xuICAgICAgICAgICBmbGlwID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBmbGlwLCBvdXRwdXQsIGNsZWFyKTtcblxuICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLnJldHVyblJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgIH1cbn07XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQmx1cllGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1ci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgQmx1cllGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGJsdXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gIHRoaXMuc3RyZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmcgPSB2YWx1ZSAqIDAuNTtcbiAgICAgICAgICAgIHRoaXMuc3RyZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG59KTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIEEgU21hcnQgQmx1ciBGaWx0ZXIuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBTbWFydEJsdXJGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbmNvbnN0IHZlYzIgZGVsdGEgPSB2ZWMyKDEuMC8xMC4wLCAwLjApO1xcblxcbmZsb2F0IHJhbmRvbSh2ZWMzIHNjYWxlLCBmbG9hdCBzZWVkKVxcbntcXG4gICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoZ2xfRnJhZ0Nvb3JkLnh5eiArIHNlZWQsIHNjYWxlKSkgKiA0Mzc1OC41NDUzICsgc2VlZCk7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG4gICAgZmxvYXQgdG90YWwgPSAwLjA7XFxuXFxuICAgIGZsb2F0IG9mZnNldCA9IHJhbmRvbSh2ZWMzKDEyLjk4OTgsIDc4LjIzMywgMTUxLjcxODIpLCAwLjApO1xcblxcbiAgICBmb3IgKGZsb2F0IHQgPSAtMzAuMDsgdCA8PSAzMC4wOyB0KyspXFxuICAgIHtcXG4gICAgICAgIGZsb2F0IHBlcmNlbnQgPSAodCArIG9mZnNldCAtIDAuNSkgLyAzMC4wO1xcbiAgICAgICAgZmxvYXQgd2VpZ2h0ID0gMS4wIC0gYWJzKHBlcmNlbnQpO1xcbiAgICAgICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyBkZWx0YSAqIHBlcmNlbnQpO1xcbiAgICAgICAgc2FtcGxlLnJnYiAqPSBzYW1wbGUuYTtcXG4gICAgICAgIGNvbG9yICs9IHNhbXBsZSAqIHdlaWdodDtcXG4gICAgICAgIHRvdGFsICs9IHdlaWdodDtcXG4gICAgfVxcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHRvdGFsO1xcbiAgICBnbF9GcmFnQ29sb3IucmdiIC89IGdsX0ZyYWdDb2xvci5hICsgMC4wMDAwMTtcXG59XFxuXCJcbiAgICApO1xufVxuXG5TbWFydEJsdXJGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5TbWFydEJsdXJGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU21hcnRCbHVyRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBTbWFydEJsdXJGaWx0ZXI7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBUaGUgQ29sb3JNYXRyaXhGaWx0ZXIgY2xhc3MgbGV0cyB5b3UgYXBwbHkgYSA1eDUgbWF0cml4IHRyYW5zZm9ybWF0aW9uIG9uIHRoZSBSR0JBXG4gKiBjb2xvciBhbmQgYWxwaGEgdmFsdWVzIG9mIGV2ZXJ5IHBpeGVsIG9uIHlvdXIgZGlzcGxheU9iamVjdCB0byBwcm9kdWNlIGEgcmVzdWx0XG4gKiB3aXRoIGEgbmV3IHNldCBvZiBSR0JBIGNvbG9yIGFuZCBhbHBoYSB2YWx1ZXMuIEl0J3MgcHJldHR5IHBvd2VyZnVsIVxuICpcbiAqIGBgYGpzXG4gKiAgdmFyIGNvbG9yTWF0cml4ID0gbmV3IFBJWEkuQ29sb3JNYXRyaXhGaWx0ZXIoKTtcbiAqICBjb250YWluZXIuZmlsdGVycyA9IFtjb2xvck1hdHJpeF07XG4gKiAgY29sb3JNYXRyaXguY29udHJhc3QoMik7XG4gKiBgYGBcbiAqIEBhdXRob3IgQ2zDqW1lbnQgQ2hlbmViYXVsdCA8Y2xlbWVudEBnb29kYm95ZGlnaXRhbC5jb20+XG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIENvbG9yTWF0cml4RmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IG1bMjRdO1xcblxcbnVuaWZvcm0gdmVjNCBkO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgXFxuICAgIHZlYzQgYyA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuXFxuXFx0Z2xfRnJhZ0NvbG9yLnIgPSBtWzBdICogYy5yICsgbVsxXSAqIGMuZyArIG1bMl0gKiBjLmIgKyBtWzNdICogYy5hICsgbVs0XTtcXG5cXHRnbF9GcmFnQ29sb3IuZyA9IG1bNV0gKiBjLnIgKyBtWzZdICogYy5nICsgbVs3XSAqIGMuYiArIG1bOF0gKiBjLmEgKyBtWzldO1xcblxcdGdsX0ZyYWdDb2xvci5iID0gbVsxMF0gKiBjLnIgKyBtWzExXSAqIGMuZyArIG1bMTJdICogYy5iICsgbVsxM10gKiBjLmEgKyBtWzE0XTtcXG5cXHRnbF9GcmFnQ29sb3IuYSA9IGMuYTtcXG59XFxuXCIsXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBtOiB7IHR5cGU6ICcxZnYnLCB2YWx1ZTogWzEsIDAsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAxLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgMSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDAsIDEsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAxXSB9LFxuICAgICAgICB9XG4gICAgKTtcbn1cblxuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xvck1hdHJpeEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gQ29sb3JNYXRyaXhGaWx0ZXI7XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGN1cnJlbnQgbWF0cml4IGFuZCBzZXQgdGhlIG5ldyBvbmVcbiAqXG4gKiBAcGFyYW0gbWF0cml4IHthcnJheX0gKG1hdCA1eDUpXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLCBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5fbG9hZE1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCwgbXVsdGlwbHkpXG57XG4gICAgbXVsdGlwbHkgPSAhIW11bHRpcGx5O1xuXG4gICAgdmFyIG5ld01hdHJpeCA9IG1hdHJpeDtcblxuICAgIGlmKG11bHRpcGx5KVxuICAgIHtcbiAgICAgICAgdGhpcy5fbXVsdGlwbHkobmV3TWF0cml4LCB0aGlzLnVuaWZvcm1zLm0udmFsdWUsIG1hdHJpeCk7XG4gICAgICAgIG5ld01hdHJpeCA9IHRoaXMuX2NvbG9yTWF0cml4KG5ld01hdHJpeCk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBuZXcgbWF0cml4XG4gICAgdGhpcy51bmlmb3Jtcy5tLnZhbHVlID0gbmV3TWF0cml4O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ1J3NcbiAqXG4gKiBAcGFyYW0gb3V0IHthcnJheX0gKG1hdCA1eDUpIHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0gYSB7YXJyYXl9IChtYXQgNXg1KSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIGIge2FycmF5fSAobWF0IDV4NSkgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyBvdXQge2FycmF5fSAobWF0IDV4NSlcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLl9tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcblxuICAgIC8vIGZpcnN0IGxpbmVcbiAgICBvdXRbMF0gPSBhWzBdKmJbMF0gKyBhWzFdKmJbNV0gKyBhWzJdKmJbMTBdICsgYVszXSpiWzE1XSArIGFbNF0qYlsyMF07XG4gICAgb3V0WzFdID0gYVswXSpiWzFdICsgYVsxXSpiWzZdICsgYVsyXSpiWzExXSArIGFbM10qYlsxNl0gK2FbNF0qYlsyMV07XG4gICAgb3V0WzJdID0gYVswXSpiWzJdICsgYVsxXSpiWzddICsgYVsyXSpiWzEyXSArIGFbM10qYlsxN10gK2FbNF0qYlsyMl07XG4gICAgb3V0WzNdID0gYVswXSpiWzNdICsgYVsxXSpiWzhdICsgYVsyXSpiWzEzXSArIGFbM10qYlsxOF0gK2FbNF0qYlsyM107XG4gICAgb3V0WzRdID0gYVswXSpiWzRdICsgYVsxXSpiWzldICsgYVsyXSpiWzE0XSArIGFbM10qYlsxOV0rYVs0XSpiWzI0XTtcblxuICAgIC8vIHNlY29uZCBsaW5lXG4gICAgb3V0WzVdID0gYVs1XSpiWzBdICsgYVs2XSpiWzVdICsgYVs3XSpiWzEwXSsgYVs4XSpiWzE1XSthWzldKmJbMjBdO1xuICAgIG91dFs2XSA9IGFbNV0qYlsxXSArIGFbNl0qYls2XSArIGFbN10qYlsxMV0rIGFbOF0qYlsxNl0rYVs5XSpiWzIxXTtcbiAgICBvdXRbN10gPSBhWzVdKmJbMl0gKyBhWzZdKmJbN10gKyBhWzddKmJbMTJdKyBhWzhdKmJbMTddK2FbOV0qYlsyMl07XG4gICAgb3V0WzhdID0gYVs1XSpiWzNdICsgYVs2XSpiWzhdICsgYVs3XSpiWzEzXSsgYVs4XSpiWzE4XSthWzldKmJbMjNdO1xuICAgIG91dFs5XSA9IGFbNV0qYls0XSArIGFbNl0qYls5XSArIGFbN10qYlsxNF0rIGFbOF0qYlsxOV0rYVs5XSpiWzI0XTtcblxuICAgIC8vIHRoaXJkIGxpbmVcbiAgICBvdXRbMTBdID0gYVsxMF0qYlswXSArIGFbMTFdKmJbNV0gKyBhWzEyXSpiWzEwXSsgYVsxM10qYlsxNV0rYVsxNF0qYlsyMF07XG4gICAgb3V0WzExXSA9IGFbMTBdKmJbMV0gKyBhWzExXSpiWzZdICsgYVsxMl0qYlsxMV0rIGFbMTNdKmJbMTZdK2FbMTRdKmJbMjFdO1xuICAgIG91dFsxMl0gPSBhWzEwXSpiWzJdICsgYVsxMV0qYls3XSArIGFbMTJdKmJbMTJdKyBhWzEzXSpiWzE3XSthWzE0XSpiWzIyXTtcbiAgICBvdXRbMTNdID0gYVsxMF0qYlszXSArIGFbMTFdKmJbOF0gKyBhWzEyXSpiWzEzXSsgYVsxM10qYlsxOF0rYVsxNF0qYlsyM107XG4gICAgb3V0WzE0XSA9IGFbMTBdKmJbNF0gKyBhWzExXSpiWzldICsgYVsxMl0qYlsxNF0rIGFbMTNdKmJbMTldK2FbMTRdKmJbMjRdO1xuXG4gICAgLy8gZm91cnRoIGxpbmVcbiAgICBvdXRbMTVdID0gYVsxNV0qYlswXSArIGFbMTZdKmJbNV0gKyBhWzE3XSpiWzEwXSsgYVsxOF0qYlsxNV0rYVsxOV0qYlsyMF07XG4gICAgb3V0WzE2XSA9IGFbMTVdKmJbMV0gKyBhWzE2XSpiWzZdICsgYVsxN10qYlsxMV0rIGFbMThdKmJbMTZdK2FbMTldKmJbMjFdO1xuICAgIG91dFsxN10gPSBhWzE1XSpiWzJdICsgYVsxNl0qYls3XSArIGFbMTddKmJbMTJdKyBhWzE4XSpiWzE3XSthWzE5XSpiWzIyXTtcbiAgICBvdXRbMThdID0gYVsxNV0qYlszXSArIGFbMTZdKmJbOF0gKyBhWzE3XSpiWzEzXSsgYVsxOF0qYlsxOF0rYVsxOV0qYlsyM107XG4gICAgb3V0WzE5XSA9IGFbMTVdKmJbNF0gKyBhWzE2XSpiWzldICsgYVsxN10qYlsxNF0rIGFbMThdKmJbMTldK2FbMTldKmJbMjRdO1xuXG4gICAgLy8gZmlmdGggbGluZVxuICAgIG91dFsyMF0gPSBhWzIwXSpiWzBdICsgYVsyMV0qYls1XSArIGFbMjJdKmJbMTBdKyBhWzIzXSpiWzE1XSthWzI0XSpiWzIwXTtcbiAgICBvdXRbMjFdID0gYVsyMF0qYlsxXSArIGFbMjFdKmJbNl0gKyBhWzIyXSpiWzExXSsgYVsyM10qYlsxNl0rYVsyNF0qYlsyMV07XG4gICAgb3V0WzIyXSA9IGFbMjBdKmJbMl0gKyBhWzIxXSpiWzddICsgYVsyMl0qYlsxMl0rIGFbMjNdKmJbMTddK2FbMjRdKmJbMjJdO1xuICAgIG91dFsyM10gPSBhWzIwXSpiWzNdICsgYVsyMV0qYls4XSArIGFbMjJdKmJbMTNdKyBhWzIzXSpiWzE4XSthWzI0XSpiWzIzXTtcbiAgICBvdXRbMjRdID0gYVsyMF0qYls0XSArIGFbMjFdKmJbOV0gKyBhWzIyXSpiWzE0XSsgYVsyM10qYlsxOV0rYVsyNF0qYlsyNF07XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBGbG9hdDMyIEFycmF5IGFuZCBub3JtYWxpemUgdGhlIG9mZnNldCBjb21wb25lbnQgdG8gMC0xXG4gKlxuICogQHBhcmFtIG1hdHJpeCB7YXJyYXl9IChtYXQgNXg1KVxuICogQHJldHVybiBtIHsgYXJyYXkgfSAobWF0IDV4NSkgd2l0aCBhbGwgdmFsdWVzIGJldHdlZW4gMC0xXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5fY29sb3JNYXRyaXggPSBmdW5jdGlvbiggbWF0cml4IClcbntcbiAgICAvLyBDcmVhdGUgYSBGbG9hdDMyIEFycmF5IGFuZCBub3JtYWxpemUgdGhlIG9mZnNldCBjb21wb25lbnQgdG8gMC0xXG4gICAgdmFyIG0gPSBuZXcgRmxvYXQzMkFycmF5KG1hdHJpeCk7XG4gICAgbVs0XSAvPSAyNTU7XG4gICAgbVs5XSAvPSAyNTU7XG4gICAgbVsxNF0gLz0gMjU1O1xuICAgIG1bMTldIC89IDI1NTtcblxuICAgIHJldHVybiBtO1xufTtcblxuLyoqXG4gKiBBZGp1c3RzIGJyaWdodG5lc3NcbiAqXG4gKiBNdWx0aXBseSB0aGUgY3VycmVudCBtYXRyaXhcbiAqIEBwYXJhbSBiIHtudW1iZXJ9IHZhbHVlIG9mIHRoZSBicmlndGhuZXNzICgwIGlzIGJsYWNrKVxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmJyaWdodG5lc3MgPSBmdW5jdGlvbihiLCBtdWx0aXBseSlcbntcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICBiLCAwLCAwLCAwLCAwLFxuICAgICAgICAwLCBiLCAwLCAwLCAwLFxuICAgICAgICAwLCAwLCBiLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAxLCAwLFxuICAgICAgICAwLCAwLCAwLCAwLCAxXG4gICAgXTtcblxuXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXRyaWNlcyBpbiBncmV5IHNjYWxlc1xuICpcbiAqIE11bHRpcGx5IHRoZSBjdXJyZW50IG1hdHJpeFxuICogQHBhcmFtIHNjYWxlIHtudW1iZXJ9IHZhbHVlIG9mIHRoZSBncmV5ICgwIGlzIGJsYWNrKVxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmdyZXlzY2FsZSA9IGZ1bmN0aW9uKHNjYWxlLCBtdWx0aXBseSlcbntcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICBzY2FsZSwgc2NhbGUsIHNjYWxlLCAwLCAwLFxuICAgICAgICBzY2FsZSwgc2NhbGUsIHNjYWxlLCAwLCAwLFxuICAgICAgICBzY2FsZSwgc2NhbGUsIHNjYWxlLCAwLCAwLFxuICAgICAgICAwLDAsMCwxLDAsXG4gICAgICAgIDAsMCwwLDAsMVxuICAgIF07XG5cbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGJsYWNrIGFuZCB3aGl0ZSBtYXRyaWNlXG4gKiBNdWx0aXBseSB0aGUgY3VycmVudCBtYXRyaXhcbiAqXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuYmxhY2tBbmRXaGl0ZSA9IGZ1bmN0aW9uKG11bHRpcGx5KVxue1xuICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgIDAuMywgMC42LCAwLjEsIDAsIDAsXG4gICAgICAgIDAuMywgMC42LCAwLjEsIDAsIDAsXG4gICAgICAgIDAuMywgMC42LCAwLjEsIDAsIDAsXG4gICAgICAgIDAsIDAsIDAsIDEsIDAsXG4gICAgICAgIDAsIDAsIDAsIDAsIDFcbiAgICBdO1xuXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBodWUgcHJvcGVydGllIG9mIHRoZSBjb2xvclxuICpcbiAqIE11bHRpcGx5IHRoZSBjdXJyZW50IG1hdHJpeFxuICogQHBhcmFtIHJvdGF0aW9uIHtudW1iZXJ9IGluIGRlZ3JlZXNcbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5odWUgPSBmdW5jdGlvbihyb3RhdGlvbiwgbXVsdGlwbHkpXG57XG4gICAgcm90YXRpb24gPSAocm90YXRpb24gfHwgMCkvMTgwICogTWF0aC5QSTtcbiAgICB2YXIgY29zID0gTWF0aC5jb3Mocm90YXRpb24pLFxuICAgICAgICBzaW4gPSBNYXRoLnNpbihyb3RhdGlvbik7XG5cbiAgICAvLyBsdW1pbmFuY2VSZWQsIGx1bWluYW5jZUdyZWVuLCBsdW1pbmFuY2VCbHVlXG4gICAgdmFyIGx1bVIgPSAwLjIxMywgLy8gb3IgMC4zMDg2XG4gICAgICAgIGx1bUcgPSAwLjcxNSwgLy8gb3IgMC42MDk0XG4gICAgICAgIGx1bUIgPSAwLjA3MjsgLy8gb3IgMC4wODIwXG5cbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICBsdW1SK2NvcyooMS1sdW1SKStzaW4qKC1sdW1SKSwgbHVtRytjb3MqKC1sdW1HKStzaW4qKC1sdW1HKSwgbHVtQitjb3MqKC1sdW1CKStzaW4qKDEtbHVtQiksIDAsIDAsXG4gICAgICAgIGx1bVIrY29zKigtbHVtUikrc2luKigwLjE0MyksIGx1bUcrY29zKigxLWx1bUcpK3NpbiooMC4xNDApLCBsdW1CK2NvcyooLWx1bUIpK3NpbiooLTAuMjgzKSwgMCwgMCxcbiAgICAgICAgbHVtUitjb3MqKC1sdW1SKStzaW4qKC0oMS1sdW1SKSksIGx1bUcrY29zKigtbHVtRykrc2luKihsdW1HKSwgbHVtQitjb3MqKDEtbHVtQikrc2luKihsdW1CKSwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMSwgMCxcbiAgICAgICAgMCwgMCwgMCwgMCwgMVxuICAgIF07XG5cbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgY29udHJhc3QgbWF0cml4LCBpbmNyZWFzZSB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuIGRhcmsgYW5kIGJyaWdodFxuICogSW5jcmVhc2UgY29udHJhc3QgOiBzaGFkb3dzIGRhcmtlciBhbmQgaGlnaGxpZ2h0cyBicmlnaHRlclxuICogRGVjcmVhc2UgY29udHJhc3QgOiBicmluZyB0aGUgc2hhZG93cyB1cCBhbmQgdGhlIGhpZ2hsaWdodHMgZG93blxuICpcbiAqIEBwYXJhbSBhbW91bnQge251bWJlcn0gdmFsdWUgb2YgdGhlIGNvbnRyYXN0XG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuY29udHJhc3QgPSBmdW5jdGlvbihhbW91bnQsIG11bHRpcGx5KVxue1xuICAgIHZhciB2ID0gKGFtb3VudCB8fCAwKSArIDE7XG4gICAgdmFyIG8gPSAtMTI4ICogKHYtMSk7XG5cbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICB2LCAwLCAwLCAwLCBvLFxuICAgICAgICAwLCB2LCAwLCAwLCBvLFxuICAgICAgICAwLCAwLCB2LCAwLCBvLFxuICAgICAgICAwLCAwLCAwLCAxLCAwLFxuICAgICAgICAwLCAwLCAwLCAwLCAxXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc2F0dXJhdGlvbiBtYXRyaXgsIGluY3JlYXNlIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gY29sb3JzXG4gKiBJbmNyZWFzZSBzYXR1cmF0aW9uIDogaW5jcmVhc2UgY29udHJhc3QsIGJyaWdodG5lc3MsIGFuZCBzaGFycG5lc3NcbiAqIEBwYXJhbSBhbW91bnQge251bWJlcn1cbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5zYXR1cmF0aW9uID0gZnVuY3Rpb24oYW1vdW50LCBtdWx0aXBseSlcbntcbiAgICB2YXIgeCA9IChhbW91bnQgfHwgMCkgKiAyLzMgKyAxO1xuICAgIHZhciB5ID0gKCh4LTEpICotMC41KTtcblxuICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgIHgsIHksIHksIDAsIDAsXG4gICAgICAgIHksIHgsIHksIDAsIDAsXG4gICAgICAgIHksIHksIHgsIDAsIDAsXG4gICAgICAgIDAsIDAsIDAsIDEsIDAsXG4gICAgICAgIDAsIDAsIDAsIDAsIDFcbiAgICBdO1xuXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbn07XG5cbi8qKlxuICogRGVzYXR1cmF0ZSBpbWFnZSAocmVtb3ZlIGNvbG9yKVxuICpcbiAqIENhbGwgdGhlIHNhdHVyYXRlIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmRlc2F0dXJhdGUgPSBmdW5jdGlvbihtdWx0aXBseSkgLy8ganNoaW50IHVudXNlZDpmYWxzZVxue1xuICAgIHRoaXMuc2F0dXJhdGlvbigtMSk7XG59O1xuXG4vKipcbiAqIE5lZ2F0aXZlIGltYWdlIChpbnZlcnNlIG9mIGNsYXNzaWMgcmdiIG1hdHJpeClcbiAqXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUubmVnYXRpdmUgPSBmdW5jdGlvbihtdWx0aXBseSlcbntcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAwLCAxLCAxLCAwLCAwLFxuICAgICAgICAxLCAwLCAxLCAwLCAwLFxuICAgICAgICAxLCAxLCAwLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAxLCAwLFxuICAgICAgICAwLCAwLCAwLCAwLCAxXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG4vKipcbiAqIFNlcGlhIGltYWdlXG4gKlxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLnNlcGlhID0gZnVuY3Rpb24obXVsdGlwbHkpXG57XG4gIHZhciBtYXRyaXggPSBbXG4gICAgICAwLjM5MywgMC43Njg5OTk5LCAwLjE4ODk5OTk5LCAwLCAwLFxuICAgICAgMC4zNDksIDAuNjg1OTk5OSwgMC4xNjc5OTk5OSwgMCwgMCxcbiAgICAgIDAuMjcyLCAwLjUzMzk5OTksIDAuMTMwOTk5OTksIDAsIDAsXG4gICAgICAwLCAwLCAwLCAxLCAwLFxuICAgICAgMCwgMCwgMCwgMCwgMV07XG5cbiAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbn07XG5cbi8qKlxuICogQ29sb3IgbW90aW9uIHBpY3R1cmUgcHJvY2VzcyBpbnZlbnRlZCBpbiAxOTE2ICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxuICpcbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS50ZWNobmljb2xvciA9IGZ1bmN0aW9uKG11bHRpcGx5KVxue1xuICB2YXIgbWF0cml4ID0gW1xuICAgICAgMS45MTI1Mjc3ODkxNDU2MDgzLC0wLjg1NDUzNDQ5NzY5NTE2NDUsLTAuMDkxNTU1MDg0ODI3NTU1ODUsMCwxMS43OTM2MDM0MzQzNzczMzcsXG4gICAgICAtMC4zMDg3ODMzMzg1OTI4MDk3LDEuNzY1ODkwODU1NTQ1ODQyOCwtMC4xMDYwMTc0MzA3NDcyMjI0NSwwLC03MC4zNTIwNTE2MTQ2MTM5OCxcbiAgICAgIC0wLjIzMTEwMzM3NzU0ODYxNiwtMC43NTAxODk5MTk3NDQwMjEyLDEuODQ3NTk3ODE2MTA4MTg5LDAsMzAuOTUwOTQwODY5NDkxMTM4LFxuICAgICAgMCwgMCwgMCwgMSwgMCxcbiAgICAgIDAsIDAsIDAsIDAsIDBdO1xuXG4gIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG4vKipcbiAqIFBvbGFyb2lkIGZpbHRlclxuICpcbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5wb2xhcm9pZCA9IGZ1bmN0aW9uKG11bHRpcGx5KVxue1xuICB2YXIgbWF0cml4ID0gW1xuICAgICAgMS40MzgsLTAuMDYyLC0wLjA2MiwwLDAsXG4gICAgICAtMC4xMjIsMS4zNzgsLTAuMTIyLDAsMCxcbiAgICAgIC0wLjAxNiwtMC4wMTYsMS40ODMsMCwwLFxuICAgICAgMCwwLDAsMSwwLFxuICAgICAgMCwwLDAsMCwxXTtcblxuICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xufTtcblxuLyoqXG4gKiBGaWx0ZXIgd2hvIHRyYW5zZm9ybXMgOiBSZWQgLT4gQmx1ZSBhbmQgQmx1ZSAtPiBSZWRcbiAqXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUudG9CR1IgPSBmdW5jdGlvbihtdWx0aXBseSlcbntcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAwLDAsMSwwLDAsXG4gICAgICAgIDAsMSwwLDAsMCxcbiAgICAgICAgMSwwLDAsMCwwLFxuICAgICAgICAwLDAsMCwxLDAsXG4gICAgICAgIDAsMCwwLDAsMVxuICAgIF07XG5cbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xufTtcblxuLyoqXG4gKiBDb2xvciByZXZlcnNhbCBmaWxtIGludHJvZHVjZWQgYnkgRWFzdG1hbiBLb2RhayBpbiAxOTM1LiAodGhhbmtzIERvbWluaWMgU3phYmxld3NraSlcbiAqXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUua29kYWNocm9tZSA9IGZ1bmN0aW9uKG11bHRpcGx5KVxue1xuICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgIDEuMTI4NTU4MjM5NjU5MzUyNSwtMC4zOTY3MzgyMjgzNjAxMzQ4LC0wLjAzOTkyNTU5MTcyOTIxNzkzLDAsNjMuNzI5NTg3NjIxOTY1MDIsXG4gICAgICAgIC0wLjE2NDA0MzM5OTYyMjQ0NjE2LDEuMDgzNTI1MTU2NjI5MTMwNCwtMC4wNTQ5ODgwNTExNTYzMzEzMiwwLDI0LjczMjQwNzg5NjcwNjIwMyxcbiAgICAgICAgLTAuMTY3ODYwMTA3MDYxNTU3NjMsLTAuNTYwMzQxNjI3NzY5NTI0OCwxLjYwMTQ4NTA3NjE5NjQ5NDMsMCwzNS42Mjk4MjgwNzQ2MDk0NixcbiAgICAgICAgMCwwLDAsMSwwLFxuICAgICAgICAwLDAsMCwwLDFcbiAgICBdO1xuXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbn07XG5cbi8qKlxuICogQnJvd24gZGVsaWNpb3VzIGJyb3duaSBmaWx0ZXIgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXG4gKlxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmJyb3duaSA9IGZ1bmN0aW9uKG11bHRpcGx5KVxue1xuICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgIDAuNTk5NzAyMzQ5ODE1OTcxNSwwLjM0NTUzMjQzMDQ4MzkxMjYzLC0wLjI3MDgyOTg2NzQ1MzgwNDIsMCw0Ny40MzE5Mjg1NTYwMDg3MyxcbiAgICAgICAgLTAuMDM3NzAzMjQ5ODM3NzgzMTU3LDAuODYwOTU3NzU4Nzk5MjY0MSwwLjE1MDU5NTUyMzg4NDU5OTEzLDAsLTM2Ljk2ODQxNDk4MzE5MTI3LFxuICAgICAgICAwLjI0MTEzNjM1MTI4MTUzMzM1LC0wLjA3NDQxMDM3OTA4NDIyNDkyLDAuNDQ5NzIxODIwNjQ4NzcxNTMsMCwtNy41NjIwNzUyNzc1OTEyODMsXG4gICAgICAgIDAsMCwwLDEsMCxcbiAgICAgICAgMCwwLDAsMCwxXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG4vKlxuICogVmludGFnZSBmaWx0ZXIgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXG4gKlxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLnZpbnRhZ2UgPSBmdW5jdGlvbihtdWx0aXBseSlcbntcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAwLjYyNzkzNDU2MzU2MDU5OTQsMC4zMjAyMTgzNDIwODE5MzY3LC0wLjAzOTY1NDA4MjExMzEyNDUzLDAsOS42NTEyODU4MzUyOTQxMjMsXG4gICAgICAgIDAuMDI1NzgzOTc3MDQ4MDg4NjgsMC42NDQxMTg4NjQ0Mzc0NzcxLDAuMDMyNTkxMjc2MTYxNDkyOTQsMCw3LjQ2MjgyOTE3NjQ3MDU5MSxcbiAgICAgICAgMC4wNDY2MDU1NTU2NzgyNzE5LC0wLjA4NTEyMzI5ODcyNDc4OTEsMC41MjQxNjQ4MDE4NzAwNDY1LDAsNS4xNTkxOTA1ODgyMzUyOTYsXG4gICAgICAgIDAsMCwwLDEsMCxcbiAgICAgICAgMCwwLDAsMCwxLFxuICAgIF07XG5cbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xufTtcblxuLypcbiAqIFdlIGRvbid0IGtub3cgZXhhY3RseSB3aGF0IGl0IGRvZXMsIGtpbmQgb2YgZ3JhZGllbnQgbWFwLCBidXQgZnVubnkgdG8gcGxheSB3aXRoIVxuICpcbiAqIEBwYXJhbSBkZXNhdHVyYXRpb24ge251bWJlcn1cbiAqIEBwYXJhbSB0b25lZCB7bnVtYmVyfVxuICogQHBhcmFtIGxpZ2h0Q29sb3Ige3N0cmluZ30gKGV4YW1wbGUgOiBcIjB4RkZFNTgwXCIpXG4gKiBAcGFyYW0gZGFya0NvbG9yIHtzdHJpbmd9ICAoZXhhbXBsZSA6IFwiMHhGRkU1ODBcIilcbiAqXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuY29sb3JUb25lID0gZnVuY3Rpb24oZGVzYXR1cmF0aW9uLCB0b25lZCwgbGlnaHRDb2xvciwgZGFya0NvbG9yLCBtdWx0aXBseSlcbntcbiAgICBkZXNhdHVyYXRpb24gPSBkZXNhdHVyYXRpb24gfHwgMC4yO1xuICAgIHRvbmVkID0gdG9uZWQgfHwgMC4xNTtcbiAgICBsaWdodENvbG9yID0gbGlnaHRDb2xvciB8fCAweEZGRTU4MDtcbiAgICBkYXJrQ29sb3IgPSBkYXJrQ29sb3IgfHwgMHgzMzgwMDA7XG5cbiAgICB2YXIgbFIgPSAoKGxpZ2h0Q29sb3IgPj4gMTYpICYgMHhGRikgLyAyNTU7XG4gICAgdmFyIGxHID0gKChsaWdodENvbG9yID4+IDgpICYgMHhGRikgLyAyNTU7XG4gICAgdmFyIGxCID0gKGxpZ2h0Q29sb3IgJiAweEZGKSAvIDI1NTtcblxuICAgIHZhciBkUiA9ICgoZGFya0NvbG9yID4+IDE2KSAmIDB4RkYpIC8gMjU1O1xuICAgIHZhciBkRyA9ICgoZGFya0NvbG9yID4+IDgpICYgMHhGRikgLyAyNTU7XG4gICAgdmFyIGRCID0gKGRhcmtDb2xvciAmIDB4RkYpIC8gMjU1O1xuXG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgMC4zLCAwLjU5LCAwLjExLCAwLCAwLFxuICAgICAgICBsUiwgbEcsIGxCLCBkZXNhdHVyYXRpb24sIDAsXG4gICAgICAgIGRSLCBkRywgZEIsIHRvbmVkLCAwLFxuICAgICAgICBsUi1kUiwgbEctZEcsIGxCLWRCLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAwLCAxXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG4vKlxuICogTmlnaHQgZWZmZWN0XG4gKlxuICogQHBhcmFtIGludGVuc2l0eSB7bnVtYmVyfVxuICogQHBhcmFtIG11bHRpcGx5IHtib29sZWFufSByZWZlciB0byAuX2xvYWRNYXRyaXgoKSBtZXRob2RcbiAqL1xuQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLm5pZ2h0ID0gZnVuY3Rpb24oaW50ZW5zaXR5LCBtdWx0aXBseSlcbntcbiAgICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkgfHwgMC4xO1xuICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgIGludGVuc2l0eSAqICggLTIuMCksIC1pbnRlbnNpdHksICAwLCAwLCAwLFxuICAgICAgICAtaW50ZW5zaXR5LCAwLCAgaW50ZW5zaXR5LCAwLCAwLFxuICAgICAgICAwLCBpbnRlbnNpdHksIGludGVuc2l0eSAqIDIuMCwgMCwgMCxcbiAgICAgICAgMCwwLDAsMSwwLFxuICAgICAgICAwLDAsMCwwLDFcbiAgICBdO1xuXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbn07XG5cblxuLypcbiAqIFByZWRhdG9yIGVmZmVjdFxuICpcbiAqIEVyYXNlIHRoZSBjdXJyZW50IG1hdHJpeCBieSBzZXR0aW5nIGEgbmV3IGluZGVwZW50IG9uZVxuICpcbiAqIEBwYXJhbSBhbW91bnQge251bWJlcn0gaG93IG11Y2ggdGhlIHByZWRhdG9yIGZlZWxzIGhpcyBmdXR1cmUgdmljdGltXG4gKiBAcGFyYW0gbXVsdGlwbHkge2Jvb2xlYW59IHJlZmVyIHRvIC5fbG9hZE1hdHJpeCgpIG1ldGhvZFxuICovXG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUucHJlZGF0b3IgPSBmdW5jdGlvbihhbW91bnQsIG11bHRpcGx5KVxue1xuICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgIDExLjIyNDEzMDYzMDQ5MzE2NCphbW91bnQsIC00Ljc5NDQ4Njk5OTUxMTcxOSphbW91bnQsIC0yLjg3NDYxMTg1NDU1MzIyMjcqYW1vdW50LCAwKmFtb3VudCwgMC40MDM0MjQzODIyMDk3Nzc4MyphbW91bnQsXG4gICAgICAgIC0zLjYzMzA2OTc1MzY0Njg1MDYqYW1vdW50LCA5LjE5MzE1NzE5NjA0NDkyMiphbW91bnQsIC0yLjk1MTgxMDgzNjc5MTk5MiphbW91bnQsIDAqYW1vdW50LCAtMS4zMTYxMzUwNDg4NjYyNzIqYW1vdW50LFxuICAgICAgICAtMy4yMTg0MTk3OTAyNjc5NDQzKmFtb3VudCwgLTQuMjM3NTAzMDUxNzU3ODEyNSphbW91bnQsIDcuNDc2NDQ4MDU5MDgyMDMxKmFtb3VudCwgMCphbW91bnQsIDAuODA0NDQ1OTIyMzc0NzI1MyphbW91bnQsXG4gICAgICAgIDAsIDAsIDAsIDEsIDAsXG4gICAgICAgIDAsIDAsIDAsIDAsIDBcbiAgICBdO1xuXG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbn07XG5cbi8qXG4gKiBMU0QgZWZmZWN0XG4gKlxuICogTXVsdGlwbHkgdGhlIGN1cnJlbnQgbWF0cml4XG4gKlxuICogQHBhcmFtIGFtb3VudCB7bnVtYmVyfSBIb3cgY3JhenkgaXMgeW91ciBlZmZlY3RcbiAqIEBwYXJhbSBtdWx0aXBseSB7Ym9vbGVhbn0gcmVmZXIgdG8gLl9sb2FkTWF0cml4KCkgbWV0aG9kXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5sc2QgPSBmdW5jdGlvbihtdWx0aXBseSlcbntcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAyLCAtMC40LCAwLjUsIDAsIDAsXG4gICAgICAgIC0wLjUsIDIsIC0wLjQsIDAsIDAsXG4gICAgICAgIC0wLjQsIC0wLjUsIDMsIDAsIDAsXG4gICAgICAgIDAsMCwwLDEsMCxcbiAgICAgICAgMCwwLDAsMCwxXG4gICAgXTtcblxuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG59O1xuXG4vKlxuICogUmVzZXQgZnVuY3Rpb25cbiAqXG4gKiBFcmFzZSB0aGUgY3VycmVudCBtYXRyaXggYnkgc2V0dGluZyB0aGUgZGVmYXVsdCBvbmVcbiAqXG4gKi9cbkNvbG9yTWF0cml4RmlsdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKClcbntcbiAgdmFyIG1hdHJpeCA9IFtcbiAgICAxLDAsMCwwLDAsXG4gICAgMCwxLDAsMCwwLFxuICAgIDAsMCwxLDAsMCxcbiAgICAwLDAsMCwxLDAsXG4gICAgMCwwLDAsMCwxXG4gIF07XG5cbiAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIGZhbHNlKTtcbn07XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWF0cml4IG9mIHRoZSBjb2xvciBtYXRyaXggZmlsdGVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgKiBAbWVtYmVyb2YgQ29sb3JNYXRyaXhGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdXG4gICAgICovXG4gICAgbWF0cml4OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMubS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBUaGlzIGxvd2VycyB0aGUgY29sb3IgZGVwdGggb2YgeW91ciBpbWFnZSBieSB0aGUgZ2l2ZW4gYW1vdW50LCBwcm9kdWNpbmcgYW4gaW1hZ2Ugd2l0aCBhIHNtYWxsZXIgcGFsZXR0ZS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIENvbG9yU3RlcEZpbHRlcigpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSBmbG9hdCBzdGVwO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuXFxuICAgIGNvbG9yID0gZmxvb3IoY29sb3IgKiBzdGVwKSAvIHN0ZXA7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIixcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0ZXA6IHsgdHlwZTogJzFmJywgdmFsdWU6IDUgfVxuICAgICAgICB9XG4gICAgKTtcbn1cblxuQ29sb3JTdGVwRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuQ29sb3JTdGVwRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbG9yU3RlcEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gQ29sb3JTdGVwRmlsdGVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb2xvclN0ZXBGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBzdGVwcyB0byByZWR1Y2UgdGhlIHBhbGV0dGUgYnkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIENvbG9yU3RlcEZpbHRlciNcbiAgICAgKi9cbiAgICBzdGVwOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc3RlcC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuc3RlcC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBUaGUgQ29udm9sdXRpb25GaWx0ZXIgY2xhc3MgYXBwbGllcyBhIG1hdHJpeCBjb252b2x1dGlvbiBmaWx0ZXIgZWZmZWN0LlxuICogQSBjb252b2x1dGlvbiBjb21iaW5lcyBwaXhlbHMgaW4gdGhlIGlucHV0IGltYWdlIHdpdGggbmVpZ2hib3JpbmcgcGl4ZWxzIHRvIHByb2R1Y2UgYSBuZXcgaW1hZ2UuXG4gKiBBIHdpZGUgdmFyaWV0eSBvZiBpbWFnZSBlZmZlY3RzIGNhbiBiZSBhY2hpZXZlZCB0aHJvdWdoIGNvbnZvbHV0aW9ucywgaW5jbHVkaW5nIGJsdXJyaW5nLCBlZGdlXG4gKiBkZXRlY3Rpb24sIHNoYXJwZW5pbmcsIGVtYm9zc2luZywgYW5kIGJldmVsaW5nLiBUaGUgbWF0cml4IHNob3VsZCBiZSBzcGVjaWZpZWQgYXMgYSA5IHBvaW50IEFycmF5LlxuICogU2VlIGh0dHA6Ly9kb2NzLmdpbXAub3JnL2VuL3BsdWctaW4tY29udm1hdHJpeC5odG1sIGZvciBtb3JlIGluZm8uXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICogQHBhcmFtIG1hdHJpeCB7bnVtYmVyW119IEFuIGFycmF5IG9mIHZhbHVlcyB1c2VkIGZvciBtYXRyaXggdHJhbnNmb3JtYXRpb24uIFNwZWNpZmllZCBhcyBhIDkgcG9pbnQgQXJyYXkuXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gV2lkdGggb2YgdGhlIG9iamVjdCB5b3UgYXJlIHRyYW5zZm9ybWluZ1xuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBIZWlnaHQgb2YgdGhlIG9iamVjdCB5b3UgYXJlIHRyYW5zZm9ybWluZ1xuICovXG5mdW5jdGlvbiBDb252b2x1dGlvbkZpbHRlcihtYXRyaXgsIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyBtZWRpdW1wIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xcbnVuaWZvcm0gZmxvYXQgbWF0cml4WzldO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICB2ZWM0IGMxMSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCAtIHRleGVsU2l6ZSk7IC8vIHRvcCBsZWZ0XFxuICAgdmVjNCBjMTIgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkgLSB0ZXhlbFNpemUueSkpOyAvLyB0b3AgY2VudGVyXFxuICAgdmVjNCBjMTMgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54ICsgdGV4ZWxTaXplLngsIHZUZXh0dXJlQ29vcmQueSAtIHRleGVsU2l6ZS55KSk7IC8vIHRvcCByaWdodFxcblxcbiAgIHZlYzQgYzIxID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCAtIHRleGVsU2l6ZS54LCB2VGV4dHVyZUNvb3JkLnkpKTsgLy8gbWlkIGxlZnRcXG4gICB2ZWM0IGMyMiA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7IC8vIG1pZCBjZW50ZXJcXG4gICB2ZWM0IGMyMyA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggKyB0ZXhlbFNpemUueCwgdlRleHR1cmVDb29yZC55KSk7IC8vIG1pZCByaWdodFxcblxcbiAgIHZlYzQgYzMxID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCAtIHRleGVsU2l6ZS54LCB2VGV4dHVyZUNvb3JkLnkgKyB0ZXhlbFNpemUueSkpOyAvLyBib3R0b20gbGVmdFxcbiAgIHZlYzQgYzMyID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgdlRleHR1cmVDb29yZC55ICsgdGV4ZWxTaXplLnkpKTsgLy8gYm90dG9tIGNlbnRlclxcbiAgIHZlYzQgYzMzID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICsgdGV4ZWxTaXplKTsgLy8gYm90dG9tIHJpZ2h0XFxuXFxuICAgZ2xfRnJhZ0NvbG9yID1cXG4gICAgICAgYzExICogbWF0cml4WzBdICsgYzEyICogbWF0cml4WzFdICsgYzEzICogbWF0cml4WzJdICtcXG4gICAgICAgYzIxICogbWF0cml4WzNdICsgYzIyICogbWF0cml4WzRdICsgYzIzICogbWF0cml4WzVdICtcXG4gICAgICAgYzMxICogbWF0cml4WzZdICsgYzMyICogbWF0cml4WzddICsgYzMzICogbWF0cml4WzhdO1xcblxcbiAgIGdsX0ZyYWdDb2xvci5hID0gYzIyLmE7XFxufVxcblwiLFxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgbWF0cml4OiAgICAgeyB0eXBlOiAnMWZ2JywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkobWF0cml4KSB9LFxuICAgICAgICAgICAgdGV4ZWxTaXplOiAgeyB0eXBlOiAnMnYnLCB2YWx1ZTogeyB4OiAxIC8gd2lkdGgsIHk6IDEgLyBoZWlnaHQgfSB9XG4gICAgICAgIH1cbiAgICApO1xufVxuXG5Db252b2x1dGlvbkZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbkNvbnZvbHV0aW9uRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnZvbHV0aW9uRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBDb252b2x1dGlvbkZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29udm9sdXRpb25GaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgdmFsdWVzIHVzZWQgZm9yIG1hdHJpeCB0cmFuc2Zvcm1hdGlvbi4gU3BlY2lmaWVkIGFzIGEgOSBwb2ludCBBcnJheS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAqIEBtZW1iZXJvZiBDb252b2x1dGlvbkZpbHRlciNcbiAgICAgKi9cbiAgICBtYXRyaXg6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXRyaXgudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLm1hdHJpeC52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHRoZSBvYmplY3QgeW91IGFyZSB0cmFuc2Zvcm1pbmdcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgQ29udm9sdXRpb25GaWx0ZXIjXG4gICAgICovXG4gICAgd2lkdGg6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gMS90aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS54O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUueCA9IDEvdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVpZ2h0IG9mIHRoZSBvYmplY3QgeW91IGFyZSB0cmFuc2Zvcm1pbmdcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgQ29udm9sdXRpb25GaWx0ZXIjXG4gICAgICovXG4gICAgaGVpZ2h0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIDEvdGhpcy51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUueTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnkgPSAxL3ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBBIENyb3NzIEhhdGNoIGVmZmVjdCBmaWx0ZXIuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBDcm9zc0hhdGNoRmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGZsb2F0IGx1bSA9IGxlbmd0aCh0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQueHkpLnJnYik7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgaWYgKGx1bSA8IDEuMDApXFxuICAgIHtcXG4gICAgICAgIGlmIChtb2QoZ2xfRnJhZ0Nvb3JkLnggKyBnbF9GcmFnQ29vcmQueSwgMTAuMCkgPT0gMC4wKVxcbiAgICAgICAge1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAobHVtIDwgMC43NSlcXG4gICAge1xcbiAgICAgICAgaWYgKG1vZChnbF9GcmFnQ29vcmQueCAtIGdsX0ZyYWdDb29yZC55LCAxMC4wKSA9PSAwLjApXFxuICAgICAgICB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChsdW0gPCAwLjUwKVxcbiAgICB7XFxuICAgICAgICBpZiAobW9kKGdsX0ZyYWdDb29yZC54ICsgZ2xfRnJhZ0Nvb3JkLnkgLSA1LjAsIDEwLjApID09IDAuMClcXG4gICAgICAgIHtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGx1bSA8IDAuMylcXG4gICAge1xcbiAgICAgICAgaWYgKG1vZChnbF9GcmFnQ29vcmQueCAtIGdsX0ZyYWdDb29yZC55IC0gNS4wLCAxMC4wKSA9PSAwLjApXFxuICAgICAgICB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcbiAgICAgICAgfVxcbiAgICB9XFxufVxcblwiXG4gICAgKTtcbn1cblxuQ3Jvc3NIYXRjaEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbkNyb3NzSGF0Y2hGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3Jvc3NIYXRjaEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gQ3Jvc3NIYXRjaEZpbHRlcjtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIFRoZSBEaXNwbGFjZW1lbnRGaWx0ZXIgY2xhc3MgdXNlcyB0aGUgcGl4ZWwgdmFsdWVzIGZyb20gdGhlIHNwZWNpZmllZCB0ZXh0dXJlIChjYWxsZWQgdGhlIGRpc3BsYWNlbWVudCBtYXApIHRvIHBlcmZvcm0gYSBkaXNwbGFjZW1lbnQgb2YgYW4gb2JqZWN0LlxuICogWW91IGNhbiB1c2UgdGhpcyBmaWx0ZXIgdG8gYXBwbHkgYWxsIG1hbm9yIG9mIGNyYXp5IHdhcnBpbmcgZWZmZWN0c1xuICogQ3VycmVudGx5IHRoZSByIHByb3BlcnR5IG9mIHRoZSB0ZXh0dXJlIGlzIHVzZWQgdG8gb2Zmc2V0IHRoZSB4IGFuZCB0aGUgZyBwcm9wZXJ0eSBvZiB0aGUgdGV4dHVyZSBpcyB1c2VkIHRvIG9mZnNldCB0aGUgeS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEFic3RyYWN0RmlsdGVyXG4gKiBAbmFtZXNwYWNlIFBJWElcbiAqIEBwYXJhbSB0ZXh0dXJlIHtUZXh0dXJlfSBUaGUgdGV4dHVyZSB1c2VkIGZvciB0aGUgZGlzcGxhY2VtZW50IG1hcCAqIG11c3QgYmUgcG93ZXIgb2YgMiB0ZXh0dXJlIGF0IHRoZSBtb21lbnRcbiAqL1xuZnVuY3Rpb24gRGlzcGxhY2VtZW50RmlsdGVyKHNwcml0ZSlcbntcbiAgICB2YXIgbWFza01hdHJpeCA9IG5ldyBjb3JlLm1hdGguTWF0cml4KCk7XG4gICAgc3ByaXRlLnJlbmRlcmFibGUgPSBmYWxzZTtcblxuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyBvdGhlck1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdk1hcENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbiAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbiAgIHZNYXBDb29yZCA9ICggb3RoZXJNYXRyaXggKiB2ZWMzKCBhVGV4dHVyZUNvb3JkLCAxLjApICApLnh5O1xcbiAgIHZDb2xvciA9IHZlYzQoYUNvbG9yLnJnYiAqIGFDb2xvci5hLCBhQ29sb3IuYSk7XFxufVxcblwiLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbG93cCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdk1hcENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudW5pZm9ybSB2ZWMyIHNjYWxlO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hcFNhbXBsZXI7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgIHZlYzQgb3JpZ2luYWwgPSAgdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG4gICB2ZWM0IG1hcCA9ICB0ZXh0dXJlMkQobWFwU2FtcGxlciwgdk1hcENvb3JkKTtcXG5cXG4gICBtYXAgLT0gMC41O1xcbiAgIG1hcC54eSAqPSBzY2FsZTtcXG5cXG4gICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54ICsgbWFwLngsIHZUZXh0dXJlQ29vcmQueSArIG1hcC55KSk7XFxufVxcblwiLFxuICAgICAgICAvLyB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBtYXBTYW1wbGVyOiAgICAgeyB0eXBlOiAnc2FtcGxlcjJEJywgdmFsdWU6IHNwcml0ZS50ZXh0dXJlIH0sXG4gICAgICAgICAgICBvdGhlck1hdHJpeDogICAgeyB0eXBlOiAnbWF0MycsIHZhbHVlOiBtYXNrTWF0cml4LnRvQXJyYXkodHJ1ZSkgfSxcbiAgICAgICAgICAgIHNjYWxlOiAgICAgICAgICB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDEsIHk6IDEgfSB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5tYXNrU3ByaXRlID0gc3ByaXRlO1xuICAgIHRoaXMubWFza01hdHJpeCA9IG1hc2tNYXRyaXg7XG5cblxuICAgIHRoaXMuc2NhbGUgPSBuZXcgY29yZS5tYXRoLlBvaW50KDIwLDIwKTtcblxufVxuXG5EaXNwbGFjZW1lbnRGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5EaXNwbGFjZW1lbnRGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlzcGxhY2VtZW50RmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBEaXNwbGFjZW1lbnRGaWx0ZXI7XG5cbkRpc3BsYWNlbWVudEZpbHRlci5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGlucHV0LCBvdXRwdXQpXG57XG4gICAgdmFyIGZpbHRlck1hbmFnZXIgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyO1xuXG4gICAgZmlsdGVyTWFuYWdlci5jYWxjdWxhdGVNYXBwZWRNYXRyaXgoaW5wdXQuZnJhbWUsIHRoaXMubWFza1Nwcml0ZSwgdGhpcy5tYXNrTWF0cml4KTtcblxuICAgIHRoaXMudW5pZm9ybXMub3RoZXJNYXRyaXgudmFsdWUgPSB0aGlzLm1hc2tNYXRyaXgudG9BcnJheSh0cnVlKTtcbiAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlLnggPSB0aGlzLnNjYWxlLnggKiAoMS9pbnB1dC5mcmFtZS53aWR0aCk7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZS55ID0gdGhpcy5zY2FsZS55ICogKDEvaW5wdXQuZnJhbWUuaGVpZ2h0KTtcblxuICAgIHZhciBzaGFkZXIgPSB0aGlzLmdldFNoYWRlcihyZW5kZXJlcik7XG4gICAgIC8vIGRyYXcgdGhlIGZpbHRlci4uLlxuICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIoc2hhZGVyLCBpbnB1dCwgb3V0cHV0KTtcbn07XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGlzcGxhY2VtZW50RmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIHVzZWQgZm9yIHRoZSBkaXNwbGFjZW1lbnQgbWFwLiBNdXN0IGJlIHBvd2VyIG9mIDIgc2l6ZWQgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1RleHR1cmV9XG4gICAgICogQG1lbWJlcm9mIERpc3BsYWNlbWVudEZpbHRlciNcbiAgICAgKi9cbiAgICBtYXA6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXBTYW1wbGVyLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXBTYW1wbGVyLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzIGh0dHA6Ly9tYXRncm92ZXMuY29tLyBARG9vcm1hdDIzXG4gKiBvcmlnaW5hbCBmaWx0ZXI6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9nbGZ4LmpzL2Jsb2IvbWFzdGVyL3NyYy9maWx0ZXJzL2Z1bi9kb3RzY3JlZW4uanNcbiAqL1xuXG4vKipcbiAqIFRoaXMgZmlsdGVyIGFwcGxpZXMgYSBkb3RzY3JlZW4gZWZmZWN0IG1ha2luZyBkaXNwbGF5IG9iamVjdHMgYXBwZWFyIHRvIGJlIG1hZGUgb3V0IG9mXG4gKiBibGFjayBhbmQgd2hpdGUgaGFsZnRvbmUgZG90cyBsaWtlIGFuIG9sZCBwcmludGVyLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gRG90U2NyZWVuRmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnVuaWZvcm0gdmVjNCBkaW1lbnNpb25zO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnVuaWZvcm0gZmxvYXQgYW5nbGU7XFxudW5pZm9ybSBmbG9hdCBzY2FsZTtcXG5cXG5mbG9hdCBwYXR0ZXJuKClcXG57XFxuICAgZmxvYXQgcyA9IHNpbihhbmdsZSksIGMgPSBjb3MoYW5nbGUpO1xcbiAgIHZlYzIgdGV4ID0gdlRleHR1cmVDb29yZCAqIGRpbWVuc2lvbnMueHk7XFxuICAgdmVjMiBwb2ludCA9IHZlYzIoXFxuICAgICAgIGMgKiB0ZXgueCAtIHMgKiB0ZXgueSxcXG4gICAgICAgcyAqIHRleC54ICsgYyAqIHRleC55XFxuICAgKSAqIHNjYWxlO1xcbiAgIHJldHVybiAoc2luKHBvaW50LngpICogc2luKHBvaW50LnkpKSAqIDQuMDtcXG59XFxuXFxudm9pZCBtYWluKClcXG57XFxuICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgZmxvYXQgYXZlcmFnZSA9IChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wO1xcbiAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVjMyhhdmVyYWdlICogMTAuMCAtIDUuMCArIHBhdHRlcm4oKSksIGNvbG9yLmEpO1xcbn1cXG5cIixcbiAgICAgICAgLy8gY3VzdG9tIHVuaWZvcm1zXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNjYWxlOiAgICAgIHsgdHlwZTogJzFmJywgdmFsdWU6IDEgfSxcbiAgICAgICAgICAgIGFuZ2xlOiAgICAgIHsgdHlwZTogJzFmJywgdmFsdWU6IDUgfSxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHsgdHlwZTogJzRmdicsIHZhbHVlOiBbMCwgMCwgMCwgMF0gfVxuICAgICAgICB9XG4gICAgKTtcbn1cblxuRG90U2NyZWVuRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuRG90U2NyZWVuRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERvdFNjcmVlbkZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gRG90U2NyZWVuRmlsdGVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhEb3RTY3JlZW5GaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHNjYWxlIG9mIHRoZSBlZmZlY3QuXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBEb3RTY3JlZW5GaWx0ZXIjXG4gICAgICovXG4gICAgc2NhbGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zY2FsZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmFkaXVzIG9mIHRoZSBlZmZlY3QuXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBEb3RTY3JlZW5GaWx0ZXIjXG4gICAgICovXG4gICAgYW5nbGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5hbmdsZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuYW5nbGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG5cbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBUaGUgQmx1cllUaW50RmlsdGVyIGFwcGxpZXMgYSB2ZXJ0aWNhbCBHYXVzc2lhbiBibHVyIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIEJsdXJZVGludEZpbHRlcigpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XFxuXFxudW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcXG51bmlmb3JtIHZlYzIgb2Zmc2V0O1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWzZdO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMygoYVZlcnRleFBvc2l0aW9uK29mZnNldCksIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcblxcbiAgICB2Qmx1clRleENvb3Jkc1sgMF0gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigwLjAsIC0wLjAxMiAqIHN0cmVuZ3RoKTtcXG4gICAgdkJsdXJUZXhDb29yZHNbIDFdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAtMC4wMDggKiBzdHJlbmd0aCk7XFxuICAgIHZCbHVyVGV4Q29vcmRzWyAyXSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgLTAuMDA0ICogc3RyZW5ndGgpO1xcbiAgICB2Qmx1clRleENvb3Jkc1sgM10gPSBhVGV4dHVyZUNvb3JkICsgdmVjMigwLjAsICAwLjAwNCAqIHN0cmVuZ3RoKTtcXG4gICAgdkJsdXJUZXhDb29yZHNbIDRdID0gYVRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAgMC4wMDggKiBzdHJlbmd0aCk7XFxuICAgIHZCbHVyVGV4Q29vcmRzWyA1XSA9IGFUZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgIDAuMDEyICogc3RyZW5ndGgpO1xcblxcbiAgIHZDb2xvciA9IHZlYzQoYUNvbG9yLnJnYiAqIGFDb2xvci5hLCBhQ29sb3IuYSk7XFxufVxcblwiLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbG93cCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbNl07XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG51bmlmb3JtIHZlYzMgY29sb3I7XFxudW5pZm9ybSBmbG9hdCBhbHBoYTtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzQgc3VtID0gdmVjNCgwLjApO1xcblxcbiAgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMF0pKjAuMDA0NDMxODQ4NDExOTM4MzQxO1xcbiAgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1sgMV0pKjAuMDUzOTkwOTY2NTEzMTg5ODU7XFxuICAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyAyXSkqMC4yNDE5NzA3MjQ1MTkxNDU0O1xcbiAgICBzdW0gKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICAgICApKjAuMzk4OTQyMjgwNDAxNDMyNztcXG4gICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDNdKSowLjI0MTk3MDcyNDUxOTE0NTQ7XFxuICAgIHN1bSArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyA0XSkqMC4wNTM5OTA5NjY1MTMxODk4NTtcXG4gICAgc3VtICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbIDVdKSowLjAwNDQzMTg0ODQxMTkzODM0MTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IucmdiICogc3VtLmEgKiBhbHBoYSwgc3VtLmEgKiBhbHBoYSApO1xcbn1cXG5cIixcbiAgICAgICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBibHVyOiB7IHR5cGU6ICcxZicsIHZhbHVlOiAxIC8gNTEyIH0sXG4gICAgICAgICAgICBjb2xvcjogeyB0eXBlOiAnYycsIHZhbHVlOiBbMCwwLDBdfSxcbiAgICAgICAgICAgIGFscGhhOiB7IHR5cGU6ICcxZicsIHZhbHVlOiAwLjcgfSxcbiAgICAgICAgICAgIG9mZnNldDogeyB0eXBlOiAnMmYnLCB2YWx1ZTpbNSwgNV19LFxuICAgICAgICAgICAgc3RyZW5ndGg6IHsgdHlwZTogJzFmJywgdmFsdWU6MX1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLnBhc3NlcyA9IDE7XG4gICAgdGhpcy5zdHJlbmd0aCA9IDQ7XG59XG5cbkJsdXJZVGludEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbkJsdXJZVGludEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbHVyWVRpbnRGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IEJsdXJZVGludEZpbHRlcjtcblxuQmx1cllUaW50RmlsdGVyLnByb3RvdHlwZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpXG57XG4gICAgdmFyIHNoYWRlciA9IHRoaXMuZ2V0U2hhZGVyKHJlbmRlcmVyKTtcblxuICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGgudmFsdWUgPSB0aGlzLnN0cmVuZ3RoIC8gNCAvIHRoaXMucGFzc2VzICogKGlucHV0LmZyYW1lLmhlaWdodCAvIGlucHV0LnNpemUuaGVpZ2h0KTtcblxuICAgIGlmKHRoaXMucGFzc2VzID09PSAxKVxuICAgIHtcbiAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcihzaGFkZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuZ2V0UmVuZGVyVGFyZ2V0KHRydWUpO1xuICAgICAgICB2YXIgZmxpcCA9IGlucHV0O1xuICAgICAgICB2YXIgZmxvcCA9IHJlbmRlclRhcmdldDtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXNzZXMtMTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHNoYWRlciwgZmxpcCwgZmxvcCwgY2xlYXIpO1xuXG4gICAgICAgICAgIHZhciB0ZW1wID0gZmxvcDtcbiAgICAgICAgICAgZmxvcCA9IGZsaXA7XG4gICAgICAgICAgIGZsaXAgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcihzaGFkZXIsIGZsaXAsIG91dHB1dCwgY2xlYXIpO1xuXG4gICAgICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIucmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgfVxufTtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCbHVyWVRpbnRGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1ci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgQmx1cllGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGJsdXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gIHRoaXMuc3RyZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmcgPSB2YWx1ZSAqIDAuNTtcbiAgICAgICAgICAgIHRoaXMuc3RyZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG59KTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpLFxuICAgIEJsdXJYRmlsdGVyID0gcmVxdWlyZSgnLi4vYmx1ci9CbHVyWEZpbHRlcicpLFxuICAgIEJsdXJZVGludEZpbHRlciA9IHJlcXVpcmUoJy4vQmx1cllUaW50RmlsdGVyJyk7XG5cbi8qKlxuICogVGhlIERyb3BTaGFkb3dGaWx0ZXIgYXBwbGllcyBhIEdhdXNzaWFuIGJsdXIgdG8gYW4gb2JqZWN0LlxuICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyIGNhbiBiZSBzZXQgZm9yIHgtIGFuZCB5LWF4aXMgc2VwYXJhdGVseS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIERyb3BTaGFkb3dGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuYmx1clhGaWx0ZXIgPSBuZXcgQmx1clhGaWx0ZXIoKTtcbiAgICB0aGlzLmJsdXJZVGludEZpbHRlciA9IG5ldyBCbHVyWVRpbnRGaWx0ZXIoKTtcblxuICAgIHRoaXMuZGVmYXVsdEZpbHRlciA9IG5ldyBjb3JlLkFic3RyYWN0RmlsdGVyKCk7XG5cbiAgICB0aGlzLnBhZGRpbmcgPSAzMDtcblxuICAgIHRoaXMuX2RpcnR5UG9zaXRpb24gPSB0cnVlO1xuICAgIHRoaXMuX2FuZ2xlID0gNDUgKiBNYXRoLlBJIC8gMTgwO1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gMTA7XG4gICAgdGhpcy5hbHBoYSA9IDAuNzU7XG4gICAgdGhpcy5oaWRlT2JqZWN0ID0gZmFsc2U7XG4gICAgdGhpcy5ibGVuZE1vZGUgPSBjb3JlLkJMRU5EX01PREVTLk1VTFRJUExZO1xufVxuXG5Ecm9wU2hhZG93RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuRHJvcFNoYWRvd0ZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcm9wU2hhZG93RmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBEcm9wU2hhZG93RmlsdGVyO1xuXG5Ecm9wU2hhZG93RmlsdGVyLnByb3RvdHlwZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgaW5wdXQsIG91dHB1dClcbntcbiAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5nZXRSZW5kZXJUYXJnZXQodHJ1ZSk7XG5cbiAgICAvL1RPRE8gLSBjb3B5VGV4U3ViSW1hZ2UyRCBjb3VsZCBiZSB1c2VkIGhlcmU/XG4gICAgaWYodGhpcy5fZGlydHlQb3NpdGlvbilcbiAgICB7XG4gICAgICAgIHRoaXMuX2RpcnR5UG9zaXRpb24gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmJsdXJZVGludEZpbHRlci51bmlmb3Jtcy5vZmZzZXQudmFsdWVbMF0gPSBNYXRoLnNpbih0aGlzLl9hbmdsZSkgKiB0aGlzLl9kaXN0YW5jZTtcbiAgICAgICAgdGhpcy5ibHVyWVRpbnRGaWx0ZXIudW5pZm9ybXMub2Zmc2V0LnZhbHVlWzFdID0gTWF0aC5jb3ModGhpcy5fYW5nbGUpICogdGhpcy5fZGlzdGFuY2U7XG4gICAgfVxuXG4gICAgdGhpcy5ibHVyWEZpbHRlci5hcHBseUZpbHRlcihyZW5kZXJlciwgaW5wdXQsIHJlbmRlclRhcmdldCk7XG5cbiAgICByZW5kZXJlci5ibGVuZE1vZGVNYW5hZ2VyLnNldEJsZW5kTW9kZSh0aGlzLmJsZW5kTW9kZSk7XG5cbiAgICB0aGlzLmJsdXJZVGludEZpbHRlci5hcHBseUZpbHRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQpO1xuXG4gICAgcmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUoY29yZS5CTEVORF9NT0RFUy5OT1JNQUwpO1xuXG4gICAgaWYoIXRoaXMuaGlkZU9iamVjdClcbiAgICB7XG5cbiAgICAgICAgdGhpcy5kZWZhdWx0RmlsdGVyLmFwcGx5RmlsdGVyKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0KTtcbiAgICB9XG5cblxuICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIucmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhEcm9wU2hhZG93RmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXJYIGFuZCBibHVyWSBwcm9wZXJ0aWVzIHNpbXVsdGFuZW91c2x5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIERyb3BTaGFkb3dGaWx0ZXIjXG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGJsdXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5ibHVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdGhpcy5ibHVyWVRpbnRGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWCBwcm9wZXJ0eVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBEcm9wU2hhZG93RmlsdGVyI1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICBibHVyWDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clkgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRHJvcFNoYWRvd0ZpbHRlciNcbiAgICAgKiBAZGVmYXVsdCAyXG4gICAgICovXG4gICAgYmx1clk6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibHVyWVRpbnRGaWx0ZXIuYmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmx1cllUaW50RmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2xvcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAgY29yZS51dGlscy5yZ2IyaGV4KCB0aGlzLmJsdXJZVGludEZpbHRlci51bmlmb3Jtcy5jb2xvci52YWx1ZSApO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5ibHVyWVRpbnRGaWx0ZXIudW5pZm9ybXMuY29sb3IudmFsdWUgPSBjb3JlLnV0aWxzLmhleDJyZ2IodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFscGhhOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICB0aGlzLmJsdXJZVGludEZpbHRlci51bmlmb3Jtcy5hbHBoYS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYmx1cllUaW50RmlsdGVyLnVuaWZvcm1zLmFscGhhLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzdGFuY2U6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gIHRoaXMuX2Rpc3RhbmNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZGlydHlQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFuZ2xlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICB0aGlzLl9hbmdsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5UG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fYW5nbGUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8qKlxuICogVGhpcyBncmV5c2NhbGVzIHRoZSBwYWxldHRlIG9mIHlvdXIgRGlzcGxheSBPYmplY3RzLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gR3JheUZpbHRlcigpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IGdyYXk7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peChnbF9GcmFnQ29sb3IucmdiLCB2ZWMzKDAuMjEyNipnbF9GcmFnQ29sb3IuciArIDAuNzE1MipnbF9GcmFnQ29sb3IuZyArIDAuMDcyMipnbF9GcmFnQ29sb3IuYiksIGdyYXkpO1xcbn1cXG5cIixcbiAgICAgICAgLy8gc2V0IHRoZSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBncmF5OiB7IHR5cGU6ICcxZicsIHZhbHVlOiAxIH1cbiAgICAgICAgfVxuICAgICk7XG59XG5cbkdyYXlGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5HcmF5RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyYXlGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IEdyYXlGaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEdyYXlGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBncmF5LiAxIHdpbGwgbWFrZSB0aGUgb2JqZWN0IGJsYWNrIGFuZCB3aGl0ZSwgMCB3aWxsIG1ha2UgdGhlIG9iamVjdCBpdHMgbm9ybWFsIGNvbG9yLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBHcmF5RmlsdGVyI1xuICAgICAqL1xuICAgIGdyYXk6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5ncmF5LnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5ncmF5LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIi8qKlxuICogQGZpbGUgICAgICAgIE1haW4gZXhwb3J0IG9mIHRoZSBQSVhJIGZpbHRlcnMgbGlicmFyeVxuICogQGF1dGhvciAgICAgIE1hdCBHcm92ZXMgPG1hdEBnb29kYm95ZGlnaXRhbC5jb20+XG4gKiBAY29weXJpZ2h0ICAgMjAxMy0yMDE1IEdvb2RCb3lEaWdpdGFsXG4gKiBAbGljZW5zZSAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29kQm95RGlnaXRhbC9waXhpLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0V8TUlUIExpY2Vuc2V9XG4gKi9cblxuLyoqXG4gKiBAbmFtZXNwYWNlIFBJWEkuZmlsdGVyc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvLyBleHBvc2Ugc29tZSBpbnRlcm5hbCBmaWx0ZXJzLi4uXG4gICAgQWJzdHJhY3RGaWx0ZXI6ICAgICByZXF1aXJlKCcuLi9jb3JlL3JlbmRlcmVycy93ZWJnbC9maWx0ZXJzL0Fic3RyYWN0RmlsdGVyJyksXG4gICAgRlhBQUZpbHRlcjogICAgICAgICByZXF1aXJlKCcuLi9jb3JlL3JlbmRlcmVycy93ZWJnbC9maWx0ZXJzL0ZYQUFGaWx0ZXInKSxcbiAgICBTcHJpdGVNYXNrRmlsdGVyOiAgIHJlcXVpcmUoJy4uL2NvcmUvcmVuZGVyZXJzL3dlYmdsL2ZpbHRlcnMvU3ByaXRlTWFza0ZpbHRlcicpLFxuICAgIC8vIGFkZCB0aGUgcmVzdCFcbiAgICBBc2NpaUZpbHRlcjogICAgICAgIHJlcXVpcmUoJy4vYXNjaWkvQXNjaWlGaWx0ZXInKSxcbiAgICBCbG9vbUZpbHRlcjogICAgICAgIHJlcXVpcmUoJy4vYmxvb20vQmxvb21GaWx0ZXInKSxcbiAgICBCbHVyRmlsdGVyOiAgICAgICAgIHJlcXVpcmUoJy4vYmx1ci9CbHVyRmlsdGVyJyksXG4gICAgQmx1clhGaWx0ZXI6ICAgICAgICByZXF1aXJlKCcuL2JsdXIvQmx1clhGaWx0ZXInKSxcbiAgICBCbHVyWUZpbHRlcjogICAgICAgIHJlcXVpcmUoJy4vYmx1ci9CbHVyWUZpbHRlcicpLFxuICAgIENvbG9yTWF0cml4RmlsdGVyOiAgcmVxdWlyZSgnLi9jb2xvci9Db2xvck1hdHJpeEZpbHRlcicpLFxuICAgIENvbG9yU3RlcEZpbHRlcjogICAgcmVxdWlyZSgnLi9jb2xvci9Db2xvclN0ZXBGaWx0ZXInKSxcbiAgICBDb252b2x1dGlvbkZpbHRlcjogIHJlcXVpcmUoJy4vY29udm9sdXRpb24vQ29udm9sdXRpb25GaWx0ZXInKSxcbiAgICBDcm9zc0hhdGNoRmlsdGVyOiAgIHJlcXVpcmUoJy4vY3Jvc3NoYXRjaC9Dcm9zc0hhdGNoRmlsdGVyJyksXG4gICAgRGlzcGxhY2VtZW50RmlsdGVyOiByZXF1aXJlKCcuL2Rpc3BsYWNlbWVudC9EaXNwbGFjZW1lbnRGaWx0ZXInKSxcbiAgICBEb3RTY3JlZW5GaWx0ZXI6ICAgIHJlcXVpcmUoJy4vZG90L0RvdFNjcmVlbkZpbHRlcicpLFxuICAgIEdyYXlGaWx0ZXI6ICAgICAgICAgcmVxdWlyZSgnLi9ncmF5L0dyYXlGaWx0ZXInKSxcbiAgICBEcm9wU2hhZG93RmlsdGVyOiAgIHJlcXVpcmUoJy4vZHJvcHNoYWRvdy9Ecm9wU2hhZG93RmlsdGVyJyksXG4gICAgSW52ZXJ0RmlsdGVyOiAgICAgICByZXF1aXJlKCcuL2ludmVydC9JbnZlcnRGaWx0ZXInKSxcbiAgICBOb2lzZUZpbHRlcjogICAgICAgIHJlcXVpcmUoJy4vbm9pc2UvTm9pc2VGaWx0ZXInKSxcbiAgICBOb3JtYWxNYXBGaWx0ZXI6ICAgIHJlcXVpcmUoJy4vbm9ybWFsL05vcm1hbE1hcEZpbHRlcicpLFxuICAgIFBpeGVsYXRlRmlsdGVyOiAgICAgcmVxdWlyZSgnLi9waXhlbGF0ZS9QaXhlbGF0ZUZpbHRlcicpLFxuICAgIFJHQlNwbGl0RmlsdGVyOiAgICAgcmVxdWlyZSgnLi9yZ2IvUkdCU3BsaXRGaWx0ZXInKSxcbiAgICBTaG9ja3dhdmVGaWx0ZXI6ICAgIHJlcXVpcmUoJy4vc2hvY2t3YXZlL1Nob2Nrd2F2ZUZpbHRlcicpLFxuICAgIFNlcGlhRmlsdGVyOiAgICAgICAgcmVxdWlyZSgnLi9zZXBpYS9TZXBpYUZpbHRlcicpLFxuICAgIFNtYXJ0Qmx1ckZpbHRlcjogICAgcmVxdWlyZSgnLi9ibHVyL1NtYXJ0Qmx1ckZpbHRlcicpLFxuICAgIFRpbHRTaGlmdEZpbHRlcjogICAgcmVxdWlyZSgnLi90aWx0c2hpZnQvVGlsdFNoaWZ0RmlsdGVyJyksXG4gICAgVGlsdFNoaWZ0WEZpbHRlcjogICByZXF1aXJlKCcuL3RpbHRzaGlmdC9UaWx0U2hpZnRYRmlsdGVyJyksXG4gICAgVGlsdFNoaWZ0WUZpbHRlcjogICByZXF1aXJlKCcuL3RpbHRzaGlmdC9UaWx0U2hpZnRZRmlsdGVyJyksXG4gICAgVHdpc3RGaWx0ZXI6ICAgICAgICByZXF1aXJlKCcuL3R3aXN0L1R3aXN0RmlsdGVyJylcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBUaGlzIGludmVydHMgeW91ciBEaXNwbGF5IE9iamVjdHMgY29sb3JzLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gSW52ZXJ0RmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIGZsb2F0IGludmVydDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoICh2ZWMzKDEpLWdsX0ZyYWdDb2xvci5yZ2IpICogZ2xfRnJhZ0NvbG9yLmEsIGdsX0ZyYWdDb2xvci5yZ2IsIDEuMCAtIGludmVydCk7XFxufVxcblwiLFxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgaW52ZXJ0OiB7IHR5cGU6ICcxZicsIHZhbHVlOiAxIH1cbiAgICAgICAgfVxuICAgICk7XG59XG5cbkludmVydEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcbkludmVydEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnZlcnRGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IEludmVydEZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSW52ZXJ0RmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgaW52ZXJ0LiBgMWAgd2lsbCBmdWxseSBpbnZlcnQgdGhlIGNvbG9ycywgYW5kXG4gICAgICogYDBgIHdpbGwgbWFrZSB0aGUgb2JqZWN0IGl0cyBub3JtYWwgY29sb3IuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIEludmVydEZpbHRlciNcbiAgICAgKi9cbiAgICBpbnZlcnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5pbnZlcnQudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmludmVydC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBAYXV0aG9yIFZpY28gQHZpY29jb3RlYVxuICogb3JpZ2luYWwgZmlsdGVyOiBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcy9ibG9iL21hc3Rlci9zcmMvZmlsdGVycy9hZGp1c3Qvbm9pc2UuanNcbiAqL1xuXG4vKipcbiAqIEEgTm9pc2UgZWZmZWN0IGZpbHRlci5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIE5vaXNlRmlsdGVyKClcbntcbiAgICBjb3JlLkFic3RyYWN0RmlsdGVyLmNhbGwodGhpcyxcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnVuaWZvcm0gZmxvYXQgbm9pc2U7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxuZmxvYXQgcmFuZCh2ZWMyIGNvKVxcbntcXG4gICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoY28ueHksIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1Myk7XFxufVxcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgZmxvYXQgZGlmZiA9IChyYW5kKHZUZXh0dXJlQ29vcmQpIC0gMC41KSAqIG5vaXNlO1xcblxcbiAgICBjb2xvci5yICs9IGRpZmY7XFxuICAgIGNvbG9yLmcgKz0gZGlmZjtcXG4gICAgY29sb3IuYiArPSBkaWZmO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCIsXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBub2lzZTogeyB0eXBlOiAnMWYnLCB2YWx1ZTogMC41IH1cbiAgICAgICAgfVxuICAgICk7XG59XG5cbk5vaXNlRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuTm9pc2VGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm9pc2VGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IE5vaXNlRmlsdGVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhOb2lzZUZpbHRlci5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYW1vdW50IG9mIG5vaXNlIHRvIGFwcGx5LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBOb2lzZUZpbHRlciNcbiAgICAgKiBAZGVmYXVsdCAwLjVcbiAgICAgKi9cbiAgICBub2lzZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm5vaXNlLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5ub2lzZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2JyZnMvaXNzdWVzLzI1XG5cblxuLyoqXG4gKiBUaGUgTm9ybWFsTWFwRmlsdGVyIGNsYXNzIHVzZXMgdGhlIHBpeGVsIHZhbHVlcyBmcm9tIHRoZSBzcGVjaWZpZWQgdGV4dHVyZSAoY2FsbGVkIHRoZSBub3JtYWwgbWFwKVxuICogdG8gcHJvamVjdCBsaWdodGluZyBvbnRvIGFuIG9iamVjdC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEFic3RyYWN0RmlsdGVyXG4gKiBAbWVtYmVyb2YgUElYSS5maWx0ZXJzXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gVGhlIHRleHR1cmUgdXNlZCBmb3IgdGhlIG5vcm1hbCBtYXAsIG11c3QgYmUgcG93ZXIgb2YgMiB0ZXh0dXJlIGF0IHRoZSBtb21lbnRcbiAqL1xuZnVuY3Rpb24gTm9ybWFsTWFwRmlsdGVyKHRleHR1cmUpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyBmbG9hdCB2Q29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgZGlzcGxhY2VtZW50TWFwO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnVuaWZvcm0gdmVjNCBkaW1lbnNpb25zO1xcblxcbmNvbnN0IHZlYzIgUmVzb2x1dGlvbiA9IHZlYzIoMS4wLDEuMCk7ICAgICAgLy9yZXNvbHV0aW9uIG9mIHNjcmVlblxcbnVuaWZvcm0gdmVjMyBMaWdodFBvczsgICAgLy9saWdodCBwb3NpdGlvbiwgbm9ybWFsaXplZFxcbmNvbnN0IHZlYzQgTGlnaHRDb2xvciA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTsgICAgICAvL2xpZ2h0IFJHQkEgLS0gYWxwaGEgaXMgaW50ZW5zaXR5XFxuY29uc3QgdmVjNCBBbWJpZW50Q29sb3IgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDAuNSk7ICAgIC8vYW1iaWVudCBSR0JBIC0tIGFscGhhIGlzIGludGVuc2l0eVxcbmNvbnN0IHZlYzMgRmFsbG9mZiA9IHZlYzMoMC4wLCAxLjAsIDAuMik7ICAgICAgICAgLy9hdHRlbnVhdGlvbiBjb2VmZmljaWVudHNcXG5cXG51bmlmb3JtIHZlYzMgTGlnaHREaXI7IC8vID0gdmVjMygxLjAsIDAuMCwgMS4wKTtcXG5cXG51bmlmb3JtIHZlYzIgbWFwRGltZW5zaW9uczsgLy8gPSB2ZWMyKDI1Ni4wLCAyNTYuMCk7XFxuXFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWMyIG1hcENvcmRzID0gdlRleHR1cmVDb29yZC54eTtcXG5cXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZC5zdCk7XFxuICAgIHZlYzMgbkNvbG9yID0gdGV4dHVyZTJEKGRpc3BsYWNlbWVudE1hcCwgdlRleHR1cmVDb29yZC5zdCkucmdiO1xcblxcblxcbiAgICBtYXBDb3JkcyAqPSB2ZWMyKGRpbWVuc2lvbnMueC81MTIuMCwgZGltZW5zaW9ucy55LzUxMi4wKTtcXG5cXG4gICAgbWFwQ29yZHMueSAqPSAtMS4wO1xcbiAgICBtYXBDb3Jkcy55ICs9IDEuMDtcXG5cXG4gICAgLy8gUkdCQSBvZiBvdXIgZGlmZnVzZSBjb2xvclxcbiAgICB2ZWM0IERpZmZ1c2VDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuXFxuICAgIC8vIFJHQiBvZiBvdXIgbm9ybWFsIG1hcFxcbiAgICB2ZWMzIE5vcm1hbE1hcCA9IHRleHR1cmUyRChkaXNwbGFjZW1lbnRNYXAsIG1hcENvcmRzKS5yZ2I7XFxuXFxuICAgIC8vIFRoZSBkZWx0YSBwb3NpdGlvbiBvZiBsaWdodFxcbiAgICAvLyB2ZWMzIExpZ2h0RGlyID0gdmVjMyhMaWdodFBvcy54eSAtIChnbF9GcmFnQ29vcmQueHkgLyBSZXNvbHV0aW9uLnh5KSwgTGlnaHRQb3Mueik7XFxuICAgIHZlYzMgTGlnaHREaXIgPSB2ZWMzKExpZ2h0UG9zLnh5IC0gKG1hcENvcmRzLnh5KSwgTGlnaHRQb3Mueik7XFxuXFxuICAgIC8vIENvcnJlY3QgZm9yIGFzcGVjdCByYXRpb1xcbiAgICAvLyBMaWdodERpci54ICo9IFJlc29sdXRpb24ueCAvIFJlc29sdXRpb24ueTtcXG5cXG4gICAgLy8gRGV0ZXJtaW5lIGRpc3RhbmNlICh1c2VkIGZvciBhdHRlbnVhdGlvbikgQkVGT1JFIHdlIG5vcm1hbGl6ZSBvdXIgTGlnaHREaXJcXG4gICAgZmxvYXQgRCA9IGxlbmd0aChMaWdodERpcik7XFxuXFxuICAgIC8vIG5vcm1hbGl6ZSBvdXIgdmVjdG9yc1xcbiAgICB2ZWMzIE4gPSBub3JtYWxpemUoTm9ybWFsTWFwICogMi4wIC0gMS4wKTtcXG4gICAgdmVjMyBMID0gbm9ybWFsaXplKExpZ2h0RGlyKTtcXG5cXG4gICAgLy8gUHJlLW11bHRpcGx5IGxpZ2h0IGNvbG9yIHdpdGggaW50ZW5zaXR5XFxuICAgIC8vIFRoZW4gcGVyZm9ybSAnTiBkb3QgTCcgdG8gZGV0ZXJtaW5lIG91ciBkaWZmdXNlIHRlcm1cXG4gICAgdmVjMyBEaWZmdXNlID0gKExpZ2h0Q29sb3IucmdiICogTGlnaHRDb2xvci5hKSAqIG1heChkb3QoTiwgTCksIDAuMCk7XFxuXFxuICAgIC8vIHByZS1tdWx0aXBseSBhbWJpZW50IGNvbG9yIHdpdGggaW50ZW5zaXR5XFxuICAgIHZlYzMgQW1iaWVudCA9IEFtYmllbnRDb2xvci5yZ2IgKiBBbWJpZW50Q29sb3IuYTtcXG5cXG4gICAgLy8gY2FsY3VsYXRlIGF0dGVudWF0aW9uXFxuICAgIGZsb2F0IEF0dGVudWF0aW9uID0gMS4wIC8gKCBGYWxsb2ZmLnggKyAoRmFsbG9mZi55KkQpICsgKEZhbGxvZmYueipEKkQpICk7XFxuXFxuICAgIC8vIHRoZSBjYWxjdWxhdGlvbiB3aGljaCBicmluZ3MgaXQgYWxsIHRvZ2V0aGVyXFxuICAgIHZlYzMgSW50ZW5zaXR5ID0gQW1iaWVudCArIERpZmZ1c2UgKiBBdHRlbnVhdGlvbjtcXG4gICAgdmVjMyBGaW5hbENvbG9yID0gRGlmZnVzZUNvbG9yLnJnYiAqIEludGVuc2l0eTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yICogdmVjNChGaW5hbENvbG9yLCBEaWZmdXNlQ29sb3IuYSk7XFxuXFxuICAgIC8vIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgQXR0ZW51YXRpb24pOyAvLyB2Q29sb3IgKiB2ZWM0KEZpbmFsQ29sb3IsIERpZmZ1c2VDb2xvci5hKTtcXG5cXG4vKlxcbiAgICAvLyBub3JtYWxpc2UgY29sb3JcXG4gICAgdmVjMyBub3JtYWwgPSBub3JtYWxpemUobkNvbG9yICogMi4wIC0gMS4wKTtcXG5cXG4gICAgdmVjMyBkZWx0YVBvcyA9IHZlYzMoIChsaWdodC54eSAtIGdsX0ZyYWdDb29yZC54eSkgLyByZXNvbHV0aW9uLnh5LCBsaWdodC56ICk7XFxuXFxuICAgIGZsb2F0IGxhbWJlcnQgPSBjbGFtcChkb3Qobm9ybWFsLCBsaWdodERpciksIDAuMCwgMS4wKTtcXG5cXG4gICAgZmxvYXQgZCA9IHNxcnQoZG90KGRlbHRhUG9zLCBkZWx0YVBvcykpO1xcbiAgICBmbG9hdCBhdHQgPSAxLjAgLyAoIGF0dGVudWF0aW9uLnggKyAoYXR0ZW51YXRpb24ueSpkKSArIChhdHRlbnVhdGlvbi56KmQqZCkgKTtcXG5cXG4gICAgdmVjMyByZXN1bHQgPSAoYW1iaWVudENvbG9yICogYW1iaWVudEludGVuc2l0eSkgKyAobGlnaHRDb2xvci5yZ2IgKiBsYW1iZXJ0KSAqIGF0dDtcXG4gICAgcmVzdWx0ICo9IGNvbG9yLnJnYjtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChyZXN1bHQsIDEuMCk7XFxuKi9cXG59XFxuXCIsXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRNYXA6ICB7IHR5cGU6ICdzYW1wbGVyMkQnLCB2YWx1ZTogdGV4dHVyZSB9LFxuICAgICAgICAgICAgc2NhbGU6ICAgICAgICAgICAgeyB0eXBlOiAnMmYnLCB2YWx1ZTogeyB4OiAxNSwgeTogMTUgfSB9LFxuICAgICAgICAgICAgb2Zmc2V0OiAgICAgICAgICAgeyB0eXBlOiAnMmYnLCB2YWx1ZTogeyB4OiAwLCAgeTogMCB9IH0sXG4gICAgICAgICAgICBtYXBEaW1lbnNpb25zOiAgICB7IHR5cGU6ICcyZicsIHZhbHVlOiB7IHg6IDEsICB5OiAxIH0gfSxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6ICAgICAgIHsgdHlwZTogJzRmJywgdmFsdWU6IFswLCAwLCAwLCAwXSB9LFxuICAgICAgICAgICAgLy8gTGlnaHREaXI6ICAgICAgICAgeyB0eXBlOiAnZjMnLCB2YWx1ZTogWzAsIDEsIDBdIH0sXG4gICAgICAgICAgICBMaWdodFBvczogICAgICAgICB7IHR5cGU6ICczZicsIHZhbHVlOiBbMCwgMSwgMF0gfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHRleHR1cmUuYmFzZVRleHR1cmUuX3Bvd2VyT2YyID0gdHJ1ZTtcblxuICAgIGlmICh0ZXh0dXJlLmJhc2VUZXh0dXJlLmhhc0xvYWRlZClcbiAgICB7XG4gICAgICAgIHRoaXMub25UZXh0dXJlTG9hZGVkKCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUub25jZSgnbG9hZGVkJywgdGhpcy5vblRleHR1cmVMb2FkZWQsIHRoaXMpO1xuICAgIH1cbn1cblxuTm9ybWFsTWFwRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuTm9ybWFsTWFwRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5vcm1hbE1hcEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsTWFwRmlsdGVyO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBkaW1lbnNpb25zIHVuaWZvcm1zIHdoZW4gdGhlIHRleHR1cmUgYmVjb21lcyBhdmFpbGFibGUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuTm9ybWFsTWFwRmlsdGVyLnByb3RvdHlwZS5vblRleHR1cmVMb2FkZWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMudW5pZm9ybXMubWFwRGltZW5zaW9ucy52YWx1ZS54ID0gdGhpcy51bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUud2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy5tYXBEaW1lbnNpb25zLnZhbHVlLnkgPSB0aGlzLnVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZS5oZWlnaHQ7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhOb3JtYWxNYXBGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmUgdXNlZCBmb3IgdGhlIGRpc3BsYWNlbWVudCBtYXAuIE11c3QgYmUgcG93ZXIgb2YgMiB0ZXh0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7VGV4dHVyZX1cbiAgICAgKiBAbWVtYmVyb2YgTm9ybWFsTWFwRmlsdGVyI1xuICAgICAqL1xuICAgIG1hcDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG11bHRpcGxpZXIgdXNlZCB0byBzY2FsZSB0aGUgZGlzcGxhY2VtZW50IHJlc3VsdCBmcm9tIHRoZSBtYXAgY2FsY3VsYXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQb2ludH1cbiAgICAgKiBAbWVtYmVyb2YgTm9ybWFsTWFwRmlsdGVyI1xuICAgICAqL1xuICAgIHNjYWxlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2NhbGUudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG9mZnNldCB1c2VkIHRvIG1vdmUgdGhlIGRpc3BsYWNlbWVudCBtYXAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQb2ludH1cbiAgICAgKiBAbWVtYmVyb2YgTm9ybWFsTWFwRmlsdGVyI1xuICAgICAqL1xuICAgIG9mZnNldDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm9mZnNldC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMub2Zmc2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIFRoaXMgZmlsdGVyIGFwcGxpZXMgYSBwaXhlbGF0ZSBlZmZlY3QgbWFraW5nIGRpc3BsYXkgb2JqZWN0cyBhcHBlYXIgJ2Jsb2NreScuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBQaXhlbGF0ZUZpbHRlcigpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSB2ZWM0IGRpbWVuc2lvbnM7XFxudW5pZm9ybSB2ZWMyIHBpeGVsU2l6ZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzIgY29vcmQgPSB2VGV4dHVyZUNvb3JkO1xcblxcbiAgICB2ZWMyIHNpemUgPSBkaW1lbnNpb25zLnh5IC8gcGl4ZWxTaXplO1xcblxcbiAgICB2ZWMyIGNvbG9yID0gZmxvb3IoICggdlRleHR1cmVDb29yZCAqIHNpemUgKSApIC8gc2l6ZSArIHBpeGVsU2l6ZS9kaW1lbnNpb25zLnh5ICogMC41O1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvbG9yKTtcXG59XFxuXCIsXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBkaW1lbnNpb25zOiB7IHR5cGU6ICc0ZnYnLCAgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDBdKSB9LFxuICAgICAgICAgICAgcGl4ZWxTaXplOiAgeyB0eXBlOiAndjInLCAgIHZhbHVlOiB7IHg6IDEwLCB5OiAxMCB9IH1cbiAgICAgICAgfVxuICAgICk7XG59XG5cblBpeGVsYXRlRmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuUGl4ZWxhdGVGaWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGl4ZWxhdGVGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFBpeGVsYXRlRmlsdGVyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhQaXhlbGF0ZUZpbHRlci5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGEgcG9pbnQgdGhhdCBkZXNjcmliZXMgdGhlIHNpemUgb2YgdGhlIGJsb2Nrcy5cbiAgICAgKiB4IGlzIHRoZSB3aWR0aCBvZiB0aGUgYmxvY2sgYW5kIHkgaXMgdGhlIGhlaWdodC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BvaW50fVxuICAgICAqIEBtZW1iZXJvZiBQaXhlbGF0ZUZpbHRlciNcbiAgICAgKi9cbiAgICBzaXplOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucGl4ZWxTaXplLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5waXhlbFNpemUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8qKlxuICogQW4gUkdCIFNwbGl0IEZpbHRlci5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEFic3RyYWN0RmlsdGVyXG4gKiBAbmFtZXNwYWNlIFBJWElcbiAqL1xuZnVuY3Rpb24gUkdCU3BsaXRGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjNCBkaW1lbnNpb25zO1xcbnVuaWZvcm0gdmVjMiByZWQ7XFxudW5pZm9ybSB2ZWMyIGdyZWVuO1xcbnVuaWZvcm0gdmVjMiBibHVlO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICBnbF9GcmFnQ29sb3IuciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCArIHJlZC9kaW1lbnNpb25zLnh5KS5yO1xcbiAgIGdsX0ZyYWdDb2xvci5nID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICsgZ3JlZW4vZGltZW5zaW9ucy54eSkuZztcXG4gICBnbF9GcmFnQ29sb3IuYiA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCArIGJsdWUvZGltZW5zaW9ucy54eSkuYjtcXG4gICBnbF9GcmFnQ29sb3IuYSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkuYTtcXG59XFxuXCIsXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICByZWQ6ICAgICAgICB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDIwLCB5OiAyMCB9IH0sXG4gICAgICAgICAgICBncmVlbjogICAgICB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IC0yMCwgeTogMjAgfSB9LFxuICAgICAgICAgICAgYmx1ZTogICAgICAgeyB0eXBlOiAndjInLCB2YWx1ZTogeyB4OiAyMCwgeTogLTIwIH0gfSxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHsgdHlwZTogJzRmdicsIHZhbHVlOiBbMCwgMCwgMCwgMF0gfVxuICAgICAgICB9XG4gICAgKTtcbn1cblxuUkdCU3BsaXRGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5SR0JTcGxpdEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSR0JTcGxpdEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gUkdCU3BsaXRGaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJHQlNwbGl0RmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFJlZCBjaGFubmVsIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BvaW50fVxuICAgICAqIEBtZW1iZXJvZiBSR0JTcGxpdEZpbHRlciNcbiAgICAgKi9cbiAgICByZWQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5yZWQudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnJlZC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyZWVuIGNoYW5uZWwgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UG9pbnR9XG4gICAgICogQG1lbWJlcm9mIFJHQlNwbGl0RmlsdGVyI1xuICAgICAqL1xuICAgIGdyZWVuOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ3JlZW4udmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmdyZWVuLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmx1ZSBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQb2ludH1cbiAgICAgKiBAbWVtYmVyb2YgUkdCU3BsaXRGaWx0ZXIjXG4gICAgICovXG4gICAgYmx1ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmJsdWUudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmJsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8qKlxuICogVGhpcyBhcHBsaWVzIGEgc2VwaWEgZWZmZWN0IHRvIHlvdXIgRGlzcGxheSBPYmplY3RzLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gU2VwaWFGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gZmxvYXQgc2VwaWE7XFxuXFxuY29uc3QgbWF0MyBzZXBpYU1hdHJpeCA9IG1hdDMoMC4zNTg4LCAwLjcwNDQsIDAuMTM2OCwgMC4yOTkwLCAwLjU4NzAsIDAuMTE0MCwgMC4yMzkyLCAwLjQ2OTYsIDAuMDkxMik7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZ2xfRnJhZ0NvbG9yLnJnYiAqIHNlcGlhTWF0cml4LCBzZXBpYSk7XFxufVxcblwiLFxuICAgICAgICAvLyBjdXN0b20gdW5pZm9ybXNcbiAgICAgICAge1xuICAgICAgICAgICAgc2VwaWE6IHsgdHlwZTogJzFmJywgdmFsdWU6IDEgfVxuICAgICAgICB9XG4gICAgKTtcbn1cblxuU2VwaWFGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5TZXBpYUZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXBpYUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gU2VwaWFGaWx0ZXI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNlcGlhRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFRoZSBzdHJlbmd0aCBvZiB0aGUgc2VwaWEuIGAxYCB3aWxsIGFwcGx5IHRoZSBmdWxsIHNlcGlhIGVmZmVjdCwgYW5kXG4gICAgICogYDBgIHdpbGwgbWFrZSB0aGUgb2JqZWN0IGl0cyBub3JtYWwgY29sb3IuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFNlcGlhRmlsdGVyI1xuICAgICAqL1xuICAgIHNlcGlhOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2VwaWEudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnNlcGlhLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIFRoZSBDb2xvck1hdHJpeEZpbHRlciBjbGFzcyBsZXRzIHlvdSBhcHBseSBhIDR4NCBtYXRyaXggdHJhbnNmb3JtYXRpb24gb24gdGhlIFJHQkFcbiAqIGNvbG9yIGFuZCBhbHBoYSB2YWx1ZXMgb2YgZXZlcnkgcGl4ZWwgb24geW91ciBkaXNwbGF5T2JqZWN0IHRvIHByb2R1Y2UgYSByZXN1bHRcbiAqIHdpdGggYSBuZXcgc2V0IG9mIFJHQkEgY29sb3IgYW5kIGFscGhhIHZhbHVlcy4gSXQncyBwcmV0dHkgcG93ZXJmdWwhXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBTaG9ja3dhdmVGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzLFxuICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBcInByZWNpc2lvbiBsb3dwIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnVuaWZvcm0gdmVjMiBjZW50ZXI7XFxudW5pZm9ybSB2ZWMzIHBhcmFtczsgLy8gMTAuMCwgMC44LCAwLjFcXG51bmlmb3JtIGZsb2F0IHRpbWU7XFxuXFxudm9pZCBtYWluKClcXG57XFxuICAgIHZlYzIgdXYgPSB2VGV4dHVyZUNvb3JkO1xcbiAgICB2ZWMyIHRleENvb3JkID0gdXY7XFxuXFxuICAgIGZsb2F0IGRpc3QgPSBkaXN0YW5jZSh1diwgY2VudGVyKTtcXG5cXG4gICAgaWYgKCAoZGlzdCA8PSAodGltZSArIHBhcmFtcy56KSkgJiYgKGRpc3QgPj0gKHRpbWUgLSBwYXJhbXMueikpIClcXG4gICAge1xcbiAgICAgICAgZmxvYXQgZGlmZiA9IChkaXN0IC0gdGltZSk7XFxuICAgICAgICBmbG9hdCBwb3dEaWZmID0gMS4wIC0gcG93KGFicyhkaWZmKnBhcmFtcy54KSwgcGFyYW1zLnkpO1xcblxcbiAgICAgICAgZmxvYXQgZGlmZlRpbWUgPSBkaWZmICAqIHBvd0RpZmY7XFxuICAgICAgICB2ZWMyIGRpZmZVViA9IG5vcm1hbGl6ZSh1diAtIGNlbnRlcik7XFxuICAgICAgICB0ZXhDb29yZCA9IHV2ICsgKGRpZmZVViAqIGRpZmZUaW1lKTtcXG4gICAgfVxcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHRleENvb3JkKTtcXG59XFxuXCIsXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBjZW50ZXI6IHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogMC41LCB5OiAwLjUgfSB9LFxuICAgICAgICAgICAgcGFyYW1zOiB7IHR5cGU6ICd2MycsIHZhbHVlOiB7IHg6IDEwLCB5OiAwLjgsIHo6IDAuMSB9IH0sXG4gICAgICAgICAgICB0aW1lOiB7IHR5cGU6ICcxZicsIHZhbHVlOiAwIH1cbiAgICAgICAgfVxuICAgICk7XG59XG5cblNob2Nrd2F2ZUZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcblNob2Nrd2F2ZUZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaG9ja3dhdmVGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFNob2Nrd2F2ZUZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU2hvY2t3YXZlRmlsdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNlbnRlciBvZiB0aGUgc2hvY2t3YXZlIGluIG5vcm1hbGl6ZWQgc2NyZWVuIGNvb3Jkcy4gVGhhdCBpc1xuICAgICAqICgwLDApIGlzIHRoZSB0b3AtbGVmdCBhbmQgKDEsMSkgaXMgdGhlIGJvdHRvbSByaWdodC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdDxzdHJpbmcsIG51bWJlcj59XG4gICAgICogQG1lbWJlcm9mIFNob2Nrd2F2ZUZpbHRlciNcbiAgICAgKi9cbiAgICBjZW50ZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5jZW50ZXIudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmNlbnRlci52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwYXJhbXMgb2YgdGhlIHNob2Nrd2F2ZS4gVGhlc2UgbW9kaWZ5IHRoZSBsb29rIGFuZCBiZWhhdmlvciBvZlxuICAgICAqIHRoZSBzaG9ja3dhdmUgYXMgaXQgcmlwcGxlcyBvdXQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3Q8c3RyaW5nLCBudW1iZXI+fVxuICAgICAqIEBtZW1iZXJvZiBTaG9ja3dhdmVGaWx0ZXIjXG4gICAgICovXG4gICAgcGFyYW1zOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMucGFyYW1zLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5wYXJhbXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZWxhcHNlZCB0aW1lIG9mIHRoZSBzaG9ja3dhdmUuIFRoaXMgY29udHJvbHMgdGhlIHNwZWVkIGF0IHdoaWNoXG4gICAgICogdGhlIHNob2Nrd2F2ZSByaXBwbGVzIG91dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgU2hvY2t3YXZlRmlsdGVyI1xuICAgICAqL1xuICAgIHRpbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy50aW1lLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy50aW1lLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpO1xuLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJmcy9pc3N1ZXMvMjVcblxuXG4vKipcbiAqIEBhdXRob3IgVmljbyBAdmljb2NvdGVhXG4gKiBvcmlnaW5hbCBmaWx0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanMgYnkgRXZhbiBXYWxsYWNlIDogaHR0cDovL21hZGVieWV2YW4uY29tL1xuICovXG5cbi8qKlxuICogQSBUaWx0U2hpZnRBeGlzRmlsdGVyLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgQWJzdHJhY3RGaWx0ZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gVGlsdFNoaWZ0QXhpc0ZpbHRlcigpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSBmbG9hdCBibHVyO1xcbnVuaWZvcm0gZmxvYXQgZ3JhZGllbnRCbHVyO1xcbnVuaWZvcm0gdmVjMiBzdGFydDtcXG51bmlmb3JtIHZlYzIgZW5kO1xcbnVuaWZvcm0gdmVjMiBkZWx0YTtcXG51bmlmb3JtIHZlYzIgdGV4U2l6ZTtcXG5cXG5mbG9hdCByYW5kb20odmVjMyBzY2FsZSwgZmxvYXQgc2VlZClcXG57XFxuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGdsX0ZyYWdDb29yZC54eXogKyBzZWVkLCBzY2FsZSkpICogNDM3NTguNTQ1MyArIHNlZWQpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuICAgIGZsb2F0IHRvdGFsID0gMC4wO1xcblxcbiAgICBmbG9hdCBvZmZzZXQgPSByYW5kb20odmVjMygxMi45ODk4LCA3OC4yMzMsIDE1MS43MTgyKSwgMC4wKTtcXG4gICAgdmVjMiBub3JtYWwgPSBub3JtYWxpemUodmVjMihzdGFydC55IC0gZW5kLnksIGVuZC54IC0gc3RhcnQueCkpO1xcbiAgICBmbG9hdCByYWRpdXMgPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCBhYnMoZG90KHZUZXh0dXJlQ29vcmQgKiB0ZXhTaXplIC0gc3RhcnQsIG5vcm1hbCkpIC8gZ3JhZGllbnRCbHVyKSAqIGJsdXI7XFxuXFxuICAgIGZvciAoZmxvYXQgdCA9IC0zMC4wOyB0IDw9IDMwLjA7IHQrKylcXG4gICAge1xcbiAgICAgICAgZmxvYXQgcGVyY2VudCA9ICh0ICsgb2Zmc2V0IC0gMC41KSAvIDMwLjA7XFxuICAgICAgICBmbG9hdCB3ZWlnaHQgPSAxLjAgLSBhYnMocGVyY2VudCk7XFxuICAgICAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCArIGRlbHRhIC8gdGV4U2l6ZSAqIHBlcmNlbnQgKiByYWRpdXMpO1xcbiAgICAgICAgc2FtcGxlLnJnYiAqPSBzYW1wbGUuYTtcXG4gICAgICAgIGNvbG9yICs9IHNhbXBsZSAqIHdlaWdodDtcXG4gICAgICAgIHRvdGFsICs9IHdlaWdodDtcXG4gICAgfVxcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHRvdGFsO1xcbiAgICBnbF9GcmFnQ29sb3IucmdiIC89IGdsX0ZyYWdDb2xvci5hICsgMC4wMDAwMTtcXG59XFxuXCIsXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBibHVyOiAgICAgICAgICAgeyB0eXBlOiAnMWYnLCB2YWx1ZTogMTAwIH0sXG4gICAgICAgICAgICBncmFkaWVudEJsdXI6ICAgeyB0eXBlOiAnMWYnLCB2YWx1ZTogNjAwIH0sXG4gICAgICAgICAgICBzdGFydDogICAgICAgICAgeyB0eXBlOiAndjInLCB2YWx1ZTogeyB4OiAwLCAgICB5OiB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIH0gfSxcbiAgICAgICAgICAgIGVuZDogICAgICAgICAgICB7IHR5cGU6ICd2MicsIHZhbHVlOiB7IHg6IDYwMCwgIHk6IHdpbmRvdy5pbm5lckhlaWdodCAvIDIgfSB9LFxuICAgICAgICAgICAgZGVsdGE6ICAgICAgICAgIHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogMzAsICAgeTogMzAgfSB9LFxuICAgICAgICAgICAgdGV4U2l6ZTogICAgICAgIHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogd2luZG93LmlubmVyV2lkdGgsIHk6IHdpbmRvdy5pbm5lckhlaWdodCB9IH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB0aGlzLnVwZGF0ZURlbHRhKCk7XG59XG5cblRpbHRTaGlmdEF4aXNGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjb3JlLkFic3RyYWN0RmlsdGVyLnByb3RvdHlwZSk7XG5UaWx0U2hpZnRBeGlzRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbHRTaGlmdEF4aXNGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFRpbHRTaGlmdEF4aXNGaWx0ZXI7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgZmlsdGVyIGRlbHRhIHZhbHVlcy5cbiAqIFRoaXMgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgWCBhbmQgWSBmaWx0ZXJzLCBkb2VzIG5vdGhpbmcgZm9yIHRoaXMgY2xhc3MuXG4gKlxuICovXG5UaWx0U2hpZnRBeGlzRmlsdGVyLnByb3RvdHlwZS51cGRhdGVEZWx0YSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YS52YWx1ZS54ID0gMDtcbiAgICB0aGlzLnVuaWZvcm1zLmRlbHRhLnZhbHVlLnkgPSAwO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGlsdFNoaWZ0QXhpc0ZpbHRlci5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc3RyZW5ndGggb2YgdGhlIGJsdXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFRpbHRTaGlmdEF4aXNGaWx0ZXIjXG4gICAgICovXG4gICAgYmx1cjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmJsdXIudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLmJsdXIudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyZW5ndGggb2YgdGhlIGdyYWRpZW50IGJsdXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFRpbHRTaGlmdEF4aXNGaWx0ZXIjXG4gICAgICovXG4gICAgZ3JhZGllbnRCbHVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ3JhZGllbnRCbHVyLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5ncmFkaWVudEJsdXIudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgWCB2YWx1ZSB0byBzdGFydCB0aGUgZWZmZWN0IGF0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UG9pbnR9XG4gICAgICogQG1lbWJlcm9mIFRpbHRTaGlmdEF4aXNGaWx0ZXIjXG4gICAgICovXG4gICAgc3RhcnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5zdGFydC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuc3RhcnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGVsdGEoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgWCB2YWx1ZSB0byBlbmQgdGhlIGVmZmVjdCBhdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BvaW50fVxuICAgICAqIEBtZW1iZXJvZiBUaWx0U2hpZnRBeGlzRmlsdGVyI1xuICAgICAqL1xuICAgIGVuZDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmVuZC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuZW5kLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURlbHRhKCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vY29yZScpLFxuICAgIFRpbHRTaGlmdFhGaWx0ZXIgPSByZXF1aXJlKCcuL1RpbHRTaGlmdFhGaWx0ZXInKSxcbiAgICBUaWx0U2hpZnRZRmlsdGVyID0gcmVxdWlyZSgnLi9UaWx0U2hpZnRZRmlsdGVyJyk7XG5cbi8qKlxuICogQGF1dGhvciBWaWNvIEB2aWNvY290ZWFcbiAqIG9yaWdpbmFsIGZpbHRlciBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcy9ibG9iL21hc3Rlci9zcmMvZmlsdGVycy9ibHVyL3RpbHRzaGlmdC5qcyBieSBFdmFuIFdhbGxhY2UgOiBodHRwOi8vbWFkZWJ5ZXZhbi5jb20vXG4gKi9cblxuLyoqXG4gKiBBIFRpbHRTaGlmdCBGaWx0ZXIuIE1hbmFnZXMgdGhlIHBhc3Mgb2YgYm90aCBhIFRpbHRTaGlmdFhGaWx0ZXIgYW5kIFRpbHRTaGlmdFlGaWx0ZXIuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBUaWx0U2hpZnRGaWx0ZXIoKVxue1xuICAgIGNvcmUuQWJzdHJhY3RGaWx0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudGlsdFNoaWZ0WEZpbHRlciA9IG5ldyBUaWx0U2hpZnRYRmlsdGVyKCk7XG4gICAgdGhpcy50aWx0U2hpZnRZRmlsdGVyID0gbmV3IFRpbHRTaGlmdFlGaWx0ZXIoKTtcbn1cblxuVGlsdFNoaWZ0RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5BYnN0cmFjdEZpbHRlci5wcm90b3R5cGUpO1xuVGlsdFNoaWZ0RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbHRTaGlmdEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gVGlsdFNoaWZ0RmlsdGVyO1xuXG5UaWx0U2hpZnRGaWx0ZXIucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBpbnB1dCwgb3V0cHV0KVxue1xuICAgIHZhciByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmdldFJlbmRlclRhcmdldCh0cnVlKTtcblxuICAgIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5hcHBseUZpbHRlcihyZW5kZXJlciwgaW5wdXQsIHJlbmRlclRhcmdldCk7XG5cbiAgICB0aGlzLnRpbHRTaGlmdFlGaWx0ZXIuYXBwbHlGaWx0ZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCwgb3V0cHV0KTtcblxuICAgIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIucmV0dXJuUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWx0U2hpZnRGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBUaWx0U2hpZnRGaWx0ZXIjXG4gICAgICovXG4gICAgYmx1cjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuYmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5ibHVyID0gdGhpcy50aWx0U2hpZnRZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyZW5ndGggb2YgdGhlIGdyYWRpZW50IGJsdXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFRpbHRTaGlmdEZpbHRlciNcbiAgICAgKi9cbiAgICBncmFkaWVudEJsdXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aWx0U2hpZnRYRmlsdGVyLmdyYWRpZW50Qmx1cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5ncmFkaWVudEJsdXIgPSB0aGlzLnRpbHRTaGlmdFlGaWx0ZXIuZ3JhZGllbnRCbHVyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIFkgdmFsdWUgdG8gc3RhcnQgdGhlIGVmZmVjdCBhdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgVGlsdFNoaWZ0RmlsdGVyI1xuICAgICAqL1xuICAgIHN0YXJ0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5zdGFydDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5zdGFydCA9IHRoaXMudGlsdFNoaWZ0WUZpbHRlci5zdGFydCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBZIHZhbHVlIHRvIGVuZCB0aGUgZWZmZWN0IGF0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBUaWx0U2hpZnRGaWx0ZXIjXG4gICAgICovXG4gICAgZW5kOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5lbmQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuZW5kID0gdGhpcy50aWx0U2hpZnRZRmlsdGVyLmVuZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCJ2YXIgVGlsdFNoaWZ0QXhpc0ZpbHRlciA9IHJlcXVpcmUoJy4vVGlsdFNoaWZ0QXhpc0ZpbHRlcicpO1xuXG4vKipcbiAqIEBhdXRob3IgVmljbyBAdmljb2NvdGVhXG4gKiBvcmlnaW5hbCBmaWx0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanMgYnkgRXZhbiBXYWxsYWNlIDogaHR0cDovL21hZGVieWV2YW4uY29tL1xuICovXG5cbi8qKlxuICogQSBUaWx0U2hpZnRYRmlsdGVyLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgVGlsdFNoaWZ0QXhpc0ZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBUaWx0U2hpZnRYRmlsdGVyKClcbntcbiAgICBUaWx0U2hpZnRBeGlzRmlsdGVyLmNhbGwodGhpcyk7XG59XG5cblRpbHRTaGlmdFhGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUaWx0U2hpZnRBeGlzRmlsdGVyLnByb3RvdHlwZSk7XG5UaWx0U2hpZnRYRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbHRTaGlmdFhGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFRpbHRTaGlmdFhGaWx0ZXI7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgZmlsdGVyIGRlbHRhIHZhbHVlcy5cbiAqXG4gKi9cblRpbHRTaGlmdFhGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZURlbHRhID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZHggPSB0aGlzLnVuaWZvcm1zLmVuZC52YWx1ZS54IC0gdGhpcy51bmlmb3Jtcy5zdGFydC52YWx1ZS54O1xuICAgIHZhciBkeSA9IHRoaXMudW5pZm9ybXMuZW5kLnZhbHVlLnkgLSB0aGlzLnVuaWZvcm1zLnN0YXJ0LnZhbHVlLnk7XG4gICAgdmFyIGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YS52YWx1ZS54ID0gZHggLyBkO1xuICAgIHRoaXMudW5pZm9ybXMuZGVsdGEudmFsdWUueSA9IGR5IC8gZDtcbn07XG4iLCJ2YXIgVGlsdFNoaWZ0QXhpc0ZpbHRlciA9IHJlcXVpcmUoJy4vVGlsdFNoaWZ0QXhpc0ZpbHRlcicpO1xuXG4vKipcbiAqIEBhdXRob3IgVmljbyBAdmljb2NvdGVhXG4gKiBvcmlnaW5hbCBmaWx0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanMgYnkgRXZhbiBXYWxsYWNlIDogaHR0cDovL21hZGVieWV2YW4uY29tL1xuICovXG5cbi8qKlxuICogQSBUaWx0U2hpZnRZRmlsdGVyLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgVGlsdFNoaWZ0QXhpc0ZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBUaWx0U2hpZnRZRmlsdGVyKClcbntcbiAgICBUaWx0U2hpZnRBeGlzRmlsdGVyLmNhbGwodGhpcyk7XG59XG5cblRpbHRTaGlmdFlGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUaWx0U2hpZnRBeGlzRmlsdGVyLnByb3RvdHlwZSk7XG5UaWx0U2hpZnRZRmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbHRTaGlmdFlGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IFRpbHRTaGlmdFlGaWx0ZXI7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgZmlsdGVyIGRlbHRhIHZhbHVlcy5cbiAqXG4gKi9cblRpbHRTaGlmdFlGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZURlbHRhID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZHggPSB0aGlzLnVuaWZvcm1zLmVuZC52YWx1ZS54IC0gdGhpcy51bmlmb3Jtcy5zdGFydC52YWx1ZS54O1xuICAgIHZhciBkeSA9IHRoaXMudW5pZm9ybXMuZW5kLnZhbHVlLnkgLSB0aGlzLnVuaWZvcm1zLnN0YXJ0LnZhbHVlLnk7XG4gICAgdmFyIGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgdGhpcy51bmlmb3Jtcy5kZWx0YS52YWx1ZS54ID0gLWR5IC8gZDtcbiAgICB0aGlzLnVuaWZvcm1zLmRlbHRhLnZhbHVlLnkgPSBkeCAvIGQ7XG59O1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icmZzL2lzc3Vlcy8yNVxuXG5cbi8qKlxuICogVGhpcyBmaWx0ZXIgYXBwbGllcyBhIHR3aXN0IGVmZmVjdCBtYWtpbmcgZGlzcGxheSBvYmplY3RzIGFwcGVhciB0d2lzdGVkIGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEZpbHRlclxuICogQG1lbWJlcm9mIFBJWEkuZmlsdGVyc1xuICovXG5mdW5jdGlvbiBUd2lzdEZpbHRlcigpXG57XG4gICAgY29yZS5BYnN0cmFjdEZpbHRlci5jYWxsKHRoaXMsXG4gICAgICAgIC8vIHZlcnRleCBzaGFkZXJcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSBmbG9hdCByYWRpdXM7XFxudW5pZm9ybSBmbG9hdCBhbmdsZTtcXG51bmlmb3JtIHZlYzIgb2Zmc2V0O1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICB2ZWMyIGNvb3JkID0gdlRleHR1cmVDb29yZCAtIG9mZnNldDtcXG4gICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGNvb3JkKTtcXG5cXG4gICBpZiAoZGlzdCA8IHJhZGl1cylcXG4gICB7XFxuICAgICAgIGZsb2F0IHJhdGlvID0gKHJhZGl1cyAtIGRpc3QpIC8gcmFkaXVzO1xcbiAgICAgICBmbG9hdCBhbmdsZU1vZCA9IHJhdGlvICogcmF0aW8gKiBhbmdsZTtcXG4gICAgICAgZmxvYXQgcyA9IHNpbihhbmdsZU1vZCk7XFxuICAgICAgIGZsb2F0IGMgPSBjb3MoYW5nbGVNb2QpO1xcbiAgICAgICBjb29yZCA9IHZlYzIoY29vcmQueCAqIGMgLSBjb29yZC55ICogcywgY29vcmQueCAqIHMgKyBjb29yZC55ICogYyk7XFxuICAgfVxcblxcbiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQrb2Zmc2V0KTtcXG59XFxuXCIsXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICByYWRpdXM6ICAgICB7IHR5cGU6ICcxZicsIHZhbHVlOiAwLjUgfSxcbiAgICAgICAgICAgIGFuZ2xlOiAgICAgIHsgdHlwZTogJzFmJywgdmFsdWU6IDUgfSxcbiAgICAgICAgICAgIG9mZnNldDogICAgIHsgdHlwZTogJ3YyJywgdmFsdWU6IHsgeDogMC41LCB5OiAwLjUgfSB9XG4gICAgICAgIH1cbiAgICApO1xufVxuXG5Ud2lzdEZpbHRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQWJzdHJhY3RGaWx0ZXIucHJvdG90eXBlKTtcblR3aXN0RmlsdGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR3aXN0RmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBUd2lzdEZpbHRlcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHdpc3RGaWx0ZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogVGhpcyBwb2ludCBkZXNjcmliZXMgdGhlIHRoZSBvZmZzZXQgb2YgdGhlIHR3aXN0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UG9pbnR9XG4gICAgICogQG1lbWJlcm9mIFR3aXN0RmlsdGVyI1xuICAgICAqL1xuICAgIG9mZnNldDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm9mZnNldC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMub2Zmc2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyByYWRpdXMgb2YgdGhlIHR3aXN0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBUd2lzdEZpbHRlciNcbiAgICAgKi9cbiAgICByYWRpdXM6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5yYWRpdXMudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgYW5nbGUgb2YgdGhlIHR3aXN0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBUd2lzdEZpbHRlciNcbiAgICAgKi9cbiAgICBhbmdsZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmFuZ2xlLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5hbmdsZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIvLyBydW4gdGhlIHBvbHlmaWxsc1xucmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG52YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbi8vIGFkZCBjb3JlIHBsdWdpbnMuXG5jb3JlLmV4dHJhcyAgICAgICAgID0gcmVxdWlyZSgnLi9leHRyYXMnKTtcbmNvcmUuZmlsdGVycyAgICAgICAgPSByZXF1aXJlKCcuL2ZpbHRlcnMnKTtcbmNvcmUuaW50ZXJhY3Rpb24gICAgPSByZXF1aXJlKCcuL2ludGVyYWN0aW9uJyk7XG5jb3JlLmxvYWRlcnMgICAgICAgID0gcmVxdWlyZSgnLi9sb2FkZXJzJyk7XG5jb3JlLm1lc2ggICAgICAgICAgID0gcmVxdWlyZSgnLi9tZXNoJyk7XG5jb3JlLnNwaW5lICAgICAgICAgID0gcmVxdWlyZSgnLi9zcGluZScpO1xuXG4vLyBleHBvcnQgYSBwcmVtYWRlIGxvYWRlciBpbnN0YW5jZVxuY29yZS5sb2FkZXIgPSBuZXcgY29yZS5sb2FkZXJzLkxvYWRlcigpO1xuXG4vLyBtaXhpbiB0aGUgZGVwcmVjYXRpb24gZmVhdHVyZXMuXG5PYmplY3QuYXNzaWduKGNvcmUsIHJlcXVpcmUoJy4vZGVwcmVjYXRpb24nKSk7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBIb2xkcyBhbGwgaW5mb3JtYXRpb24gcmVsYXRlZCB0byBhbiBJbnRlcmFjdGlvbiBldmVudFxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuaW50ZXJhY3Rpb25cbiAqL1xuZnVuY3Rpb24gSW50ZXJhY3Rpb25EYXRhKClcbntcbiAgICAvKipcbiAgICAgKiBUaGlzIHBvaW50IHN0b3JlcyB0aGUgZ2xvYmFsIGNvb3JkcyBvZiB3aGVyZSB0aGUgdG91Y2gvbW91c2UgZXZlbnQgaGFwcGVuZWRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BvaW50fVxuICAgICAqL1xuICAgIHRoaXMuZ2xvYmFsID0gbmV3IGNvcmUuUG9pbnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgU3ByaXRlIHRoYXQgd2FzIGludGVyYWN0ZWQgd2l0aFxuICAgICAqXG4gICAgICogQG1lbWJlciB7U3ByaXRlfVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcGFzc2VkIHRvIGFuIGV2ZW50IGhhbmRsZXIsIHRoaXMgd2lsbCBiZSB0aGUgb3JpZ2luYWwgRE9NIEV2ZW50IHRoYXQgd2FzIGNhcHR1cmVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtFdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBudWxsO1xufVxuXG5JbnRlcmFjdGlvbkRhdGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50ZXJhY3Rpb25EYXRhO1xubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmFjdGlvbkRhdGE7XG5cbi8qKlxuICogVGhpcyB3aWxsIHJldHVybiB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHNwZWNpZmllZCBkaXNwbGF5T2JqZWN0IGZvciB0aGlzIEludGVyYWN0aW9uRGF0YVxuICpcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtEaXNwbGF5T2JqZWN0fSBUaGUgRGlzcGxheU9iamVjdCB0aGF0IHlvdSB3b3VsZCBsaWtlIHRoZSBsb2NhbCBjb29yZHMgb2ZmXG4gKiBAcGFyYW0gW3BvaW50XSB7UG9pbnR9IEEgUG9pbnQgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSB2YWx1ZSwgb3B0aW9uYWwgKG90aGVyd2lzZSB3aWxsIGNyZWF0ZSBhIG5ldyBwb2ludClcbiAqIHBhcmFtIFtnbG9iYWxQb3NdIHtQb2ludH0gQSBQb2ludCBvYmplY3QgY29udGFpbmluZyB5b3VyIGN1c3RvbSBnbG9iYWwgY29vcmRzLCBvcHRpb25hbCAob3RoZXJ3aXNlIHdpbGwgdXNlIHRoZSBjdXJyZW50IGdsb2JhbCBjb29yZHMpXG4gKiBAcmV0dXJuIHtQb2ludH0gQSBwb2ludCBjb250YWluaW5nIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgSW50ZXJhY3Rpb25EYXRhIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBEaXNwbGF5T2JqZWN0XG4gKi9cbkludGVyYWN0aW9uRGF0YS5wcm90b3R5cGUuZ2V0TG9jYWxQb3NpdGlvbiA9IGZ1bmN0aW9uIChkaXNwbGF5T2JqZWN0LCBwb2ludCwgZ2xvYmFsUG9zKVxue1xuICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm07XG4gICAgdmFyIGdsb2JhbCA9IGdsb2JhbFBvcyA/IGdsb2JhbFBvcyA6IHRoaXMuZ2xvYmFsO1xuXG4gICAgLy8gZG8gYSBjaGVla3kgdHJhbnNmb3JtIHRvIGdldCB0aGUgbW91c2UgY29vcmRzO1xuICAgIHZhciBhMDAgPSB3b3JsZFRyYW5zZm9ybS5hLCBhMDEgPSB3b3JsZFRyYW5zZm9ybS5jLCBhMDIgPSB3b3JsZFRyYW5zZm9ybS50eCxcbiAgICAgICAgYTEwID0gd29ybGRUcmFuc2Zvcm0uYiwgYTExID0gd29ybGRUcmFuc2Zvcm0uZCwgYTEyID0gd29ybGRUcmFuc2Zvcm0udHksXG4gICAgICAgIGlkID0gMSAvIChhMDAgKiBhMTEgKyBhMDEgKiAtYTEwKTtcblxuICAgIHBvaW50ID0gcG9pbnQgfHwgbmV3IGNvcmUubWF0aC5Qb2ludCgpO1xuXG4gICAgcG9pbnQueCA9IGExMSAqIGlkICogZ2xvYmFsLnggKyAtYTAxICogaWQgKiBnbG9iYWwueSArIChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogaWQ7XG4gICAgcG9pbnQueSA9IGEwMCAqIGlkICogZ2xvYmFsLnkgKyAtYTEwICogaWQgKiBnbG9iYWwueCArICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGlkO1xuXG4gICAgLy8gc2V0IHRoZSBtb3VzZSBjb29yZHMuLi5cbiAgICByZXR1cm4gcG9pbnQ7XG59O1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyksXG4gICAgSW50ZXJhY3Rpb25EYXRhID0gcmVxdWlyZSgnLi9JbnRlcmFjdGlvbkRhdGEnKTtcblxuLy8gTWl4IGludGVyYWN0aXZlVGFyZ2V0IGludG8gY29yZS5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZVxuT2JqZWN0LmFzc2lnbihcbiAgICBjb3JlLkRpc3BsYXlPYmplY3QucHJvdG90eXBlLFxuICAgIHJlcXVpcmUoJy4vaW50ZXJhY3RpdmVUYXJnZXQnKVxuKTtcblxuLyoqXG4gKiBUaGUgaW50ZXJhY3Rpb24gbWFuYWdlciBkZWFscyB3aXRoIG1vdXNlIGFuZCB0b3VjaCBldmVudHMuIEFueSBEaXNwbGF5T2JqZWN0IGNhbiBiZSBpbnRlcmFjdGl2ZVxuICogaWYgaXRzIGludGVyYWN0aXZlIHBhcmFtZXRlciBpcyBzZXQgdG8gdHJ1ZVxuICogVGhpcyBtYW5hZ2VyIGFsc28gc3VwcG9ydHMgbXVsdGl0b3VjaC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmludGVyYWN0aW9uXG4gKiBAcGFyYW0gcmVuZGVyZXIge0NhbnZhc1JlbmRlcmVyfFdlYkdMUmVuZGVyZXJ9IEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVyXG4gKiBAcGFyYW0gW29wdGlvbnNdIHtvYmplY3R9XG4gKiBAcGFyYW0gW29wdGlvbnMuYXV0b1ByZXZlbnREZWZhdWx0PXRydWVdIHtib29sZWFufSBTaG91bGQgdGhlIG1hbmFnZXIgYXV0b21hdGljYWxseSBwcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBhY3Rpb25zLlxuICogQHBhcmFtIFtvcHRpb25zLmludGVyYWN0aW9uRnJlcXVlbmN5PTEwXSB7bnVtYmVyfSBGcmVxdWVuY3kgaW5jcmVhc2VzIHRoZSBpbnRlcmFjdGlvbiBldmVudHMgd2lsbCBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBJbnRlcmFjdGlvbk1hbmFnZXIocmVuZGVyZXIsIG9wdGlvbnMpXG57XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVuZGVyZXIgdGhpcyBpbnRlcmFjdGlvbiBtYW5hZ2VyIHdvcmtzIGZvci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1N5c3RlbVJlbmRlcmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCBkZWZhdWx0IGJyb3dzZXIgYWN0aW9ucyBhdXRvbWF0aWNhbGx5IGJlIHByZXZlbnRlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0ID0gb3B0aW9ucy5hdXRvUHJldmVudERlZmF1bHQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXV0b1ByZXZlbnREZWZhdWx0IDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEFzIHRoaXMgZnJlcXVlbmN5IGluY3JlYXNlcyB0aGUgaW50ZXJhY3Rpb24gZXZlbnRzIHdpbGwgYmUgY2hlY2tlZCBtb3JlIG9mdGVuLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICovXG4gICAgdGhpcy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSA9IG9wdGlvbnMuaW50ZXJhY3Rpb25GcmVxdWVuY3kgfHwgMTA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW91c2UgZGF0YVxuICAgICAqXG4gICAgICogQG1lbWJlciB7SW50ZXJhY3Rpb25EYXRhfVxuICAgICAqL1xuICAgIHRoaXMubW91c2UgPSBuZXcgSW50ZXJhY3Rpb25EYXRhKCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBkYXRhIG9iamVjdCB0byBoYW5kbGUgYWxsIHRoZSBldmVudCB0cmFja2luZy9kaXNwYXRjaGluZ1xuICAgICAqXG4gICAgICogQG1lbWJlciB7RXZlbnREYXRhfVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnREYXRhID0ge1xuICAgICAgICBzdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICBkYXRhOiB0aGlzLm1vdXNlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRpbnkgbGl0dGxlIGludGVyYWN0aXZlRGF0YSBwb29sICFcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJhY3RpdmVEYXRhUG9vbCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIERPTSBlbGVtZW50IHRvIGJpbmQgdG8uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEhhdmUgZXZlbnRzIGJlZW4gYXR0YWNoZWQgdG8gdGhlIGRvbSBlbGVtZW50P1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRzQWRkZWQgPSBmYWxzZTtcblxuICAgIC8vdGhpcyB3aWxsIG1ha2UgaXQgc28gdGhhdCB5b3UgZG9uJ3QgaGF2ZSB0byBjYWxsIGJpbmQgYWxsIHRoZSB0aW1lXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm9uTW91c2VVcCA9IHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9jZXNzTW91c2VVcCA9IHRoaXMucHJvY2Vzc01vdXNlVXAuYmluZCggdGhpcyApO1xuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm9uTW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvY2Vzc01vdXNlRG93biA9IHRoaXMucHJvY2Vzc01vdXNlRG93bi5iaW5kKCB0aGlzICk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm9uTW91c2VNb3ZlID0gdGhpcy5vbk1vdXNlTW92ZS5iaW5kKCB0aGlzICk7XG4gICAgdGhpcy5wcm9jZXNzTW91c2VNb3ZlID0gdGhpcy5wcm9jZXNzTW91c2VNb3ZlLmJpbmQoIHRoaXMgKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMub25Nb3VzZU91dCA9IHRoaXMub25Nb3VzZU91dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvY2Vzc01vdXNlT3Zlck91dCA9IHRoaXMucHJvY2Vzc01vdXNlT3Zlck91dC5iaW5kKCB0aGlzICk7XG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMub25Ub3VjaFN0YXJ0ID0gdGhpcy5vblRvdWNoU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb2Nlc3NUb3VjaFN0YXJ0ID0gdGhpcy5wcm9jZXNzVG91Y2hTdGFydC5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5vblRvdWNoRW5kID0gdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9jZXNzVG91Y2hFbmQgPSB0aGlzLnByb2Nlc3NUb3VjaEVuZC5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5vblRvdWNoTW92ZSA9IHRoaXMub25Ub3VjaE1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb2Nlc3NUb3VjaE1vdmUgPSB0aGlzLnByb2Nlc3NUb3VjaE1vdmUuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3QgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNzcyBzdHlsZSBvZiB0aGUgY3Vyc29yIHRoYXQgaXMgYmVpbmcgdXNlZFxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRDdXJzb3JTdHlsZSA9ICdpbmhlcml0JztcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNhY2hlZCB2YXJcbiAgICAgKiBAbWVtYmVyIHtQb2ludH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RlbXBQb2ludCA9IG5ldyBjb3JlLlBvaW50KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCByZXNvbHV0aW9uXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXBkYXRlIG1ldGhvZCBib3VuZCB0byBvdXIgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy51cGRhdGVCb3VuZCA9IHRoaXMudXBkYXRlLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnNldFRhcmdldEVsZW1lbnQodGhpcy5yZW5kZXJlci52aWV3LCB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb24pO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcbn1cblxuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludGVyYWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gSW50ZXJhY3Rpb25NYW5hZ2VyO1xuXG4vKipcbiAqIFNldHMgdGhlIERPTSBlbGVtZW50IHdoaWNoIHdpbGwgcmVjZWl2ZSBtb3VzZS90b3VjaCBldmVudHMuIFRoaXMgaXMgdXNlZnVsIGZvciB3aGVuIHlvdSBoYXZlXG4gKiBvdGhlciBET00gZWxlbWVudHMgb24gdG9wIG9mIHRoZSByZW5kZXJlcnMgQ2FudmFzIGVsZW1lbnQuIFdpdGggdGhpcyB5b3UnbGwgYmUgYmFsZSB0byBkZWxldGVnYXRlXG4gKiBhbm90aGVyIERPTSBlbGVtZW50IHRvIHJlY2VpdmUgdGhvc2UgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSBlbGVtZW50IHtIVE1MRWxlbWVudH0gdGhlIERPTSBlbGVtZW50IHdoaWNoIHdpbGwgcmVjZWl2ZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzLlxuICogQHBhcmFtIFtyZXNvbHV0aW9uPTFdIHtudW1iZXJ9IFRIZSByZXNvbHV0aW9uIG9mIHRoZSBuZXcgZWxlbWVudCAocmVsYXRpdmUgdG8gdGhlIGNhbnZhcykuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgcmVzb2x1dGlvbilcbntcbiAgICB0aGlzLnJlbW92ZUV2ZW50cygpO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCAxO1xuXG4gICAgdGhpcy5hZGRFdmVudHMoKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFsbCB0aGUgRE9NIGV2ZW50c1xuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGRFdmVudHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICghdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZClcbiAgICB7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtY29udGVudC16b29taW5nJ10gPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgICAgdGhpcy5vbk1vdXNlTW92ZSwgdHJ1ZSk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgICAgdGhpcy5vbk1vdXNlRG93biwgdHJ1ZSk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCAgICAgdGhpcy5vbk1vdXNlT3V0LCB0cnVlKTtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCAgIHRoaXMub25Ub3VjaFN0YXJ0LCB0cnVlKTtcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICAgICB0aGlzLm9uVG91Y2hFbmQsIHRydWUpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsICAgIHRoaXMub25Ub3VjaE1vdmUsIHRydWUpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAgdGhpcy5vbk1vdXNlVXAsIHRydWUpO1xuXG4gICAgdGhpcy5ldmVudHNBZGRlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIHRoZSBET00gZXZlbnRzIHRoYXQgd2VyZSBwcmV2aW91c2x5IHJlZ2lzdGVyZWRcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50KVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpXG4gICAge1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLWNvbnRlbnQtem9vbWluZyddID0gJyc7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLCB0cnVlKTtcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsICB0aGlzLm9uTW91c2VPdXQsIHRydWUpO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCB0cnVlKTtcbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICB0aGlzLm9uVG91Y2hFbmQsIHRydWUpO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUsIHRydWUpO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBudWxsO1xuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAgdGhpcy5vbk1vdXNlVXAsIHRydWUpO1xuXG4gICAgdGhpcy5ldmVudHNBZGRlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiB1cGRhdGVzIHRoZSBzdGF0ZSBvZiBpbnRlcmFjdGl2ZSBvYmplY3RzXG4gKlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZUJvdW5kKTtcblxuICAgIGlmKCB0aGlzLnRocm90dGxlVXBkYXRlKCkgfHwgIXRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50KVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSB1c2VyIG1vdmUgdGhlIG1vdXNlIHRoaXMgY2hlY2sgaGFzIGFscmVhZHkgYmVlbiBkZm9uZSB1c2luZyB0aGUgbW91c2UgbW92ZSFcbiAgICBpZih0aGlzLmRpZE1vdmUpXG4gICAge1xuICAgICAgICB0aGlzLmRpZE1vdmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3Vyc29yID0gJ2luaGVyaXQnO1xuXG4gICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUodGhpcy5tb3VzZS5nbG9iYWwsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCAsIHRoaXMucHJvY2Vzc01vdXNlT3Zlck91dC5iaW5kKHRoaXMpICwgdHJ1ZSApO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudEN1cnNvclN0eWxlICE9PSB0aGlzLmN1cnNvcilcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVudEN1cnNvclN0eWxlID0gdGhpcy5jdXJzb3I7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlLmN1cnNvciA9IHRoaXMuY3Vyc29yO1xuICAgIH1cblxuICAgIC8vVE9ET1xufTtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IG9uIHRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyBpbnRlcmFjdGVkIHdpdGhcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtDb250YWluZXJ8U3ByaXRlfFRpbGluZ1Nwcml0ZX0gdGhlIGRpc3BsYXkgb2JqZWN0IGluIHF1ZXN0aW9uXG4gKiBAcGFyYW0gZXZlbnRTdHJpbmcge3N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIGV2ZW50IChlLmcsIG1vdXNlZG93bilcbiAqIEBwYXJhbSBldmVudERhdGEge0V2ZW50RGF0YX0gdGhlIGV2ZW50IGRhdGEgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoIGRpc3BsYXlPYmplY3QsIGV2ZW50U3RyaW5nLCBldmVudERhdGEgKVxue1xuICAgIGlmKCFldmVudERhdGEuc3RvcHBlZClcbiAgICB7XG4gICAgICAgIGV2ZW50RGF0YS50YXJnZXQgPSBkaXNwbGF5T2JqZWN0O1xuICAgICAgICBldmVudERhdGEudHlwZSA9IGV2ZW50U3RyaW5nO1xuXG4gICAgICAgIGRpc3BsYXlPYmplY3QuZW1pdCggZXZlbnRTdHJpbmcsIGV2ZW50RGF0YSApO1xuXG4gICAgICAgIGlmKCBkaXNwbGF5T2JqZWN0W2V2ZW50U3RyaW5nXSApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3RbZXZlbnRTdHJpbmddKCBldmVudERhdGEgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRW5zdXJlcyB0aGUgaW50ZXJhY3Rpb24gY2hlY2tzIGRvbid0IGhhcHBlbiB0b28gb2Z0ZW4gYnkgZGVsYXlpbmcgdGhlIHVwZGF0ZSBsb29wXG4gKlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS50aHJvdHRsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gZnJlcXVlbmN5IG9mIDMwZnBzPz9cbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgZGlmZiA9IG5vdyAtIHRoaXMubGFzdDtcblxuICAgIGRpZmYgPSAoZGlmZiAqIHRoaXMuaW50ZXJhY3Rpb25GcmVxdWVuY3kgKSAvIDEwMDA7XG5cbiAgICBpZiAoZGlmZiA8IDEpXG4gICAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3QgPSBub3c7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIE1hcHMgeCBhbmQgeSBjb29yZHMgZnJvbSBhIERPTSBvYmplY3QgYW5kIG1hcHMgdGhlbSBjb3JyZWN0bHkgdG8gdGhlIHBpeGkgdmlldy4gVGhlIHJlc3VsdGluZyB2YWx1ZSBpcyBzdG9yZWQgaW4gdGhlIHBvaW50LlxuICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgdGhlIGZhY3QgdGhhdCB0aGUgRE9NIGVsZW1lbnQgY291bGQgYmUgc2NhbGVkIGFuZCBwb3NpdGlvbmVkIGFueXdoZXJlIG9uIHRoZSBzY3JlZW4uXG4gKlxuICogQHBhcmFtICB7UG9pbnR9IHBvaW50IHRoZSBwb2ludCB0aGF0IHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgaW5cbiAqIEBwYXJhbSAge251bWJlcn0geCAgICAgdGhlIHggY29vcmQgb2YgdGhlIHBvc2l0aW9uIHRvIG1hcFxuICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICB0aGUgeSBjb29yZCBvZiB0aGUgcG9zaXRpb24gdG8gbWFwXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUubWFwUG9zaXRpb25Ub1BvaW50ID0gZnVuY3Rpb24gKCBwb2ludCwgeCwgeSApXG57XG4gICAgdmFyIHJlY3QgPSB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBwb2ludC54ID0gKCAoIHggLSByZWN0LmxlZnQgKSAqICh0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC53aWR0aCAgLyByZWN0LndpZHRoICApICkgLyB0aGlzLnJlc29sdXRpb247XG4gICAgcG9pbnQueSA9ICggKCB5IC0gcmVjdC50b3AgICkgKiAodGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuaGVpZ2h0IC8gcmVjdC5oZWlnaHQgKSApIC8gdGhpcy5yZXNvbHV0aW9uO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHByb3ZpZGVzIGEgbmVhdCB3YXkgb2YgY3Jhd2xpbmcgdGhyb3VnaCB0aGUgc2NlbmUgZ3JhcGggYW5kIHJ1bm5pbmcgYSBzcGVjaWZpZWQgZnVuY3Rpb24gb24gYWxsIGludGVyYWN0aXZlIG9iamVjdHMgaXQgZmluZHMuXG4gKiBJdCB3aWxsIGFsc28gdGFrZSBjYXJlIG9mIGhpdCB0ZXN0aW5nIHRoZSBpbnRlcmFjdGl2ZSBvYmplY3RzIGFuZCBwYXNzZXMgdGhlIGhpdCBhY3Jvc3MgaW4gdGhlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSAge1BvaW50fSBwb2ludCB0aGUgcG9pbnQgdGhhdCBpcyB0ZXN0ZWQgZm9yIGNvbGxpc2lvblxuICogQHBhcmFtICB7Q29udGFpbmVyfFNwcml0ZXxUaWxpbmdTcHJpdGV9IGRpc3BsYXlPYmplY3QgdGhlIGRpc3BsYXlPYmplY3QgdGhhdCB3aWxsIGJlIGhpdCB0ZXN0IChyZWN1cmNzaXZseSBjcmF3bHMgaXRzIGNoaWxkcmVuKVxuICogQHBhcmFtICB7ZnVuY3Rpb259IGZ1bmMgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBpbnRlcmFjdGl2ZSBvYmplY3QuIFRoZSBkaXNwbGF5T2JqZWN0IGFuZCBoaXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gIHtib29sZWFufSBoaXRUZXN0IHRoaXMgaW5kaWNhdGVzIGlmIHRoZSBvYmplY3RzIGluc2lkZSBzaG91bGQgYmUgaGl0IHRlc3QgYWdhaW5zdCB0aGUgcG9pbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHJldHVybnMgdHJ1ZSBpZiB0aGUgZGlzcGxheU9iamVjdCBoaXQgdGhlIHBvaW50XG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc0ludGVyYWN0aXZlID0gZnVuY3Rpb24gKHBvaW50LCBkaXNwbGF5T2JqZWN0LCBmdW5jLCBoaXRUZXN0LCBpbnRlcmFjdGl2ZSApXG57XG4gICAgaWYoIWRpc3BsYXlPYmplY3QudmlzaWJsZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgdmFyIGhpdCA9IGZhbHNlO1xuXG4gICAgLy8gaWYgdGhlIG9iamVjdCBpcyBpbnRlcmFjdGl2ZSB3ZSBtdXN0IGhpdCB0ZXN0IGFsbCBpdHMgY2hpbGRyZW4uLlxuICAgIGludGVyYWN0aXZlID0gaW50ZXJhY3RpdmUgfHwgZGlzcGxheU9iamVjdC5pbnRlcmFjdGl2ZTtcblxuICAgIGlmKGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmVDaGlsZHJlbilcbiAgICB7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aC0xOyBpID49IDA7IGktLSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoISBoaXQgICYmIGhpdFRlc3QpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaGl0ID0gdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUocG9pbnQsIGNoaWxkcmVuW2ldLCBmdW5jLCB0cnVlLCBpbnRlcmFjdGl2ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIG5vdyB3ZSBrbm93IHdlIGNhbiBtaXNzIGl0IGFsbCFcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZShwb2ludCwgY2hpbGRyZW5baV0sIGZ1bmMsIGZhbHNlLCBmYWxzZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBpZihpbnRlcmFjdGl2ZSlcbiAgICB7XG4gICAgICAgIGlmKGhpdFRlc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKGRpc3BsYXlPYmplY3QuaGl0QXJlYSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBsZXRzIHVzZSB0aGUgaGl0IG9iamVjdCBmaXJzdCFcbiAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgIHRoaXMuX3RlbXBQb2ludCk7XG4gICAgICAgICAgICAgICAgaGl0ID0gZGlzcGxheU9iamVjdC5oaXRBcmVhLmNvbnRhaW5zKCB0aGlzLl90ZW1wUG9pbnQueCwgdGhpcy5fdGVtcFBvaW50LnkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoZGlzcGxheU9iamVjdC5jb250YWluc1BvaW50KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGhpdCA9IGRpc3BsYXlPYmplY3QuY29udGFpbnNQb2ludChwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihkaXNwbGF5T2JqZWN0LmludGVyYWN0aXZlKVxuICAgICAgICB7XG4gICAgICAgICAgICBmdW5jKGRpc3BsYXlPYmplY3QsIGhpdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGl0O1xufTtcblxuXG5cblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQgZG93biBvbiB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSBtb3VzZSBidXR0b24gYmVpbmcgcHJlc3NlZCBkb3duXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KVxue1xuICAgIHRoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMuZXZlbnREYXRhLmRhdGEgPSB0aGlzLm1vdXNlO1xuICAgIHRoaXMuZXZlbnREYXRhLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdClcbiAgICB7XG4gICAgICAgIHRoaXMubW91c2Uub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKHRoaXMubW91c2UuZ2xvYmFsLCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc01vdXNlRG93biwgdHJ1ZSApO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzZXMgdGhlIHJlc3VsdCBvZiB0aGUgbW91c2UgZG93biBjaGVjayBhbmQgZGlzcGF0Y2hlcyB0aGUgZXZlbnQgaWYgbmVlZCBiZVxuICpcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtDb250YWluZXJ8U3ByaXRlfFRpbGluZ1Nwcml0ZX0gVGhlIGRpc3BsYXkgb2JqZWN0IHRoYXQgd2FzIHRlc3RlZFxuICogQHBhcmFtIGhpdCB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgaGl0IHRlc3Qgb24gdGhlIGRpc3BheSBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc01vdXNlRG93biA9IGZ1bmN0aW9uICggZGlzcGxheU9iamVjdCwgaGl0IClcbntcbiAgICB2YXIgZSA9IHRoaXMubW91c2Uub3JpZ2luYWxFdmVudDtcblxuICAgIHZhciBpc1JpZ2h0QnV0dG9uID0gZS5idXR0b24gPT09IDIgfHwgZS53aGljaCA9PT0gMztcblxuICAgIGlmKGhpdClcbiAgICB7XG4gICAgICAgIGRpc3BsYXlPYmplY3RbIGlzUmlnaHRCdXR0b24gPyAnX2lzUmlnaHREb3duJyA6ICdfaXNMZWZ0RG93bicgXSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggZGlzcGxheU9iamVjdCwgaXNSaWdodEJ1dHRvbiA/ICdyaWdodGRvd24nIDogJ21vdXNlZG93bicsIHRoaXMuZXZlbnREYXRhICk7XG4gICAgfVxufTtcblxuXG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGJ1dHRvbiBpcyByZWxlYXNlZCBvbiB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSBtb3VzZSBidXR0b24gYmVpbmcgcmVsZWFzZWRcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Nb3VzZVVwID0gZnVuY3Rpb24gKGV2ZW50KVxue1xuICAgIHRoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMuZXZlbnREYXRhLmRhdGEgPSB0aGlzLm1vdXNlO1xuICAgIHRoaXMuZXZlbnREYXRhLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKHRoaXMubW91c2UuZ2xvYmFsLCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc01vdXNlVXAsIHRydWUgKTtcbn07XG5cbi8qKlxuICogUHJvY2Vzc2VzIHRoZSByZXN1bHQgb2YgdGhlIG1vdXNlIHVwIGNoZWNrIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXG4gKlxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0NvbnRhaW5lcnxTcHJpdGV8VGlsaW5nU3ByaXRlfSBUaGUgZGlzcGxheSBvYmplY3QgdGhhdCB3YXMgdGVzdGVkXG4gKiBAcGFyYW0gaGl0IHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSBoaXQgdGVzdCBvbiB0aGUgZGlzcGxheSBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc01vdXNlVXAgPSBmdW5jdGlvbiAoIGRpc3BsYXlPYmplY3QsIGhpdCApXG57XG4gICAgdmFyIGUgPSB0aGlzLm1vdXNlLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICB2YXIgaXNSaWdodEJ1dHRvbiA9IGUuYnV0dG9uID09PSAyIHx8IGUud2hpY2ggPT09IDM7XG4gICAgdmFyIGlzRG93biA9ICBpc1JpZ2h0QnV0dG9uID8gJ19pc1JpZ2h0RG93bicgOiAnX2lzTGVmdERvd24nO1xuXG4gICAgaWYoaGl0KVxuICAgIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBkaXNwbGF5T2JqZWN0LCBpc1JpZ2h0QnV0dG9uID8gJ3JpZ2h0dXAnIDogJ21vdXNldXAnLCB0aGlzLmV2ZW50RGF0YSApO1xuXG4gICAgICAgIGlmKCBkaXNwbGF5T2JqZWN0WyBpc0Rvd24gXSApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3RbIGlzRG93biBdID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsIGlzUmlnaHRCdXR0b24gPyAncmlnaHRjbGljaycgOiAnY2xpY2snLCB0aGlzLmV2ZW50RGF0YSApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGlmKCBkaXNwbGF5T2JqZWN0WyBpc0Rvd24gXSApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3RbIGlzRG93biBdID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsIGlzUmlnaHRCdXR0b24gPyAncmlnaHR1cG91dHNpZGUnIDogJ21vdXNldXBvdXRzaWRlJywgdGhpcy5ldmVudERhdGEgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgYWNyb3NzIHRoZSByZW5kZXJlciBlbGVtZW50XG4gKlxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiB0aGUgbW91c2UgbW92aW5nXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KVxue1xuICAgIHRoaXMubW91c2Uub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMuZXZlbnREYXRhLmRhdGEgPSB0aGlzLm1vdXNlO1xuICAgIHRoaXMuZXZlbnREYXRhLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIHRoaXMubWFwUG9zaXRpb25Ub1BvaW50KCB0aGlzLm1vdXNlLmdsb2JhbCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG5cbiAgICB0aGlzLmRpZE1vdmUgPSB0cnVlO1xuXG4gICAgdGhpcy5jdXJzb3IgPSAnaW5oZXJpdCc7XG5cbiAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZSh0aGlzLm1vdXNlLmdsb2JhbCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NNb3VzZU1vdmUsIHRydWUgKTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRDdXJzb3JTdHlsZSAhPT0gdGhpcy5jdXJzb3IpXG4gICAge1xuICAgICAgICB0aGlzLmN1cnJlbnRDdXJzb3JTdHlsZSA9IHRoaXMuY3Vyc29yO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZS5jdXJzb3IgPSB0aGlzLmN1cnNvcjtcbiAgICB9XG5cbiAgICAvL1RPRE8gQlVHIGZvciBwYXJlbnRzIGluZXJhY3RpdmUgb2JqZWN0IChib3JkZXIgb3JkZXIgaXNzdWUpXG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyB0aGUgcmVzdWx0IG9mIHRoZSBtb3VzZSBtb3ZlIGNoZWNrIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXG4gKlxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0NvbnRhaW5lcnxTcHJpdGV8VGlsaW5nU3ByaXRlfSBUaGUgZGlzcGxheSBvYmplY3QgdGhhdCB3YXMgdGVzdGVkXG4gKiBAcGFyYW0gaGl0IHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSBoaXQgdGVzdCBvbiB0aGUgZGlzcGxheSBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc01vdXNlTW92ZSA9IGZ1bmN0aW9uICggZGlzcGxheU9iamVjdCwgaGl0IClcbntcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICdtb3VzZW1vdmUnLCB0aGlzLmV2ZW50RGF0YSk7XG4gICAgdGhpcy5wcm9jZXNzTW91c2VPdmVyT3V0KGRpc3BsYXlPYmplY3QsIGhpdCk7XG59O1xuXG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGlzIG1vdmVkIG91dCBvZiB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSBtb3VzZSBiZWluZyBtb3ZlZCBvdXRcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Nb3VzZU91dCA9IGZ1bmN0aW9uIChldmVudClcbntcbiAgICB0aGlzLm1vdXNlLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcbiAgICB0aGlzLmV2ZW50RGF0YS5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnaW5oZXJpdCc7XG5cbiAgICAvLyBUT0RPIG9wdGltaXplIGJ5IG5vdCBjaGVjayBFVkVSWSBUSU1FISBtYXliZSBoYWxmIGFzIG9mdGVuPyAvL1xuICAgIHRoaXMubWFwUG9zaXRpb25Ub1BvaW50KCB0aGlzLm1vdXNlLmdsb2JhbCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG4gICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoIHRoaXMubW91c2UuZ2xvYmFsLCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc01vdXNlT3Zlck91dCwgZmFsc2UgKTtcbn07XG5cbi8qKlxuICogUHJvY2Vzc2VzIHRoZSByZXN1bHQgb2YgdGhlIG1vdXNlIG92ZXIvb3V0IGNoZWNrIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBpZiBuZWVkIGJlXG4gKlxuICogQHBhcmFtIGRpc3BsYXlPYmplY3Qge0NvbnRhaW5lcnxTcHJpdGV8VGlsaW5nU3ByaXRlfSBUaGUgZGlzcGxheSBvYmplY3QgdGhhdCB3YXMgdGVzdGVkXG4gKiBAcGFyYW0gaGl0IHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSBoaXQgdGVzdCBvbiB0aGUgZGlzcGxheSBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc01vdXNlT3Zlck91dCA9IGZ1bmN0aW9uICggZGlzcGxheU9iamVjdCwgaGl0IClcbntcbiAgICBpZihoaXQpXG4gICAge1xuICAgICAgICBpZighZGlzcGxheU9iamVjdC5fb3ZlcilcbiAgICAgICAge1xuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5fb3ZlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICdtb3VzZW92ZXInLCB0aGlzLmV2ZW50RGF0YSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuYnV0dG9uTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBkaXNwbGF5T2JqZWN0LmRlZmF1bHRDdXJzb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgaWYoZGlzcGxheU9iamVjdC5fb3ZlcilcbiAgICAgICAge1xuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5fb3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBkaXNwbGF5T2JqZWN0LCAnbW91c2VvdXQnLCB0aGlzLmV2ZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuICogSXMgY2FsbGVkIHdoZW4gYSB0b3VjaCBpcyBzdGFydGVkIG9uIHRoZSByZW5kZXJlciBlbGVtZW50XG4gKlxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiBhIHRvdWNoIHN0YXJ0aW5nIG9uIHRoZSByZW5kZXJlciB2aWV3XG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldmVudClcbntcbiAgICBpZiAodGhpcy5hdXRvUHJldmVudERlZmF1bHQpXG4gICAge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHZhciBjaGFuZ2VkVG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgIHZhciBjTGVuZ3RoID0gY2hhbmdlZFRvdWNoZXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaT0wOyBpIDwgY0xlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHRvdWNoRXZlbnQgPSBjaGFuZ2VkVG91Y2hlc1tpXTtcbiAgICAgICAgLy9UT0RPIFBPT0xcbiAgICAgICAgdmFyIHRvdWNoRGF0YSA9IHRoaXMuZ2V0VG91Y2hEYXRhKCB0b3VjaEV2ZW50ICk7XG5cbiAgICAgICAgdG91Y2hEYXRhLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcblxuICAgICAgICB0aGlzLmV2ZW50RGF0YS5kYXRhID0gdG91Y2hEYXRhO1xuICAgICAgICB0aGlzLmV2ZW50RGF0YS5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoIHRvdWNoRGF0YS5nbG9iYWwsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCwgdGhpcy5wcm9jZXNzVG91Y2hTdGFydCwgdHJ1ZSApO1xuXG4gICAgICAgIHRoaXMucmV0dXJuVG91Y2hEYXRhKCB0b3VjaERhdGEgKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyB0aGUgcmVzdWx0IG9mIGEgdG91Y2ggY2hlY2sgYW5kIGRpc3BhdGNoZXMgdGhlIGV2ZW50IGlmIG5lZWQgYmVcbiAqXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7Q29udGFpbmVyfFNwcml0ZXxUaWxpbmdTcHJpdGV9IFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcbiAqIEBwYXJhbSBoaXQge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGhpdCB0ZXN0IG9uIHRoZSBkaXNwbGF5IG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzVG91Y2hTdGFydCA9IGZ1bmN0aW9uICggZGlzcGxheU9iamVjdCwgaGl0IClcbntcbiAgICAvL2NvbnNvbGUubG9nKFwiaGl0XCIgKyBoaXQpXG4gICAgaWYoaGl0KVxuICAgIHtcbiAgICAgICAgZGlzcGxheU9iamVjdC5fdG91Y2hEb3duID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBkaXNwbGF5T2JqZWN0LCAndG91Y2hzdGFydCcsIHRoaXMuZXZlbnREYXRhICk7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIElzIGNhbGxlZCB3aGVuIGEgdG91Y2ggZW5kcyBvbiB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICogQHBhcmFtIGV2ZW50IHtFdmVudH0gVGhlIERPTSBldmVudCBvZiBhIHRvdWNoIGVuZGluZyBvbiB0aGUgcmVuZGVyZXIgdmlld1xuICpcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vblRvdWNoRW5kID0gZnVuY3Rpb24gKGV2ZW50KVxue1xuICAgIGlmICh0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdClcbiAgICB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgdmFyIGNMZW5ndGggPSBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpPTA7IGkgPCBjTGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgdG91Y2hFdmVudCA9IGNoYW5nZWRUb3VjaGVzW2ldO1xuXG4gICAgICAgIHZhciB0b3VjaERhdGEgPSB0aGlzLmdldFRvdWNoRGF0YSggdG91Y2hFdmVudCApO1xuXG4gICAgICAgIHRvdWNoRGF0YS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG5cbiAgICAgICAgLy9UT0RPIHRoaXMgc2hvdWxkIGJlIHBhc3NlZCBhbG9uZy4uIG5vIHNldFxuICAgICAgICB0aGlzLmV2ZW50RGF0YS5kYXRhID0gdG91Y2hEYXRhO1xuICAgICAgICB0aGlzLmV2ZW50RGF0YS5zdG9wcGVkID0gZmFsc2U7XG5cblxuICAgICAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZSggdG91Y2hEYXRhLmdsb2JhbCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NUb3VjaEVuZCwgdHJ1ZSApO1xuXG4gICAgICAgIHRoaXMucmV0dXJuVG91Y2hEYXRhKCB0b3VjaERhdGEgKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyB0aGUgcmVzdWx0IG9mIHRoZSBlbmQgb2YgYSB0b3VjaCBhbmQgZGlzcGF0Y2hlcyB0aGUgZXZlbnQgaWYgbmVlZCBiZVxuICpcbiAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0IHtDb250YWluZXJ8U3ByaXRlfFRpbGluZ1Nwcml0ZX0gVGhlIGRpc3BsYXkgb2JqZWN0IHRoYXQgd2FzIHRlc3RlZFxuICogQHBhcmFtIGhpdCB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgaGl0IHRlc3Qgb24gdGhlIGRpc3BsYXkgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NUb3VjaEVuZCA9IGZ1bmN0aW9uICggZGlzcGxheU9iamVjdCwgaGl0IClcbntcbiAgICBpZihoaXQpXG4gICAge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICd0b3VjaGVuZCcsIHRoaXMuZXZlbnREYXRhICk7XG5cbiAgICAgICAgaWYoIGRpc3BsYXlPYmplY3QuX3RvdWNoRG93biApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuX3RvdWNoRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCBkaXNwbGF5T2JqZWN0LCAndGFwJywgdGhpcy5ldmVudERhdGEgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiggZGlzcGxheU9iamVjdC5fdG91Y2hEb3duIClcbiAgICAgICAge1xuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5fdG91Y2hEb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICd0b3VjaGVuZG91dHNpZGUnLCB0aGlzLmV2ZW50RGF0YSApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBJcyBjYWxsZWQgd2hlbiBhIHRvdWNoIGlzIG1vdmVkIGFjcm9zcyB0aGUgcmVuZGVyZXIgZWxlbWVudFxuICpcbiAqIEBwYXJhbSBldmVudCB7RXZlbnR9IFRoZSBET00gZXZlbnQgb2YgYSB0b3VjaCBtb3ZpbmcgYWNyb3NzIHRoZSByZW5kZXJlciB2aWV3XG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KVxue1xuICAgIGlmICh0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdClcbiAgICB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgdmFyIGNMZW5ndGggPSBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpPTA7IGkgPCBjTGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgdG91Y2hFdmVudCA9IGNoYW5nZWRUb3VjaGVzW2ldO1xuXG4gICAgICAgIHZhciB0b3VjaERhdGEgPSB0aGlzLmdldFRvdWNoRGF0YSggdG91Y2hFdmVudCApO1xuXG4gICAgICAgIHRvdWNoRGF0YS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG5cbiAgICAgICAgdGhpcy5ldmVudERhdGEuZGF0YSA9IHRvdWNoRGF0YTtcbiAgICAgICAgdGhpcy5ldmVudERhdGEuc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKCB0b3VjaERhdGEuZ2xvYmFsLCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc1RvdWNoTW92ZSwgZmFsc2UgKTtcblxuICAgICAgICB0aGlzLnJldHVyblRvdWNoRGF0YSggdG91Y2hEYXRhICk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQcm9jZXNzZXMgdGhlIHJlc3VsdCBvZiBhIHRvdWNoIG1vdmUgY2hlY2sgYW5kIGRpc3BhdGNoZXMgdGhlIGV2ZW50IGlmIG5lZWQgYmVcbiAqXG4gKiBAcGFyYW0gZGlzcGxheU9iamVjdCB7Q29udGFpbmVyfFNwcml0ZXxUaWxpbmdTcHJpdGV9IFRoZSBkaXNwbGF5IG9iamVjdCB0aGF0IHdhcyB0ZXN0ZWRcbiAqIEBwYXJhbSBoaXQge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGhpdCB0ZXN0IG9uIHRoZSBkaXNwbGF5IG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzVG91Y2hNb3ZlID0gZnVuY3Rpb24gKCBkaXNwbGF5T2JqZWN0LCBoaXQgKVxue1xuICAgIGhpdCA9IGhpdDtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGRpc3BsYXlPYmplY3QsICd0b3VjaG1vdmUnLCB0aGlzLmV2ZW50RGF0YSk7XG59O1xuXG4vKipcbiAqIEdyYWJzIGFuIGludGVyYWN0aW9uIGRhdGEgb2JqZWN0IGZyb20gdGhlIGludGVybmFsIHBvb2xcbiAqXG4gKiBAcGFyYW0gdG91Y2hFdmVudCB7RXZlbnREYXRhfSBUaGUgdG91Y2ggZXZlbnQgd2UgbmVlZCB0byBwYWlyIHdpdGggYW4gaW50ZXJhY3Rpb25EYXRhIG9iamVjdFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkludGVyYWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VG91Y2hEYXRhID0gZnVuY3Rpb24gKHRvdWNoRXZlbnQpXG57XG4gICAgdmFyIHRvdWNoRGF0YSA9IHRoaXMuaW50ZXJhY3RpdmVEYXRhUG9vbC5wb3AoKTtcblxuICAgIGlmKCF0b3VjaERhdGEpXG4gICAge1xuICAgICAgICB0b3VjaERhdGEgPSBuZXcgSW50ZXJhY3Rpb25EYXRhKCk7XG4gICAgfVxuXG4gICAgdG91Y2hEYXRhLmlkZW50aWZpZXIgPSB0b3VjaEV2ZW50LmlkZW50aWZpZXI7XG4gICAgdGhpcy5tYXBQb3NpdGlvblRvUG9pbnQoIHRvdWNoRGF0YS5nbG9iYWwsIHRvdWNoRXZlbnQuY2xpZW50WCwgdG91Y2hFdmVudC5jbGllbnRZICk7XG5cbiAgICB0b3VjaEV2ZW50Lmdsb2JhbFggPSB0b3VjaERhdGEuZ2xvYmFsLng7XG4gICAgdG91Y2hFdmVudC5nbG9iYWxZID0gdG91Y2hEYXRhLmdsb2JhbC55O1xuXG4gICAgcmV0dXJuIHRvdWNoRGF0YTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBpbnRlcmFjdGlvbiBkYXRhIG9iamVjdCB0byB0aGUgaW50ZXJuYWwgcG9vbFxuICpcbiAqIEBwYXJhbSB0b3VjaERhdGEge0ludGVyYWN0aW9uRGF0YX0gVGhlIHRvdWNoIGRhdGEgb2JqZWN0IHdlIHdhbnQgdG8gcmV0dXJuIHRvIHRoZSBwb29sXG4gKlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJhY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZXR1cm5Ub3VjaERhdGEgPSBmdW5jdGlvbiAoIHRvdWNoRGF0YSApXG57XG4gICAgdGhpcy5pbnRlcmFjdGl2ZURhdGFQb29sLnB1c2goIHRvdWNoRGF0YSApO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgaW50ZXJhY3Rpb24gbWFuYWdlclxuICovXG5JbnRlcmFjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG5cbiAgICB0aGlzLm1vdXNlID0gbnVsbDtcblxuICAgIHRoaXMuZXZlbnREYXRhID0gbnVsbDtcblxuICAgIHRoaXMuaW50ZXJhY3RpdmVEYXRhUG9vbCA9IG51bGw7XG5cbiAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLm9uTW91c2VVcCA9IG51bGw7XG4gICAgdGhpcy5wcm9jZXNzTW91c2VVcCA9IG51bGw7XG5cblxuICAgIHRoaXMub25Nb3VzZURvd24gPSBudWxsO1xuICAgIHRoaXMucHJvY2Vzc01vdXNlRG93biA9IG51bGw7XG5cbiAgICB0aGlzLm9uTW91c2VNb3ZlID0gbnVsbDtcbiAgICB0aGlzLnByb2Nlc3NNb3VzZU1vdmUgPSBudWxsO1xuXG4gICAgdGhpcy5vbk1vdXNlT3V0ID0gbnVsbDtcbiAgICB0aGlzLnByb2Nlc3NNb3VzZU92ZXJPdXQgPSBudWxsO1xuXG5cbiAgICB0aGlzLm9uVG91Y2hTdGFydCA9IG51bGw7XG4gICAgdGhpcy5wcm9jZXNzVG91Y2hTdGFydCA9IG51bGw7XG5cbiAgICB0aGlzLm9uVG91Y2hFbmQgPSBudWxsO1xuICAgIHRoaXMucHJvY2Vzc1RvdWNoRW5kID0gbnVsbDtcblxuICAgIHRoaXMub25Ub3VjaE1vdmUgPSBudWxsO1xuICAgIHRoaXMucHJvY2Vzc1RvdWNoTW92ZSA9IG51bGw7XG5cbiAgICB0aGlzLl90ZW1wUG9pbnQgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVCb3VuZCA9IG51bGw7XG59O1xuXG5jb3JlLldlYkdMUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2ludGVyYWN0aW9uJywgSW50ZXJhY3Rpb25NYW5hZ2VyKTtcbmNvcmUuQ2FudmFzUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2ludGVyYWN0aW9uJywgSW50ZXJhY3Rpb25NYW5hZ2VyKTtcbiIsIi8qKlxuICogQGZpbGUgICAgICAgIE1haW4gZXhwb3J0IG9mIHRoZSBQSVhJIGludGVyYWN0aW9ucyBsaWJyYXJ5XG4gKiBAYXV0aG9yICAgICAgTWF0IEdyb3ZlcyA8bWF0QGdvb2Rib3lkaWdpdGFsLmNvbT5cbiAqIEBjb3B5cmlnaHQgICAyMDEzLTIwMTUgR29vZEJveURpZ2l0YWxcbiAqIEBsaWNlbnNlICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0dvb2RCb3lEaWdpdGFsL3BpeGkuanMvYmxvYi9tYXN0ZXIvTElDRU5TRXxNSVQgTGljZW5zZX1cbiAqL1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgUElYSS5pbnRlcmFjdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBJbnRlcmFjdGlvbkRhdGE6ICAgIHJlcXVpcmUoJy4vSW50ZXJhY3Rpb25EYXRhJyksXG4gICAgSW50ZXJhY3Rpb25NYW5hZ2VyOiByZXF1aXJlKCcuL0ludGVyYWN0aW9uTWFuYWdlcicpLFxuICAgIGludGVyYWN0aXZlVGFyZ2V0OiByZXF1aXJlKCcuL2ludGVyYWN0aXZlVGFyZ2V0Jylcbn07XG4iLCIvKipcbiAqIERlZmF1bHQgcHJvcGVydHkgdmFsdWVzIG9mIGludGVyYWN0aXZlIG9iamVjdHNcbiAqIHVzZWQgYnkge0BsaW5rIFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyfS5cbiAqXG4gKiBAbWl4aW5cbiAqIEBtZW1iZXJvZiBQSVhJLmludGVyYWN0aW9uXG4gKiBAZXhhbXBsZVxuICogICAgICBmdW5jdGlvbiBNeU9iamVjdCgpIHt9XG4gKlxuICogICAgICBPYmplY3QuYXNzaWduKFxuICogICAgICAgICAgTXlPYmplY3QucHJvdG90eXBlLFxuICogICAgICAgICAgUElYSS5pbnRlcmFjdGlvbi5pbnRlcmFjdGl2ZVRhcmdldClcbiAqICAgICAgKTtcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBAdG9kb1xuICAgICAqL1xuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAdG9kb1xuICAgICAqL1xuICAgIGJ1dHRvbk1vZGU6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEB0b2RvXG4gICAgICovXG4gICAgaW50ZXJhY3RpdmVDaGlsZHJlbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAdG9kb1xuICAgICAqL1xuICAgIGRlZmF1bHRDdXJzb3I6ICdwb2ludGVyJyxcblxuICAgIC8vIHNvbWUgaW50ZXJuYWwgY2hlY2tzLi5cblxuICAgIC8qKlxuICAgICAqIEB0b2RvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb3ZlcjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQHRvZG9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b3VjaERvd246IGZhbHNlXG59O1xuIiwidmFyIFJlc291cmNlID0gcmVxdWlyZSgncmVzb3VyY2UtbG9hZGVyJykuUmVzb3VyY2UsXG4gICAgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKSxcbiAgICBleHRyYXMgPSByZXF1aXJlKCcuLi9leHRyYXMnKSxcbiAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvdXJjZSwgbmV4dClcbiAgICB7XG4gICAgICAgIC8vIHNraXAgaWYgbm8gZGF0YVxuICAgICAgICBpZiAoIXJlc291cmNlLmRhdGEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZSA9IHJlc291cmNlLmRhdGEubm9kZU5hbWUgJiYgcmVzb3VyY2UuZGF0YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vIHNraXAgaWYgbm90IHhtbCBkYXRhXG4gICAgICAgIGlmICghbmFtZSB8fCAobmFtZSAhPT0gJyNkb2N1bWVudCcgJiYgbmFtZSAhPT0gJ2RpdicpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2tpcCBpZiBub3QgYml0bWFwIGZvbnQgZGF0YSwgdXNpbmcgc29tZSBzaWxseSBkdWNrLXR5cGluZ1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICByZXNvdXJjZS5kYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYWdlJykubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICByZXNvdXJjZS5kYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbmZvJykubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICByZXNvdXJjZS5kYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbmZvJylbMF0uZ2V0QXR0cmlidXRlKCdmYWNlJykgPT09IG51bGxcbiAgICAgICAgICAgIClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4bWxVcmwgPSBwYXRoLmRpcm5hbWUocmVzb3VyY2UudXJsKTtcblxuICAgICAgICBpZiAoeG1sVXJsID09PSAnLicpIHtcbiAgICAgICAgICAgIHhtbFVybCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYmFzZVVybCAmJiB4bWxVcmwpIHtcbiAgICAgICAgICAgIC8vIGlmIGJhc2V1cmwgaGFzIGEgdHJhaWxpbmcgc2xhc2ggdGhlbiBhZGQgb25lIHRvIHhtbFVybCBzbyB0aGUgcmVwbGFjZSB3b3JrcyBiZWxvd1xuICAgICAgICAgICAgaWYgKHRoaXMuYmFzZVVybC5jaGFyQXQodGhpcy5iYXNlVXJsLmxlbmd0aCAtIDEpID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICB4bWxVcmwgKz0gJy8nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZW1vdmUgYmFzZVVybCBmcm9tIHhtbFVybFxuICAgICAgICAgICAgeG1sVXJsID0geG1sVXJsLnJlcGxhY2UodGhpcy5iYXNlVXJsLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbiB4bWxVcmwgbm93LCBpdCBuZWVkcyBhIHRyYWlsaW5nIHNsYXNoLiBFbnN1cmUgdGhhdCBpdCBkb2VzIGlmIHRoZSBzdHJpbmcgaXNuJ3QgZW1wdHkuXG4gICAgICAgIGlmICh4bWxVcmwgJiYgeG1sVXJsLmNoYXJBdCh4bWxVcmwubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgICAgICAgeG1sVXJsICs9ICcvJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0dXJlVXJsID0geG1sVXJsICsgcmVzb3VyY2UuZGF0YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFnZScpWzBdLmdldEF0dHJpYnV0ZSgnZmlsZScpO1xuICAgICAgICB2YXIgbG9hZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjcm9zc09yaWdpbjogcmVzb3VyY2UuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICBsb2FkVHlwZTogUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbG9hZCB0aGUgdGV4dHVyZSBmb3IgdGhlIGZvbnRcbiAgICAgICAgdGhpcy5hZGQocmVzb3VyY2UubmFtZSArICdfaW1hZ2UnLCB0ZXh0dXJlVXJsLCBsb2FkT3B0aW9ucywgZnVuY3Rpb24gKHJlcylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIHZhciBpbmZvID0gcmVzb3VyY2UuZGF0YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5mbycpWzBdO1xuICAgICAgICAgICAgdmFyIGNvbW1vbiA9IHJlc291cmNlLmRhdGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NvbW1vbicpWzBdO1xuXG4gICAgICAgICAgICBkYXRhLmZvbnQgPSBpbmZvLmdldEF0dHJpYnV0ZSgnZmFjZScpO1xuICAgICAgICAgICAgZGF0YS5zaXplID0gcGFyc2VJbnQoaW5mby5nZXRBdHRyaWJ1dGUoJ3NpemUnKSwgMTApO1xuICAgICAgICAgICAgZGF0YS5saW5lSGVpZ2h0ID0gcGFyc2VJbnQoY29tbW9uLmdldEF0dHJpYnV0ZSgnbGluZUhlaWdodCcpLCAxMCk7XG4gICAgICAgICAgICBkYXRhLmNoYXJzID0ge307XG5cbiAgICAgICAgICAgIC8vcGFyc2UgbGV0dGVyc1xuICAgICAgICAgICAgdmFyIGxldHRlcnMgPSByZXNvdXJjZS5kYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjaGFyJyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgnaWQnKSwgMTApO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHR1cmVSZWN0ID0gbmV3IGNvcmUubWF0aC5SZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGxldHRlcnNbaV0uZ2V0QXR0cmlidXRlKCd4JyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3knKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksIDEwKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBkYXRhLmNoYXJzW2NoYXJDb2RlXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgeE9mZnNldDogcGFyc2VJbnQobGV0dGVyc1tpXS5nZXRBdHRyaWJ1dGUoJ3hvZmZzZXQnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB5T2Zmc2V0OiBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgneW9mZnNldCcpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIHhBZHZhbmNlOiBwYXJzZUludChsZXR0ZXJzW2ldLmdldEF0dHJpYnV0ZSgneGFkdmFuY2UnKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBrZXJuaW5nOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTogY29yZS51dGlscy5UZXh0dXJlQ2FjaGVbY2hhckNvZGVdID0gbmV3IGNvcmUuVGV4dHVyZShyZXMudGV4dHVyZS5iYXNlVGV4dHVyZSwgdGV4dHVyZVJlY3QpXG5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3BhcnNlIGtlcm5pbmdzXG4gICAgICAgICAgICB2YXIga2VybmluZ3MgPSByZXNvdXJjZS5kYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdrZXJuaW5nJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2VybmluZ3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gcGFyc2VJbnQoa2VybmluZ3NbaV0uZ2V0QXR0cmlidXRlKCdmaXJzdCcpLCAxMCk7XG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZCA9IHBhcnNlSW50KGtlcm5pbmdzW2ldLmdldEF0dHJpYnV0ZSgnc2Vjb25kJyksIDEwKTtcbiAgICAgICAgICAgICAgICB2YXIgYW1vdW50ID0gcGFyc2VJbnQoa2VybmluZ3NbaV0uZ2V0QXR0cmlidXRlKCdhbW91bnQnKSwgMTApO1xuXG4gICAgICAgICAgICAgICAgZGF0YS5jaGFyc1tzZWNvbmRdLmtlcm5pbmdbZmlyc3RdID0gYW1vdW50O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc291cmNlLmJpdG1hcEZvbnQgPSBkYXRhO1xuXG4gICAgICAgICAgICAvLyBJJ20gbGVhdmluZyB0aGlzIGFzIGEgdGVtcG9yYXJ5IGZpeCBzbyB3ZSBjYW4gdGVzdCB0aGUgYml0bWFwIGZvbnRzIGluIHYzXG4gICAgICAgICAgICAvLyBidXQgaXQncyB2ZXJ5IGxpa2VseSB0byBjaGFuZ2VcbiAgICAgICAgICAgIGV4dHJhcy5CaXRtYXBUZXh0LmZvbnRzW2RhdGEuZm9udF0gPSBkYXRhO1xuXG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuIiwiLyoqXG4gKiBAZmlsZSAgICAgICAgTWFpbiBleHBvcnQgb2YgdGhlIFBJWEkgbG9hZGVycyBsaWJyYXJ5XG4gKiBAYXV0aG9yICAgICAgTWF0IEdyb3ZlcyA8bWF0QGdvb2Rib3lkaWdpdGFsLmNvbT5cbiAqIEBjb3B5cmlnaHQgICAyMDEzLTIwMTUgR29vZEJveURpZ2l0YWxcbiAqIEBsaWNlbnNlICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0dvb2RCb3lEaWdpdGFsL3BpeGkuanMvYmxvYi9tYXN0ZXIvTElDRU5TRXxNSVQgTGljZW5zZX1cbiAqL1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgUElYSS5sb2FkZXJzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIExvYWRlcjogICAgICAgICAgICAgcmVxdWlyZSgnLi9sb2FkZXInKSxcblxuICAgIC8vIHBhcnNlcnNcbiAgICBiaXRtYXBGb250UGFyc2VyOiAgIHJlcXVpcmUoJy4vYml0bWFwRm9udFBhcnNlcicpLFxuICAgIHNwaW5lQXRsYXNQYXJzZXI6ICAgcmVxdWlyZSgnLi9zcGluZUF0bGFzUGFyc2VyJyksXG4gICAgc3ByaXRlc2hlZXRQYXJzZXI6ICByZXF1aXJlKCcuL3Nwcml0ZXNoZWV0UGFyc2VyJyksXG4gICAgdGV4dHVyZVBhcnNlcjogICAgICByZXF1aXJlKCcuL3RleHR1cmVQYXJzZXInKVxufTtcbiIsInZhciBSZXNvdXJjZUxvYWRlciA9IHJlcXVpcmUoJ3Jlc291cmNlLWxvYWRlcicpLFxuICAgIHRleHR1cmVQYXJzZXIgPSByZXF1aXJlKCcuL3RleHR1cmVQYXJzZXInKSxcbiAgICBzcHJpdGVzaGVldFBhcnNlciA9IHJlcXVpcmUoJy4vc3ByaXRlc2hlZXRQYXJzZXInKSxcbiAgICBzcGluZUF0bGFzUGFyc2VyID0gcmVxdWlyZSgnLi9zcGluZUF0bGFzUGFyc2VyJyksXG4gICAgYml0bWFwRm9udFBhcnNlciA9IHJlcXVpcmUoJy4vYml0bWFwRm9udFBhcnNlcicpO1xuXG4vKipcbiAqXG4gKiBUaGUgbmV3IGxvYWRlciwgZXh0ZW5kcyBSZXNvdXJjZSBMb2FkZXIgYnkgQ2hhZCBFbmdsZXIgOiBodHRwczovL2dpdGh1Yi5jb20vZW5nbGVyY2ovcmVzb3VyY2UtbG9hZGVyXG4gKlxuICogYGBganNcbiAqIHZhciBsb2FkZXIgPSBuZXcgUElYSS5sb2FkZXIoKTtcbiAqXG4gKiBsb2FkZXIuYWRkKCdzcGluZWJveScsXCJkYXRhL3NwaW5lYm95Lmpzb25cIik7XG4gKlxuICogbG9hZGVyLm9uY2UoJ2NvbXBsZXRlJyxvbkFzc2V0c0xvYWRlZCk7XG4gKlxuICogbG9hZGVyLmxvYWQoKTtcbiAqIGBgYFxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUmVzb3VyY2VMb2FkZXJcbiAqIEBtZW1iZXJvZiBQSVhJLmxvYWRlcnNcbiAqIEBwYXJhbSBbYmFzZVVybD0nJ10ge3N0cmluZ30gVGhlIGJhc2UgdXJsIGZvciBhbGwgcmVzb3VyY2VzIGxvYWRlZCBieSB0aGlzIGxvYWRlci5cbiAqIEBwYXJhbSBbY29uY3VycmVuY3k9MTBdIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcmVzb3VyY2VzIHRvIGxvYWQgY29uY3VycmVudGx5LlxuICovXG5mdW5jdGlvbiBMb2FkZXIoYmFzZVVybCwgY29uY3VycmVuY3kpXG57XG4gICAgUmVzb3VyY2VMb2FkZXIuY2FsbCh0aGlzLCBiYXNlVXJsLCBjb25jdXJyZW5jeSk7XG5cbiAgICAvLyBwYXJzZSBhbnkgYmxvYiBpbnRvIG1vcmUgdXNhYmxlIG9iamVjdHMgKGUuZy4gSW1hZ2UpXG4gICAgdGhpcy51c2UoUmVzb3VyY2VMb2FkZXIubWlkZGxld2FyZS5wYXJzaW5nLmJsb2IoKSk7XG5cbiAgICAvLyBwYXJzZSBhbnkgSW1hZ2Ugb2JqZWN0cyBpbnRvIHRleHR1cmVzXG4gICAgdGhpcy51c2UodGV4dHVyZVBhcnNlcigpKTtcblxuICAgIC8vIHBhcnNlIGFueSBzcHJpdGVzaGVldCBkYXRhIGludG8gbXVsdGlwbGUgdGV4dHVyZXNcbiAgICB0aGlzLnVzZShzcHJpdGVzaGVldFBhcnNlcigpKTtcblxuICAgIC8vIHBhcnNlIGFueSBzcGluZSBkYXRhIGludG8gYSBzcGluZSBvYmplY3RcbiAgICB0aGlzLnVzZShzcGluZUF0bGFzUGFyc2VyKCkpO1xuXG4gICAgLy8gcGFyc2UgYW55IHNwcml0ZXNoZWV0IGRhdGEgaW50byBtdWx0aXBsZSB0ZXh0dXJlc1xuICAgIHRoaXMudXNlKGJpdG1hcEZvbnRQYXJzZXIoKSk7XG59XG5cbkxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlc291cmNlTG9hZGVyLnByb3RvdHlwZSk7XG5Mb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9hZGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlcjtcbiIsInZhciBSZXNvdXJjZSA9IHJlcXVpcmUoJ3Jlc291cmNlLWxvYWRlcicpLlJlc291cmNlLFxuICAgIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKSxcbiAgICBzcGluZSA9IHJlcXVpcmUoJy4uL3NwaW5lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlc291cmNlLCBuZXh0KVxuICAgIHtcbiAgICAgICAgLy8gc2tpcCBpZiBubyBkYXRhXG4gICAgICAgIGlmICghcmVzb3VyY2UuZGF0YSB8fCAhcmVzb3VyY2UuZGF0YS5ib25lcylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1c2UgYSBiaXQgb2YgaGFja2VyeSB0byBsb2FkIHRoZSBhdGxhcyBmaWxlLCBoZXJlIHdlIGFzc3VtZSB0aGF0IHRoZSAuanNvbiwgLmF0bGFzIGFuZCAucG5nIGZpbGVzXG4gICAgICAgICAqIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgc3BpbmUgZmlsZSBhcmUgaW4gdGhlIHNhbWUgYmFzZSBVUkwgYW5kIHRoYXQgdGhlIC5qc29uIGFuZCAuYXRsYXMgZmlsZXNcbiAgICAgICAgICogaGF2ZSB0aGUgc2FtZSBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYXRsYXNQYXRoID0gcmVzb3VyY2UudXJsLnN1YnN0cigwLCByZXNvdXJjZS51cmwubGFzdEluZGV4T2YoJy4nKSkgKyAnLmF0bGFzJztcbiAgICAgICAgdmFyIGF0bGFzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNyb3NzT3JpZ2luOiByZXNvdXJjZS5jcm9zc09yaWdpbixcbiAgICAgICAgICAgIHhoclR5cGU6IFJlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFLlRFWFRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSByZXNvdXJjZS51cmwuc3Vic3RyKDAsIHJlc291cmNlLnVybC5sYXN0SW5kZXhPZignLycpICsgMSk7XG5cblxuICAgICAgICB0aGlzLmFkZChyZXNvdXJjZS5uYW1lICsgJ19hdGxhcycsIGF0bGFzUGF0aCwgYXRsYXNPcHRpb25zLCBmdW5jdGlvbiAocmVzKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBzcGluZSBhdGxhcyB1c2luZyB0aGUgbG9hZGVkIHRleHRcbiAgICAgICAgICAgIHZhciBzcGluZUF0bGFzID0gbmV3IHNwaW5lLlNwaW5lUnVudGltZS5BdGxhcyh0aGlzLnhoci5yZXNwb25zZVRleHQsIGJhc2VVcmwsIHJlcy5jcm9zc09yaWdpbik7XG5cbiAgICAgICAgICAgIC8vIHNwaW5lIGFuaW1hdGlvblxuICAgICAgICAgICAgdmFyIHNwaW5lSnNvblBhcnNlciA9IG5ldyBzcGluZS5TcGluZVJ1bnRpbWUuU2tlbGV0b25Kc29uUGFyc2VyKG5ldyBzcGluZS5TcGluZVJ1bnRpbWUuQXRsYXNBdHRhY2htZW50UGFyc2VyKHNwaW5lQXRsYXMpKTtcbiAgICAgICAgICAgIHZhciBza2VsZXRvbkRhdGEgPSBzcGluZUpzb25QYXJzZXIucmVhZFNrZWxldG9uRGF0YShyZXNvdXJjZS5kYXRhKTtcblxuICAgICAgICAgICAgcmVzb3VyY2Uuc3BpbmVEYXRhID0gc2tlbGV0b25EYXRhO1xuICAgICAgICAgICAgcmVzb3VyY2Uuc3BpbmVBdGxhcyA9IHNwaW5lQXRsYXM7XG5cbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBzcGluZUF0bGFzLnBhZ2VzIGFuZCB3YWl0IGZvciBwYWdlLnJlbmRlcmVyT2JqZWN0IChhIGJhc2VUZXh0dXJlKSB0b1xuICAgICAgICAgICAgLy8gbG9hZC4gT25jZSBhbGwgbG9hZGVkLCB0aGVuIGNhbGwgdGhlIG5leHQgZnVuY3Rpb24uXG4gICAgICAgICAgICBhc3luYy5lYWNoKHNwaW5lQXRsYXMucGFnZXMsIGZ1bmN0aW9uIChwYWdlLCBkb25lKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChwYWdlLnJlbmRlcmVyT2JqZWN0Lmhhc0xvYWRlZClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5yZW5kZXJlck9iamVjdC5vbmNlKCdsb2FkZWQnLCBkb25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBuZXh0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG4iLCJ2YXIgUmVzb3VyY2UgPSByZXF1aXJlKCdyZXNvdXJjZS1sb2FkZXInKS5SZXNvdXJjZSxcbiAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgIGNvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlc291cmNlLCBuZXh0KVxuICAgIHtcbiAgICAgICAgLy8gc2tpcCBpZiBubyBkYXRhXG4gICAgICAgIGlmICghcmVzb3VyY2UuZGF0YSB8fCAhcmVzb3VyY2UuZGF0YS5mcmFtZXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9hZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjcm9zc09yaWdpbjogcmVzb3VyY2UuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICBsb2FkVHlwZTogUmVzb3VyY2UuTE9BRF9UWVBFLklNQUdFXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJvdXRlID0gcGF0aC5kaXJuYW1lKHJlc291cmNlLnVybC5yZXBsYWNlKHRoaXMuYmFzZVVybCwgJycpKTtcblxuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGNvcmUudXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKCByZXNvdXJjZS51cmwgKTtcblxuICAgICAgICAvLyBsb2FkIHRoZSBpbWFnZSBmb3IgdGhpcyBzaGVldFxuICAgICAgICB0aGlzLmFkZChyZXNvdXJjZS5uYW1lICsgJ19pbWFnZScsIHJvdXRlICsgJy8nICsgcmVzb3VyY2UuZGF0YS5tZXRhLmltYWdlLCBsb2FkT3B0aW9ucywgZnVuY3Rpb24gKHJlcylcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzb3VyY2UudGV4dHVyZXMgPSB7fTtcblxuICAgICAgICAgICAgdmFyIGZyYW1lcyA9IHJlc291cmNlLmRhdGEuZnJhbWVzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGZyYW1lcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGZyYW1lc1tpXS5mcmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChyZWN0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJpbSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lc1tpXS5yb3RhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gbmV3IGNvcmUubWF0aC5SZWN0YW5nbGUocmVjdC54LCByZWN0LnksIHJlY3QuaCwgcmVjdC53KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSBuZXcgY29yZS5tYXRoLlJlY3RhbmdsZShyZWN0LngsIHJlY3QueSwgcmVjdC53LCByZWN0LmgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gIENoZWNrIHRvIHNlZSBpZiB0aGUgc3ByaXRlIGlzIHRyaW1tZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lc1tpXS50cmltbWVkKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltID0gbmV3IGNvcmUubWF0aC5SZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVzW2ldLnNwcml0ZVNvdXJjZVNpemUueCAvIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVzW2ldLnNwcml0ZVNvdXJjZVNpemUueSAvIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVzW2ldLnNvdXJjZVNpemUudyAvIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVzW2ldLnNvdXJjZVNpemUuaCAvIHJlc29sdXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmxpcCB0aGUgd2lkdGggYW5kIGhlaWdodCFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lc1tpXS5yb3RhdGVkKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHNpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplLndpZHRoID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplLmhlaWdodCA9IHRlbXA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzaXplLnggLz0gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZS55IC89IHJlc29sdXRpb247XG4gICAgICAgICAgICAgICAgICAgIHNpemUud2lkdGggLz0gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZS5oZWlnaHQgLz0gcmVzb2x1dGlvbjtcblxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS50ZXh0dXJlc1tpXSA9IG5ldyBjb3JlLlRleHR1cmUocmVzLnRleHR1cmUuYmFzZVRleHR1cmUsIHNpemUsIHNpemUuY2xvbmUoKSwgdHJpbSwgZnJhbWVzW2ldLnJvdGF0ZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldHMgYWxzbyBhZGQgdGhlIGZyYW1lIHRvIHBpeGkncyBnbG9iYWwgY2FjaGUgZm9yIGZyb21GcmFtZSBhbmQgZnJvbUltYWdlIGZ1Y250aW9uc1xuICAgICAgICAgICAgICAgICAgICBjb3JlLnV0aWxzLlRleHR1cmVDYWNoZVtpXSA9IHJlc291cmNlLnRleHR1cmVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvdXJjZSwgbmV4dClcbiAgICB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyB0ZXh0dXJlIGlmIHRoZSBkYXRhIGlzIGFuIEltYWdlIG9iamVjdFxuICAgICAgICBpZiAocmVzb3VyY2UuZGF0YSAmJiByZXNvdXJjZS5kYXRhLm5vZGVOYW1lICYmIHJlc291cmNlLmRhdGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc291cmNlLnRleHR1cmUgPSBuZXcgY29yZS5UZXh0dXJlKG5ldyBjb3JlLkJhc2VUZXh0dXJlKHJlc291cmNlLmRhdGEsIG51bGwsIGNvcmUudXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHJlc291cmNlLnVybCkpKTtcbiAgICAgICAgICAgIC8vIGxldHMgYWxzbyBhZGQgdGhlIGZyYW1lIHRvIHBpeGkncyBnbG9iYWwgY2FjaGUgZm9yIGZyb21GcmFtZSBhbmQgZnJvbUltYWdlIGZ1Y250aW9uc1xuICAgICAgICAgICAgY29yZS51dGlscy5UZXh0dXJlQ2FjaGVbcmVzb3VyY2UudXJsXSA9IHJlc291cmNlLnRleHR1cmU7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KCk7XG4gICAgfTtcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBCYXNlIG1lc2ggY2xhc3NcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgQ29udGFpbmVyXG4gKiBAbWVtYmVyb2YgUElYSS5tZXNoXG4gKiBAcGFyYW0gdGV4dHVyZSB7VGV4dHVyZX0gVGhlIHRleHR1cmUgdG8gdXNlXG4gKiBAcGFyYW0gW3ZlcnRpY2VzXSB7RmxvYXQzMkFycmlmIHlvdSB3YW50IHRvIHNwZWNpZnkgdGhlIHZlcnRpY2VzXG4gKiBAcGFyYW0gW3V2c10ge0Zsb2F0MzJBcnJheX0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgdXZzXG4gKiBAcGFyYW0gW2luZGljZXNdIHtVaW50MTZBcnJheX0gaWYgeW91IHdhbnQgdG8gc3BlY2lmeSB0aGUgaW5kaWNlc1xuICogQHBhcmFtIFtkcmF3TW9kZV0ge251bWJlcn0gdGhlIGRyYXdNb2RlLCBjYW4gYmUgYW55IG9mIHRoZSBNZXNoLkRSQVdfTU9ERVMgY29uc3RzXG4gKi9cbmZ1bmN0aW9uIE1lc2godGV4dHVyZSwgdmVydGljZXMsIHV2cywgaW5kaWNlcywgZHJhd01vZGUpXG57XG4gICAgY29yZS5Db250YWluZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIG9mIHRoZSBNZXNoXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtUZXh0dXJlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgVXZzIG9mIHRoZSBNZXNoXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XG4gICAgICovXG4gICAgdGhpcy51dnMgPSB1dnMgfHwgbmV3IEZsb2F0MzJBcnJheShbMCwgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMV0pO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgdmVydGljZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXMgfHwgbmV3IEZsb2F0MzJBcnJheShbMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMDAsIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMTAwXSk7XG5cbiAgICAvKlxuICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlc1xuICAgICAqL1xuICAgIC8vICBUT0RPIGF1dG8gZ2VuZXJhdGUgdGhpcyBiYXNlZCBvbiBkcmF3IG1vZGUhXG4gICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcyB8fCBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDNdKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIE1lc2ggaXMgZGlydHkgb3Igbm90XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBTZXQgdG8gYmxlbmRNb2Rlcy5OT1JNQUwgdG8gcmVtb3ZlIGFueSBibGVuZCBtb2RlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IENPTlNULkJMRU5EX01PREVTLk5PUk1BTDtcbiAgICAgKi9cbiAgICB0aGlzLmJsZW5kTW9kZSA9IGNvcmUuQkxFTkRfTU9ERVMuTk9STUFMO1xuXG4gICAgLyoqXG4gICAgICogVHJpYW5nbGVzIGluIGNhbnZhcyBtb2RlIGFyZSBhdXRvbWF0aWNhbGx5IGFudGlhbGlhc2VkLCB1c2UgdGhpcyB2YWx1ZSB0byBmb3JjZSB0cmlhbmdsZXMgdG8gb3ZlcmxhcCBhIGJpdCB3aXRoIGVhY2ggb3RoZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jYW52YXNQYWRkaW5nID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3YXkgdGhlIE1lc2ggc2hvdWxkIGJlIGRyYXduLCBjYW4gYmUgYW55IG9mIHRoZSBNZXNoLkRSQVdfTU9ERVMgY29uc3RzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kcmF3TW9kZSA9IGRyYXdNb2RlIHx8IE1lc2guRFJBV19NT0RFUy5UUklBTkdMRV9NRVNIO1xufVxuXG4vLyBjb25zdHJ1Y3RvclxuTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuQ29udGFpbmVyLnByb3RvdHlwZSk7XG5NZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2g7XG5tb2R1bGUuZXhwb3J0cyA9IE1lc2g7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7V2ViR0xSZW5kZXJlcn0gYSByZWZlcmVuY2UgdG8gdGhlIFdlYkdMIHJlbmRlcmVyXG4gKiBAcHJpdmF0ZVxuICovXG5NZXNoLnByb3RvdHlwZS5fcmVuZGVyV2ViR0wgPSBmdW5jdGlvbiAocmVuZGVyZXIpXG57XG4gICAgcmVuZGVyZXIuc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2lucy5tZXNoKTtcbiAgICByZW5kZXJlci5wbHVnaW5zLm1lc2gucmVuZGVyKHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIENhbnZhcyByZW5kZXJlclxuICpcbiAqIEBwYXJhbSByZW5kZXJlciB7Q2FudmFzUmVuZGVyZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5NZXNoLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzID0gZnVuY3Rpb24gKHJlbmRlcmVyKVxue1xuICAgIHZhciBjb250ZXh0ID0gcmVuZGVyZXIuY29udGV4dDtcblxuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuXG4gICAgaWYgKHJlbmRlcmVyLnJvdW5kUGl4ZWxzKVxuICAgIHtcbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtLmEsIHRyYW5zZm9ybS5iLCB0cmFuc2Zvcm0uYywgdHJhbnNmb3JtLmQsIHRyYW5zZm9ybS50eCB8IDAsIHRyYW5zZm9ybS50eSB8IDApO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm0uYSwgdHJhbnNmb3JtLmIsIHRyYW5zZm9ybS5jLCB0cmFuc2Zvcm0uZCwgdHJhbnNmb3JtLnR4LCB0cmFuc2Zvcm0udHkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRyYXdNb2RlID09PSBNZXNoLkRSQVdfTU9ERVMuVFJJQU5HTEVfTUVTSClcbiAgICB7XG4gICAgICAgIHRoaXMuX3JlbmRlckNhbnZhc1RyaWFuZ2xlTWVzaChjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2FudmFzVHJpYW5nbGVzKGNvbnRleHQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRHJhd3MgdGhlIG9iamVjdCBpbiBUcmlhbmdsZSBNZXNoIG1vZGUgdXNpbmcgY2FudmFzXG4gKlxuICogQHBhcmFtIGNvbnRleHQge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gdGhlIGN1cnJlbnQgZHJhd2luZyBjb250ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5NZXNoLnByb3RvdHlwZS5fcmVuZGVyQ2FudmFzVHJpYW5nbGVNZXNoID0gZnVuY3Rpb24gKGNvbnRleHQpXG57XG4gICAgLy8gZHJhdyB0cmlhbmdsZXMhIVxuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIHV2cyA9IHRoaXMudXZzO1xuXG4gICAgdmFyIGxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aCAvIDI7XG4gICAgLy8gdGhpcy5jb3VudCsrO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggLSAyOyBpKyspXG4gICAge1xuICAgICAgICAvLyBkcmF3IHNvbWUgdHJpYW5nbGVzIVxuICAgICAgICB2YXIgaW5kZXggPSBpICogMjtcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2FudmFzRHJhd1RyaWFuZ2xlKGNvbnRleHQsIHZlcnRpY2VzLCB1dnMsIGluZGV4LCAoaW5kZXggKyAyKSwgKGluZGV4ICsgNCkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRHJhd3MgdGhlIG9iamVjdCBpbiB0cmlhbmdsZSBtb2RlIHVzaW5nIGNhbnZhc1xuICpcbiAqIEBwYXJhbSBjb250ZXh0IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IHRoZSBjdXJyZW50IGRyYXdpbmcgY29udGV4dFxuICogQHByaXZhdGVcbiAqL1xuTWVzaC5wcm90b3R5cGUuX3JlbmRlckNhbnZhc1RyaWFuZ2xlcyA9IGZ1bmN0aW9uIChjb250ZXh0KVxue1xuICAgIC8vIGRyYXcgdHJpYW5nbGVzISFcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHZhciB1dnMgPSB0aGlzLnV2cztcbiAgICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcblxuICAgIHZhciBsZW5ndGggPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAvLyB0aGlzLmNvdW50Kys7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAzKVxuICAgIHtcbiAgICAgICAgLy8gZHJhdyBzb21lIHRyaWFuZ2xlcyFcbiAgICAgICAgdmFyIGluZGV4MCA9IGluZGljZXNbaV0gKiAyLCBpbmRleDEgPSBpbmRpY2VzW2kgKyAxXSAqIDIsIGluZGV4MiA9IGluZGljZXNbaSArIDJdICogMjtcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2FudmFzRHJhd1RyaWFuZ2xlKGNvbnRleHQsIHZlcnRpY2VzLCB1dnMsIGluZGV4MCwgaW5kZXgxLCBpbmRleDIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRHJhd3Mgb25lIG9mIHRoZSB0cmlhbmdsZXMgdGhhdCBmb3JtIHRoaXMgTWVzaFxuICpcbiAqIEBwYXJhbSBjb250ZXh0IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IHRoZSBjdXJyZW50IGRyYXdpbmcgY29udGV4dFxuICogQHBhcmFtIHZlcnRpY2VzIHtGbG9hdDMyQXJyYXl9IGEgcmVmZXJlbmNlIHRvIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgTWVzaFxuICogQHBhcmFtIHV2cyB7RmxvYXQzMkFycmF5fSBhIHJlZmVyZW5jZSB0byB0aGUgdXZzIG9mIHRoZSBNZXNoXG4gKiBAcGFyYW0gaW5kZXgwIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdmVydGV4XG4gKiBAcGFyYW0gaW5kZXgxIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIHZlcnRleFxuICogQHBhcmFtIGluZGV4MiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIHRoaXJkIHZlcnRleFxuICogQHByaXZhdGVcbiAqL1xuTWVzaC5wcm90b3R5cGUuX3JlbmRlckNhbnZhc0RyYXdUcmlhbmdsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCB2ZXJ0aWNlcywgdXZzLCBpbmRleDAsIGluZGV4MSwgaW5kZXgyKVxue1xuICAgIHZhciB0ZXh0dXJlU291cmNlID0gdGhpcy50ZXh0dXJlLmJhc2VUZXh0dXJlLnNvdXJjZTtcbiAgICB2YXIgdGV4dHVyZVdpZHRoID0gdGhpcy50ZXh0dXJlLndpZHRoO1xuICAgIHZhciB0ZXh0dXJlSGVpZ2h0ID0gdGhpcy50ZXh0dXJlLmhlaWdodDtcblxuICAgIHZhciB4MCA9IHZlcnRpY2VzW2luZGV4MF0sIHgxID0gdmVydGljZXNbaW5kZXgxXSwgeDIgPSB2ZXJ0aWNlc1tpbmRleDJdO1xuICAgIHZhciB5MCA9IHZlcnRpY2VzW2luZGV4MCArIDFdLCB5MSA9IHZlcnRpY2VzW2luZGV4MSArIDFdLCB5MiA9IHZlcnRpY2VzW2luZGV4MiArIDFdO1xuXG4gICAgdmFyIHUwID0gdXZzW2luZGV4MF0gKiB0ZXh0dXJlV2lkdGgsIHUxID0gdXZzW2luZGV4MV0gKiB0ZXh0dXJlV2lkdGgsIHUyID0gdXZzW2luZGV4Ml0gKiB0ZXh0dXJlV2lkdGg7XG4gICAgdmFyIHYwID0gdXZzW2luZGV4MCArIDFdICogdGV4dHVyZUhlaWdodCwgdjEgPSB1dnNbaW5kZXgxICsgMV0gKiB0ZXh0dXJlSGVpZ2h0LCB2MiA9IHV2c1tpbmRleDIgKyAxXSAqIHRleHR1cmVIZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5jYW52YXNQYWRkaW5nID4gMClcbiAgICB7XG4gICAgICAgIHZhciBwYWRkaW5nWCA9IHRoaXMuY2FudmFzUGFkZGluZyAvIHRoaXMud29ybGRUcmFuc2Zvcm0uYTtcbiAgICAgICAgdmFyIHBhZGRpbmdZID0gdGhpcy5jYW52YXNQYWRkaW5nIC8gdGhpcy53b3JsZFRyYW5zZm9ybS5kO1xuICAgICAgICB2YXIgY2VudGVyWCA9ICh4MCArIHgxICsgeDIpIC8gMztcbiAgICAgICAgdmFyIGNlbnRlclkgPSAoeTAgKyB5MSArIHkyKSAvIDM7XG5cbiAgICAgICAgdmFyIG5vcm1YID0geDAgLSBjZW50ZXJYO1xuICAgICAgICB2YXIgbm9ybVkgPSB5MCAtIGNlbnRlclk7XG5cbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQobm9ybVggKiBub3JtWCArIG5vcm1ZICogbm9ybVkpO1xuICAgICAgICB4MCA9IGNlbnRlclggKyAobm9ybVggLyBkaXN0KSAqIChkaXN0ICsgcGFkZGluZ1gpO1xuICAgICAgICB5MCA9IGNlbnRlclkgKyAobm9ybVkgLyBkaXN0KSAqIChkaXN0ICsgcGFkZGluZ1kpO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgbm9ybVggPSB4MSAtIGNlbnRlclg7XG4gICAgICAgIG5vcm1ZID0geTEgLSBjZW50ZXJZO1xuXG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQobm9ybVggKiBub3JtWCArIG5vcm1ZICogbm9ybVkpO1xuICAgICAgICB4MSA9IGNlbnRlclggKyAobm9ybVggLyBkaXN0KSAqIChkaXN0ICsgcGFkZGluZ1gpO1xuICAgICAgICB5MSA9IGNlbnRlclkgKyAobm9ybVkgLyBkaXN0KSAqIChkaXN0ICsgcGFkZGluZ1kpO1xuXG4gICAgICAgIG5vcm1YID0geDIgLSBjZW50ZXJYO1xuICAgICAgICBub3JtWSA9IHkyIC0gY2VudGVyWTtcblxuICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KG5vcm1YICogbm9ybVggKyBub3JtWSAqIG5vcm1ZKTtcbiAgICAgICAgeDIgPSBjZW50ZXJYICsgKG5vcm1YIC8gZGlzdCkgKiAoZGlzdCArIHBhZGRpbmdYKTtcbiAgICAgICAgeTIgPSBjZW50ZXJZICsgKG5vcm1ZIC8gZGlzdCkgKiAoZGlzdCArIHBhZGRpbmdZKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG5cbiAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICBjb250ZXh0LmNsaXAoKTtcblxuICAgIC8vIENvbXB1dGUgbWF0cml4IHRyYW5zZm9ybVxuICAgIHZhciBkZWx0YSA9ICAodTAgKiB2MSkgICAgICArICh2MCAqIHUyKSAgICAgICsgKHUxICogdjIpICAgICAgLSAodjEgKiB1MikgICAgICAtICh2MCAqIHUxKSAgICAgIC0gKHUwICogdjIpO1xuICAgIHZhciBkZWx0YUEgPSAoeDAgKiB2MSkgICAgICArICh2MCAqIHgyKSAgICAgICsgKHgxICogdjIpICAgICAgLSAodjEgKiB4MikgICAgICAtICh2MCAqIHgxKSAgICAgIC0gKHgwICogdjIpO1xuICAgIHZhciBkZWx0YUIgPSAodTAgKiB4MSkgICAgICArICh4MCAqIHUyKSAgICAgICsgKHUxICogeDIpICAgICAgLSAoeDEgKiB1MikgICAgICAtICh4MCAqIHUxKSAgICAgIC0gKHUwICogeDIpO1xuICAgIHZhciBkZWx0YUMgPSAodTAgKiB2MSAqIHgyKSArICh2MCAqIHgxICogdTIpICsgKHgwICogdTEgKiB2MikgLSAoeDAgKiB2MSAqIHUyKSAtICh2MCAqIHUxICogeDIpIC0gKHUwICogeDEgKiB2Mik7XG4gICAgdmFyIGRlbHRhRCA9ICh5MCAqIHYxKSAgICAgICsgKHYwICogeTIpICAgICAgKyAoeTEgKiB2MikgICAgICAtICh2MSAqIHkyKSAgICAgIC0gKHYwICogeTEpICAgICAgLSAoeTAgKiB2Mik7XG4gICAgdmFyIGRlbHRhRSA9ICh1MCAqIHkxKSAgICAgICsgKHkwICogdTIpICAgICAgKyAodTEgKiB5MikgICAgICAtICh5MSAqIHUyKSAgICAgIC0gKHkwICogdTEpICAgICAgLSAodTAgKiB5Mik7XG4gICAgdmFyIGRlbHRhRiA9ICh1MCAqIHYxICogeTIpICsgKHYwICogeTEgKiB1MikgKyAoeTAgKiB1MSAqIHYyKSAtICh5MCAqIHYxICogdTIpIC0gKHYwICogdTEgKiB5MikgLSAodTAgKiB5MSAqIHYyKTtcblxuICAgIGNvbnRleHQudHJhbnNmb3JtKGRlbHRhQSAvIGRlbHRhLCBkZWx0YUQgLyBkZWx0YSxcbiAgICAgICAgZGVsdGFCIC8gZGVsdGEsIGRlbHRhRSAvIGRlbHRhLFxuICAgICAgICBkZWx0YUMgLyBkZWx0YSwgZGVsdGFGIC8gZGVsdGEpO1xuXG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZVNvdXJjZSwgMCwgMCk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG59O1xuXG5cblxuLyoqXG4gKiBSZW5kZXJzIGEgZmxhdCBNZXNoXG4gKlxuICogQHBhcmFtIE1lc2gge01lc2h9IFRoZSBNZXNoIHRvIHJlbmRlclxuICogQHByaXZhdGVcbiAqL1xuTWVzaC5wcm90b3R5cGUucmVuZGVyTWVzaEZsYXQgPSBmdW5jdGlvbiAoTWVzaClcbntcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICB2YXIgdmVydGljZXMgPSBNZXNoLnZlcnRpY2VzO1xuXG4gICAgdmFyIGxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aC8yO1xuICAgIC8vIHRoaXMuY291bnQrKztcblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgZm9yICh2YXIgaT0xOyBpIDwgbGVuZ3RoLTI7IGkrKylcbiAgICB7XG4gICAgICAgIC8vIGRyYXcgc29tZSB0cmlhbmdsZXMhXG4gICAgICAgIHZhciBpbmRleCA9IGkqMjtcblxuICAgICAgICB2YXIgeDAgPSB2ZXJ0aWNlc1tpbmRleF0sICAgeDEgPSB2ZXJ0aWNlc1tpbmRleCsyXSwgeDIgPSB2ZXJ0aWNlc1tpbmRleCs0XTtcbiAgICAgICAgdmFyIHkwID0gdmVydGljZXNbaW5kZXgrMV0sIHkxID0gdmVydGljZXNbaW5kZXgrM10sIHkyID0gdmVydGljZXNbaW5kZXgrNV07XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjRkYwMDAwJztcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuLypcbk1lc2gucHJvdG90eXBlLnNldFRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSlcbntcbiAgICAvL1RPRE8gU0VUIFRIRSBURVhUVVJFU1xuICAgIC8vVE9ETyBWSVNJQklMSVRZXG4gICAgLy9UT0RPIFNFVFRFUlxuXG4gICAgLy8gc3RvcCBjdXJyZW50IHRleHR1cmVcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIHRoaXMud2lkdGggICA9IHRleHR1cmUuZnJhbWUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgID0gdGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gICAgdGhpcy51cGRhdGVGcmFtZSA9IHRydWU7XG59O1xuICovXG5cbi8qKlxuICogV2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkLCB0aGlzIGV2ZW50IHdpbGwgZmlyZSB0byB1cGRhdGUgdGhlIHNjYWxlIGFuZCBmcmFtZVxuICpcbiAqIEBwYXJhbSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuXG5NZXNoLnByb3RvdHlwZS5vblRleHR1cmVVcGRhdGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMudXBkYXRlRnJhbWUgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIG1lc2ggYXMgYSByZWN0YW5nbGUuIFRoZSBib3VuZHMgY2FsY3VsYXRpb24gdGFrZXMgdGhlIHdvcmxkVHJhbnNmb3JtIGludG8gYWNjb3VudC5cbiAqXG4gKiBAcGFyYW0gbWF0cml4IHtNYXRyaXh9IHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIHNwcml0ZVxuICogQHJldHVybiB7UmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcbiAqL1xuTWVzaC5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKG1hdHJpeClcbntcbiAgICB2YXIgd29ybGRUcmFuc2Zvcm0gPSBtYXRyaXggfHwgdGhpcy53b3JsZFRyYW5zZm9ybTtcblxuICAgIHZhciBhID0gd29ybGRUcmFuc2Zvcm0uYTtcbiAgICB2YXIgYiA9IHdvcmxkVHJhbnNmb3JtLmI7XG4gICAgdmFyIGMgPSB3b3JsZFRyYW5zZm9ybS5jO1xuICAgIHZhciBkID0gd29ybGRUcmFuc2Zvcm0uZDtcbiAgICB2YXIgdHggPSB3b3JsZFRyYW5zZm9ybS50eDtcbiAgICB2YXIgdHkgPSB3b3JsZFRyYW5zZm9ybS50eTtcblxuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuXG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IG47IGkgKz0gMilcbiAgICB7XG4gICAgICAgIHZhciByYXdYID0gdmVydGljZXNbaV0sIHJhd1kgPSB2ZXJ0aWNlc1tpICsgMV07XG4gICAgICAgIHZhciB4ID0gKGEgKiByYXdYKSArIChjICogcmF3WSkgKyB0eDtcbiAgICAgICAgdmFyIHkgPSAoZCAqIHJhd1kpICsgKGIgKiByYXdYKSArIHR5O1xuXG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcblxuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgfVxuXG4gICAgaWYgKG1pblggPT09IC1JbmZpbml0eSB8fCBtYXhZID09PSBJbmZpbml0eSlcbiAgICB7XG4gICAgICAgIHJldHVybiBjb3JlLm1hdGguUmVjdGFuZ2xlLkVNUFRZO1xuICAgIH1cblxuICAgIHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG5cbiAgICBib3VuZHMueCA9IG1pblg7XG4gICAgYm91bmRzLndpZHRoID0gbWF4WCAtIG1pblg7XG5cbiAgICBib3VuZHMueSA9IG1pblk7XG4gICAgYm91bmRzLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgLy8gc3RvcmUgYSByZWZlcmVuY2Ugc28gdGhhdCBpZiB0aGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGFnYWluIGluIHRoZSByZW5kZXIgY3ljbGUgd2UgZG8gbm90IGhhdmUgdG8gcmVjYWxjdWxhdGVcbiAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gYm91bmRzO1xuXG4gICAgcmV0dXJuIGJvdW5kcztcbn07XG5cbi8qKlxuICogRGlmZmVyZW50IGRyYXdpbmcgYnVmZmVyIG1vZGVzIHN1cHBvcnRlZFxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQHByb3BlcnR5IHtvYmplY3R9IERSQVdfTU9ERVNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLlRSSUFOR0xFX01FU0hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBEUkFXX01PREVTLlRSSUFOR0xFU1xuICovXG5NZXNoLkRSQVdfTU9ERVMgPSB7XG4gICAgVFJJQU5HTEVfTUVTSDogMCxcbiAgICBUUklBTkdMRVM6IDFcbn07XG4iLCJ2YXIgTWVzaCA9IHJlcXVpcmUoJy4vTWVzaCcpO1xuXG4vKipcbiAqIFRoZSByb3BlIGFsbG93cyB5b3UgdG8gZHJhdyBhIHRleHR1cmUgYWNyb3NzIHNldmVyYWwgcG9pbnRzIGFuZCB0aGVtIG1hbmlwdWxhdGUgdGhlc2UgcG9pbnRzXG4gKlxuICpgYGBqc1xuICogZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gKiAgICAgcG9pbnRzLnB1c2gobmV3IFBJWEkuUG9pbnQoaSAqIDUwLCAwKSk7XG4gKiB9O1xuICogdmFyIHJvcGUgPSBuZXcgUElYSS5Sb3BlKFBJWEkuVGV4dHVyZS5mcm9tSW1hZ2UoXCJzbmFrZS5wbmdcIiksIHBvaW50cyk7XG4gKiAgYGBgXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBNZXNoXG4gKiBAbWVtYmVyb2YgUElYSS5tZXNoXG4gKiBAcGFyYW0ge1RleHR1cmV9IHRleHR1cmUgLSBUaGUgdGV4dHVyZSB0byB1c2Ugb24gdGhlIHJvcGUuXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgLSBBbiBhcnJheSBvZiB7UG9pbnR9IG9iamVjdHMgdG8gY29uc3RydWN0IHRoaXMgcm9wZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIFJvcGUodGV4dHVyZSwgcG9pbnRzKVxue1xuICAgIE1lc2guY2FsbCh0aGlzLCB0ZXh0dXJlKTtcblxuICAgIC8qXG4gICAgICogQG1lbWJlciB7QXJyYXl9IEFuIGFycmF5IG9mIHBvaW50cyB0aGF0IGRldGVybWluZSB0aGUgcm9wZVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgLypcbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9IEFuIGFycmF5IG9mIHZlcnRpY2VzIHVzZWQgdG8gY29uc3RydWN0IHRoaXMgcm9wZS5cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCk7XG5cbiAgICAvKlxuICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX0gVGhlIFdlYkdMIFV2cyBvZiB0aGUgcm9wZS5cbiAgICAgKi9cbiAgICB0aGlzLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuXG4gICAgLypcbiAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbG9yIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICB0aGlzLmNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuXG4gICAgLypcbiAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXNcbiAgICAgKi9cbiAgICB0aGlzLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuXG4gICAgdGhpcy5yZWZyZXNoKCk7XG59XG5cblxuLy8gY29uc3RydWN0b3JcblJvcGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNZXNoLnByb3RvdHlwZSk7XG5Sb3BlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvcGU7XG5tb2R1bGUuZXhwb3J0cyA9IFJvcGU7XG5cbi8qKlxuICogUmVmcmVzaGVzXG4gKlxuICovXG5Sb3BlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDEpXG4gICAge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHV2cyA9IHRoaXMudXZzO1xuXG4gICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gICAgdmFyIGNvbG9ycyA9IHRoaXMuY29sb3JzO1xuXG4gICAgLy8gdGhpcy5jb3VudCAtPSAwLjI7XG5cbiAgICB1dnNbMF0gPSAwO1xuICAgIHV2c1sxXSA9IDA7XG4gICAgdXZzWzJdID0gMDtcbiAgICB1dnNbM10gPSAxO1xuXG4gICAgY29sb3JzWzBdID0gMTtcbiAgICBjb2xvcnNbMV0gPSAxO1xuXG4gICAgaW5kaWNlc1swXSA9IDA7XG4gICAgaW5kaWNlc1sxXSA9IDE7XG5cbiAgICB2YXIgdG90YWwgPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBwb2ludCwgaW5kZXgsIGFtb3VudDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdG90YWw7IGkrKylcbiAgICB7XG4gICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICBpbmRleCA9IGkgKiA0O1xuICAgICAgICAvLyB0aW1lIHRvIGRvIHNvbWUgc21hcnQgZHJhd2luZyFcbiAgICAgICAgYW1vdW50ID0gaSAvICh0b3RhbC0xKTtcblxuICAgICAgICBpZiAoaSUyKVxuICAgICAgICB7XG4gICAgICAgICAgICB1dnNbaW5kZXhdID0gYW1vdW50O1xuICAgICAgICAgICAgdXZzW2luZGV4KzFdID0gMDtcblxuICAgICAgICAgICAgdXZzW2luZGV4KzJdID0gYW1vdW50O1xuICAgICAgICAgICAgdXZzW2luZGV4KzNdID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHV2c1tpbmRleF0gPSBhbW91bnQ7XG4gICAgICAgICAgICB1dnNbaW5kZXgrMV0gPSAwO1xuXG4gICAgICAgICAgICB1dnNbaW5kZXgrMl0gPSBhbW91bnQ7XG4gICAgICAgICAgICB1dnNbaW5kZXgrM10gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBpICogMjtcbiAgICAgICAgY29sb3JzW2luZGV4XSA9IDE7XG4gICAgICAgIGNvbG9yc1tpbmRleCsxXSA9IDE7XG5cbiAgICAgICAgaW5kZXggPSBpICogMjtcbiAgICAgICAgaW5kaWNlc1tpbmRleF0gPSBpbmRleDtcbiAgICAgICAgaW5kaWNlc1tpbmRleCArIDFdID0gaW5kZXggKyAxO1xuICAgIH1cbn07XG5cbi8qXG4gKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmdcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5Sb3BlLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblxuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMSlcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGFzdFBvaW50ID0gcG9pbnRzWzBdO1xuICAgIHZhciBuZXh0UG9pbnQ7XG4gICAgdmFyIHBlcnBYID0gMDtcbiAgICB2YXIgcGVycFkgPSAwO1xuXG4gICAgLy8gdGhpcy5jb3VudCAtPSAwLjI7XG5cbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHZhciB0b3RhbCA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIHBvaW50LCBpbmRleCwgcmF0aW8sIHBlcnBMZW5ndGgsIG51bTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKylcbiAgICB7XG4gICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICBpbmRleCA9IGkgKiA0O1xuXG4gICAgICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbaSsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcGVycFkgPSAtKG5leHRQb2ludC54IC0gbGFzdFBvaW50LngpO1xuICAgICAgICBwZXJwWCA9IG5leHRQb2ludC55IC0gbGFzdFBvaW50Lnk7XG5cbiAgICAgICAgcmF0aW8gPSAoMSAtIChpIC8gKHRvdGFsLTEpKSkgKiAxMDtcblxuICAgICAgICBpZiAocmF0aW8gPiAxKVxuICAgICAgICB7XG4gICAgICAgICAgICByYXRpbyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBwZXJwTGVuZ3RoID0gTWF0aC5zcXJ0KHBlcnBYICogcGVycFggKyBwZXJwWSAqIHBlcnBZKTtcbiAgICAgICAgbnVtID0gdGhpcy50ZXh0dXJlLmhlaWdodCAvIDI7IC8vKDIwICsgTWF0aC5hYnMoTWF0aC5zaW4oKGkgKyB0aGlzLmNvdW50KSAqIDAuMykgKiA1MCkgKSogcmF0aW87XG4gICAgICAgIHBlcnBYIC89IHBlcnBMZW5ndGg7XG4gICAgICAgIHBlcnBZIC89IHBlcnBMZW5ndGg7XG5cbiAgICAgICAgcGVycFggKj0gbnVtO1xuICAgICAgICBwZXJwWSAqPSBudW07XG5cbiAgICAgICAgdmVydGljZXNbaW5kZXhdID0gcG9pbnQueCArIHBlcnBYO1xuICAgICAgICB2ZXJ0aWNlc1tpbmRleCsxXSA9IHBvaW50LnkgKyBwZXJwWTtcbiAgICAgICAgdmVydGljZXNbaW5kZXgrMl0gPSBwb2ludC54IC0gcGVycFg7XG4gICAgICAgIHZlcnRpY2VzW2luZGV4KzNdID0gcG9pbnQueSAtIHBlcnBZO1xuXG4gICAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICAgIH1cblxuICAgIHRoaXMuY29udGFpbmVyVXBkYXRlVHJhbnNmb3JtKCk7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSAgICAgICAgTWFpbiBleHBvcnQgb2YgdGhlIFBJWEkgZXh0cmFzIGxpYnJhcnlcbiAqIEBhdXRob3IgICAgICBNYXQgR3JvdmVzIDxtYXRAZ29vZGJveWRpZ2l0YWwuY29tPlxuICogQGNvcHlyaWdodCAgIDIwMTMtMjAxNSBHb29kQm95RGlnaXRhbFxuICogQGxpY2Vuc2UgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vR29vZEJveURpZ2l0YWwvcGl4aS5qcy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVCBMaWNlbnNlfVxuICovXG5cbi8qKlxuICogQG5hbWVzcGFjZSBQSVhJLm1lc2hcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWVzaDogICAgICAgICAgIHJlcXVpcmUoJy4vTWVzaCcpLFxuICAgIFJvcGU6ICAgICAgICAgICByZXF1aXJlKCcuL1JvcGUnKSxcbiAgICBNZXNoUmVuZGVyZXI6ICAgcmVxdWlyZSgnLi93ZWJnbC9NZXNoUmVuZGVyZXInKSxcbiAgICBNZXNoU2hhZGVyOiAgICAgcmVxdWlyZSgnLi93ZWJnbC9NZXNoU2hhZGVyJylcbn07XG4iLCJ2YXIgT2JqZWN0UmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3JlbmRlcmVycy93ZWJnbC91dGlscy9PYmplY3RSZW5kZXJlcicpLFxuICAgIFdlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3JlbmRlcmVycy93ZWJnbC9XZWJHTFJlbmRlcmVyJyk7XG5cbi8qKlxuICogQGF1dGhvciBNYXQgR3JvdmVzXG4gKlxuICogQmlnIHRoYW5rcyB0byB0aGUgdmVyeSBjbGV2ZXIgTWF0dCBEZXNMYXVyaWVycyA8bWF0dGRlc2w+IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9cbiAqIGZvciBjcmVhdGluZyB0aGUgb3JpZ2luYWwgcGl4aSB2ZXJzaW9uIVxuICogQWxzbyBhIHRoYW5rcyB0byBodHRwczovL2dpdGh1Yi5jb20vYmNoZXZhbGllciBmb3IgdHdlYWtpbmcgdGhlIHRpbnQgYW5kIGFscGhhIHNvIHRoYXQgdGhleSBub3cgc2hhcmUgNCBieXRlcyBvbiB0aGUgdmVydGV4IGJ1ZmZlclxuICpcbiAqIEhlYXZpbHkgaW5zcGlyZWQgYnkgTGliR0RYJ3MgTWVzaFJlbmRlcmVyOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi9tYXN0ZXIvZ2R4L3NyYy9jb20vYmFkbG9naWMvZ2R4L2dyYXBoaWNzL2cyZC9NZXNoUmVuZGVyZXIuamF2YVxuICovXG5cbi8qKlxuICpcbiAqIEBjbGFzc1xuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBQSVhJLm1lc2hcbiAqIEBleHRlbmRzIE9iamVjdFJlbmRlcmVyXG4gKiBAcGFyYW0gcmVuZGVyZXIge1dlYkdMUmVuZGVyZXJ9IFRoZSByZW5kZXJlciB0aGlzIHNwcml0ZSBiYXRjaCB3b3JrcyBmb3IuXG4gKi9cbmZ1bmN0aW9uIE1lc2hSZW5kZXJlcihyZW5kZXJlcilcbntcbiAgICBPYmplY3RSZW5kZXJlci5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcblxuXG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIGluZGljZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSgxNTAwMCk7XG5cbiAgICAvL1RPRE8gdGhpcyBjb3VsZCBiZSBhIHNpbmdsZSBidWZmZXIgc2hhcmVkIGFtb25nc3QgYWxsIHJlbmRlcmVycyBhcyB3ZSByZXVzZSB0aGlzIHNldCB1cCBpbiBtb3N0IHJlbmRlcmVyc1xuICAgIGZvciAodmFyIGk9MCwgaj0wOyBpIDwgMTUwMDA7IGkgKz0gNiwgaiArPSA0KVxuICAgIHtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAwXSA9IGogKyAwO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDFdID0gaiArIDE7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgMl0gPSBqICsgMjtcbiAgICAgICAgdGhpcy5pbmRpY2VzW2kgKyAzXSA9IGogKyAwO1xuICAgICAgICB0aGlzLmluZGljZXNbaSArIDRdID0gaiArIDI7XG4gICAgICAgIHRoaXMuaW5kaWNlc1tpICsgNV0gPSBqICsgMztcbiAgICB9XG59XG5cbk1lc2hSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdFJlbmRlcmVyLnByb3RvdHlwZSk7XG5NZXNoUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaFJlbmRlcmVyO1xubW9kdWxlLmV4cG9ydHMgPSBNZXNoUmVuZGVyZXI7XG5cbldlYkdMUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ21lc2gnLCBNZXNoUmVuZGVyZXIpO1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gdGhlIGN1cnJlbnQgV2ViR0wgZHJhd2luZyBjb250ZXh0XG4gKi9cbk1lc2hSZW5kZXJlci5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlID0gZnVuY3Rpb24gKClcbntcblxufTtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzcHJpdGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBtZXNoIHtNZXNofSB0aGUgbWVzaCB0byByZW5kZXJcbiAqL1xuTWVzaFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAobWVzaClcbntcbi8vICAgIHJldHVybjtcbiAgICBpZighbWVzaC5fdmVydGV4QnVmZmVyKVxuICAgIHtcbiAgICAgICAgdGhpcy5faW5pdFdlYkdMKG1lc2gpO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgIGdsID0gcmVuZGVyZXIuZ2wsXG4gICAgICAgIHRleHR1cmUgPSBtZXNoLnRleHR1cmUuYmFzZVRleHR1cmUsXG4gICAgICAgIHNoYWRlciA9IHJlbmRlcmVyLnNoYWRlck1hbmFnZXIucGx1Z2lucy5tZXNoU2hhZGVyO1xuXG4vLyAgICB2YXIgZHJhd01vZGUgPSBtZXNoLmRyYXdNb2RlID09PSBTdHJpcC5EUkFXX01PREVTLlRSSUFOR0xFX1NUUklQID8gZ2wuVFJJQU5HTEVfU1RSSVAgOiBnbC5UUklBTkdMRVM7XG4gICAgdmFyIGRyYXdNb2RlID0gIGdsLlRSSUFOR0xFX1NUUklQO1xuXG4gICAgcmVuZGVyZXIuYmxlbmRNb2RlTWFuYWdlci5zZXRCbGVuZE1vZGUobWVzaC5ibGVuZE1vZGUpO1xuXG5cbiAgICAvLyBzZXQgdW5pZm9ybXNcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeC5fbG9jYXRpb24sIGZhbHNlLCBtZXNoLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSkpO1xuXG4gICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC5fbG9jYXRpb24sIGZhbHNlLCByZW5kZXJlci5jdXJyZW50UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgudG9BcnJheSh0cnVlKSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51bmlmb3Jtcy5hbHBoYS5fbG9jYXRpb24sIG1lc2gud29ybGRBbHBoYSk7XG5cbiAgICBpZiAoIW1lc2guZGlydHkpXG4gICAge1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLl92ZXJ0ZXhCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgbWVzaC52ZXJ0aWNlcyk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB1dnNcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG1lc2guX3V2QnVmZmVyKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG5cbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cbiAgICAgICBpZiAoIXRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBiaW5kIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbZ2wuaWRdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuXG4gICAgICAgIG1lc2guZGlydHkgPSBmYWxzZTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG1lc2guX3ZlcnRleEJ1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLnZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdXZzXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLl91dkJ1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLnV2cywgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblxuICAgICAgIGlmICghdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIGN1cnJlbnQgdGV4dHVyZVxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fZ2xUZXh0dXJlc1tnbC5pZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9udCBuZWVkIHRvIHVwbG9hZCFcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbWVzaC5faW5kZXhCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBtZXNoLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIH1cblxuICAgIGdsLmRyYXdFbGVtZW50cyhkcmF3TW9kZSwgbWVzaC5pbmRpY2VzLmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuXG59O1xuXG4vKipcbiAqIFByZXBhcmVzIGFsbCB0aGUgYnVmZmVycyB0byByZW5kZXIgdGhpcyBtZXNoXG4gKiBAcGFyYW0gbWVzaCB7TWVzaH0gdGhlIG1lc2ggdG8gcmVuZGVyXG4gKi9cbk1lc2hSZW5kZXJlci5wcm90b3R5cGUuX2luaXRXZWJHTCA9IGZ1bmN0aW9uIChtZXNoKVxue1xuICAgIC8vIGJ1aWxkIHRoZSBzdHJpcCFcbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuXG4gICAgbWVzaC5fdmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgbWVzaC5faW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBtZXNoLl91dkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIG1lc2guX2NvbG9yQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbWVzaC5fdmVydGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbWVzaC52ZXJ0aWNlcywgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLl91dkJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsICBtZXNoLnV2cywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG1lc2guX2NvbG9yQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbWVzaC5jb2xvcnMsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG1lc2guX2luZGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBtZXNoLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcbn07XG5cblxuLyoqXG4gKiBFbXB0aWVzIHRoZSBjdXJyZW50IGJhdGNoLlxuICpcbiAqL1xuTWVzaFJlbmRlcmVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpXG57XG5cbn07XG5cbi8qKlxuICogU3RhcnRzIGEgbmV3IG1lc2ggcmVuZGVyZXIuXG4gKlxuICovXG5NZXNoUmVuZGVyZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgc2hhZGVyID0gdGhpcy5yZW5kZXJlci5zaGFkZXJNYW5hZ2VyLnBsdWdpbnMubWVzaFNoYWRlcjtcblxuICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyTWFuYWdlci5zZXRTaGFkZXIoc2hhZGVyKTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIE1lc2ggcmVuZGVyZXJcbiAqXG4gKi9cbk1lc2hSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG59O1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlJyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBTaGFkZXJcbiAqIEBtZW1iZXJvZiBQSVhJLm1lc2hcbiAqIEBwYXJhbSBzaGFkZXJNYW5hZ2VyIHtTaGFkZXJNYW5hZ2VyfSBUaGUgV2ViR0wgc2hhZGVyIG1hbmFnZXIgdGhpcyBzaGFkZXIgd29ya3MgZm9yLlxuICovXG5mdW5jdGlvbiBTdHJpcFNoYWRlcihzaGFkZXJNYW5hZ2VyKVxue1xuICAgIGNvcmUuU2hhZGVyLmNhbGwodGhpcyxcbiAgICAgICAgc2hhZGVyTWFuYWdlcixcbiAgICAgICAgLy8gdmVydGV4IHNoYWRlclxuICAgICAgICBbXG4gICAgICAgICAgICAncHJlY2lzaW9uIGxvd3AgZmxvYXQ7JyxcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247JyxcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkOycsXG5cbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsnLFxuXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcblxuICAgICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxuICAgICAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7JyxcbiAgICAgICAgICAgICcgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIFtcbiAgICAgICAgICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxuXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGFscGhhOycsXG5cbiAgICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjsnLFxuXG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpeycsXG4gICAgICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIGFscGhhIDsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIC8vIGN1c3RvbSB1bmlmb3Jtc1xuICAgICAgICB7XG4gICAgICAgICAgICBhbHBoYTogIHsgdHlwZTogJzFmJywgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiB7IHR5cGU6ICdtYXQzJywgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoOSkgfSxcbiAgICAgICAgICAgIHByb2plY3Rpb25NYXRyaXg6IHsgdHlwZTogJ21hdDMnLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg5KSB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGN1c3RvbSBhdHRyaWJ1dGVzXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFWZXJ0ZXhQb3NpdGlvbjowLFxuICAgICAgICAgICAgYVRleHR1cmVDb29yZDowXG4gICAgICAgIH1cbiAgICApO1xufVxuXG5TdHJpcFNoYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvcmUuU2hhZGVyLnByb3RvdHlwZSk7XG5TdHJpcFNoYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdHJpcFNoYWRlcjtcbm1vZHVsZS5leHBvcnRzID0gU3RyaXBTaGFkZXI7XG5cbmNvcmUuU2hhZGVyTWFuYWdlci5yZWdpc3RlclBsdWdpbignbWVzaFNoYWRlcicsIFN0cmlwU2hhZGVyKTtcbiIsIi8vIFJlZmVyZW5jZXM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL29iamVjdC1hc3NpZ25cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cblxuaWYgKCFPYmplY3QuYXNzaWduKVxue1xuICAgIE9iamVjdC5hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG59XG4iLCJyZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnJlcXVpcmUoJy4vcmVxdWVzdEFuaW1hdGlvbkZyYW1lJyk7XG4iLCIvLyBSZWZlcmVuY2VzOlxuLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE1Nzk2NzFcbi8vIGh0dHA6Ly91cGRhdGVzLmh0bWw1cm9ja3MuY29tLzIwMTIvMDUvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLUFQSS1ub3ctd2l0aC1zdWItbWlsbGlzZWNvbmQtcHJlY2lzaW9uXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS90aW1oYWxsLzQwNzg2MTRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9GaW5hbmNpYWwtVGltZXMvcG9seWZpbGwtc2VydmljZS90cmVlL21hc3Rlci9wb2x5ZmlsbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cbi8vIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCBCcm93c2VyZml5XG4vLyBCcm93c2VyaWZ5IGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyB0aGUgdXNlIG9mIGBnbG9iYWxgIGFuZCBwYXNzZXMgdGhlXG4vLyBjb3JyZWN0IHJlZmVyZW5jZSBvZiBgZ2xvYmFsYCwgYHNlbGZgLCBhbmQgZmluYWxseSBgd2luZG93YFxuXG4vLyBEYXRlLm5vd1xuaWYgKCEoRGF0ZS5ub3cgJiYgRGF0ZS5wcm90b3R5cGUuZ2V0VGltZSkpIHtcbiAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG59XG5cbi8vIHBlcmZvcm1hbmNlLm5vd1xuaWYgKCEoZ2xvYmFsLnBlcmZvcm1hbmNlICYmIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cpKSB7XG4gICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgaWYgKCFnbG9iYWwucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgZ2xvYmFsLnBlcmZvcm1hbmNlID0ge307XG4gICAgfVxuICAgIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIH07XG59XG5cbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZVxudmFyIGxhc3RUaW1lID0gRGF0ZS5ub3coKTtcbnZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcblxuZm9yKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fFxuICAgICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbn1cblxuaWYgKCFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJ2lzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZGVsYXkgPSAxNiArIGxhc3RUaW1lIC0gY3VycmVudFRpbWU7XG5cbiAgICAgICAgaWYgKGRlbGF5IDwgMCkge1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFRpbWUgPSBjdXJyZW50VGltZTtcblxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsYXN0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBjYWxsYmFjayhnbG9iYWwucGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfTtcbn1cblxuaWYgKCFnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG59XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKSxcbiAgICBzcGluZSA9IHJlcXVpcmUoJy4vU3BpbmVSdW50aW1lJyk7XG5cbi8qIEVzb3RlcmljIFNvZnR3YXJlIFNQSU5FIHdyYXBwZXIgZm9yIHBpeGkuanMgKi9cblxuc3BpbmUuQm9uZS55RG93biA9IHRydWU7XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGVuYWJsZXMgdGhlIHlvdSB0byBpbXBvcnQgYW5kIHJ1biB5b3VyIHNwaW5lIGFuaW1hdGlvbnMgaW4gcGl4aS5cbiAqIFRoZSBTcGluZSBhbmltYXRpb24gZGF0YSBuZWVkcyB0byBiZSBsb2FkZWQgdXNpbmcgZWl0aGVyIHRoZSBMb2FkZXIgb3IgYSBTcGluZUxvYWRlciBiZWZvcmUgaXQgY2FuIGJlIHVzZWQgYnkgdGhpcyBjbGFzc1xuICogU2VlIGV4YW1wbGUgMTIgKGh0dHA6Ly93d3cuZ29vZGJveWRpZ2l0YWwuY29tL3BpeGlqcy9leGFtcGxlcy8xMi8pIHRvIHNlZSBhIHdvcmtpbmcgZXhhbXBsZSBhbmQgY2hlY2sgb3V0IHRoZSBzb3VyY2VcbiAqXG4gKiBgYGBqc1xuICogdmFyIHNwaW5lQW5pbWF0aW9uID0gbmV3IFBJWEkuU3BpbmUoc3BpbmVEYXRhKTtcbiAqIGBgYFxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgQ29udGFpbmVyXG4gKiBAbWVtYmVyb2YgUElYSS5zcGluZVxuICogQHBhcmFtIHNwaW5lRGF0YSB7b2JqZWN0fSBUaGUgc3BpbmUgZGF0YSBsb2FkZWQgZnJvbSBhIHNwaW5lIGF0bGFzLlxuICovXG5mdW5jdGlvbiBTcGluZShzcGluZURhdGEpXG57XG4gICAgY29yZS5Db250YWluZXIuY2FsbCh0aGlzKTtcblxuICAgIGlmICghc3BpbmVEYXRhKVxuICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3BpbmVEYXRhIHBhcmFtIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzcGluZURhdGEgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5zcGluZURhdGEgPSBzcGluZURhdGE7XG5cbiAgICAvKipcbiAgICAgKiBBIHNwaW5lIFNrZWxldG9uIG9iamVjdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuc2tlbGV0b24gPSBuZXcgc3BpbmUuU2tlbGV0b24oc3BpbmVEYXRhKTtcbiAgICB0aGlzLnNrZWxldG9uLnVwZGF0ZVdvcmxkVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBBIHNwaW5lIEFuaW1hdGlvblN0YXRlRGF0YSBvYmplY3QgY3JlYXRlZCBmcm9tIHRoZSBzcGluZSBkYXRhIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlRGF0YSA9IG5ldyBzcGluZS5BbmltYXRpb25TdGF0ZURhdGEoc3BpbmVEYXRhKTtcblxuICAgIC8qKlxuICAgICAqIEEgc3BpbmUgQW5pbWF0aW9uU3RhdGUgb2JqZWN0IGNyZWF0ZWQgZnJvbSB0aGUgc3BpbmUgQW5pbWF0aW9uU3RhdGVEYXRhIG9iamVjdFxuICAgICAqXG4gICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgc3BpbmUuQW5pbWF0aW9uU3RhdGUodGhpcy5zdGF0ZURhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgY29udGFpbmVyc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Q29udGFpbmVyW119XG4gICAgICovXG4gICAgdGhpcy5zbG90Q29udGFpbmVycyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLnNrZWxldG9uLmRyYXdPcmRlci5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuc2tlbGV0b24uZHJhd09yZGVyW2ldO1xuICAgICAgICB2YXIgYXR0YWNobWVudCA9IHNsb3QuYXR0YWNobWVudDtcbiAgICAgICAgdmFyIHNsb3RDb250YWluZXIgPSBuZXcgY29yZS5Db250YWluZXIoKTtcbiAgICAgICAgdGhpcy5zbG90Q29udGFpbmVycy5wdXNoKHNsb3RDb250YWluZXIpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHNsb3RDb250YWluZXIpO1xuXG4gICAgICAgIGlmIChhdHRhY2htZW50IGluc3RhbmNlb2Ygc3BpbmUuUmVnaW9uQXR0YWNobWVudClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHNwcml0ZU5hbWUgPSBhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0Lm5hbWU7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5jcmVhdGVTcHJpdGUoc2xvdCwgYXR0YWNobWVudCk7XG4gICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGUgPSBzcHJpdGU7XG4gICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGVOYW1lID0gc3ByaXRlTmFtZTtcbiAgICAgICAgICAgIHNsb3RDb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRhY2htZW50IGluc3RhbmNlb2Ygc3BpbmUuTWVzaEF0dGFjaG1lbnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBtZXNoID0gdGhpcy5jcmVhdGVNZXNoKHNsb3QsIGF0dGFjaG1lbnQpO1xuICAgICAgICAgICAgc2xvdC5jdXJyZW50TWVzaCA9IG1lc2g7XG4gICAgICAgICAgICBzbG90LmN1cnJlbnRNZXNoTmFtZSA9IGF0dGFjaG1lbnQubmFtZTtcbiAgICAgICAgICAgIHNsb3RDb250YWluZXIuYWRkQ2hpbGQobWVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRoZSBTcGluZSBvYmplY3QgdXBkYXRlIGl0cyB0cmFuc2Zvcm1zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG59XG5cblNwaW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY29yZS5Db250YWluZXIucHJvdG90eXBlKTtcblNwaW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwaW5lO1xubW9kdWxlLmV4cG9ydHMgPSBTcGluZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3BpbmUucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBmbGFnIGlzIHNldCB0byB0cnVlLCB0aGUgc3BpbmUgYW5pbWF0aW9uIHdpbGwgYmUgYXV0b3VwZGF0ZWQgZXZlcnkgdGltZVxuICAgICAqIHRoZSBvYmplY3QgaWQgZHJhd24uIFRoZSBkb3duIHNpZGUgb2YgdGhpcyBhcHByb2FjaCBpcyB0aGF0IHRoZSBkZWx0YSB0aW1lIGlzXG4gICAgICogYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGFuZCB5b3UgY291bGQgbWlzcyBvdXQgb24gY29vbCBlZmZlY3RzIGxpa2Ugc2xvdyBtb3Rpb24sXG4gICAgICogcGF1c2UsIHNraXAgYWhlYWQgYW5kIHRoZSBzb3J0cy4gTW9zdCBvZiB0aGVzZSBlZmZlY3RzIGNhbiBiZSBhY2hpZXZlZCBldmVuIHdpdGhcbiAgICAgKiBhdXRvdXBkYXRlIGVuYWJsZWQgYnV0IGFyZSBoYXJkZXIgdG8gYWNoaWV2ZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIFNwaW5lI1xuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBhdXRvVXBkYXRlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9PT0gU3BpbmUucHJvdG90eXBlLmF1dG9VcGRhdGVUcmFuc2Zvcm0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IHZhbHVlID8gU3BpbmUucHJvdG90eXBlLmF1dG9VcGRhdGVUcmFuc2Zvcm0gOiBjb3JlLkNvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogVXBkYXRlIHRoZSBzcGluZSBza2VsZXRvbiBhbmQgaXRzIGFuaW1hdGlvbnMgYnkgZGVsdGEgdGltZSAoZHQpXG4gKlxuICogQHBhcmFtIGR0IHtudW1iZXJ9IERlbHRhIHRpbWUuIFRpbWUgYnkgd2hpY2ggdGhlIGFuaW1hdGlvbiBzaG91bGQgYmUgdXBkYXRlZFxuICovXG5TcGluZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGR0KVxue1xuICAgIHRoaXMuc3RhdGUudXBkYXRlKGR0KTtcbiAgICB0aGlzLnN0YXRlLmFwcGx5KHRoaXMuc2tlbGV0b24pO1xuICAgIHRoaXMuc2tlbGV0b24udXBkYXRlV29ybGRUcmFuc2Zvcm0oKTtcblxuICAgIHZhciBkcmF3T3JkZXIgPSB0aGlzLnNrZWxldG9uLmRyYXdPcmRlcjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGRyYXdPcmRlci5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgc2xvdCA9IGRyYXdPcmRlcltpXTtcbiAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSBzbG90LmF0dGFjaG1lbnQ7XG4gICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gdGhpcy5zbG90Q29udGFpbmVyc1tpXTtcblxuICAgICAgICBpZiAoIWF0dGFjaG1lbnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNsb3RDb250YWluZXIudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHlwZSA9IGF0dGFjaG1lbnQudHlwZTtcbiAgICAgICAgaWYgKHR5cGUgPT09IHNwaW5lLkF0dGFjaG1lbnRUeXBlLnJlZ2lvbilcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKCFzbG90LmN1cnJlbnRTcHJpdGVOYW1lIHx8IHNsb3QuY3VycmVudFNwcml0ZU5hbWUgIT09IGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QubmFtZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGVOYW1lID0gYXR0YWNobWVudC5yZW5kZXJlck9iamVjdC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdC5jdXJyZW50U3ByaXRlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudFNwcml0ZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2xvdC5zcHJpdGVzID0gc2xvdC5zcHJpdGVzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdC5zcHJpdGVzW3Nwcml0ZU5hbWVdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Quc3ByaXRlc1tzcHJpdGVOYW1lXS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLmNyZWF0ZVNwcml0ZShzbG90LCBhdHRhY2htZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGUgPSBzbG90LnNwcml0ZXNbc3ByaXRlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudFNwcml0ZU5hbWUgPSBzcHJpdGVOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJvbmUgPSBzbG90LmJvbmU7XG5cbiAgICAgICAgICAgIHNsb3RDb250YWluZXIucG9zaXRpb24ueCA9IGJvbmUud29ybGRYICsgYXR0YWNobWVudC54ICogYm9uZS5tMDAgKyBhdHRhY2htZW50LnkgKiBib25lLm0wMTtcbiAgICAgICAgICAgIHNsb3RDb250YWluZXIucG9zaXRpb24ueSA9IGJvbmUud29ybGRZICsgYXR0YWNobWVudC54ICogYm9uZS5tMTAgKyBhdHRhY2htZW50LnkgKiBib25lLm0xMTtcbiAgICAgICAgICAgIHNsb3RDb250YWluZXIuc2NhbGUueCA9IGJvbmUud29ybGRTY2FsZVg7XG4gICAgICAgICAgICBzbG90Q29udGFpbmVyLnNjYWxlLnkgPSBib25lLndvcmxkU2NhbGVZO1xuXG4gICAgICAgICAgICBzbG90Q29udGFpbmVyLnJvdGF0aW9uID0gLShzbG90LmJvbmUud29ybGRSb3RhdGlvbiAqIHNwaW5lLmRlZ1JhZCk7XG5cbiAgICAgICAgICAgIHNsb3QuY3VycmVudFNwcml0ZS50aW50ID0gY29yZS51dGlscy5yZ2IyaGV4KFtzbG90LnIsc2xvdC5nLHNsb3QuYl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IHNwaW5lLkF0dGFjaG1lbnRUeXBlLnNraW5uZWRtZXNoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXNsb3QuY3VycmVudE1lc2hOYW1lIHx8IHNsb3QuY3VycmVudE1lc2hOYW1lICE9PSBhdHRhY2htZW50Lm5hbWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc2hOYW1lID0gYXR0YWNobWVudC5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChzbG90LmN1cnJlbnRNZXNoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRNZXNoLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzbG90Lm1lc2hlcyA9IHNsb3QubWVzaGVzIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHNsb3QubWVzaGVzW21lc2hOYW1lXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2xvdC5tZXNoZXNbbWVzaE5hbWVdLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzaCA9IHRoaXMuY3JlYXRlTWVzaChzbG90LCBhdHRhY2htZW50KTtcbiAgICAgICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lci5hZGRDaGlsZChtZXNoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzbG90LmN1cnJlbnRNZXNoID0gc2xvdC5tZXNoZXNbbWVzaE5hbWVdO1xuICAgICAgICAgICAgICAgIHNsb3QuY3VycmVudE1lc2hOYW1lID0gbWVzaE5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF0dGFjaG1lbnQuY29tcHV0ZVdvcmxkVmVydGljZXMoc2xvdC5ib25lLnNrZWxldG9uLngsIHNsb3QuYm9uZS5za2VsZXRvbi55LCBzbG90LCBzbG90LmN1cnJlbnRNZXNoLnZlcnRpY2VzKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgc2xvdENvbnRhaW5lci52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzbG90Q29udGFpbmVyLnZpc2libGUgPSB0cnVlO1xuXG4gICAgICAgIHNsb3RDb250YWluZXIuYWxwaGEgPSBzbG90LmE7XG4gICAgfVxufTtcblxuLyoqXG4gKiBXaGVuIGF1dG91cGRhdGUgaXMgc2V0IHRvIHllcyB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgYXMgcGl4aSdzIHVwZGF0ZVRyYW5zZm9ybSBmdW5jdGlvblxuICpcbiAqIEBwcml2YXRlXG4gKi9cblNwaW5lLnByb3RvdHlwZS5hdXRvVXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmxhc3RUaW1lID0gdGhpcy5sYXN0VGltZSB8fCBEYXRlLm5vdygpO1xuICAgIHZhciB0aW1lRGVsdGEgPSAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdFRpbWUpICogMC4wMDE7XG4gICAgdGhpcy5sYXN0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICB0aGlzLnVwZGF0ZSh0aW1lRGVsdGEpO1xuXG4gICAgY29yZS5Db250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3ByaXRlIHRvIGJlIHVzZWQgd2l0aCBzcGluZS5SZWdpb25BdHRhY2htZW50XG4gKlxuICogQHBhcmFtIHNsb3Qge3NwaW5lLlNsb3R9IFRoZSBzbG90IHRvIHdoaWNoIHRoZSBhdHRhY2htZW50IGlzIHBhcmVudGVkXG4gKiBAcGFyYW0gYXR0YWNobWVudCB7c3BpbmUuUmVnaW9uQXR0YWNobWVudH0gVGhlIGF0dGFjaG1lbnQgdGhhdCB0aGUgc3ByaXRlIHdpbGwgcmVwcmVzZW50XG4gKiBAcHJpdmF0ZVxuICovXG5TcGluZS5wcm90b3R5cGUuY3JlYXRlU3ByaXRlID0gZnVuY3Rpb24gKHNsb3QsIGF0dGFjaG1lbnQpXG57XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0O1xuICAgIHZhciBiYXNlVGV4dHVyZSA9IGRlc2NyaXB0b3IucGFnZS5yZW5kZXJlck9iamVjdDtcbiAgICB2YXIgc3ByaXRlUmVjdCA9IG5ldyBjb3JlLm1hdGguUmVjdGFuZ2xlKGRlc2NyaXB0b3IueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvci5yb3RhdGUgPyBkZXNjcmlwdG9yLmhlaWdodCA6IGRlc2NyaXB0b3Iud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvci5yb3RhdGUgPyBkZXNjcmlwdG9yLndpZHRoIDogZGVzY3JpcHRvci5oZWlnaHQpO1xuICAgIHZhciBzcHJpdGVUZXh0dXJlID0gbmV3IGNvcmUuVGV4dHVyZShiYXNlVGV4dHVyZSwgc3ByaXRlUmVjdCk7XG4gICAgdmFyIHNwcml0ZSA9IG5ldyBjb3JlLlNwcml0ZShzcHJpdGVUZXh0dXJlKTtcblxuICAgIHZhciBiYXNlUm90YXRpb24gPSBkZXNjcmlwdG9yLnJvdGF0ZSA/IE1hdGguUEkgKiAwLjUgOiAwLjA7XG4gICAgc3ByaXRlLnNjYWxlLnNldChkZXNjcmlwdG9yLndpZHRoIC8gZGVzY3JpcHRvci5vcmlnaW5hbFdpZHRoLCBkZXNjcmlwdG9yLmhlaWdodCAvIGRlc2NyaXB0b3Iub3JpZ2luYWxIZWlnaHQpO1xuICAgIHNwcml0ZS5yb3RhdGlvbiA9IGJhc2VSb3RhdGlvbiAtIChhdHRhY2htZW50LnJvdGF0aW9uICogc3BpbmUuZGVnUmFkKTtcbiAgICBzcHJpdGUuYW5jaG9yLnggPSBzcHJpdGUuYW5jaG9yLnkgPSAwLjU7XG5cbiAgICBzbG90LnNwcml0ZXMgPSBzbG90LnNwcml0ZXMgfHwge307XG4gICAgc2xvdC5zcHJpdGVzW2Rlc2NyaXB0b3IubmFtZV0gPSBzcHJpdGU7XG4gICAgcmV0dXJuIHNwcml0ZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFN0cmlwIGZyb20gdGhlIHNwaW5lIGRhdGFcbiAqIEBwYXJhbSBzbG90IHtzcGluZS5TbG90fSBUaGUgc2xvdCB0byB3aGljaCB0aGUgYXR0YWNobWVudCBpcyBwYXJlbnRlZFxuICogQHBhcmFtIGF0dGFjaG1lbnQge3NwaW5lLlJlZ2lvbkF0dGFjaG1lbnR9IFRoZSBhdHRhY2htZW50IHRoYXQgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxuICogQHByaXZhdGVcbiAqL1xuU3BpbmUucHJvdG90eXBlLmNyZWF0ZU1lc2ggPSBmdW5jdGlvbiAoc2xvdCwgYXR0YWNobWVudClcbntcbiAgICB2YXIgZGVzY3JpcHRvciA9IGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3Q7XG4gICAgdmFyIGJhc2VUZXh0dXJlID0gZGVzY3JpcHRvci5wYWdlLnJlbmRlcmVyT2JqZWN0O1xuICAgIHZhciB0ZXh0dXJlID0gbmV3IGNvcmUuVGV4dHVyZShiYXNlVGV4dHVyZSk7XG5cbiAgICB2YXIgc3RyaXAgPSBuZXcgY29yZS5TdHJpcCh0ZXh0dXJlKTtcbiAgICBzdHJpcC5kcmF3TW9kZSA9IGNvcmUuU3RyaXAuRFJBV19NT0RFUy5UUklBTkdMRVM7XG4gICAgc3RyaXAuY2FudmFzUGFkZGluZyA9IDEuNTtcblxuICAgIHN0cmlwLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShhdHRhY2htZW50LnV2cy5sZW5ndGgpO1xuICAgIHN0cmlwLnV2cyA9IGF0dGFjaG1lbnQudXZzO1xuICAgIHN0cmlwLmluZGljZXMgPSBhdHRhY2htZW50LnRyaWFuZ2xlcztcblxuICAgIHNsb3QubWVzaGVzID0gc2xvdC5tZXNoZXMgfHwge307XG4gICAgc2xvdC5tZXNoZXNbYXR0YWNobWVudC5uYW1lXSA9IHN0cmlwO1xuXG4gICAgcmV0dXJuIHN0cmlwO1xufTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFNwaW5lIFJ1bnRpbWVzIFNvZnR3YXJlIExpY2Vuc2VcbiAqIFZlcnNpb24gMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLCBFc290ZXJpYyBTb2Z0d2FyZVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBZb3UgYXJlIGdyYW50ZWQgYSBwZXJwZXR1YWwsIG5vbi1leGNsdXNpdmUsIG5vbi1zdWJsaWNlbnNhYmxlIGFuZFxuICogbm9uLXRyYW5zZmVyYWJsZSBsaWNlbnNlIHRvIGluc3RhbGwsIGV4ZWN1dGUgYW5kIHBlcmZvcm0gdGhlIFNwaW5lIFJ1bnRpbWVzXG4gKiBTb2Z0d2FyZSAodGhlIFwiU29mdHdhcmVcIikgc29sZWx5IGZvciBpbnRlcm5hbCB1c2UuIFdpdGhvdXQgdGhlIHdyaXR0ZW5cbiAqIHBlcm1pc3Npb24gb2YgRXNvdGVyaWMgU29mdHdhcmUgKHR5cGljYWxseSBncmFudGVkIGJ5IGxpY2Vuc2luZyBTcGluZSksIHlvdVxuICogbWF5IG5vdCAoYSkgbW9kaWZ5LCB0cmFuc2xhdGUsIGFkYXB0IG9yIG90aGVyd2lzZSBjcmVhdGUgZGVyaXZhdGl2ZSB3b3JrcyxcbiAqIGltcHJvdmVtZW50cyBvZiB0aGUgU29mdHdhcmUgb3IgZGV2ZWxvcCBuZXcgYXBwbGljYXRpb25zIHVzaW5nIHRoZSBTb2Z0d2FyZVxuICogb3IgKGIpIHJlbW92ZSwgZGVsZXRlLCBhbHRlciBvciBvYnNjdXJlIGFueSB0cmFkZW1hcmtzIG9yIGFueSBjb3B5cmlnaHQsXG4gKiB0cmFkZW1hcmssIHBhdGVudCBvciBvdGhlciBpbnRlbGxlY3R1YWwgcHJvcGVydHkgb3IgcHJvcHJpZXRhcnkgcmlnaHRzXG4gKiBub3RpY2VzIG9uIG9yIGluIHRoZSBTb2Z0d2FyZSwgaW5jbHVkaW5nIGFueSBjb3B5IHRoZXJlb2YuIFJlZGlzdHJpYnV0aW9uc1xuICogaW4gYmluYXJ5IG9yIHNvdXJjZSBmb3JtIG11c3QgaW5jbHVkZSB0aGlzIGxpY2Vuc2UgYW5kIHRlcm1zLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgRVNPVEVSSUMgU09GVFdBUkUgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUlxuICogSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk9cbiAqIEVWRU5UIFNIQUxMIEVTT1RFUklDIFNPRlRBUkUgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTO1xuICogT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUlxuICogT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRlxuICogQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuXG52YXIgc3BpbmUgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0cmFkRGVnOiAxODAgLyBNYXRoLlBJLFxuXHRkZWdSYWQ6IE1hdGguUEkgLyAxODAsXG5cdHRlbXA6IFtdLFxuICAgIEZsb2F0MzJBcnJheTogKHR5cGVvZihGbG9hdDMyQXJyYXkpID09PSAndW5kZWZpbmVkJykgPyBBcnJheSA6IEZsb2F0MzJBcnJheSxcbiAgICBVaW50MTZBcnJheTogKHR5cGVvZihVaW50MTZBcnJheSkgPT09ICd1bmRlZmluZWQnKSA/IEFycmF5IDogVWludDE2QXJyYXlcbn07XG5cbnNwaW5lLkJvbmVEYXRhID0gZnVuY3Rpb24gKG5hbWUsIHBhcmVudClcbntcblx0dGhpcy5uYW1lID0gbmFtZTtcblx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG59O1xuc3BpbmUuQm9uZURhdGEucHJvdG90eXBlID0ge1xuXHRsZW5ndGg6IDAsXG5cdHg6IDAsIHk6IDAsXG5cdHJvdGF0aW9uOiAwLFxuXHRzY2FsZVg6IDEsIHNjYWxlWTogMSxcblx0aW5oZXJpdFNjYWxlOiB0cnVlLFxuXHRpbmhlcml0Um90YXRpb246IHRydWUsXG5cdGZsaXBYOiBmYWxzZSwgZmxpcFk6IGZhbHNlXG59O1xuXG5zcGluZS5TbG90RGF0YSA9IGZ1bmN0aW9uIChuYW1lLCBib25lRGF0YSlcbntcblx0dGhpcy5uYW1lID0gbmFtZTtcblx0dGhpcy5ib25lRGF0YSA9IGJvbmVEYXRhO1xufTtcbnNwaW5lLlNsb3REYXRhLnByb3RvdHlwZSA9IHtcblx0cjogMSwgZzogMSwgYjogMSwgYTogMSxcblx0YXR0YWNobWVudE5hbWU6IG51bGwsXG5cdGFkZGl0aXZlQmxlbmRpbmc6IGZhbHNlXG59O1xuXG5zcGluZS5Ja0NvbnN0cmFpbnREYXRhID0gZnVuY3Rpb24gKG5hbWUpXG57XG5cdHRoaXMubmFtZSA9IG5hbWU7XG5cdHRoaXMuYm9uZXMgPSBbXTtcbn07XG5zcGluZS5Ja0NvbnN0cmFpbnREYXRhLnByb3RvdHlwZSA9IHtcblx0dGFyZ2V0OiBudWxsLFxuXHRiZW5kRGlyZWN0aW9uOiAxLFxuXHRtaXg6IDFcbn07XG5cbnNwaW5lLkJvbmUgPSBmdW5jdGlvbiAoYm9uZURhdGEsIHNrZWxldG9uLCBwYXJlbnQpXG57XG5cdHRoaXMuZGF0YSA9IGJvbmVEYXRhO1xuXHR0aGlzLnNrZWxldG9uID0gc2tlbGV0b247XG5cdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXHR0aGlzLnNldFRvU2V0dXBQb3NlKCk7XG59O1xuc3BpbmUuQm9uZS55RG93biA9IGZhbHNlO1xuc3BpbmUuQm9uZS5wcm90b3R5cGUgPSB7XG5cdHg6IDAsIHk6IDAsXG5cdHJvdGF0aW9uOiAwLCByb3RhdGlvbklLOiAwLFxuXHRzY2FsZVg6IDEsIHNjYWxlWTogMSxcblx0ZmxpcFg6IGZhbHNlLCBmbGlwWTogZmFsc2UsXG5cdG0wMDogMCwgbTAxOiAwLCB3b3JsZFg6IDAsIC8vIGEgYiB4XG5cdG0xMDogMCwgbTExOiAwLCB3b3JsZFk6IDAsIC8vIGMgZCB5XG5cdHdvcmxkUm90YXRpb246IDAsXG5cdHdvcmxkU2NhbGVYOiAxLCB3b3JsZFNjYWxlWTogMSxcblx0d29ybGRGbGlwWDogZmFsc2UsIHdvcmxkRmxpcFk6IGZhbHNlLFxuICAgIHVwZGF0ZVdvcmxkVHJhbnNmb3JtOiBmdW5jdGlvbiAoKVxuICAgIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgIHtcblx0XHRcdHRoaXMud29ybGRYID0gdGhpcy54ICogcGFyZW50Lm0wMCArIHRoaXMueSAqIHBhcmVudC5tMDEgKyBwYXJlbnQud29ybGRYO1xuXHRcdFx0dGhpcy53b3JsZFkgPSB0aGlzLnggKiBwYXJlbnQubTEwICsgdGhpcy55ICogcGFyZW50Lm0xMSArIHBhcmVudC53b3JsZFk7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmluaGVyaXRTY2FsZSlcbiAgICAgICAgICAgIHtcblx0XHRcdFx0dGhpcy53b3JsZFNjYWxlWCA9IHBhcmVudC53b3JsZFNjYWxlWCAqIHRoaXMuc2NhbGVYO1xuXHRcdFx0XHR0aGlzLndvcmxkU2NhbGVZID0gcGFyZW50LndvcmxkU2NhbGVZICogdGhpcy5zY2FsZVk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLndvcmxkU2NhbGVYID0gdGhpcy5zY2FsZVg7XG5cdFx0XHRcdHRoaXMud29ybGRTY2FsZVkgPSB0aGlzLnNjYWxlWTtcblx0XHRcdH1cblx0XHRcdHRoaXMud29ybGRSb3RhdGlvbiA9IHRoaXMuZGF0YS5pbmhlcml0Um90YXRpb24gPyAocGFyZW50LndvcmxkUm90YXRpb24gKyB0aGlzLnJvdGF0aW9uSUspIDogdGhpcy5yb3RhdGlvbklLO1xuXHRcdFx0dGhpcy53b3JsZEZsaXBYID0gcGFyZW50LndvcmxkRmxpcFggIT0gdGhpcy5mbGlwWDtcblx0XHRcdHRoaXMud29ybGRGbGlwWSA9IHBhcmVudC53b3JsZEZsaXBZICE9IHRoaXMuZmxpcFk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBza2VsZXRvbkZsaXBYID0gdGhpcy5za2VsZXRvbi5mbGlwWCwgc2tlbGV0b25GbGlwWSA9IHRoaXMuc2tlbGV0b24uZmxpcFk7XG5cdFx0XHR0aGlzLndvcmxkWCA9IHNrZWxldG9uRmxpcFggPyAtdGhpcy54IDogdGhpcy54O1xuXHRcdFx0dGhpcy53b3JsZFkgPSAoc2tlbGV0b25GbGlwWSAhPSBzcGluZS5Cb25lLnlEb3duKSA/IC10aGlzLnkgOiB0aGlzLnk7XG5cdFx0XHR0aGlzLndvcmxkU2NhbGVYID0gdGhpcy5zY2FsZVg7XG5cdFx0XHR0aGlzLndvcmxkU2NhbGVZID0gdGhpcy5zY2FsZVk7XG5cdFx0XHR0aGlzLndvcmxkUm90YXRpb24gPSB0aGlzLnJvdGF0aW9uSUs7XG5cdFx0XHR0aGlzLndvcmxkRmxpcFggPSBza2VsZXRvbkZsaXBYICE9IHRoaXMuZmxpcFg7XG5cdFx0XHR0aGlzLndvcmxkRmxpcFkgPSBza2VsZXRvbkZsaXBZICE9IHRoaXMuZmxpcFk7XG5cdFx0fVxuXHRcdHZhciByYWRpYW5zID0gdGhpcy53b3JsZFJvdGF0aW9uICogc3BpbmUuZGVnUmFkO1xuXHRcdHZhciBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKTtcblx0XHR2YXIgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gICAgICAgIGlmICh0aGlzLndvcmxkRmxpcFgpXG4gICAgICAgIHtcblx0XHRcdHRoaXMubTAwID0gLWNvcyAqIHRoaXMud29ybGRTY2FsZVg7XG5cdFx0XHR0aGlzLm0wMSA9IHNpbiAqIHRoaXMud29ybGRTY2FsZVk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubTAwID0gY29zICogdGhpcy53b3JsZFNjYWxlWDtcblx0XHRcdHRoaXMubTAxID0gLXNpbiAqIHRoaXMud29ybGRTY2FsZVk7XG5cdFx0fVxuICAgICAgICBpZiAodGhpcy53b3JsZEZsaXBZICE9IHNwaW5lLkJvbmUueURvd24pXG4gICAgICAgIHtcblx0XHRcdHRoaXMubTEwID0gLXNpbiAqIHRoaXMud29ybGRTY2FsZVg7XG5cdFx0XHR0aGlzLm0xMSA9IC1jb3MgKiB0aGlzLndvcmxkU2NhbGVZO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm0xMCA9IHNpbiAqIHRoaXMud29ybGRTY2FsZVg7XG5cdFx0XHR0aGlzLm0xMSA9IGNvcyAqIHRoaXMud29ybGRTY2FsZVk7XG5cdFx0fVxuXHR9LFxuICAgIHNldFRvU2V0dXBQb3NlOiBmdW5jdGlvbiAoKVxuICAgIHtcblx0XHR2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblx0XHR0aGlzLnggPSBkYXRhLng7XG5cdFx0dGhpcy55ID0gZGF0YS55O1xuXHRcdHRoaXMucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuXHRcdHRoaXMucm90YXRpb25JSyA9IHRoaXMucm90YXRpb247XG5cdFx0dGhpcy5zY2FsZVggPSBkYXRhLnNjYWxlWDtcblx0XHR0aGlzLnNjYWxlWSA9IGRhdGEuc2NhbGVZO1xuXHRcdHRoaXMuZmxpcFggPSBkYXRhLmZsaXBYO1xuXHRcdHRoaXMuZmxpcFkgPSBkYXRhLmZsaXBZO1xuXHR9LFxuICAgIHdvcmxkVG9Mb2NhbDogZnVuY3Rpb24gKHdvcmxkKVxuICAgIHtcblx0XHR2YXIgZHggPSB3b3JsZFswXSAtIHRoaXMud29ybGRYLCBkeSA9IHdvcmxkWzFdIC0gdGhpcy53b3JsZFk7XG5cdFx0dmFyIG0wMCA9IHRoaXMubTAwLCBtMTAgPSB0aGlzLm0xMCwgbTAxID0gdGhpcy5tMDEsIG0xMSA9IHRoaXMubTExO1xuICAgICAgICBpZiAodGhpcy53b3JsZEZsaXBYICE9ICh0aGlzLndvcmxkRmxpcFkgIT0gc3BpbmUuQm9uZS55RG93bikpXG4gICAgICAgIHtcblx0XHRcdG0wMCA9IC1tMDA7XG5cdFx0XHRtMTEgPSAtbTExO1xuXHRcdH1cblx0XHR2YXIgaW52RGV0ID0gMSAvIChtMDAgKiBtMTEgLSBtMDEgKiBtMTApO1xuXHRcdHdvcmxkWzBdID0gZHggKiBtMDAgKiBpbnZEZXQgLSBkeSAqIG0wMSAqIGludkRldDtcblx0XHR3b3JsZFsxXSA9IGR5ICogbTExICogaW52RGV0IC0gZHggKiBtMTAgKiBpbnZEZXQ7XG5cdH0sXG4gICAgbG9jYWxUb1dvcmxkOiBmdW5jdGlvbiAobG9jYWwpXG4gICAge1xuXHRcdHZhciBsb2NhbFggPSBsb2NhbFswXSwgbG9jYWxZID0gbG9jYWxbMV07XG5cdFx0bG9jYWxbMF0gPSBsb2NhbFggKiB0aGlzLm0wMCArIGxvY2FsWSAqIHRoaXMubTAxICsgdGhpcy53b3JsZFg7XG5cdFx0bG9jYWxbMV0gPSBsb2NhbFggKiB0aGlzLm0xMCArIGxvY2FsWSAqIHRoaXMubTExICsgdGhpcy53b3JsZFk7XG5cdH1cbn07XG5cbnNwaW5lLlNsb3QgPSBmdW5jdGlvbiAoc2xvdERhdGEsIGJvbmUpXG57XG5cdHRoaXMuZGF0YSA9IHNsb3REYXRhO1xuXHR0aGlzLmJvbmUgPSBib25lO1xuXHR0aGlzLnNldFRvU2V0dXBQb3NlKCk7XG59O1xuc3BpbmUuU2xvdC5wcm90b3R5cGUgPSB7XG5cdHI6IDEsIGc6IDEsIGI6IDEsIGE6IDEsXG5cdF9hdHRhY2htZW50VGltZTogMCxcblx0YXR0YWNobWVudDogbnVsbCxcblx0YXR0YWNobWVudFZlcnRpY2VzOiBbXSxcbiAgICBzZXRBdHRhY2htZW50OiBmdW5jdGlvbiAoYXR0YWNobWVudClcbiAgICB7XG5cdFx0dGhpcy5hdHRhY2htZW50ID0gYXR0YWNobWVudDtcblx0XHR0aGlzLl9hdHRhY2htZW50VGltZSA9IHRoaXMuYm9uZS5za2VsZXRvbi50aW1lO1xuXHRcdHRoaXMuYXR0YWNobWVudFZlcnRpY2VzLmxlbmd0aCA9IDA7XG5cdH0sXG4gICAgc2V0QXR0YWNobWVudFRpbWU6IGZ1bmN0aW9uICh0aW1lKVxuICAgIHtcblx0XHR0aGlzLl9hdHRhY2htZW50VGltZSA9IHRoaXMuYm9uZS5za2VsZXRvbi50aW1lIC0gdGltZTtcblx0fSxcbiAgICBnZXRBdHRhY2htZW50VGltZTogZnVuY3Rpb24gKClcbiAgICB7XG5cdFx0cmV0dXJuIHRoaXMuYm9uZS5za2VsZXRvbi50aW1lIC0gdGhpcy5fYXR0YWNobWVudFRpbWU7XG5cdH0sXG4gICAgc2V0VG9TZXR1cFBvc2U6IGZ1bmN0aW9uICgpXG4gICAge1xuXHRcdHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXHRcdHRoaXMuciA9IGRhdGEucjtcblx0XHR0aGlzLmcgPSBkYXRhLmc7XG5cdFx0dGhpcy5iID0gZGF0YS5iO1xuXHRcdHRoaXMuYSA9IGRhdGEuYTtcblxuXHRcdHZhciBzbG90RGF0YXMgPSB0aGlzLmJvbmUuc2tlbGV0b24uZGF0YS5zbG90cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzbG90RGF0YXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoc2xvdERhdGFzW2ldID09IGRhdGEpXG4gICAgICAgICAgICB7XG5cdFx0XHRcdHRoaXMuc2V0QXR0YWNobWVudCghZGF0YS5hdHRhY2htZW50TmFtZSA/IG51bGwgOiB0aGlzLmJvbmUuc2tlbGV0b24uZ2V0QXR0YWNobWVudEJ5U2xvdEluZGV4KGksIGRhdGEuYXR0YWNobWVudE5hbWUpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5zcGluZS5Ja0NvbnN0cmFpbnQgPSBmdW5jdGlvbiAoZGF0YSwgc2tlbGV0b24pXG57XG5cdHRoaXMuZGF0YSA9IGRhdGE7XG5cdHRoaXMubWl4ID0gZGF0YS5taXg7XG5cdHRoaXMuYmVuZERpcmVjdGlvbiA9IGRhdGEuYmVuZERpcmVjdGlvbjtcblxuXHR0aGlzLmJvbmVzID0gW107XG5cdGZvciAodmFyIGkgPSAwLCBuID0gZGF0YS5ib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0dGhpcy5ib25lcy5wdXNoKHNrZWxldG9uLmZpbmRCb25lKGRhdGEuYm9uZXNbaV0ubmFtZSkpO1xuXHR0aGlzLnRhcmdldCA9IHNrZWxldG9uLmZpbmRCb25lKGRhdGEudGFyZ2V0Lm5hbWUpO1xufTtcbnNwaW5lLklrQ29uc3RyYWludC5wcm90b3R5cGUgPSB7XG4gICAgYXBwbHk6IGZ1bmN0aW9uICgpXG4gICAge1xuXHRcdHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblx0XHR2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuICAgICAgICBzd2l0Y2ggKGJvbmVzLmxlbmd0aClcbiAgICAgICAge1xuXHRcdGNhc2UgMTpcblx0XHRcdHNwaW5lLklrQ29uc3RyYWludC5hcHBseTEoYm9uZXNbMF0sIHRhcmdldC53b3JsZFgsIHRhcmdldC53b3JsZFksIHRoaXMubWl4KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdHNwaW5lLklrQ29uc3RyYWludC5hcHBseTIoYm9uZXNbMF0sIGJvbmVzWzFdLCB0YXJnZXQud29ybGRYLCB0YXJnZXQud29ybGRZLCB0aGlzLmJlbmREaXJlY3Rpb24sIHRoaXMubWl4KTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxufTtcbi8qKiBBZGp1c3RzIHRoZSBib25lIHJvdGF0aW9uIHNvIHRoZSB0aXAgaXMgYXMgY2xvc2UgdG8gdGhlIHRhcmdldCBwb3NpdGlvbiBhcyBwb3NzaWJsZS4gVGhlIHRhcmdldCBpcyBzcGVjaWZpZWQgaW4gdGhlIHdvcmxkXG4gKiBjb29yZGluYXRlIHN5c3RlbS4gKi9cbnNwaW5lLklrQ29uc3RyYWludC5hcHBseTEgPSBmdW5jdGlvbiAoYm9uZSwgdGFyZ2V0WCwgdGFyZ2V0WSwgYWxwaGEpXG57XG5cdHZhciBwYXJlbnRSb3RhdGlvbiA9ICghYm9uZS5kYXRhLmluaGVyaXRSb3RhdGlvbiB8fCAhYm9uZS5wYXJlbnQpID8gMCA6IGJvbmUucGFyZW50LndvcmxkUm90YXRpb247XG5cdHZhciByb3RhdGlvbiA9IGJvbmUucm90YXRpb247XG5cdHZhciByb3RhdGlvbklLID0gTWF0aC5hdGFuMih0YXJnZXRZIC0gYm9uZS53b3JsZFksIHRhcmdldFggLSBib25lLndvcmxkWCkgKiBzcGluZS5yYWREZWcgLSBwYXJlbnRSb3RhdGlvbjtcblx0Ym9uZS5yb3RhdGlvbklLID0gcm90YXRpb24gKyAocm90YXRpb25JSyAtIHJvdGF0aW9uKSAqIGFscGhhO1xufTtcbi8qKiBBZGp1c3RzIHRoZSBwYXJlbnQgYW5kIGNoaWxkIGJvbmUgcm90YXRpb25zIHNvIHRoZSB0aXAgb2YgdGhlIGNoaWxkIGlzIGFzIGNsb3NlIHRvIHRoZSB0YXJnZXQgcG9zaXRpb24gYXMgcG9zc2libGUuIFRoZVxuICogdGFyZ2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgd29ybGQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gKiBAcGFyYW0gY2hpbGQgQW55IGRlc2NlbmRhbnQgYm9uZSBvZiB0aGUgcGFyZW50LiAqL1xuc3BpbmUuSWtDb25zdHJhaW50LmFwcGx5MiA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB0YXJnZXRYLCB0YXJnZXRZLCBiZW5kRGlyZWN0aW9uLCBhbHBoYSlcbntcblx0dmFyIGNoaWxkUm90YXRpb24gPSBjaGlsZC5yb3RhdGlvbiwgcGFyZW50Um90YXRpb24gPSBwYXJlbnQucm90YXRpb247XG4gICAgaWYgKCFhbHBoYSlcbiAgICB7XG5cdFx0Y2hpbGQucm90YXRpb25JSyA9IGNoaWxkUm90YXRpb247XG5cdFx0cGFyZW50LnJvdGF0aW9uSUsgPSBwYXJlbnRSb3RhdGlvbjtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIHBvc2l0aW9uWCwgcG9zaXRpb25ZLCB0ZW1wUG9zaXRpb24gPSBzcGluZS50ZW1wO1xuXHR2YXIgcGFyZW50UGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICBpZiAocGFyZW50UGFyZW50KVxuICAgIHtcblx0XHR0ZW1wUG9zaXRpb25bMF0gPSB0YXJnZXRYO1xuXHRcdHRlbXBQb3NpdGlvblsxXSA9IHRhcmdldFk7XG5cdFx0cGFyZW50UGFyZW50LndvcmxkVG9Mb2NhbCh0ZW1wUG9zaXRpb24pO1xuXHRcdHRhcmdldFggPSAodGVtcFBvc2l0aW9uWzBdIC0gcGFyZW50LngpICogcGFyZW50UGFyZW50LndvcmxkU2NhbGVYO1xuXHRcdHRhcmdldFkgPSAodGVtcFBvc2l0aW9uWzFdIC0gcGFyZW50LnkpICogcGFyZW50UGFyZW50LndvcmxkU2NhbGVZO1xuXHR9IGVsc2Uge1xuXHRcdHRhcmdldFggLT0gcGFyZW50Lng7XG5cdFx0dGFyZ2V0WSAtPSBwYXJlbnQueTtcblx0fVxuICAgIGlmIChjaGlsZC5wYXJlbnQgPT0gcGFyZW50KVxuICAgIHtcblx0XHRwb3NpdGlvblggPSBjaGlsZC54O1xuXHRcdHBvc2l0aW9uWSA9IGNoaWxkLnk7XG5cdH0gZWxzZSB7XG5cdFx0dGVtcFBvc2l0aW9uWzBdID0gY2hpbGQueDtcblx0XHR0ZW1wUG9zaXRpb25bMV0gPSBjaGlsZC55O1xuXHRcdGNoaWxkLnBhcmVudC5sb2NhbFRvV29ybGQodGVtcFBvc2l0aW9uKTtcblx0XHRwYXJlbnQud29ybGRUb0xvY2FsKHRlbXBQb3NpdGlvbik7XG5cdFx0cG9zaXRpb25YID0gdGVtcFBvc2l0aW9uWzBdO1xuXHRcdHBvc2l0aW9uWSA9IHRlbXBQb3NpdGlvblsxXTtcblx0fVxuXHR2YXIgY2hpbGRYID0gcG9zaXRpb25YICogcGFyZW50LndvcmxkU2NhbGVYLCBjaGlsZFkgPSBwb3NpdGlvblkgKiBwYXJlbnQud29ybGRTY2FsZVk7XG5cdHZhciBvZmZzZXQgPSBNYXRoLmF0YW4yKGNoaWxkWSwgY2hpbGRYKTtcblx0dmFyIGxlbjEgPSBNYXRoLnNxcnQoY2hpbGRYICogY2hpbGRYICsgY2hpbGRZICogY2hpbGRZKSwgbGVuMiA9IGNoaWxkLmRhdGEubGVuZ3RoICogY2hpbGQud29ybGRTY2FsZVg7XG5cdC8vIEJhc2VkIG9uIGNvZGUgYnkgUnlhbiBKdWNrZXR0IHdpdGggcGVybWlzc2lvbjogQ29weXJpZ2h0IChjKSAyMDA4LTIwMDkgUnlhbiBKdWNrZXR0LCBodHRwOi8vd3d3LnJ5YW5qdWNrZXR0LmNvbS9cblx0dmFyIGNvc0Rlbm9tID0gMiAqIGxlbjEgKiBsZW4yO1xuICAgIGlmIChjb3NEZW5vbSA8IDAuMDAwMSlcbiAgICB7XG5cdFx0Y2hpbGQucm90YXRpb25JSyA9IGNoaWxkUm90YXRpb24gKyAoTWF0aC5hdGFuMih0YXJnZXRZLCB0YXJnZXRYKSAqIHNwaW5lLnJhZERlZyAtIHBhcmVudFJvdGF0aW9uIC0gY2hpbGRSb3RhdGlvbikgKiBhbHBoYTtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIGNvcyA9ICh0YXJnZXRYICogdGFyZ2V0WCArIHRhcmdldFkgKiB0YXJnZXRZIC0gbGVuMSAqIGxlbjEgLSBsZW4yICogbGVuMikgLyBjb3NEZW5vbTtcblx0aWYgKGNvcyA8IC0xKVxuXHRcdGNvcyA9IC0xO1xuXHRlbHNlIGlmIChjb3MgPiAxKVxuXHRcdGNvcyA9IDE7XG5cdHZhciBjaGlsZEFuZ2xlID0gTWF0aC5hY29zKGNvcykgKiBiZW5kRGlyZWN0aW9uO1xuXHR2YXIgYWRqYWNlbnQgPSBsZW4xICsgbGVuMiAqIGNvcywgb3Bwb3NpdGUgPSBsZW4yICogTWF0aC5zaW4oY2hpbGRBbmdsZSk7XG5cdHZhciBwYXJlbnRBbmdsZSA9IE1hdGguYXRhbjIodGFyZ2V0WSAqIGFkamFjZW50IC0gdGFyZ2V0WCAqIG9wcG9zaXRlLCB0YXJnZXRYICogYWRqYWNlbnQgKyB0YXJnZXRZICogb3Bwb3NpdGUpO1xuXHR2YXIgcm90YXRpb24gPSAocGFyZW50QW5nbGUgLSBvZmZzZXQpICogc3BpbmUucmFkRGVnIC0gcGFyZW50Um90YXRpb247XG5cdGlmIChyb3RhdGlvbiA+IDE4MClcblx0XHRyb3RhdGlvbiAtPSAzNjA7XG5cdGVsc2UgaWYgKHJvdGF0aW9uIDwgLTE4MCkgLy9cblx0XHRyb3RhdGlvbiArPSAzNjA7XG5cdHBhcmVudC5yb3RhdGlvbklLID0gcGFyZW50Um90YXRpb24gKyByb3RhdGlvbiAqIGFscGhhO1xuXHRyb3RhdGlvbiA9IChjaGlsZEFuZ2xlICsgb2Zmc2V0KSAqIHNwaW5lLnJhZERlZyAtIGNoaWxkUm90YXRpb247XG5cdGlmIChyb3RhdGlvbiA+IDE4MClcblx0XHRyb3RhdGlvbiAtPSAzNjA7XG5cdGVsc2UgaWYgKHJvdGF0aW9uIDwgLTE4MCkgLy9cblx0XHRyb3RhdGlvbiArPSAzNjA7XG5cdGNoaWxkLnJvdGF0aW9uSUsgPSBjaGlsZFJvdGF0aW9uICsgKHJvdGF0aW9uICsgcGFyZW50LndvcmxkUm90YXRpb24gLSBjaGlsZC5wYXJlbnQud29ybGRSb3RhdGlvbikgKiBhbHBoYTtcbn07XG5cbnNwaW5lLlNraW4gPSBmdW5jdGlvbiAobmFtZSlcbntcblx0dGhpcy5uYW1lID0gbmFtZTtcblx0dGhpcy5hdHRhY2htZW50cyA9IHt9O1xufTtcbnNwaW5lLlNraW4ucHJvdG90eXBlID0ge1xuICAgIGFkZEF0dGFjaG1lbnQ6IGZ1bmN0aW9uIChzbG90SW5kZXgsIG5hbWUsIGF0dGFjaG1lbnQpXG4gICAge1xuXHRcdHRoaXMuYXR0YWNobWVudHNbc2xvdEluZGV4ICsgXCI6XCIgKyBuYW1lXSA9IGF0dGFjaG1lbnQ7XG5cdH0sXG4gICAgZ2V0QXR0YWNobWVudDogZnVuY3Rpb24gKHNsb3RJbmRleCwgbmFtZSlcbiAgICB7XG5cdFx0cmV0dXJuIHRoaXMuYXR0YWNobWVudHNbc2xvdEluZGV4ICsgXCI6XCIgKyBuYW1lXTtcblx0fSxcbiAgICBfYXR0YWNoQWxsOiBmdW5jdGlvbiAoc2tlbGV0b24sIG9sZFNraW4pXG4gICAge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2xkU2tpbi5hdHRhY2htZW50cylcbiAgICAgICAge1xuXHRcdFx0dmFyIGNvbG9uID0ga2V5LmluZGV4T2YoXCI6XCIpO1xuXHRcdFx0dmFyIHNsb3RJbmRleCA9IHBhcnNlSW50KGtleS5zdWJzdHJpbmcoMCwgY29sb24pKTtcblx0XHRcdHZhciBuYW1lID0ga2V5LnN1YnN0cmluZyhjb2xvbiArIDEpO1xuXHRcdFx0dmFyIHNsb3QgPSBza2VsZXRvbi5zbG90c1tzbG90SW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNsb3QuYXR0YWNobWVudCAmJiBzbG90LmF0dGFjaG1lbnQubmFtZSA9PSBuYW1lKVxuICAgICAgICAgICAge1xuXHRcdFx0XHR2YXIgYXR0YWNobWVudCA9IHRoaXMuZ2V0QXR0YWNobWVudChzbG90SW5kZXgsIG5hbWUpO1xuXHRcdFx0XHRpZiAoYXR0YWNobWVudCkgc2xvdC5zZXRBdHRhY2htZW50KGF0dGFjaG1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuc3BpbmUuQW5pbWF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHRpbWVsaW5lcywgZHVyYXRpb24pXG57XG5cdHRoaXMubmFtZSA9IG5hbWU7XG5cdHRoaXMudGltZWxpbmVzID0gdGltZWxpbmVzO1xuXHR0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG59O1xuc3BpbmUuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgbG9vcCwgZXZlbnRzKVxuICAgIHtcbiAgICAgICAgaWYgKGxvb3AgJiYgdGhpcy5kdXJhdGlvbiAhPSAwKVxuICAgICAgICB7XG5cdFx0XHR0aW1lICU9IHRoaXMuZHVyYXRpb247XG5cdFx0XHRsYXN0VGltZSAlPSB0aGlzLmR1cmF0aW9uO1xuXHRcdH1cblx0XHR2YXIgdGltZWxpbmVzID0gdGhpcy50aW1lbGluZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSB0aW1lbGluZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0dGltZWxpbmVzW2ldLmFwcGx5KHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZXZlbnRzLCAxKTtcblx0fSxcbiAgICBtaXg6IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGxvb3AsIGV2ZW50cywgYWxwaGEpXG4gICAge1xuICAgICAgICBpZiAobG9vcCAmJiB0aGlzLmR1cmF0aW9uICE9IDApXG4gICAgICAgIHtcblx0XHRcdHRpbWUgJT0gdGhpcy5kdXJhdGlvbjtcblx0XHRcdGxhc3RUaW1lICU9IHRoaXMuZHVyYXRpb247XG5cdFx0fVxuXHRcdHZhciB0aW1lbGluZXMgPSB0aGlzLnRpbWVsaW5lcztcblx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHRpbWVsaW5lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHR0aW1lbGluZXNbaV0uYXBwbHkoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBldmVudHMsIGFscGhhKTtcblx0fVxufTtcbnNwaW5lLkFuaW1hdGlvbi5iaW5hcnlTZWFyY2ggPSBmdW5jdGlvbiAodmFsdWVzLCB0YXJnZXQsIHN0ZXApXG57XG5cdHZhciBsb3cgPSAwO1xuXHR2YXIgaGlnaCA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIHN0ZXApIC0gMjtcblx0aWYgKCFoaWdoKSByZXR1cm4gc3RlcDtcblx0dmFyIGN1cnJlbnQgPSBoaWdoID4+PiAxO1xuICAgIHdoaWxlICh0cnVlKVxuICAgIHtcblx0XHRpZiAodmFsdWVzWyhjdXJyZW50ICsgMSkgKiBzdGVwXSA8PSB0YXJnZXQpXG5cdFx0XHRsb3cgPSBjdXJyZW50ICsgMTtcblx0XHRlbHNlXG5cdFx0XHRoaWdoID0gY3VycmVudDtcblx0XHRpZiAobG93ID09IGhpZ2gpIHJldHVybiAobG93ICsgMSkgKiBzdGVwO1xuXHRcdGN1cnJlbnQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG5cdH1cbn07XG5zcGluZS5BbmltYXRpb24uYmluYXJ5U2VhcmNoMSA9IGZ1bmN0aW9uICh2YWx1ZXMsIHRhcmdldClcbntcblx0dmFyIGxvdyA9IDA7XG5cdHZhciBoaWdoID0gdmFsdWVzLmxlbmd0aCAtIDI7XG5cdGlmICghaGlnaCkgcmV0dXJuIDE7XG5cdHZhciBjdXJyZW50ID0gaGlnaCA+Pj4gMTtcbiAgICB3aGlsZSAodHJ1ZSlcbiAgICB7XG5cdFx0aWYgKHZhbHVlc1tjdXJyZW50ICsgMV0gPD0gdGFyZ2V0KVxuXHRcdFx0bG93ID0gY3VycmVudCArIDE7XG5cdFx0ZWxzZVxuXHRcdFx0aGlnaCA9IGN1cnJlbnQ7XG5cdFx0aWYgKGxvdyA9PSBoaWdoKSByZXR1cm4gbG93ICsgMTtcblx0XHRjdXJyZW50ID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuXHR9XG59O1xuc3BpbmUuQW5pbWF0aW9uLmxpbmVhclNlYXJjaCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHRhcmdldCwgc3RlcClcbntcblx0Zm9yICh2YXIgaSA9IDAsIGxhc3QgPSB2YWx1ZXMubGVuZ3RoIC0gc3RlcDsgaSA8PSBsYXN0OyBpICs9IHN0ZXApXG5cdFx0aWYgKHZhbHVlc1tpXSA+IHRhcmdldCkgcmV0dXJuIGk7XG5cdHJldHVybiAtMTtcbn07XG5cbnNwaW5lLkN1cnZlcyA9IGZ1bmN0aW9uIChmcmFtZUNvdW50KVxue1xuXHR0aGlzLmN1cnZlcyA9IFtdOyAvLyB0eXBlLCB4LCB5LCAuLi5cblx0Ly90aGlzLmN1cnZlcy5sZW5ndGggPSAoZnJhbWVDb3VudCAtIDEpICogMTkvKkJFWklFUl9TSVpFKi87XG59O1xuc3BpbmUuQ3VydmVzLnByb3RvdHlwZSA9IHtcbiAgICBzZXRMaW5lYXI6IGZ1bmN0aW9uIChmcmFtZUluZGV4KVxuICAgIHtcblx0XHR0aGlzLmN1cnZlc1tmcmFtZUluZGV4ICogMTkvKkJFWklFUl9TSVpFKi9dID0gMC8qTElORUFSKi87XG5cdH0sXG4gICAgc2V0U3RlcHBlZDogZnVuY3Rpb24gKGZyYW1lSW5kZXgpXG4gICAge1xuXHRcdHRoaXMuY3VydmVzW2ZyYW1lSW5kZXggKiAxOS8qQkVaSUVSX1NJWkUqL10gPSAxLypTVEVQUEVEKi87XG5cdH0sXG5cdC8qKiBTZXRzIHRoZSBjb250cm9sIGhhbmRsZSBwb3NpdGlvbnMgZm9yIGFuIGludGVycG9sYXRpb24gYmV6aWVyIGN1cnZlIHVzZWQgdG8gdHJhbnNpdGlvbiBmcm9tIHRoaXMga2V5ZnJhbWUgdG8gdGhlIG5leHQuXG5cdCAqIGN4MSBhbmQgY3gyIGFyZSBmcm9tIDAgdG8gMSwgcmVwcmVzZW50aW5nIHRoZSBwZXJjZW50IG9mIHRpbWUgYmV0d2VlbiB0aGUgdHdvIGtleWZyYW1lcy4gY3kxIGFuZCBjeTIgYXJlIHRoZSBwZXJjZW50IG9mXG5cdCAqIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGtleWZyYW1lJ3MgdmFsdWVzLiAqL1xuICAgIHNldEN1cnZlOiBmdW5jdGlvbiAoZnJhbWVJbmRleCwgY3gxLCBjeTEsIGN4MiwgY3kyKVxuICAgIHtcblx0XHR2YXIgc3ViZGl2MSA9IDEgLyAxMC8qQkVaSUVSX1NFR01FTlRTKi8sIHN1YmRpdjIgPSBzdWJkaXYxICogc3ViZGl2MSwgc3ViZGl2MyA9IHN1YmRpdjIgKiBzdWJkaXYxO1xuXHRcdHZhciBwcmUxID0gMyAqIHN1YmRpdjEsIHByZTIgPSAzICogc3ViZGl2MiwgcHJlNCA9IDYgKiBzdWJkaXYyLCBwcmU1ID0gNiAqIHN1YmRpdjM7XG5cdFx0dmFyIHRtcDF4ID0gLWN4MSAqIDIgKyBjeDIsIHRtcDF5ID0gLWN5MSAqIDIgKyBjeTIsIHRtcDJ4ID0gKGN4MSAtIGN4MikgKiAzICsgMSwgdG1wMnkgPSAoY3kxIC0gY3kyKSAqIDMgKyAxO1xuXHRcdHZhciBkZnggPSBjeDEgKiBwcmUxICsgdG1wMXggKiBwcmUyICsgdG1wMnggKiBzdWJkaXYzLCBkZnkgPSBjeTEgKiBwcmUxICsgdG1wMXkgKiBwcmUyICsgdG1wMnkgKiBzdWJkaXYzO1xuXHRcdHZhciBkZGZ4ID0gdG1wMXggKiBwcmU0ICsgdG1wMnggKiBwcmU1LCBkZGZ5ID0gdG1wMXkgKiBwcmU0ICsgdG1wMnkgKiBwcmU1O1xuXHRcdHZhciBkZGRmeCA9IHRtcDJ4ICogcHJlNSwgZGRkZnkgPSB0bXAyeSAqIHByZTU7XG5cblx0XHR2YXIgaSA9IGZyYW1lSW5kZXggKiAxOS8qQkVaSUVSX1NJWkUqLztcblx0XHR2YXIgY3VydmVzID0gdGhpcy5jdXJ2ZXM7XG5cdFx0Y3VydmVzW2krK10gPSAyLypCRVpJRVIqLztcblxuXHRcdHZhciB4ID0gZGZ4LCB5ID0gZGZ5O1xuICAgICAgICBmb3IgKHZhciBuID0gaSArIDE5LypCRVpJRVJfU0laRSovIC0gMTsgaSA8IG47IGkgKz0gMilcbiAgICAgICAge1xuXHRcdFx0Y3VydmVzW2ldID0geDtcblx0XHRcdGN1cnZlc1tpICsgMV0gPSB5O1xuXHRcdFx0ZGZ4ICs9IGRkZng7XG5cdFx0XHRkZnkgKz0gZGRmeTtcblx0XHRcdGRkZnggKz0gZGRkZng7XG5cdFx0XHRkZGZ5ICs9IGRkZGZ5O1xuXHRcdFx0eCArPSBkZng7XG5cdFx0XHR5ICs9IGRmeTtcblx0XHR9XG5cdH0sXG4gICAgZ2V0Q3VydmVQZXJjZW50OiBmdW5jdGlvbiAoZnJhbWVJbmRleCwgcGVyY2VudClcbiAgICB7XG5cdFx0cGVyY2VudCA9IHBlcmNlbnQgPCAwID8gMCA6IChwZXJjZW50ID4gMSA/IDEgOiBwZXJjZW50KTtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5jdXJ2ZXM7XG5cdFx0dmFyIGkgPSBmcmFtZUluZGV4ICogMTkvKkJFWklFUl9TSVpFKi87XG5cdFx0dmFyIHR5cGUgPSBjdXJ2ZXNbaV07XG5cdFx0aWYgKHR5cGUgPT09IDAvKkxJTkVBUiovKSByZXR1cm4gcGVyY2VudDtcblx0XHRpZiAodHlwZSA9PSAxLypTVEVQUEVEKi8pIHJldHVybiAwO1xuXHRcdGkrKztcblx0XHR2YXIgeCA9IDA7XG4gICAgICAgIGZvciAodmFyIHN0YXJ0ID0gaSwgbiA9IGkgKyAxOS8qQkVaSUVSX1NJWkUqLyAtIDE7IGkgPCBuOyBpICs9IDIpXG4gICAgICAgIHtcblx0XHRcdHggPSBjdXJ2ZXNbaV07XG4gICAgICAgICAgICBpZiAoeCA+PSBwZXJjZW50KVxuICAgICAgICAgICAge1xuXHRcdFx0XHR2YXIgcHJldlgsIHByZXZZO1xuICAgICAgICAgICAgICAgIGlmIChpID09IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHRwcmV2WCA9IDA7XG5cdFx0XHRcdFx0cHJldlkgPSAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByZXZYID0gY3VydmVzW2kgLSAyXTtcblx0XHRcdFx0XHRwcmV2WSA9IGN1cnZlc1tpIC0gMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHByZXZZICsgKGN1cnZlc1tpICsgMV0gLSBwcmV2WSkgKiAocGVyY2VudCAtIHByZXZYKSAvICh4IC0gcHJldlgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgeSA9IGN1cnZlc1tpIC0gMV07XG5cdFx0cmV0dXJuIHkgKyAoMSAtIHkpICogKHBlcmNlbnQgLSB4KSAvICgxIC0geCk7IC8vIExhc3QgcG9pbnQgaXMgMSwxLlxuXHR9XG59O1xuXG5zcGluZS5Sb3RhdGVUaW1lbGluZSA9IGZ1bmN0aW9uIChmcmFtZUNvdW50KVxue1xuXHR0aGlzLmN1cnZlcyA9IG5ldyBzcGluZS5DdXJ2ZXMoZnJhbWVDb3VudCk7XG5cdHRoaXMuZnJhbWVzID0gW107IC8vIHRpbWUsIGFuZ2xlLCAuLi5cblx0dGhpcy5mcmFtZXMubGVuZ3RoID0gZnJhbWVDb3VudCAqIDI7XG59O1xuc3BpbmUuUm90YXRlVGltZWxpbmUucHJvdG90eXBlID0ge1xuXHRib25lSW5kZXg6IDAsXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24gKClcbiAgICB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aCAvIDI7XG5cdH0sXG4gICAgc2V0RnJhbWU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCBhbmdsZSlcbiAgICB7XG5cdFx0ZnJhbWVJbmRleCAqPSAyO1xuXHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcblx0XHR0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgMV0gPSBhbmdsZTtcblx0fSxcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhKVxuICAgIHtcblx0XHR2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XG5cdFx0aWYgKHRpbWUgPCBmcmFtZXNbMF0pIHJldHVybjsgLy8gVGltZSBpcyBiZWZvcmUgZmlyc3QgZnJhbWUuXG5cblx0XHR2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW3RoaXMuYm9uZUluZGV4XTtcblxuICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDJdKVxuICAgICAgICB7IC8vIFRpbWUgaXMgYWZ0ZXIgbGFzdCBmcmFtZS5cblx0XHRcdHZhciBhbW91bnQgPSBib25lLmRhdGEucm90YXRpb24gKyBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdIC0gYm9uZS5yb3RhdGlvbjtcblx0XHRcdHdoaWxlIChhbW91bnQgPiAxODApXG5cdFx0XHRcdGFtb3VudCAtPSAzNjA7XG5cdFx0XHR3aGlsZSAoYW1vdW50IDwgLTE4MClcblx0XHRcdFx0YW1vdW50ICs9IDM2MDtcblx0XHRcdGJvbmUucm90YXRpb24gKz0gYW1vdW50ICogYWxwaGE7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSW50ZXJwb2xhdGUgYmV0d2VlbiB0aGUgcHJldmlvdXMgZnJhbWUgYW5kIHRoZSBjdXJyZW50IGZyYW1lLlxuXHRcdHZhciBmcmFtZUluZGV4ID0gc3BpbmUuQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIDIpO1xuXHRcdHZhciBwcmV2RnJhbWVWYWx1ZSA9IGZyYW1lc1tmcmFtZUluZGV4IC0gMV07XG5cdFx0dmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZUluZGV4XTtcblx0XHR2YXIgcGVyY2VudCA9IDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lSW5kZXggLSAyLypQUkVWX0ZSQU1FX1RJTUUqL10gLSBmcmFtZVRpbWUpO1xuXHRcdHBlcmNlbnQgPSB0aGlzLmN1cnZlcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWVJbmRleCAvIDIgLSAxLCBwZXJjZW50KTtcblxuXHRcdHZhciBhbW91bnQgPSBmcmFtZXNbZnJhbWVJbmRleCArIDEvKkZSQU1FX1ZBTFVFKi9dIC0gcHJldkZyYW1lVmFsdWU7XG5cdFx0d2hpbGUgKGFtb3VudCA+IDE4MClcblx0XHRcdGFtb3VudCAtPSAzNjA7XG5cdFx0d2hpbGUgKGFtb3VudCA8IC0xODApXG5cdFx0XHRhbW91bnQgKz0gMzYwO1xuXHRcdGFtb3VudCA9IGJvbmUuZGF0YS5yb3RhdGlvbiArIChwcmV2RnJhbWVWYWx1ZSArIGFtb3VudCAqIHBlcmNlbnQpIC0gYm9uZS5yb3RhdGlvbjtcblx0XHR3aGlsZSAoYW1vdW50ID4gMTgwKVxuXHRcdFx0YW1vdW50IC09IDM2MDtcblx0XHR3aGlsZSAoYW1vdW50IDwgLTE4MClcblx0XHRcdGFtb3VudCArPSAzNjA7XG5cdFx0Ym9uZS5yb3RhdGlvbiArPSBhbW91bnQgKiBhbHBoYTtcblx0fVxufTtcblxuc3BpbmUuVHJhbnNsYXRlVGltZWxpbmUgPSBmdW5jdGlvbiAoZnJhbWVDb3VudClcbntcblx0dGhpcy5jdXJ2ZXMgPSBuZXcgc3BpbmUuQ3VydmVzKGZyYW1lQ291bnQpO1xuXHR0aGlzLmZyYW1lcyA9IFtdOyAvLyB0aW1lLCB4LCB5LCAuLi5cblx0dGhpcy5mcmFtZXMubGVuZ3RoID0gZnJhbWVDb3VudCAqIDM7XG59O1xuc3BpbmUuVHJhbnNsYXRlVGltZWxpbmUucHJvdG90eXBlID0ge1xuXHRib25lSW5kZXg6IDAsXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24gKClcbiAgICB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aCAvIDM7XG5cdH0sXG4gICAgc2V0RnJhbWU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCB4LCB5KVxuICAgIHtcblx0XHRmcmFtZUluZGV4ICo9IDM7XG5cdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuXHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAxXSA9IHg7XG5cdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDJdID0geTtcblx0fSxcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhKVxuICAgIHtcblx0XHR2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XG5cdFx0aWYgKHRpbWUgPCBmcmFtZXNbMF0pIHJldHVybjsgLy8gVGltZSBpcyBiZWZvcmUgZmlyc3QgZnJhbWUuXG5cblx0XHR2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW3RoaXMuYm9uZUluZGV4XTtcblxuICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDNdKVxuICAgICAgICB7IC8vIFRpbWUgaXMgYWZ0ZXIgbGFzdCBmcmFtZS5cblx0XHRcdGJvbmUueCArPSAoYm9uZS5kYXRhLnggKyBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDJdIC0gYm9uZS54KSAqIGFscGhhO1xuXHRcdFx0Ym9uZS55ICs9IChib25lLmRhdGEueSArIGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMV0gLSBib25lLnkpICogYWxwaGE7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSW50ZXJwb2xhdGUgYmV0d2VlbiB0aGUgcHJldmlvdXMgZnJhbWUgYW5kIHRoZSBjdXJyZW50IGZyYW1lLlxuXHRcdHZhciBmcmFtZUluZGV4ID0gc3BpbmUuQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIDMpO1xuXHRcdHZhciBwcmV2RnJhbWVYID0gZnJhbWVzW2ZyYW1lSW5kZXggLSAyXTtcblx0XHR2YXIgcHJldkZyYW1lWSA9IGZyYW1lc1tmcmFtZUluZGV4IC0gMV07XG5cdFx0dmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZUluZGV4XTtcblx0XHR2YXIgcGVyY2VudCA9IDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAtMy8qUFJFVl9GUkFNRV9USU1FKi9dIC0gZnJhbWVUaW1lKTtcblx0XHRwZXJjZW50ID0gdGhpcy5jdXJ2ZXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lSW5kZXggLyAzIC0gMSwgcGVyY2VudCk7XG5cblx0XHRib25lLnggKz0gKGJvbmUuZGF0YS54ICsgcHJldkZyYW1lWCArIChmcmFtZXNbZnJhbWVJbmRleCArIDEvKkZSQU1FX1gqL10gLSBwcmV2RnJhbWVYKSAqIHBlcmNlbnQgLSBib25lLngpICogYWxwaGE7XG5cdFx0Ym9uZS55ICs9IChib25lLmRhdGEueSArIHByZXZGcmFtZVkgKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAyLypGUkFNRV9ZKi9dIC0gcHJldkZyYW1lWSkgKiBwZXJjZW50IC0gYm9uZS55KSAqIGFscGhhO1xuXHR9XG59O1xuXG5zcGluZS5TY2FsZVRpbWVsaW5lID0gZnVuY3Rpb24gKGZyYW1lQ291bnQpXG57XG5cdHRoaXMuY3VydmVzID0gbmV3IHNwaW5lLkN1cnZlcyhmcmFtZUNvdW50KTtcblx0dGhpcy5mcmFtZXMgPSBbXTsgLy8gdGltZSwgeCwgeSwgLi4uXG5cdHRoaXMuZnJhbWVzLmxlbmd0aCA9IGZyYW1lQ291bnQgKiAzO1xufTtcbnNwaW5lLlNjYWxlVGltZWxpbmUucHJvdG90eXBlID0ge1xuXHRib25lSW5kZXg6IDAsXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24gKClcbiAgICB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aCAvIDM7XG5cdH0sXG4gICAgc2V0RnJhbWU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCB4LCB5KVxuICAgIHtcblx0XHRmcmFtZUluZGV4ICo9IDM7XG5cdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuXHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAxXSA9IHg7XG5cdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDJdID0geTtcblx0fSxcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhKVxuICAgIHtcblx0XHR2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XG5cdFx0aWYgKHRpbWUgPCBmcmFtZXNbMF0pIHJldHVybjsgLy8gVGltZSBpcyBiZWZvcmUgZmlyc3QgZnJhbWUuXG5cblx0XHR2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW3RoaXMuYm9uZUluZGV4XTtcblxuICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDNdKVxuICAgICAgICB7IC8vIFRpbWUgaXMgYWZ0ZXIgbGFzdCBmcmFtZS5cblx0XHRcdGJvbmUuc2NhbGVYICs9IChib25lLmRhdGEuc2NhbGVYICogZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAyXSAtIGJvbmUuc2NhbGVYKSAqIGFscGhhO1xuXHRcdFx0Ym9uZS5zY2FsZVkgKz0gKGJvbmUuZGF0YS5zY2FsZVkgKiBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdIC0gYm9uZS5zY2FsZVkpICogYWxwaGE7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSW50ZXJwb2xhdGUgYmV0d2VlbiB0aGUgcHJldmlvdXMgZnJhbWUgYW5kIHRoZSBjdXJyZW50IGZyYW1lLlxuXHRcdHZhciBmcmFtZUluZGV4ID0gc3BpbmUuQW5pbWF0aW9uLmJpbmFyeVNlYXJjaChmcmFtZXMsIHRpbWUsIDMpO1xuXHRcdHZhciBwcmV2RnJhbWVYID0gZnJhbWVzW2ZyYW1lSW5kZXggLSAyXTtcblx0XHR2YXIgcHJldkZyYW1lWSA9IGZyYW1lc1tmcmFtZUluZGV4IC0gMV07XG5cdFx0dmFyIGZyYW1lVGltZSA9IGZyYW1lc1tmcmFtZUluZGV4XTtcblx0XHR2YXIgcGVyY2VudCA9IDEgLSAodGltZSAtIGZyYW1lVGltZSkgLyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAtMy8qUFJFVl9GUkFNRV9USU1FKi9dIC0gZnJhbWVUaW1lKTtcblx0XHRwZXJjZW50ID0gdGhpcy5jdXJ2ZXMuZ2V0Q3VydmVQZXJjZW50KGZyYW1lSW5kZXggLyAzIC0gMSwgcGVyY2VudCk7XG5cblx0XHRib25lLnNjYWxlWCArPSAoYm9uZS5kYXRhLnNjYWxlWCAqIChwcmV2RnJhbWVYICsgKGZyYW1lc1tmcmFtZUluZGV4ICsgMS8qRlJBTUVfWCovXSAtIHByZXZGcmFtZVgpICogcGVyY2VudCkgLSBib25lLnNjYWxlWCkgKiBhbHBoYTtcblx0XHRib25lLnNjYWxlWSArPSAoYm9uZS5kYXRhLnNjYWxlWSAqIChwcmV2RnJhbWVZICsgKGZyYW1lc1tmcmFtZUluZGV4ICsgMi8qRlJBTUVfWSovXSAtIHByZXZGcmFtZVkpICogcGVyY2VudCkgLSBib25lLnNjYWxlWSkgKiBhbHBoYTtcblx0fVxufTtcblxuc3BpbmUuQ29sb3JUaW1lbGluZSA9IGZ1bmN0aW9uIChmcmFtZUNvdW50KVxue1xuXHR0aGlzLmN1cnZlcyA9IG5ldyBzcGluZS5DdXJ2ZXMoZnJhbWVDb3VudCk7XG5cdHRoaXMuZnJhbWVzID0gW107IC8vIHRpbWUsIHIsIGcsIGIsIGEsIC4uLlxuXHR0aGlzLmZyYW1lcy5sZW5ndGggPSBmcmFtZUNvdW50ICogNTtcbn07XG5zcGluZS5Db2xvclRpbWVsaW5lLnByb3RvdHlwZSA9IHtcblx0c2xvdEluZGV4OiAwLFxuICAgIGdldEZyYW1lQ291bnQ6IGZ1bmN0aW9uICgpXG4gICAge1xuXHRcdHJldHVybiB0aGlzLmZyYW1lcy5sZW5ndGggLyA1O1xuXHR9LFxuICAgIHNldEZyYW1lOiBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgciwgZywgYiwgYSlcbiAgICB7XG5cdFx0ZnJhbWVJbmRleCAqPSA1O1xuXHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcblx0XHR0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgMV0gPSByO1xuXHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAyXSA9IGc7XG5cdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDNdID0gYjtcblx0XHR0aGlzLmZyYW1lc1tmcmFtZUluZGV4ICsgNF0gPSBhO1xuXHR9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEpXG4gICAge1xuXHRcdHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcblx0XHRpZiAodGltZSA8IGZyYW1lc1swXSkgcmV0dXJuOyAvLyBUaW1lIGlzIGJlZm9yZSBmaXJzdCBmcmFtZS5cblxuXHRcdHZhciByLCBnLCBiLCBhO1xuICAgICAgICBpZiAodGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDVdKVxuICAgICAgICB7XG5cdFx0XHQvLyBUaW1lIGlzIGFmdGVyIGxhc3QgZnJhbWUuXG5cdFx0XHR2YXIgaSA9IGZyYW1lcy5sZW5ndGggLSAxO1xuXHRcdFx0ciA9IGZyYW1lc1tpIC0gM107XG5cdFx0XHRnID0gZnJhbWVzW2kgLSAyXTtcblx0XHRcdGIgPSBmcmFtZXNbaSAtIDFdO1xuXHRcdFx0YSA9IGZyYW1lc1tpXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSW50ZXJwb2xhdGUgYmV0d2VlbiB0aGUgcHJldmlvdXMgZnJhbWUgYW5kIHRoZSBjdXJyZW50IGZyYW1lLlxuXHRcdFx0dmFyIGZyYW1lSW5kZXggPSBzcGluZS5BbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgNSk7XG5cdFx0XHR2YXIgcHJldkZyYW1lUiA9IGZyYW1lc1tmcmFtZUluZGV4IC0gNF07XG5cdFx0XHR2YXIgcHJldkZyYW1lRyA9IGZyYW1lc1tmcmFtZUluZGV4IC0gM107XG5cdFx0XHR2YXIgcHJldkZyYW1lQiA9IGZyYW1lc1tmcmFtZUluZGV4IC0gMl07XG5cdFx0XHR2YXIgcHJldkZyYW1lQSA9IGZyYW1lc1tmcmFtZUluZGV4IC0gMV07XG5cdFx0XHR2YXIgZnJhbWVUaW1lID0gZnJhbWVzW2ZyYW1lSW5kZXhdO1xuXHRcdFx0dmFyIHBlcmNlbnQgPSAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZUluZGV4IC0gNS8qUFJFVl9GUkFNRV9USU1FKi9dIC0gZnJhbWVUaW1lKTtcblx0XHRcdHBlcmNlbnQgPSB0aGlzLmN1cnZlcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWVJbmRleCAvIDUgLSAxLCBwZXJjZW50KTtcblxuXHRcdFx0ciA9IHByZXZGcmFtZVIgKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAxLypGUkFNRV9SKi9dIC0gcHJldkZyYW1lUikgKiBwZXJjZW50O1xuXHRcdFx0ZyA9IHByZXZGcmFtZUcgKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAyLypGUkFNRV9HKi9dIC0gcHJldkZyYW1lRykgKiBwZXJjZW50O1xuXHRcdFx0YiA9IHByZXZGcmFtZUIgKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyAzLypGUkFNRV9CKi9dIC0gcHJldkZyYW1lQikgKiBwZXJjZW50O1xuXHRcdFx0YSA9IHByZXZGcmFtZUEgKyAoZnJhbWVzW2ZyYW1lSW5kZXggKyA0LypGUkFNRV9BKi9dIC0gcHJldkZyYW1lQSkgKiBwZXJjZW50O1xuXHRcdH1cblx0XHR2YXIgc2xvdCA9IHNrZWxldG9uLnNsb3RzW3RoaXMuc2xvdEluZGV4XTtcbiAgICAgICAgaWYgKGFscGhhIDwgMSlcbiAgICAgICAge1xuXHRcdFx0c2xvdC5yICs9IChyIC0gc2xvdC5yKSAqIGFscGhhO1xuXHRcdFx0c2xvdC5nICs9IChnIC0gc2xvdC5nKSAqIGFscGhhO1xuXHRcdFx0c2xvdC5iICs9IChiIC0gc2xvdC5iKSAqIGFscGhhO1xuXHRcdFx0c2xvdC5hICs9IChhIC0gc2xvdC5hKSAqIGFscGhhO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzbG90LnIgPSByO1xuXHRcdFx0c2xvdC5nID0gZztcblx0XHRcdHNsb3QuYiA9IGI7XG5cdFx0XHRzbG90LmEgPSBhO1xuXHRcdH1cblx0fVxufTtcblxuc3BpbmUuQXR0YWNobWVudFRpbWVsaW5lID0gZnVuY3Rpb24gKGZyYW1lQ291bnQpXG57XG5cdHRoaXMuY3VydmVzID0gbmV3IHNwaW5lLkN1cnZlcyhmcmFtZUNvdW50KTtcblx0dGhpcy5mcmFtZXMgPSBbXTsgLy8gdGltZSwgLi4uXG5cdHRoaXMuZnJhbWVzLmxlbmd0aCA9IGZyYW1lQ291bnQ7XG5cdHRoaXMuYXR0YWNobWVudE5hbWVzID0gW107XG5cdHRoaXMuYXR0YWNobWVudE5hbWVzLmxlbmd0aCA9IGZyYW1lQ291bnQ7XG59O1xuc3BpbmUuQXR0YWNobWVudFRpbWVsaW5lLnByb3RvdHlwZSA9IHtcblx0c2xvdEluZGV4OiAwLFxuICAgIGdldEZyYW1lQ291bnQ6IGZ1bmN0aW9uICgpXG4gICAge1xuXHRcdHJldHVybiB0aGlzLmZyYW1lcy5sZW5ndGg7XG5cdH0sXG4gICAgc2V0RnJhbWU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCBhdHRhY2htZW50TmFtZSlcbiAgICB7XG5cdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuXHRcdHRoaXMuYXR0YWNobWVudE5hbWVzW2ZyYW1lSW5kZXhdID0gYXR0YWNobWVudE5hbWU7XG5cdH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGZpcmVkRXZlbnRzLCBhbHBoYSlcbiAgICB7XG5cdFx0dmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xuICAgICAgICBpZiAodGltZSA8IGZyYW1lc1swXSlcbiAgICAgICAge1xuXHRcdFx0aWYgKGxhc3RUaW1lID4gdGltZSkgdGhpcy5hcHBseShza2VsZXRvbiwgbGFzdFRpbWUsIE51bWJlci5NQVhfVkFMVUUsIG51bGwsIDApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gZWxzZSBpZiAobGFzdFRpbWUgPiB0aW1lKSAvL1xuXHRcdFx0bGFzdFRpbWUgPSAtMTtcblxuXHRcdHZhciBmcmFtZUluZGV4ID0gdGltZSA+PSBmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDFdID8gZnJhbWVzLmxlbmd0aCAtIDEgOiBzcGluZS5BbmltYXRpb24uYmluYXJ5U2VhcmNoMShmcmFtZXMsIHRpbWUpIC0gMTtcblx0XHRpZiAoZnJhbWVzW2ZyYW1lSW5kZXhdIDwgbGFzdFRpbWUpIHJldHVybjtcblxuXHRcdHZhciBhdHRhY2htZW50TmFtZSA9IHRoaXMuYXR0YWNobWVudE5hbWVzW2ZyYW1lSW5kZXhdO1xuXHRcdHNrZWxldG9uLnNsb3RzW3RoaXMuc2xvdEluZGV4XS5zZXRBdHRhY2htZW50KFxuXHRcdFx0IWF0dGFjaG1lbnROYW1lID8gbnVsbCA6IHNrZWxldG9uLmdldEF0dGFjaG1lbnRCeVNsb3RJbmRleCh0aGlzLnNsb3RJbmRleCwgYXR0YWNobWVudE5hbWUpKTtcblx0fVxufTtcblxuc3BpbmUuRXZlbnRUaW1lbGluZSA9IGZ1bmN0aW9uIChmcmFtZUNvdW50KVxue1xuXHR0aGlzLmZyYW1lcyA9IFtdOyAvLyB0aW1lLCAuLi5cblx0dGhpcy5mcmFtZXMubGVuZ3RoID0gZnJhbWVDb3VudDtcblx0dGhpcy5ldmVudHMgPSBbXTtcblx0dGhpcy5ldmVudHMubGVuZ3RoID0gZnJhbWVDb3VudDtcbn07XG5zcGluZS5FdmVudFRpbWVsaW5lLnByb3RvdHlwZSA9IHtcbiAgICBnZXRGcmFtZUNvdW50OiBmdW5jdGlvbiAoKVxuICAgIHtcblx0XHRyZXR1cm4gdGhpcy5mcmFtZXMubGVuZ3RoO1xuXHR9LFxuICAgIHNldEZyYW1lOiBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgZXZlbnQpXG4gICAge1xuXHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXhdID0gdGltZTtcblx0XHR0aGlzLmV2ZW50c1tmcmFtZUluZGV4XSA9IGV2ZW50O1xuXHR9LFxuXHQvKiogRmlyZXMgZXZlbnRzIGZvciBmcmFtZXMgPiBsYXN0VGltZSBhbmQgPD0gdGltZS4gKi9cbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhKVxuICAgIHtcblx0XHRpZiAoIWZpcmVkRXZlbnRzKSByZXR1cm47XG5cblx0XHR2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XG5cdFx0dmFyIGZyYW1lQ291bnQgPSBmcmFtZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsYXN0VGltZSA+IHRpbWUpXG4gICAgICAgIHsgLy8gRmlyZSBldmVudHMgYWZ0ZXIgbGFzdCB0aW1lIGZvciBsb29wZWQgYW5pbWF0aW9ucy5cblx0XHRcdHRoaXMuYXBwbHkoc2tlbGV0b24sIGxhc3RUaW1lLCBOdW1iZXIuTUFYX1ZBTFVFLCBmaXJlZEV2ZW50cywgYWxwaGEpO1xuXHRcdFx0bGFzdFRpbWUgPSAtMTtcblx0XHR9IGVsc2UgaWYgKGxhc3RUaW1lID49IGZyYW1lc1tmcmFtZUNvdW50IC0gMV0pIC8vIExhc3QgdGltZSBpcyBhZnRlciBsYXN0IGZyYW1lLlxuXHRcdFx0cmV0dXJuO1xuXHRcdGlmICh0aW1lIDwgZnJhbWVzWzBdKSByZXR1cm47IC8vIFRpbWUgaXMgYmVmb3JlIGZpcnN0IGZyYW1lLlxuXG5cdFx0dmFyIGZyYW1lSW5kZXg7XG5cdFx0aWYgKGxhc3RUaW1lIDwgZnJhbWVzWzBdKVxuXHRcdFx0ZnJhbWVJbmRleCA9IDA7XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuXHRcdFx0ZnJhbWVJbmRleCA9IHNwaW5lLkFuaW1hdGlvbi5iaW5hcnlTZWFyY2gxKGZyYW1lcywgbGFzdFRpbWUpO1xuXHRcdFx0dmFyIGZyYW1lID0gZnJhbWVzW2ZyYW1lSW5kZXhdO1xuICAgICAgICAgICAgd2hpbGUgKGZyYW1lSW5kZXggPiAwKVxuICAgICAgICAgICAgeyAvLyBGaXJlIG11bHRpcGxlIGV2ZW50cyB3aXRoIHRoZSBzYW1lIGZyYW1lLlxuXHRcdFx0XHRpZiAoZnJhbWVzW2ZyYW1lSW5kZXggLSAxXSAhPSBmcmFtZSkgYnJlYWs7XG5cdFx0XHRcdGZyYW1lSW5kZXgtLTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuXHRcdGZvciAoOyBmcmFtZUluZGV4IDwgZnJhbWVDb3VudCAmJiB0aW1lID49IGZyYW1lc1tmcmFtZUluZGV4XTsgZnJhbWVJbmRleCsrKVxuXHRcdFx0ZmlyZWRFdmVudHMucHVzaChldmVudHNbZnJhbWVJbmRleF0pO1xuXHR9XG59O1xuXG5zcGluZS5EcmF3T3JkZXJUaW1lbGluZSA9IGZ1bmN0aW9uIChmcmFtZUNvdW50KVxue1xuXHR0aGlzLmZyYW1lcyA9IFtdOyAvLyB0aW1lLCAuLi5cblx0dGhpcy5mcmFtZXMubGVuZ3RoID0gZnJhbWVDb3VudDtcblx0dGhpcy5kcmF3T3JkZXJzID0gW107XG5cdHRoaXMuZHJhd09yZGVycy5sZW5ndGggPSBmcmFtZUNvdW50O1xufTtcbnNwaW5lLkRyYXdPcmRlclRpbWVsaW5lLnByb3RvdHlwZSA9IHtcbiAgICBnZXRGcmFtZUNvdW50OiBmdW5jdGlvbiAoKVxuICAgIHtcblx0XHRyZXR1cm4gdGhpcy5mcmFtZXMubGVuZ3RoO1xuXHR9LFxuICAgIHNldEZyYW1lOiBmdW5jdGlvbiAoZnJhbWVJbmRleCwgdGltZSwgZHJhd09yZGVyKVxuICAgIHtcblx0XHR0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XG5cdFx0dGhpcy5kcmF3T3JkZXJzW2ZyYW1lSW5kZXhdID0gZHJhd09yZGVyO1xuXHR9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiAoc2tlbGV0b24sIGxhc3RUaW1lLCB0aW1lLCBmaXJlZEV2ZW50cywgYWxwaGEpXG4gICAge1xuXHRcdHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcblx0XHRpZiAodGltZSA8IGZyYW1lc1swXSkgcmV0dXJuOyAvLyBUaW1lIGlzIGJlZm9yZSBmaXJzdCBmcmFtZS5cblxuXHRcdHZhciBmcmFtZUluZGV4O1xuXHRcdGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMV0pIC8vIFRpbWUgaXMgYWZ0ZXIgbGFzdCBmcmFtZS5cblx0XHRcdGZyYW1lSW5kZXggPSBmcmFtZXMubGVuZ3RoIC0gMTtcblx0XHRlbHNlXG5cdFx0XHRmcmFtZUluZGV4ID0gc3BpbmUuQW5pbWF0aW9uLmJpbmFyeVNlYXJjaDEoZnJhbWVzLCB0aW1lKSAtIDE7XG5cblx0XHR2YXIgZHJhd09yZGVyID0gc2tlbGV0b24uZHJhd09yZGVyO1xuXHRcdHZhciBzbG90cyA9IHNrZWxldG9uLnNsb3RzO1xuXHRcdHZhciBkcmF3T3JkZXJUb1NldHVwSW5kZXggPSB0aGlzLmRyYXdPcmRlcnNbZnJhbWVJbmRleF07XG4gICAgICAgIGlmICghZHJhd09yZGVyVG9TZXR1cEluZGV4KVxuICAgICAgICB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdFx0ZHJhd09yZGVyW2ldID0gc2xvdHNbaV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBuID0gZHJhd09yZGVyVG9TZXR1cEluZGV4Lmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdFx0ZHJhd09yZGVyW2ldID0gc2tlbGV0b24uc2xvdHNbZHJhd09yZGVyVG9TZXR1cEluZGV4W2ldXTtcblx0XHR9XG5cblx0fVxufTtcblxuc3BpbmUuRmZkVGltZWxpbmUgPSBmdW5jdGlvbiAoZnJhbWVDb3VudClcbntcblx0dGhpcy5jdXJ2ZXMgPSBuZXcgc3BpbmUuQ3VydmVzKGZyYW1lQ291bnQpO1xuXHR0aGlzLmZyYW1lcyA9IFtdO1xuXHR0aGlzLmZyYW1lcy5sZW5ndGggPSBmcmFtZUNvdW50O1xuXHR0aGlzLmZyYW1lVmVydGljZXMgPSBbXTtcblx0dGhpcy5mcmFtZVZlcnRpY2VzLmxlbmd0aCA9IGZyYW1lQ291bnQ7XG59O1xuc3BpbmUuRmZkVGltZWxpbmUucHJvdG90eXBlID0ge1xuXHRzbG90SW5kZXg6IDAsXG5cdGF0dGFjaG1lbnQ6IDAsXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24gKClcbiAgICB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aDtcblx0fSxcbiAgICBzZXRGcmFtZTogZnVuY3Rpb24gKGZyYW1lSW5kZXgsIHRpbWUsIHZlcnRpY2VzKVxuICAgIHtcblx0XHR0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XG5cdFx0dGhpcy5mcmFtZVZlcnRpY2VzW2ZyYW1lSW5kZXhdID0gdmVydGljZXM7XG5cdH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGZpcmVkRXZlbnRzLCBhbHBoYSlcbiAgICB7XG5cdFx0dmFyIHNsb3QgPSBza2VsZXRvbi5zbG90c1t0aGlzLnNsb3RJbmRleF07XG5cdFx0aWYgKHNsb3QuYXR0YWNobWVudCAhPSB0aGlzLmF0dGFjaG1lbnQpIHJldHVybjtcblxuXHRcdHZhciBmcmFtZXMgPSB0aGlzLmZyYW1lcztcblx0XHRpZiAodGltZSA8IGZyYW1lc1swXSkgcmV0dXJuOyAvLyBUaW1lIGlzIGJlZm9yZSBmaXJzdCBmcmFtZS5cblxuXHRcdHZhciBmcmFtZVZlcnRpY2VzID0gdGhpcy5mcmFtZVZlcnRpY2VzO1xuXHRcdHZhciB2ZXJ0ZXhDb3VudCA9IGZyYW1lVmVydGljZXNbMF0ubGVuZ3RoO1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gc2xvdC5hdHRhY2htZW50VmVydGljZXM7XG5cdFx0aWYgKHZlcnRpY2VzLmxlbmd0aCAhPSB2ZXJ0ZXhDb3VudCkgYWxwaGEgPSAxO1xuXHRcdHZlcnRpY2VzLmxlbmd0aCA9IHZlcnRleENvdW50O1xuXG4gICAgICAgIGlmICh0aW1lID49IGZyYW1lc1tmcmFtZXMubGVuZ3RoIC0gMV0pXG4gICAgICAgIHsgLy8gVGltZSBpcyBhZnRlciBsYXN0IGZyYW1lLlxuXHRcdFx0dmFyIGxhc3RWZXJ0aWNlcyA9IGZyYW1lVmVydGljZXNbZnJhbWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGFscGhhIDwgMSlcbiAgICAgICAgICAgIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKVxuXHRcdFx0XHRcdHZlcnRpY2VzW2ldICs9IChsYXN0VmVydGljZXNbaV0gLSB2ZXJ0aWNlc1tpXSkgKiBhbHBoYTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKylcblx0XHRcdFx0XHR2ZXJ0aWNlc1tpXSA9IGxhc3RWZXJ0aWNlc1tpXTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHRoZSBwcmV2aW91cyBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgZnJhbWUuXG5cdFx0dmFyIGZyYW1lSW5kZXggPSBzcGluZS5BbmltYXRpb24uYmluYXJ5U2VhcmNoMShmcmFtZXMsIHRpbWUpO1xuXHRcdHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVJbmRleF07XG5cdFx0dmFyIHBlcmNlbnQgPSAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZUluZGV4IC0gMV0gLSBmcmFtZVRpbWUpO1xuXHRcdHBlcmNlbnQgPSB0aGlzLmN1cnZlcy5nZXRDdXJ2ZVBlcmNlbnQoZnJhbWVJbmRleCAtIDEsIHBlcmNlbnQgPCAwID8gMCA6IChwZXJjZW50ID4gMSA/IDEgOiBwZXJjZW50KSk7XG5cblx0XHR2YXIgcHJldlZlcnRpY2VzID0gZnJhbWVWZXJ0aWNlc1tmcmFtZUluZGV4IC0gMV07XG5cdFx0dmFyIG5leHRWZXJ0aWNlcyA9IGZyYW1lVmVydGljZXNbZnJhbWVJbmRleF07XG5cbiAgICAgICAgaWYgKGFscGhhIDwgMSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKVxuICAgICAgICAgICAge1xuXHRcdFx0XHR2YXIgcHJldiA9IHByZXZWZXJ0aWNlc1tpXTtcblx0XHRcdFx0dmVydGljZXNbaV0gKz0gKHByZXYgKyAobmV4dFZlcnRpY2VzW2ldIC0gcHJldikgKiBwZXJjZW50IC0gdmVydGljZXNbaV0pICogYWxwaGE7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKylcbiAgICAgICAgICAgIHtcblx0XHRcdFx0dmFyIHByZXYgPSBwcmV2VmVydGljZXNbaV07XG5cdFx0XHRcdHZlcnRpY2VzW2ldID0gcHJldiArIChuZXh0VmVydGljZXNbaV0gLSBwcmV2KSAqIHBlcmNlbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5zcGluZS5Ja0NvbnN0cmFpbnRUaW1lbGluZSA9IGZ1bmN0aW9uIChmcmFtZUNvdW50KVxue1xuXHR0aGlzLmN1cnZlcyA9IG5ldyBzcGluZS5DdXJ2ZXMoZnJhbWVDb3VudCk7XG5cdHRoaXMuZnJhbWVzID0gW107IC8vIHRpbWUsIG1peCwgYmVuZERpcmVjdGlvbiwgLi4uXG5cdHRoaXMuZnJhbWVzLmxlbmd0aCA9IGZyYW1lQ291bnQgKiAzO1xufTtcbnNwaW5lLklrQ29uc3RyYWludFRpbWVsaW5lLnByb3RvdHlwZSA9IHtcblx0aWtDb25zdHJhaW50SW5kZXg6IDAsXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24gKClcbiAgICB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aCAvIDM7XG5cdH0sXG4gICAgc2V0RnJhbWU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCBtaXgsIGJlbmREaXJlY3Rpb24pXG4gICAge1xuXHRcdGZyYW1lSW5kZXggKj0gMztcblx0XHR0aGlzLmZyYW1lc1tmcmFtZUluZGV4XSA9IHRpbWU7XG5cdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleCArIDFdID0gbWl4O1xuXHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAyXSA9IGJlbmREaXJlY3Rpb247XG5cdH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIChza2VsZXRvbiwgbGFzdFRpbWUsIHRpbWUsIGZpcmVkRXZlbnRzLCBhbHBoYSlcbiAgICB7XG5cdFx0dmFyIGZyYW1lcyA9IHRoaXMuZnJhbWVzO1xuXHRcdGlmICh0aW1lIDwgZnJhbWVzWzBdKSByZXR1cm47IC8vIFRpbWUgaXMgYmVmb3JlIGZpcnN0IGZyYW1lLlxuXG5cdFx0dmFyIGlrQ29uc3RyYWludCA9IHNrZWxldG9uLmlrQ29uc3RyYWludHNbdGhpcy5pa0NvbnN0cmFpbnRJbmRleF07XG5cbiAgICAgICAgaWYgKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAzXSlcbiAgICAgICAgeyAvLyBUaW1lIGlzIGFmdGVyIGxhc3QgZnJhbWUuXG5cdFx0XHRpa0NvbnN0cmFpbnQubWl4ICs9IChmcmFtZXNbZnJhbWVzLmxlbmd0aCAtIDJdIC0gaWtDb25zdHJhaW50Lm1peCkgKiBhbHBoYTtcblx0XHRcdGlrQ29uc3RyYWludC5iZW5kRGlyZWN0aW9uID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHRoZSBwcmV2aW91cyBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgZnJhbWUuXG5cdFx0dmFyIGZyYW1lSW5kZXggPSBzcGluZS5BbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgMyk7XG5cdFx0dmFyIHByZXZGcmFtZU1peCA9IGZyYW1lc1tmcmFtZUluZGV4ICsgLTIvKlBSRVZfRlJBTUVfTUlYKi9dO1xuXHRcdHZhciBmcmFtZVRpbWUgPSBmcmFtZXNbZnJhbWVJbmRleF07XG5cdFx0dmFyIHBlcmNlbnQgPSAxIC0gKHRpbWUgLSBmcmFtZVRpbWUpIC8gKGZyYW1lc1tmcmFtZUluZGV4ICsgLTMvKlBSRVZfRlJBTUVfVElNRSovXSAtIGZyYW1lVGltZSk7XG5cdFx0cGVyY2VudCA9IHRoaXMuY3VydmVzLmdldEN1cnZlUGVyY2VudChmcmFtZUluZGV4IC8gMyAtIDEsIHBlcmNlbnQpO1xuXG5cdFx0dmFyIG1peCA9IHByZXZGcmFtZU1peCArIChmcmFtZXNbZnJhbWVJbmRleCArIDEvKkZSQU1FX01JWCovXSAtIHByZXZGcmFtZU1peCkgKiBwZXJjZW50O1xuXHRcdGlrQ29uc3RyYWludC5taXggKz0gKG1peCAtIGlrQ29uc3RyYWludC5taXgpICogYWxwaGE7XG5cdFx0aWtDb25zdHJhaW50LmJlbmREaXJlY3Rpb24gPSBmcmFtZXNbZnJhbWVJbmRleCArIC0xLypQUkVWX0ZSQU1FX0JFTkRfRElSRUNUSU9OKi9dO1xuXHR9XG59O1xuXG5zcGluZS5GbGlwWFRpbWVsaW5lID0gZnVuY3Rpb24gKGZyYW1lQ291bnQpXG57XG5cdHRoaXMuY3VydmVzID0gbmV3IHNwaW5lLkN1cnZlcyhmcmFtZUNvdW50KTtcblx0dGhpcy5mcmFtZXMgPSBbXTsgLy8gdGltZSwgZmxpcCwgLi4uXG5cdHRoaXMuZnJhbWVzLmxlbmd0aCA9IGZyYW1lQ291bnQgKiAyO1xufTtcbnNwaW5lLkZsaXBYVGltZWxpbmUucHJvdG90eXBlID0ge1xuXHRib25lSW5kZXg6IDAsXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24gKClcbiAgICB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aCAvIDI7XG5cdH0sXG4gICAgc2V0RnJhbWU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCBmbGlwKVxuICAgIHtcblx0XHRmcmFtZUluZGV4ICo9IDI7XG5cdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuXHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAxXSA9IGZsaXAgPyAxIDogMDtcblx0fSxcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhKVxuICAgIHtcblx0XHR2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XG4gICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKVxuICAgICAgICB7XG5cdFx0XHRpZiAobGFzdFRpbWUgPiB0aW1lKSB0aGlzLmFwcGx5KHNrZWxldG9uLCBsYXN0VGltZSwgTnVtYmVyLk1BWF9WQUxVRSwgbnVsbCwgMCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSBlbHNlIGlmIChsYXN0VGltZSA+IHRpbWUpIC8vXG5cdFx0XHRsYXN0VGltZSA9IC0xO1xuXHRcdHZhciBmcmFtZUluZGV4ID0gKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAyXSA/IGZyYW1lcy5sZW5ndGggOiBzcGluZS5BbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgMikpIC0gMjtcblx0XHRpZiAoZnJhbWVzW2ZyYW1lSW5kZXhdIDwgbGFzdFRpbWUpIHJldHVybjtcblx0XHRza2VsZXRvbi5ib25lc1tib25lSW5kZXhdLmZsaXBYID0gZnJhbWVzW2ZyYW1lSW5kZXggKyAxXSAhPSAwO1xuXHR9XG59O1xuXG5zcGluZS5GbGlwWVRpbWVsaW5lID0gZnVuY3Rpb24gKGZyYW1lQ291bnQpXG57XG5cdHRoaXMuY3VydmVzID0gbmV3IHNwaW5lLkN1cnZlcyhmcmFtZUNvdW50KTtcblx0dGhpcy5mcmFtZXMgPSBbXTsgLy8gdGltZSwgZmxpcCwgLi4uXG5cdHRoaXMuZnJhbWVzLmxlbmd0aCA9IGZyYW1lQ291bnQgKiAyO1xufTtcbnNwaW5lLkZsaXBZVGltZWxpbmUucHJvdG90eXBlID0ge1xuXHRib25lSW5kZXg6IDAsXG4gICAgZ2V0RnJhbWVDb3VudDogZnVuY3Rpb24gKClcbiAgICB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhbWVzLmxlbmd0aCAvIDI7XG5cdH0sXG4gICAgc2V0RnJhbWU6IGZ1bmN0aW9uIChmcmFtZUluZGV4LCB0aW1lLCBmbGlwKVxuICAgIHtcblx0XHRmcmFtZUluZGV4ICo9IDI7XG5cdFx0dGhpcy5mcmFtZXNbZnJhbWVJbmRleF0gPSB0aW1lO1xuXHRcdHRoaXMuZnJhbWVzW2ZyYW1lSW5kZXggKyAxXSA9IGZsaXAgPyAxIDogMDtcblx0fSxcbiAgICBhcHBseTogZnVuY3Rpb24gKHNrZWxldG9uLCBsYXN0VGltZSwgdGltZSwgZmlyZWRFdmVudHMsIGFscGhhKVxuICAgIHtcblx0XHR2YXIgZnJhbWVzID0gdGhpcy5mcmFtZXM7XG4gICAgICAgIGlmICh0aW1lIDwgZnJhbWVzWzBdKVxuICAgICAgICB7XG5cdFx0XHRpZiAobGFzdFRpbWUgPiB0aW1lKSB0aGlzLmFwcGx5KHNrZWxldG9uLCBsYXN0VGltZSwgTnVtYmVyLk1BWF9WQUxVRSwgbnVsbCwgMCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSBlbHNlIGlmIChsYXN0VGltZSA+IHRpbWUpIC8vXG5cdFx0XHRsYXN0VGltZSA9IC0xO1xuXHRcdHZhciBmcmFtZUluZGV4ID0gKHRpbWUgPj0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAyXSA/IGZyYW1lcy5sZW5ndGggOiBzcGluZS5BbmltYXRpb24uYmluYXJ5U2VhcmNoKGZyYW1lcywgdGltZSwgMikpIC0gMjtcblx0XHRpZiAoZnJhbWVzW2ZyYW1lSW5kZXhdIDwgbGFzdFRpbWUpIHJldHVybjtcblx0XHRza2VsZXRvbi5ib25lc1tib25lSW5kZXhdLmZsaXBZID0gZnJhbWVzW2ZyYW1lSW5kZXggKyAxXSAhPSAwO1xuXHR9XG59O1xuXG5zcGluZS5Ta2VsZXRvbkRhdGEgPSBmdW5jdGlvbiAoKVxue1xuXHR0aGlzLmJvbmVzID0gW107XG5cdHRoaXMuc2xvdHMgPSBbXTtcblx0dGhpcy5za2lucyA9IFtdO1xuXHR0aGlzLmV2ZW50cyA9IFtdO1xuXHR0aGlzLmFuaW1hdGlvbnMgPSBbXTtcblx0dGhpcy5pa0NvbnN0cmFpbnRzID0gW107XG59O1xuc3BpbmUuU2tlbGV0b25EYXRhLnByb3RvdHlwZSA9IHtcblx0bmFtZTogbnVsbCxcblx0ZGVmYXVsdFNraW46IG51bGwsXG5cdHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG5cdHZlcnNpb246IG51bGwsIGhhc2g6IG51bGwsXG5cdC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGZpbmRCb25lOiBmdW5jdGlvbiAoYm9uZU5hbWUpXG4gICAge1xuXHRcdHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRpZiAoYm9uZXNbaV0ubmFtZSA9PSBib25lTmFtZSkgcmV0dXJuIGJvbmVzW2ldO1xuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXHQvKiogQHJldHVybiAtMSBpZiB0aGUgYm9uZSB3YXMgbm90IGZvdW5kLiAqL1xuICAgIGZpbmRCb25lSW5kZXg6IGZ1bmN0aW9uIChib25lTmFtZSlcbiAgICB7XG5cdFx0dmFyIGJvbmVzID0gdGhpcy5ib25lcztcblx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdGlmIChib25lc1tpXS5uYW1lID09IGJvbmVOYW1lKSByZXR1cm4gaTtcblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cdC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGZpbmRTbG90OiBmdW5jdGlvbiAoc2xvdE5hbWUpXG4gICAge1xuXHRcdHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICB7XG5cdFx0XHRpZiAoc2xvdHNbaV0ubmFtZSA9PSBzbG90TmFtZSkgcmV0dXJuIHNsb3RbaV07XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXHQvKiogQHJldHVybiAtMSBpZiB0aGUgYm9uZSB3YXMgbm90IGZvdW5kLiAqL1xuICAgIGZpbmRTbG90SW5kZXg6IGZ1bmN0aW9uIChzbG90TmFtZSlcbiAgICB7XG5cdFx0dmFyIHNsb3RzID0gdGhpcy5zbG90cztcblx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdGlmIChzbG90c1tpXS5uYW1lID09IHNsb3ROYW1lKSByZXR1cm4gaTtcblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cdC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGZpbmRTa2luOiBmdW5jdGlvbiAoc2tpbk5hbWUpXG4gICAge1xuXHRcdHZhciBza2lucyA9IHRoaXMuc2tpbnM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBza2lucy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRpZiAoc2tpbnNbaV0ubmFtZSA9PSBza2luTmFtZSkgcmV0dXJuIHNraW5zW2ldO1xuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXHQvKiogQHJldHVybiBNYXkgYmUgbnVsbC4gKi9cbiAgICBmaW5kRXZlbnQ6IGZ1bmN0aW9uIChldmVudE5hbWUpXG4gICAge1xuXHRcdHZhciBldmVudHMgPSB0aGlzLmV2ZW50cztcblx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRpZiAoZXZlbnRzW2ldLm5hbWUgPT0gZXZlbnROYW1lKSByZXR1cm4gZXZlbnRzW2ldO1xuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXHQvKiogQHJldHVybiBNYXkgYmUgbnVsbC4gKi9cbiAgICBmaW5kQW5pbWF0aW9uOiBmdW5jdGlvbiAoYW5pbWF0aW9uTmFtZSlcbiAgICB7XG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBhbmltYXRpb25zLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdGlmIChhbmltYXRpb25zW2ldLm5hbWUgPT0gYW5pbWF0aW9uTmFtZSkgcmV0dXJuIGFuaW1hdGlvbnNbaV07XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cdC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGZpbmRJa0NvbnN0cmFpbnQ6IGZ1bmN0aW9uIChpa0NvbnN0cmFpbnROYW1lKVxuICAgIHtcblx0XHR2YXIgaWtDb25zdHJhaW50cyA9IHRoaXMuaWtDb25zdHJhaW50cztcblx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGlrQ29uc3RyYWludHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0aWYgKGlrQ29uc3RyYWludHNbaV0ubmFtZSA9PSBpa0NvbnN0cmFpbnROYW1lKSByZXR1cm4gaWtDb25zdHJhaW50c1tpXTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufTtcblxuc3BpbmUuU2tlbGV0b24gPSBmdW5jdGlvbiAoc2tlbGV0b25EYXRhKVxue1xuXHR0aGlzLmRhdGEgPSBza2VsZXRvbkRhdGE7XG5cblx0dGhpcy5ib25lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2tlbGV0b25EYXRhLmJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICB7XG5cdFx0dmFyIGJvbmVEYXRhID0gc2tlbGV0b25EYXRhLmJvbmVzW2ldO1xuXHRcdHZhciBwYXJlbnQgPSAhYm9uZURhdGEucGFyZW50ID8gbnVsbCA6IHRoaXMuYm9uZXNbc2tlbGV0b25EYXRhLmJvbmVzLmluZGV4T2YoYm9uZURhdGEucGFyZW50KV07XG5cdFx0dGhpcy5ib25lcy5wdXNoKG5ldyBzcGluZS5Cb25lKGJvbmVEYXRhLCB0aGlzLCBwYXJlbnQpKTtcblx0fVxuXG5cdHRoaXMuc2xvdHMgPSBbXTtcblx0dGhpcy5kcmF3T3JkZXIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNrZWxldG9uRGF0YS5zbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAge1xuXHRcdHZhciBzbG90RGF0YSA9IHNrZWxldG9uRGF0YS5zbG90c1tpXTtcblx0XHR2YXIgYm9uZSA9IHRoaXMuYm9uZXNbc2tlbGV0b25EYXRhLmJvbmVzLmluZGV4T2Yoc2xvdERhdGEuYm9uZURhdGEpXTtcblx0XHR2YXIgc2xvdCA9IG5ldyBzcGluZS5TbG90KHNsb3REYXRhLCBib25lKTtcblx0XHR0aGlzLnNsb3RzLnB1c2goc2xvdCk7XG5cdFx0dGhpcy5kcmF3T3JkZXIucHVzaChzbG90KTtcblx0fVxuXG5cdHRoaXMuaWtDb25zdHJhaW50cyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMCwgbiA9IHNrZWxldG9uRGF0YS5pa0NvbnN0cmFpbnRzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHR0aGlzLmlrQ29uc3RyYWludHMucHVzaChuZXcgc3BpbmUuSWtDb25zdHJhaW50KHNrZWxldG9uRGF0YS5pa0NvbnN0cmFpbnRzW2ldLCB0aGlzKSk7XG5cblx0dGhpcy5ib25lQ2FjaGUgPSBbXTtcblx0dGhpcy51cGRhdGVDYWNoZSgpO1xufTtcbnNwaW5lLlNrZWxldG9uLnByb3RvdHlwZSA9IHtcblx0eDogMCwgeTogMCxcblx0c2tpbjogbnVsbCxcblx0cjogMSwgZzogMSwgYjogMSwgYTogMSxcblx0dGltZTogMCxcblx0ZmxpcFg6IGZhbHNlLCBmbGlwWTogZmFsc2UsXG5cdC8qKiBDYWNoZXMgaW5mb3JtYXRpb24gYWJvdXQgYm9uZXMgYW5kIElLIGNvbnN0cmFpbnRzLiBNdXN0IGJlIGNhbGxlZCBpZiBib25lcyBvciBJSyBjb25zdHJhaW50cyBhcmUgYWRkZWQgb3IgcmVtb3ZlZC4gKi9cbiAgICB1cGRhdGVDYWNoZTogZnVuY3Rpb24gKClcbiAgICB7XG5cdFx0dmFyIGlrQ29uc3RyYWludHMgPSB0aGlzLmlrQ29uc3RyYWludHM7XG5cdFx0dmFyIGlrQ29uc3RyYWludHNDb3VudCA9IGlrQ29uc3RyYWludHMubGVuZ3RoO1xuXG5cdFx0dmFyIGFycmF5Q291bnQgPSBpa0NvbnN0cmFpbnRzQ291bnQgKyAxO1xuXHRcdHZhciBib25lQ2FjaGUgPSB0aGlzLmJvbmVDYWNoZTtcblx0XHRpZiAoYm9uZUNhY2hlLmxlbmd0aCA+IGFycmF5Q291bnQpIGJvbmVDYWNoZS5sZW5ndGggPSBhcnJheUNvdW50O1xuXHRcdGZvciAodmFyIGkgPSAwLCBuID0gYm9uZUNhY2hlLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdGJvbmVDYWNoZVtpXS5sZW5ndGggPSAwO1xuXHRcdHdoaWxlIChib25lQ2FjaGUubGVuZ3RoIDwgYXJyYXlDb3VudClcblx0XHRcdGJvbmVDYWNoZVtib25lQ2FjaGUubGVuZ3RoXSA9IFtdO1xuXG5cdFx0dmFyIG5vbklrQm9uZXMgPSBib25lQ2FjaGVbMF07XG5cdFx0dmFyIGJvbmVzID0gdGhpcy5ib25lcztcblxuXHRcdG91dGVyOlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAge1xuXHRcdFx0dmFyIGJvbmUgPSBib25lc1tpXTtcblx0XHRcdHZhciBjdXJyZW50ID0gYm9uZTtcblx0XHRcdGRvIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaWtDb25zdHJhaW50c0NvdW50OyBpaSsrKVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHR2YXIgaWtDb25zdHJhaW50ID0gaWtDb25zdHJhaW50c1tpaV07XG5cdFx0XHRcdFx0dmFyIHBhcmVudCA9IGlrQ29uc3RyYWludC5ib25lc1swXTtcblx0XHRcdFx0XHR2YXIgY2hpbGQ9IGlrQ29uc3RyYWludC5ib25lc1tpa0NvbnN0cmFpbnQuYm9uZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PSBjaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHRcdFx0Ym9uZUNhY2hlW2lpXS5wdXNoKGJvbmUpO1xuXHRcdFx0XHRcdFx0XHRib25lQ2FjaGVbaWkgKyAxXS5wdXNoKGJvbmUpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZSBvdXRlcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChjaGlsZCA9PSBwYXJlbnQpIGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2hpbGQgPSBjaGlsZC5wYXJlbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcblx0XHRcdH0gd2hpbGUgKGN1cnJlbnQpO1xuXHRcdFx0bm9uSWtCb25lc1tub25Ja0JvbmVzLmxlbmd0aF0gPSBib25lO1xuXHRcdH1cblx0fSxcblx0LyoqIFVwZGF0ZXMgdGhlIHdvcmxkIHRyYW5zZm9ybSBmb3IgZWFjaCBib25lLiAqL1xuICAgIHVwZGF0ZVdvcmxkVHJhbnNmb3JtOiBmdW5jdGlvbiAoKVxuICAgIHtcblx0XHR2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAge1xuXHRcdFx0dmFyIGJvbmUgPSBib25lc1tpXTtcblx0XHRcdGJvbmUucm90YXRpb25JSyA9IGJvbmUucm90YXRpb247XG5cdFx0fVxuXHRcdHZhciBpID0gMCwgbGFzdCA9IHRoaXMuYm9uZUNhY2hlLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlICh0cnVlKVxuICAgICAgICB7XG5cdFx0XHR2YXIgY2FjaGVCb25lcyA9IHRoaXMuYm9uZUNhY2hlW2ldO1xuXHRcdFx0Zm9yICh2YXIgaWkgPSAwLCBubiA9IGNhY2hlQm9uZXMubGVuZ3RoOyBpaSA8IG5uOyBpaSsrKVxuXHRcdFx0XHRjYWNoZUJvbmVzW2lpXS51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xuXHRcdFx0aWYgKGkgPT0gbGFzdCkgYnJlYWs7XG5cdFx0XHR0aGlzLmlrQ29uc3RyYWludHNbaV0uYXBwbHkoKTtcblx0XHRcdGkrKztcblx0XHR9XG5cdH0sXG5cdC8qKiBTZXRzIHRoZSBib25lcyBhbmQgc2xvdHMgdG8gdGhlaXIgc2V0dXAgcG9zZSB2YWx1ZXMuICovXG4gICAgc2V0VG9TZXR1cFBvc2U6IGZ1bmN0aW9uICgpXG4gICAge1xuXHRcdHRoaXMuc2V0Qm9uZXNUb1NldHVwUG9zZSgpO1xuXHRcdHRoaXMuc2V0U2xvdHNUb1NldHVwUG9zZSgpO1xuXHR9LFxuICAgIHNldEJvbmVzVG9TZXR1cFBvc2U6IGZ1bmN0aW9uICgpXG4gICAge1xuXHRcdHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRib25lc1tpXS5zZXRUb1NldHVwUG9zZSgpO1xuXG5cdFx0dmFyIGlrQ29uc3RyYWludHMgPSB0aGlzLmlrQ29uc3RyYWludHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaWtDb25zdHJhaW50cy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgIHtcblx0XHRcdHZhciBpa0NvbnN0cmFpbnQgPSBpa0NvbnN0cmFpbnRzW2ldO1xuXHRcdFx0aWtDb25zdHJhaW50LmJlbmREaXJlY3Rpb24gPSBpa0NvbnN0cmFpbnQuZGF0YS5iZW5kRGlyZWN0aW9uO1xuXHRcdFx0aWtDb25zdHJhaW50Lm1peCA9IGlrQ29uc3RyYWludC5kYXRhLm1peDtcblx0XHR9XG5cdH0sXG4gICAgc2V0U2xvdHNUb1NldHVwUG9zZTogZnVuY3Rpb24gKClcbiAgICB7XG5cdFx0dmFyIHNsb3RzID0gdGhpcy5zbG90cztcblx0XHR2YXIgZHJhd09yZGVyID0gdGhpcy5kcmF3T3JkZXI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICB7XG5cdFx0XHRkcmF3T3JkZXJbaV0gPSBzbG90c1tpXTtcblx0XHRcdHNsb3RzW2ldLnNldFRvU2V0dXBQb3NlKGkpO1xuXHRcdH1cblx0fSxcblx0LyoqIEByZXR1cm4gTWF5IHJldHVybiBudWxsLiAqL1xuICAgIGdldFJvb3RCb25lOiBmdW5jdGlvbiAoKVxuICAgIHtcblx0XHRyZXR1cm4gdGhpcy5ib25lcy5sZW5ndGggPyB0aGlzLmJvbmVzWzBdIDogbnVsbDtcblx0fSxcblx0LyoqIEByZXR1cm4gTWF5IGJlIG51bGwuICovXG4gICAgZmluZEJvbmU6IGZ1bmN0aW9uIChib25lTmFtZSlcbiAgICB7XG5cdFx0dmFyIGJvbmVzID0gdGhpcy5ib25lcztcblx0XHRmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdGlmIChib25lc1tpXS5kYXRhLm5hbWUgPT0gYm9uZU5hbWUpIHJldHVybiBib25lc1tpXTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblx0LyoqIEByZXR1cm4gLTEgaWYgdGhlIGJvbmUgd2FzIG5vdCBmb3VuZC4gKi9cbiAgICBmaW5kQm9uZUluZGV4OiBmdW5jdGlvbiAoYm9uZU5hbWUpXG4gICAge1xuXHRcdHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBib25lcy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRpZiAoYm9uZXNbaV0uZGF0YS5uYW1lID09IGJvbmVOYW1lKSByZXR1cm4gaTtcblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cdC8qKiBAcmV0dXJuIE1heSBiZSBudWxsLiAqL1xuICAgIGZpbmRTbG90OiBmdW5jdGlvbiAoc2xvdE5hbWUpXG4gICAge1xuXHRcdHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRpZiAoc2xvdHNbaV0uZGF0YS5uYW1lID09IHNsb3ROYW1lKSByZXR1cm4gc2xvdHNbaV07XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cdC8qKiBAcmV0dXJuIC0xIGlmIHRoZSBib25lIHdhcyBub3QgZm91bmQuICovXG4gICAgZmluZFNsb3RJbmRleDogZnVuY3Rpb24gKHNsb3ROYW1lKVxuICAgIHtcblx0XHR2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0aWYgKHNsb3RzW2ldLmRhdGEubmFtZSA9PSBzbG90TmFtZSkgcmV0dXJuIGk7XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuICAgIHNldFNraW5CeU5hbWU6IGZ1bmN0aW9uIChza2luTmFtZSlcbiAgICB7XG5cdFx0dmFyIHNraW4gPSB0aGlzLmRhdGEuZmluZFNraW4oc2tpbk5hbWUpO1xuXHRcdGlmICghc2tpbikgdGhyb3cgXCJTa2luIG5vdCBmb3VuZDogXCIgKyBza2luTmFtZTtcblx0XHR0aGlzLnNldFNraW4oc2tpbik7XG5cdH0sXG5cdC8qKiBTZXRzIHRoZSBza2luIHVzZWQgdG8gbG9vayB1cCBhdHRhY2htZW50cyBiZWZvcmUgbG9va2luZyBpbiB0aGUge0BsaW5rIFNrZWxldG9uRGF0YSNnZXREZWZhdWx0U2tpbigpIGRlZmF1bHQgc2tpbn0uXG5cdCAqIEF0dGFjaG1lbnRzIGZyb20gdGhlIG5ldyBza2luIGFyZSBhdHRhY2hlZCBpZiB0aGUgY29ycmVzcG9uZGluZyBhdHRhY2htZW50IGZyb20gdGhlIG9sZCBza2luIHdhcyBhdHRhY2hlZC4gSWYgdGhlcmUgd2FzXG5cdCAqIG5vIG9sZCBza2luLCBlYWNoIHNsb3QncyBzZXR1cCBtb2RlIGF0dGFjaG1lbnQgaXMgYXR0YWNoZWQgZnJvbSB0aGUgbmV3IHNraW4uXG5cdCAqIEBwYXJhbSBuZXdTa2luIE1heSBiZSBudWxsLiAqL1xuICAgIHNldFNraW46IGZ1bmN0aW9uIChuZXdTa2luKVxuICAgIHtcbiAgICAgICAgaWYgKG5ld1NraW4pXG4gICAgICAgIHtcblx0XHRcdGlmICh0aGlzLnNraW4pXG5cdFx0XHRcdG5ld1NraW4uX2F0dGFjaEFsbCh0aGlzLCB0aGlzLnNraW4pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuXHRcdFx0XHR2YXIgc2xvdHMgPSB0aGlzLnNsb3RzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHR2YXIgc2xvdCA9IHNsb3RzW2ldO1xuXHRcdFx0XHRcdHZhciBuYW1lID0gc2xvdC5kYXRhLmF0dGFjaG1lbnROYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSlcbiAgICAgICAgICAgICAgICAgICAge1xuXHRcdFx0XHRcdFx0dmFyIGF0dGFjaG1lbnQgPSBuZXdTa2luLmdldEF0dGFjaG1lbnQoaSwgbmFtZSk7XG5cdFx0XHRcdFx0XHRpZiAoYXR0YWNobWVudCkgc2xvdC5zZXRBdHRhY2htZW50KGF0dGFjaG1lbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnNraW4gPSBuZXdTa2luO1xuXHR9LFxuXHQvKiogQHJldHVybiBNYXkgYmUgbnVsbC4gKi9cbiAgICBnZXRBdHRhY2htZW50QnlTbG90TmFtZTogZnVuY3Rpb24gKHNsb3ROYW1lLCBhdHRhY2htZW50TmFtZSlcbiAgICB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0QXR0YWNobWVudEJ5U2xvdEluZGV4KHRoaXMuZGF0YS5maW5kU2xvdEluZGV4KHNsb3ROYW1lKSwgYXR0YWNobWVudE5hbWUpO1xuXHR9LFxuXHQvKiogQHJldHVybiBNYXkgYmUgbnVsbC4gKi9cbiAgICBnZXRBdHRhY2htZW50QnlTbG90SW5kZXg6IGZ1bmN0aW9uIChzbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuc2tpbilcbiAgICAgICAge1xuXHRcdFx0dmFyIGF0dGFjaG1lbnQgPSB0aGlzLnNraW4uZ2V0QXR0YWNobWVudChzbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lKTtcblx0XHRcdGlmIChhdHRhY2htZW50KSByZXR1cm4gYXR0YWNobWVudDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuZGF0YS5kZWZhdWx0U2tpbikgcmV0dXJuIHRoaXMuZGF0YS5kZWZhdWx0U2tpbi5nZXRBdHRhY2htZW50KHNsb3RJbmRleCwgYXR0YWNobWVudE5hbWUpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXHQvKiogQHBhcmFtIGF0dGFjaG1lbnROYW1lIE1heSBiZSBudWxsLiAqL1xuICAgIHNldEF0dGFjaG1lbnQ6IGZ1bmN0aW9uIChzbG90TmFtZSwgYXR0YWNobWVudE5hbWUpXG4gICAge1xuXHRcdHZhciBzbG90cyA9IHRoaXMuc2xvdHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2xvdHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICB7XG5cdFx0XHR2YXIgc2xvdCA9IHNsb3RzW2ldO1xuICAgICAgICAgICAgaWYgKHNsb3QuZGF0YS5uYW1lID09IHNsb3ROYW1lKVxuICAgICAgICAgICAge1xuXHRcdFx0XHR2YXIgYXR0YWNobWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnROYW1lKVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHRhdHRhY2htZW50ID0gdGhpcy5nZXRBdHRhY2htZW50QnlTbG90SW5kZXgoaSwgYXR0YWNobWVudE5hbWUpO1xuXHRcdFx0XHRcdGlmICghYXR0YWNobWVudCkgdGhyb3cgXCJBdHRhY2htZW50IG5vdCBmb3VuZDogXCIgKyBhdHRhY2htZW50TmFtZSArIFwiLCBmb3Igc2xvdDogXCIgKyBzbG90TmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzbG90LnNldEF0dGFjaG1lbnQoYXR0YWNobWVudCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhyb3cgXCJTbG90IG5vdCBmb3VuZDogXCIgKyBzbG90TmFtZTtcblx0fSxcblx0LyoqIEByZXR1cm4gTWF5IGJlIG51bGwuICovXG4gICAgZmluZElrQ29uc3RyYWludDogZnVuY3Rpb24gKGlrQ29uc3RyYWludE5hbWUpXG4gICAge1xuXHRcdHZhciBpa0NvbnN0cmFpbnRzID0gdGhpcy5pa0NvbnN0cmFpbnRzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBuID0gaWtDb25zdHJhaW50cy5sZW5ndGg7IGkgPCBuOyBpKyspXG5cdFx0XHRpZiAoaWtDb25zdHJhaW50c1tpXS5kYXRhLm5hbWUgPT0gaWtDb25zdHJhaW50TmFtZSkgcmV0dXJuIGlrQ29uc3RyYWludHNbaV07XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZGVsdGEpXG4gICAge1xuXHRcdHRoaXMudGltZSArPSBkZWx0YTtcblx0fVxufTtcblxuc3BpbmUuRXZlbnREYXRhID0gZnVuY3Rpb24gKG5hbWUpXG57XG5cdHRoaXMubmFtZSA9IG5hbWU7XG59O1xuc3BpbmUuRXZlbnREYXRhLnByb3RvdHlwZSA9IHtcblx0aW50VmFsdWU6IDAsXG5cdGZsb2F0VmFsdWU6IDAsXG5cdHN0cmluZ1ZhbHVlOiBudWxsXG59O1xuXG5zcGluZS5FdmVudCA9IGZ1bmN0aW9uIChkYXRhKVxue1xuXHR0aGlzLmRhdGEgPSBkYXRhO1xufTtcbnNwaW5lLkV2ZW50LnByb3RvdHlwZSA9IHtcblx0aW50VmFsdWU6IDAsXG5cdGZsb2F0VmFsdWU6IDAsXG5cdHN0cmluZ1ZhbHVlOiBudWxsXG59O1xuXG5zcGluZS5BdHRhY2htZW50VHlwZSA9IHtcblx0cmVnaW9uOiAwLFxuXHRib3VuZGluZ2JveDogMSxcblx0bWVzaDogMixcblx0c2tpbm5lZG1lc2g6IDNcbn07XG5cbnNwaW5lLlJlZ2lvbkF0dGFjaG1lbnQgPSBmdW5jdGlvbiAobmFtZSlcbntcblx0dGhpcy5uYW1lID0gbmFtZTtcblx0dGhpcy5vZmZzZXQgPSBbXTtcblx0dGhpcy5vZmZzZXQubGVuZ3RoID0gODtcblx0dGhpcy51dnMgPSBbXTtcblx0dGhpcy51dnMubGVuZ3RoID0gODtcbn07XG5zcGluZS5SZWdpb25BdHRhY2htZW50LnByb3RvdHlwZSA9IHtcblx0dHlwZTogc3BpbmUuQXR0YWNobWVudFR5cGUucmVnaW9uLFxuXHR4OiAwLCB5OiAwLFxuXHRyb3RhdGlvbjogMCxcblx0c2NhbGVYOiAxLCBzY2FsZVk6IDEsXG5cdHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG5cdHI6IDEsIGc6IDEsIGI6IDEsIGE6IDEsXG5cdHBhdGg6IG51bGwsXG5cdHJlbmRlcmVyT2JqZWN0OiBudWxsLFxuXHRyZWdpb25PZmZzZXRYOiAwLCByZWdpb25PZmZzZXRZOiAwLFxuXHRyZWdpb25XaWR0aDogMCwgcmVnaW9uSGVpZ2h0OiAwLFxuXHRyZWdpb25PcmlnaW5hbFdpZHRoOiAwLCByZWdpb25PcmlnaW5hbEhlaWdodDogMCxcbiAgICBzZXRVVnM6IGZ1bmN0aW9uICh1LCB2LCB1MiwgdjIsIHJvdGF0ZSlcbiAgICB7XG5cdFx0dmFyIHV2cyA9IHRoaXMudXZzO1xuICAgICAgICBpZiAocm90YXRlKVxuICAgICAgICB7XG5cdFx0XHR1dnNbMi8qWDIqL10gPSB1O1xuXHRcdFx0dXZzWzMvKlkyKi9dID0gdjI7XG5cdFx0XHR1dnNbNC8qWDMqL10gPSB1O1xuXHRcdFx0dXZzWzUvKlkzKi9dID0gdjtcblx0XHRcdHV2c1s2LypYNCovXSA9IHUyO1xuXHRcdFx0dXZzWzcvKlk0Ki9dID0gdjtcblx0XHRcdHV2c1swLypYMSovXSA9IHUyO1xuXHRcdFx0dXZzWzEvKlkxKi9dID0gdjI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHV2c1swLypYMSovXSA9IHU7XG5cdFx0XHR1dnNbMS8qWTEqL10gPSB2Mjtcblx0XHRcdHV2c1syLypYMiovXSA9IHU7XG5cdFx0XHR1dnNbMy8qWTIqL10gPSB2O1xuXHRcdFx0dXZzWzQvKlgzKi9dID0gdTI7XG5cdFx0XHR1dnNbNS8qWTMqL10gPSB2O1xuXHRcdFx0dXZzWzYvKlg0Ki9dID0gdTI7XG5cdFx0XHR1dnNbNy8qWTQqL10gPSB2Mjtcblx0XHR9XG5cdH0sXG4gICAgdXBkYXRlT2Zmc2V0OiBmdW5jdGlvbiAoKVxuICAgIHtcblx0XHR2YXIgcmVnaW9uU2NhbGVYID0gdGhpcy53aWR0aCAvIHRoaXMucmVnaW9uT3JpZ2luYWxXaWR0aCAqIHRoaXMuc2NhbGVYO1xuXHRcdHZhciByZWdpb25TY2FsZVkgPSB0aGlzLmhlaWdodCAvIHRoaXMucmVnaW9uT3JpZ2luYWxIZWlnaHQgKiB0aGlzLnNjYWxlWTtcblx0XHR2YXIgbG9jYWxYID0gLXRoaXMud2lkdGggLyAyICogdGhpcy5zY2FsZVggKyB0aGlzLnJlZ2lvbk9mZnNldFggKiByZWdpb25TY2FsZVg7XG5cdFx0dmFyIGxvY2FsWSA9IC10aGlzLmhlaWdodCAvIDIgKiB0aGlzLnNjYWxlWSArIHRoaXMucmVnaW9uT2Zmc2V0WSAqIHJlZ2lvblNjYWxlWTtcblx0XHR2YXIgbG9jYWxYMiA9IGxvY2FsWCArIHRoaXMucmVnaW9uV2lkdGggKiByZWdpb25TY2FsZVg7XG5cdFx0dmFyIGxvY2FsWTIgPSBsb2NhbFkgKyB0aGlzLnJlZ2lvbkhlaWdodCAqIHJlZ2lvblNjYWxlWTtcblx0XHR2YXIgcmFkaWFucyA9IHRoaXMucm90YXRpb24gKiBzcGluZS5kZWdSYWQ7XG5cdFx0dmFyIGNvcyA9IE1hdGguY29zKHJhZGlhbnMpO1xuXHRcdHZhciBzaW4gPSBNYXRoLnNpbihyYWRpYW5zKTtcblx0XHR2YXIgbG9jYWxYQ29zID0gbG9jYWxYICogY29zICsgdGhpcy54O1xuXHRcdHZhciBsb2NhbFhTaW4gPSBsb2NhbFggKiBzaW47XG5cdFx0dmFyIGxvY2FsWUNvcyA9IGxvY2FsWSAqIGNvcyArIHRoaXMueTtcblx0XHR2YXIgbG9jYWxZU2luID0gbG9jYWxZICogc2luO1xuXHRcdHZhciBsb2NhbFgyQ29zID0gbG9jYWxYMiAqIGNvcyArIHRoaXMueDtcblx0XHR2YXIgbG9jYWxYMlNpbiA9IGxvY2FsWDIgKiBzaW47XG5cdFx0dmFyIGxvY2FsWTJDb3MgPSBsb2NhbFkyICogY29zICsgdGhpcy55O1xuXHRcdHZhciBsb2NhbFkyU2luID0gbG9jYWxZMiAqIHNpbjtcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG5cdFx0b2Zmc2V0WzAvKlgxKi9dID0gbG9jYWxYQ29zIC0gbG9jYWxZU2luO1xuXHRcdG9mZnNldFsxLypZMSovXSA9IGxvY2FsWUNvcyArIGxvY2FsWFNpbjtcblx0XHRvZmZzZXRbMi8qWDIqL10gPSBsb2NhbFhDb3MgLSBsb2NhbFkyU2luO1xuXHRcdG9mZnNldFszLypZMiovXSA9IGxvY2FsWTJDb3MgKyBsb2NhbFhTaW47XG5cdFx0b2Zmc2V0WzQvKlgzKi9dID0gbG9jYWxYMkNvcyAtIGxvY2FsWTJTaW47XG5cdFx0b2Zmc2V0WzUvKlkzKi9dID0gbG9jYWxZMkNvcyArIGxvY2FsWDJTaW47XG5cdFx0b2Zmc2V0WzYvKlg0Ki9dID0gbG9jYWxYMkNvcyAtIGxvY2FsWVNpbjtcblx0XHRvZmZzZXRbNy8qWTQqL10gPSBsb2NhbFlDb3MgKyBsb2NhbFgyU2luO1xuXHR9LFxuICAgIGNvbXB1dGVWZXJ0aWNlczogZnVuY3Rpb24gKHgsIHksIGJvbmUsIHZlcnRpY2VzKVxuICAgIHtcblx0XHR4ICs9IGJvbmUud29ybGRYO1xuXHRcdHkgKz0gYm9uZS53b3JsZFk7XG5cdFx0dmFyIG0wMCA9IGJvbmUubTAwLCBtMDEgPSBib25lLm0wMSwgbTEwID0gYm9uZS5tMTAsIG0xMSA9IGJvbmUubTExO1xuXHRcdHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcblx0XHR2ZXJ0aWNlc1swLypYMSovXSA9IG9mZnNldFswLypYMSovXSAqIG0wMCArIG9mZnNldFsxLypZMSovXSAqIG0wMSArIHg7XG5cdFx0dmVydGljZXNbMS8qWTEqL10gPSBvZmZzZXRbMC8qWDEqL10gKiBtMTAgKyBvZmZzZXRbMS8qWTEqL10gKiBtMTEgKyB5O1xuXHRcdHZlcnRpY2VzWzIvKlgyKi9dID0gb2Zmc2V0WzIvKlgyKi9dICogbTAwICsgb2Zmc2V0WzMvKlkyKi9dICogbTAxICsgeDtcblx0XHR2ZXJ0aWNlc1szLypZMiovXSA9IG9mZnNldFsyLypYMiovXSAqIG0xMCArIG9mZnNldFszLypZMiovXSAqIG0xMSArIHk7XG5cdFx0dmVydGljZXNbNC8qWDMqL10gPSBvZmZzZXRbNC8qWDMqL10gKiBtMDAgKyBvZmZzZXRbNS8qWDMqL10gKiBtMDEgKyB4O1xuXHRcdHZlcnRpY2VzWzUvKlgzKi9dID0gb2Zmc2V0WzQvKlgzKi9dICogbTEwICsgb2Zmc2V0WzUvKlgzKi9dICogbTExICsgeTtcblx0XHR2ZXJ0aWNlc1s2LypYNCovXSA9IG9mZnNldFs2LypYNCovXSAqIG0wMCArIG9mZnNldFs3LypZNCovXSAqIG0wMSArIHg7XG5cdFx0dmVydGljZXNbNy8qWTQqL10gPSBvZmZzZXRbNi8qWDQqL10gKiBtMTAgKyBvZmZzZXRbNy8qWTQqL10gKiBtMTEgKyB5O1xuXHR9XG59O1xuXG5zcGluZS5NZXNoQXR0YWNobWVudCA9IGZ1bmN0aW9uIChuYW1lKVxue1xuXHR0aGlzLm5hbWUgPSBuYW1lO1xufTtcbnNwaW5lLk1lc2hBdHRhY2htZW50LnByb3RvdHlwZSA9IHtcblx0dHlwZTogc3BpbmUuQXR0YWNobWVudFR5cGUubWVzaCxcblx0dmVydGljZXM6IG51bGwsXG5cdHV2czogbnVsbCxcblx0cmVnaW9uVVZzOiBudWxsLFxuXHR0cmlhbmdsZXM6IG51bGwsXG5cdGh1bGxMZW5ndGg6IDAsXG5cdHI6IDEsIGc6IDEsIGI6IDEsIGE6IDEsXG5cdHBhdGg6IG51bGwsXG5cdHJlbmRlcmVyT2JqZWN0OiBudWxsLFxuXHRyZWdpb25VOiAwLCByZWdpb25WOiAwLCByZWdpb25VMjogMCwgcmVnaW9uVjI6IDAsIHJlZ2lvblJvdGF0ZTogZmFsc2UsXG5cdHJlZ2lvbk9mZnNldFg6IDAsIHJlZ2lvbk9mZnNldFk6IDAsXG5cdHJlZ2lvbldpZHRoOiAwLCByZWdpb25IZWlnaHQ6IDAsXG5cdHJlZ2lvbk9yaWdpbmFsV2lkdGg6IDAsIHJlZ2lvbk9yaWdpbmFsSGVpZ2h0OiAwLFxuXHRlZGdlczogbnVsbCxcblx0d2lkdGg6IDAsIGhlaWdodDogMCxcbiAgICB1cGRhdGVVVnM6IGZ1bmN0aW9uICgpXG4gICAge1xuXHRcdHZhciB3aWR0aCA9IHRoaXMucmVnaW9uVTIgLSB0aGlzLnJlZ2lvblUsIGhlaWdodCA9IHRoaXMucmVnaW9uVjIgLSB0aGlzLnJlZ2lvblY7XG5cdFx0dmFyIG4gPSB0aGlzLnJlZ2lvblVWcy5sZW5ndGg7XG4gICAgICAgIGlmICghdGhpcy51dnMgfHwgdGhpcy51dnMubGVuZ3RoICE9IG4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXZzID0gbmV3IHNwaW5lLkZsb2F0MzJBcnJheShuKTtcblx0XHR9XG4gICAgICAgIGlmICh0aGlzLnJlZ2lvblJvdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpICs9IDIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy51dnNbaV0gPSB0aGlzLnJlZ2lvblUgKyB0aGlzLnJlZ2lvblVWc1tpICsgMV0gKiB3aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLnV2c1tpICsgMV0gPSB0aGlzLnJlZ2lvblYgKyBoZWlnaHQgLSB0aGlzLnJlZ2lvblVWc1tpXSAqIGhlaWdodDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpICs9IDIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy51dnNbaV0gPSB0aGlzLnJlZ2lvblUgKyB0aGlzLnJlZ2lvblVWc1tpXSAqIHdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMudXZzW2kgKyAxXSA9IHRoaXMucmVnaW9uViArIHRoaXMucmVnaW9uVVZzW2kgKyAxXSAqIGhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG4gICAgY29tcHV0ZVdvcmxkVmVydGljZXM6IGZ1bmN0aW9uICh4LCB5LCBzbG90LCB3b3JsZFZlcnRpY2VzKVxuICAgIHtcblx0XHR2YXIgYm9uZSA9IHNsb3QuYm9uZTtcblx0XHR4ICs9IGJvbmUud29ybGRYO1xuXHRcdHkgKz0gYm9uZS53b3JsZFk7XG5cdFx0dmFyIG0wMCA9IGJvbmUubTAwLCBtMDEgPSBib25lLm0wMSwgbTEwID0gYm9uZS5tMTAsIG0xMSA9IGJvbmUubTExO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG5cdFx0dmFyIHZlcnRpY2VzQ291bnQgPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cdFx0aWYgKHNsb3QuYXR0YWNobWVudFZlcnRpY2VzLmxlbmd0aCA9PSB2ZXJ0aWNlc0NvdW50KSB2ZXJ0aWNlcyA9IHNsb3QuYXR0YWNobWVudFZlcnRpY2VzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzQ291bnQ7IGkgKz0gMilcbiAgICAgICAge1xuXHRcdFx0dmFyIHZ4ID0gdmVydGljZXNbaV07XG5cdFx0XHR2YXIgdnkgPSB2ZXJ0aWNlc1tpICsgMV07XG5cdFx0XHR3b3JsZFZlcnRpY2VzW2ldID0gdnggKiBtMDAgKyB2eSAqIG0wMSArIHg7XG5cdFx0XHR3b3JsZFZlcnRpY2VzW2kgKyAxXSA9IHZ4ICogbTEwICsgdnkgKiBtMTEgKyB5O1xuXHRcdH1cblx0fVxufTtcblxuc3BpbmUuU2tpbm5lZE1lc2hBdHRhY2htZW50ID0gZnVuY3Rpb24gKG5hbWUpXG57XG5cdHRoaXMubmFtZSA9IG5hbWU7XG59O1xuc3BpbmUuU2tpbm5lZE1lc2hBdHRhY2htZW50LnByb3RvdHlwZSA9IHtcblx0dHlwZTogc3BpbmUuQXR0YWNobWVudFR5cGUuc2tpbm5lZG1lc2gsXG5cdGJvbmVzOiBudWxsLFxuXHR3ZWlnaHRzOiBudWxsLFxuXHR1dnM6IG51bGwsXG5cdHJlZ2lvblVWczogbnVsbCxcblx0dHJpYW5nbGVzOiBudWxsLFxuXHRodWxsTGVuZ3RoOiAwLFxuXHRyOiAxLCBnOiAxLCBiOiAxLCBhOiAxLFxuXHRwYXRoOiBudWxsLFxuXHRyZW5kZXJlck9iamVjdDogbnVsbCxcblx0cmVnaW9uVTogMCwgcmVnaW9uVjogMCwgcmVnaW9uVTI6IDAsIHJlZ2lvblYyOiAwLCByZWdpb25Sb3RhdGU6IGZhbHNlLFxuXHRyZWdpb25PZmZzZXRYOiAwLCByZWdpb25PZmZzZXRZOiAwLFxuXHRyZWdpb25XaWR0aDogMCwgcmVnaW9uSGVpZ2h0OiAwLFxuXHRyZWdpb25PcmlnaW5hbFdpZHRoOiAwLCByZWdpb25PcmlnaW5hbEhlaWdodDogMCxcblx0ZWRnZXM6IG51bGwsXG5cdHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG4gICAgdXBkYXRlVVZzOiBmdW5jdGlvbiAodSwgdiwgdTIsIHYyLCByb3RhdGUpXG4gICAge1xuXHRcdHZhciB3aWR0aCA9IHRoaXMucmVnaW9uVTIgLSB0aGlzLnJlZ2lvblUsIGhlaWdodCA9IHRoaXMucmVnaW9uVjIgLSB0aGlzLnJlZ2lvblY7XG5cdFx0dmFyIG4gPSB0aGlzLnJlZ2lvblVWcy5sZW5ndGg7XG4gICAgICAgIGlmICghdGhpcy51dnMgfHwgdGhpcy51dnMubGVuZ3RoICE9IG4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXZzID0gbmV3IHNwaW5lLkZsb2F0MzJBcnJheShuKTtcblx0XHR9XG4gICAgICAgIGlmICh0aGlzLnJlZ2lvblJvdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpICs9IDIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy51dnNbaV0gPSB0aGlzLnJlZ2lvblUgKyB0aGlzLnJlZ2lvblVWc1tpICsgMV0gKiB3aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLnV2c1tpICsgMV0gPSB0aGlzLnJlZ2lvblYgKyBoZWlnaHQgLSB0aGlzLnJlZ2lvblVWc1tpXSAqIGhlaWdodDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpICs9IDIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy51dnNbaV0gPSB0aGlzLnJlZ2lvblUgKyB0aGlzLnJlZ2lvblVWc1tpXSAqIHdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMudXZzW2kgKyAxXSA9IHRoaXMucmVnaW9uViArIHRoaXMucmVnaW9uVVZzW2kgKyAxXSAqIGhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG4gICAgY29tcHV0ZVdvcmxkVmVydGljZXM6IGZ1bmN0aW9uICh4LCB5LCBzbG90LCB3b3JsZFZlcnRpY2VzKVxuICAgIHtcblx0XHR2YXIgc2tlbGV0b25Cb25lcyA9IHNsb3QuYm9uZS5za2VsZXRvbi5ib25lcztcblx0XHR2YXIgd2VpZ2h0cyA9IHRoaXMud2VpZ2h0cztcblx0XHR2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXG5cdFx0dmFyIHcgPSAwLCB2ID0gMCwgYiA9IDAsIGYgPSAwLCBuID0gYm9uZXMubGVuZ3RoLCBubjtcblx0XHR2YXIgd3gsIHd5LCBib25lLCB2eCwgdnksIHdlaWdodDtcbiAgICAgICAgaWYgKCFzbG90LmF0dGFjaG1lbnRWZXJ0aWNlcy5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAoOyB2IDwgbjsgdyArPSAyKVxuICAgICAgICAgICAge1xuXHRcdFx0XHR3eCA9IDA7XG5cdFx0XHRcdHd5ID0gMDtcblx0XHRcdFx0bm4gPSBib25lc1t2KytdICsgdjtcbiAgICAgICAgICAgICAgICBmb3IgKDsgdiA8IG5uOyB2KyssIGIgKz0gMylcbiAgICAgICAgICAgICAgICB7XG5cdFx0XHRcdFx0Ym9uZSA9IHNrZWxldG9uQm9uZXNbYm9uZXNbdl1dO1xuXHRcdFx0XHRcdHZ4ID0gd2VpZ2h0c1tiXTtcblx0XHRcdFx0XHR2eSA9IHdlaWdodHNbYiArIDFdO1xuXHRcdFx0XHRcdHdlaWdodCA9IHdlaWdodHNbYiArIDJdO1xuXHRcdFx0XHRcdHd4ICs9ICh2eCAqIGJvbmUubTAwICsgdnkgKiBib25lLm0wMSArIGJvbmUud29ybGRYKSAqIHdlaWdodDtcblx0XHRcdFx0XHR3eSArPSAodnggKiBib25lLm0xMCArIHZ5ICogYm9uZS5tMTEgKyBib25lLndvcmxkWSkgKiB3ZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0d29ybGRWZXJ0aWNlc1t3XSA9IHd4ICsgeDtcblx0XHRcdFx0d29ybGRWZXJ0aWNlc1t3ICsgMV0gPSB3eSArIHk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBmZmQgPSBzbG90LmF0dGFjaG1lbnRWZXJ0aWNlcztcbiAgICAgICAgICAgIGZvciAoOyB2IDwgbjsgdyArPSAyKVxuICAgICAgICAgICAge1xuXHRcdFx0XHR3eCA9IDA7XG5cdFx0XHRcdHd5ID0gMDtcblx0XHRcdFx0bm4gPSBib25lc1t2KytdICsgdjtcbiAgICAgICAgICAgICAgICBmb3IgKDsgdiA8IG5uOyB2KyssIGIgKz0gMywgZiArPSAyKVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHRib25lID0gc2tlbGV0b25Cb25lc1tib25lc1t2XV07XG5cdFx0XHRcdFx0dnggPSB3ZWlnaHRzW2JdICsgZmZkW2ZdO1xuXHRcdFx0XHRcdHZ5ID0gd2VpZ2h0c1tiICsgMV0gKyBmZmRbZiArIDFdO1xuXHRcdFx0XHRcdHdlaWdodCA9IHdlaWdodHNbYiArIDJdO1xuXHRcdFx0XHRcdHd4ICs9ICh2eCAqIGJvbmUubTAwICsgdnkgKiBib25lLm0wMSArIGJvbmUud29ybGRYKSAqIHdlaWdodDtcblx0XHRcdFx0XHR3eSArPSAodnggKiBib25lLm0xMCArIHZ5ICogYm9uZS5tMTEgKyBib25lLndvcmxkWSkgKiB3ZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0d29ybGRWZXJ0aWNlc1t3XSA9IHd4ICsgeDtcblx0XHRcdFx0d29ybGRWZXJ0aWNlc1t3ICsgMV0gPSB3eSArIHk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5zcGluZS5Cb3VuZGluZ0JveEF0dGFjaG1lbnQgPSBmdW5jdGlvbiAobmFtZSlcbntcblx0dGhpcy5uYW1lID0gbmFtZTtcblx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xufTtcbnNwaW5lLkJvdW5kaW5nQm94QXR0YWNobWVudC5wcm90b3R5cGUgPSB7XG5cdHR5cGU6IHNwaW5lLkF0dGFjaG1lbnRUeXBlLmJvdW5kaW5nYm94LFxuICAgIGNvbXB1dGVXb3JsZFZlcnRpY2VzOiBmdW5jdGlvbiAoeCwgeSwgYm9uZSwgd29ybGRWZXJ0aWNlcylcbiAgICB7XG5cdFx0eCArPSBib25lLndvcmxkWDtcblx0XHR5ICs9IGJvbmUud29ybGRZO1xuXHRcdHZhciBtMDAgPSBib25lLm0wMCwgbTAxID0gYm9uZS5tMDEsIG0xMCA9IGJvbmUubTEwLCBtMTEgPSBib25lLm0xMTtcblx0XHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IG47IGkgKz0gMilcbiAgICAgICAge1xuXHRcdFx0dmFyIHB4ID0gdmVydGljZXNbaV07XG5cdFx0XHR2YXIgcHkgPSB2ZXJ0aWNlc1tpICsgMV07XG5cdFx0XHR3b3JsZFZlcnRpY2VzW2ldID0gcHggKiBtMDAgKyBweSAqIG0wMSArIHg7XG5cdFx0XHR3b3JsZFZlcnRpY2VzW2kgKyAxXSA9IHB4ICogbTEwICsgcHkgKiBtMTEgKyB5O1xuXHRcdH1cblx0fVxufTtcblxuc3BpbmUuQW5pbWF0aW9uU3RhdGVEYXRhID0gZnVuY3Rpb24gKHNrZWxldG9uRGF0YSlcbntcblx0dGhpcy5za2VsZXRvbkRhdGEgPSBza2VsZXRvbkRhdGE7XG5cdHRoaXMuYW5pbWF0aW9uVG9NaXhUaW1lID0ge307XG59O1xuc3BpbmUuQW5pbWF0aW9uU3RhdGVEYXRhLnByb3RvdHlwZSA9IHtcblx0ZGVmYXVsdE1peDogMCxcbiAgICBzZXRNaXhCeU5hbWU6IGZ1bmN0aW9uIChmcm9tTmFtZSwgdG9OYW1lLCBkdXJhdGlvbilcbiAgICB7XG5cdFx0dmFyIGZyb20gPSB0aGlzLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKGZyb21OYW1lKTtcblx0XHRpZiAoIWZyb20pIHRocm93IFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyBmcm9tTmFtZTtcblx0XHR2YXIgdG8gPSB0aGlzLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKHRvTmFtZSk7XG5cdFx0aWYgKCF0bykgdGhyb3cgXCJBbmltYXRpb24gbm90IGZvdW5kOiBcIiArIHRvTmFtZTtcblx0XHR0aGlzLnNldE1peChmcm9tLCB0bywgZHVyYXRpb24pO1xuXHR9LFxuICAgIHNldE1peDogZnVuY3Rpb24gKGZyb20sIHRvLCBkdXJhdGlvbilcbiAgICB7XG5cdFx0dGhpcy5hbmltYXRpb25Ub01peFRpbWVbZnJvbS5uYW1lICsgXCI6XCIgKyB0by5uYW1lXSA9IGR1cmF0aW9uO1xuXHR9LFxuICAgIGdldE1peDogZnVuY3Rpb24gKGZyb20sIHRvKVxuICAgIHtcblx0XHR2YXIga2V5ID0gZnJvbS5uYW1lICsgXCI6XCIgKyB0by5uYW1lO1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGlvblRvTWl4VGltZS5oYXNPd25Qcm9wZXJ0eShrZXkpID8gdGhpcy5hbmltYXRpb25Ub01peFRpbWVba2V5XSA6IHRoaXMuZGVmYXVsdE1peDtcblx0fVxufTtcblxuc3BpbmUuVHJhY2tFbnRyeSA9IGZ1bmN0aW9uICgpXG57fTtcbnNwaW5lLlRyYWNrRW50cnkucHJvdG90eXBlID0ge1xuXHRuZXh0OiBudWxsLCBwcmV2aW91czogbnVsbCxcblx0YW5pbWF0aW9uOiBudWxsLFxuXHRsb29wOiBmYWxzZSxcblx0ZGVsYXk6IDAsIHRpbWU6IDAsIGxhc3RUaW1lOiAtMSwgZW5kVGltZTogMCxcblx0dGltZVNjYWxlOiAxLFxuXHRtaXhUaW1lOiAwLCBtaXhEdXJhdGlvbjogMCwgbWl4OiAxLFxuXHRvblN0YXJ0OiBudWxsLCBvbkVuZDogbnVsbCwgb25Db21wbGV0ZTogbnVsbCwgb25FdmVudDogbnVsbFxufTtcblxuc3BpbmUuQW5pbWF0aW9uU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGVEYXRhKVxue1xuXHR0aGlzLmRhdGEgPSBzdGF0ZURhdGE7XG5cdHRoaXMudHJhY2tzID0gW107XG5cdHRoaXMuZXZlbnRzID0gW107XG59O1xuc3BpbmUuQW5pbWF0aW9uU3RhdGUucHJvdG90eXBlID0ge1xuXHRvblN0YXJ0OiBudWxsLFxuXHRvbkVuZDogbnVsbCxcblx0b25Db21wbGV0ZTogbnVsbCxcblx0b25FdmVudDogbnVsbCxcblx0dGltZVNjYWxlOiAxLFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRlbHRhKVxuICAgIHtcblx0XHRkZWx0YSAqPSB0aGlzLnRpbWVTY2FsZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSB0aGlzLnRyYWNrc1tpXTtcblx0XHRcdGlmICghY3VycmVudCkgY29udGludWU7XG5cblx0XHRcdGN1cnJlbnQudGltZSArPSBkZWx0YSAqIGN1cnJlbnQudGltZVNjYWxlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQucHJldmlvdXMpXG4gICAgICAgICAgICB7XG5cdFx0XHRcdHZhciBwcmV2aW91c0RlbHRhID0gZGVsdGEgKiBjdXJyZW50LnByZXZpb3VzLnRpbWVTY2FsZTtcblx0XHRcdFx0Y3VycmVudC5wcmV2aW91cy50aW1lICs9IHByZXZpb3VzRGVsdGE7XG5cdFx0XHRcdGN1cnJlbnQubWl4VGltZSArPSBwcmV2aW91c0RlbHRhO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbmV4dCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAge1xuXHRcdFx0XHRuZXh0LnRpbWUgPSBjdXJyZW50Lmxhc3RUaW1lIC0gbmV4dC5kZWxheTtcblx0XHRcdFx0aWYgKG5leHQudGltZSA+PSAwKSB0aGlzLnNldEN1cnJlbnQoaSwgbmV4dCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBFbmQgbm9uLWxvb3BpbmcgYW5pbWF0aW9uIHdoZW4gaXQgcmVhY2hlcyBpdHMgZW5kIHRpbWUgYW5kIHRoZXJlIGlzIG5vIG5leHQgZW50cnkuXG5cdFx0XHRcdGlmICghY3VycmVudC5sb29wICYmIGN1cnJlbnQubGFzdFRpbWUgPj0gY3VycmVudC5lbmRUaW1lKSB0aGlzLmNsZWFyVHJhY2soaSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuICAgIGFwcGx5OiBmdW5jdGlvbiAoc2tlbGV0b24pXG4gICAge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG5cdFx0XHR2YXIgY3VycmVudCA9IHRoaXMudHJhY2tzW2ldO1xuXHRcdFx0aWYgKCFjdXJyZW50KSBjb250aW51ZTtcblxuXHRcdFx0dGhpcy5ldmVudHMubGVuZ3RoID0gMDtcblxuXHRcdFx0dmFyIHRpbWUgPSBjdXJyZW50LnRpbWU7XG5cdFx0XHR2YXIgbGFzdFRpbWUgPSBjdXJyZW50Lmxhc3RUaW1lO1xuXHRcdFx0dmFyIGVuZFRpbWUgPSBjdXJyZW50LmVuZFRpbWU7XG5cdFx0XHR2YXIgbG9vcCA9IGN1cnJlbnQubG9vcDtcblx0XHRcdGlmICghbG9vcCAmJiB0aW1lID4gZW5kVGltZSkgdGltZSA9IGVuZFRpbWU7XG5cblx0XHRcdHZhciBwcmV2aW91cyA9IGN1cnJlbnQucHJldmlvdXM7XG4gICAgICAgICAgICBpZiAoIXByZXZpb3VzKVxuICAgICAgICAgICAge1xuXHRcdFx0XHRpZiAoY3VycmVudC5taXggPT0gMSlcblx0XHRcdFx0XHRjdXJyZW50LmFuaW1hdGlvbi5hcHBseShza2VsZXRvbiwgY3VycmVudC5sYXN0VGltZSwgdGltZSwgbG9vcCwgdGhpcy5ldmVudHMpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0Y3VycmVudC5hbmltYXRpb24ubWl4KHNrZWxldG9uLCBjdXJyZW50Lmxhc3RUaW1lLCB0aW1lLCBsb29wLCB0aGlzLmV2ZW50cywgY3VycmVudC5taXgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHByZXZpb3VzVGltZSA9IHByZXZpb3VzLnRpbWU7XG5cdFx0XHRcdGlmICghcHJldmlvdXMubG9vcCAmJiBwcmV2aW91c1RpbWUgPiBwcmV2aW91cy5lbmRUaW1lKSBwcmV2aW91c1RpbWUgPSBwcmV2aW91cy5lbmRUaW1lO1xuXHRcdFx0XHRwcmV2aW91cy5hbmltYXRpb24uYXBwbHkoc2tlbGV0b24sIHByZXZpb3VzVGltZSwgcHJldmlvdXNUaW1lLCBwcmV2aW91cy5sb29wLCBudWxsKTtcblxuXHRcdFx0XHR2YXIgYWxwaGEgPSBjdXJyZW50Lm1peFRpbWUgLyBjdXJyZW50Lm1peER1cmF0aW9uICogY3VycmVudC5taXg7XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhID49IDEpXG4gICAgICAgICAgICAgICAge1xuXHRcdFx0XHRcdGFscGhhID0gMTtcblx0XHRcdFx0XHRjdXJyZW50LnByZXZpb3VzID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdXJyZW50LmFuaW1hdGlvbi5taXgoc2tlbGV0b24sIGN1cnJlbnQubGFzdFRpbWUsIHRpbWUsIGxvb3AsIHRoaXMuZXZlbnRzLCBhbHBoYSk7XG5cdFx0XHR9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGlpID0gMCwgbm4gPSB0aGlzLmV2ZW50cy5sZW5ndGg7IGlpIDwgbm47IGlpKyspXG4gICAgICAgICAgICB7XG5cdFx0XHRcdHZhciBldmVudCA9IHRoaXMuZXZlbnRzW2lpXTtcblx0XHRcdFx0aWYgKGN1cnJlbnQub25FdmVudCkgY3VycmVudC5vbkV2ZW50KGksIGV2ZW50KTtcblx0XHRcdFx0aWYgKHRoaXMub25FdmVudCkgdGhpcy5vbkV2ZW50KGksIGV2ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgaWYgY29tcGxldGVkIHRoZSBhbmltYXRpb24gb3IgYSBsb29wIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgIGlmIChsb29wID8gKGxhc3RUaW1lICUgZW5kVGltZSA+IHRpbWUgJSBlbmRUaW1lKSA6IChsYXN0VGltZSA8IGVuZFRpbWUgJiYgdGltZSA+PSBlbmRUaW1lKSlcbiAgICAgICAgICAgIHtcblx0XHRcdFx0dmFyIGNvdW50ID0gTWF0aC5mbG9vcih0aW1lIC8gZW5kVGltZSk7XG5cdFx0XHRcdGlmIChjdXJyZW50Lm9uQ29tcGxldGUpIGN1cnJlbnQub25Db21wbGV0ZShpLCBjb3VudCk7XG5cdFx0XHRcdGlmICh0aGlzLm9uQ29tcGxldGUpIHRoaXMub25Db21wbGV0ZShpLCBjb3VudCk7XG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnQubGFzdFRpbWUgPSBjdXJyZW50LnRpbWU7XG5cdFx0fVxuXHR9LFxuICAgIGNsZWFyVHJhY2tzOiBmdW5jdGlvbiAoKVxuICAgIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMudHJhY2tzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdHRoaXMuY2xlYXJUcmFjayhpKTtcblx0XHR0aGlzLnRyYWNrcy5sZW5ndGggPSAwO1xuXHR9LFxuICAgIGNsZWFyVHJhY2s6IGZ1bmN0aW9uICh0cmFja0luZGV4KVxuICAgIHtcblx0XHRpZiAodHJhY2tJbmRleCA+PSB0aGlzLnRyYWNrcy5sZW5ndGgpIHJldHVybjtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMudHJhY2tzW3RyYWNrSW5kZXhdO1xuXHRcdGlmICghY3VycmVudCkgcmV0dXJuO1xuXG5cdFx0aWYgKGN1cnJlbnQub25FbmQpIGN1cnJlbnQub25FbmQodHJhY2tJbmRleCk7XG5cdFx0aWYgKHRoaXMub25FbmQpIHRoaXMub25FbmQodHJhY2tJbmRleCk7XG5cblx0XHR0aGlzLnRyYWNrc1t0cmFja0luZGV4XSA9IG51bGw7XG5cdH0sXG4gICAgX2V4cGFuZFRvSW5kZXg6IGZ1bmN0aW9uIChpbmRleClcbiAgICB7XG5cdFx0aWYgKGluZGV4IDwgdGhpcy50cmFja3MubGVuZ3RoKSByZXR1cm4gdGhpcy50cmFja3NbaW5kZXhdO1xuXHRcdHdoaWxlIChpbmRleCA+PSB0aGlzLnRyYWNrcy5sZW5ndGgpXG5cdFx0XHR0aGlzLnRyYWNrcy5wdXNoKG51bGwpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuICAgIHNldEN1cnJlbnQ6IGZ1bmN0aW9uIChpbmRleCwgZW50cnkpXG4gICAge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5fZXhwYW5kVG9JbmRleChpbmRleCk7XG4gICAgICAgIGlmIChjdXJyZW50KVxuICAgICAgICB7XG5cdFx0XHR2YXIgcHJldmlvdXMgPSBjdXJyZW50LnByZXZpb3VzO1xuXHRcdFx0Y3VycmVudC5wcmV2aW91cyA9IG51bGw7XG5cblx0XHRcdGlmIChjdXJyZW50Lm9uRW5kKSBjdXJyZW50Lm9uRW5kKGluZGV4KTtcblx0XHRcdGlmICh0aGlzLm9uRW5kKSB0aGlzLm9uRW5kKGluZGV4KTtcblxuXHRcdFx0ZW50cnkubWl4RHVyYXRpb24gPSB0aGlzLmRhdGEuZ2V0TWl4KGN1cnJlbnQuYW5pbWF0aW9uLCBlbnRyeS5hbmltYXRpb24pO1xuICAgICAgICAgICAgaWYgKGVudHJ5Lm1peER1cmF0aW9uID4gMClcbiAgICAgICAgICAgIHtcblx0XHRcdFx0ZW50cnkubWl4VGltZSA9IDA7XG5cdFx0XHRcdC8vIElmIGEgbWl4IGlzIGluIHByb2dyZXNzLCBtaXggZnJvbSB0aGUgY2xvc2VzdCBhbmltYXRpb24uXG5cdFx0XHRcdGlmIChwcmV2aW91cyAmJiBjdXJyZW50Lm1peFRpbWUgLyBjdXJyZW50Lm1peER1cmF0aW9uIDwgMC41KVxuXHRcdFx0XHRcdGVudHJ5LnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRlbnRyeS5wcmV2aW91cyA9IGN1cnJlbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy50cmFja3NbaW5kZXhdID0gZW50cnk7XG5cblx0XHRpZiAoZW50cnkub25TdGFydCkgZW50cnkub25TdGFydChpbmRleCk7XG5cdFx0aWYgKHRoaXMub25TdGFydCkgdGhpcy5vblN0YXJ0KGluZGV4KTtcblx0fSxcbiAgICBzZXRBbmltYXRpb25CeU5hbWU6IGZ1bmN0aW9uICh0cmFja0luZGV4LCBhbmltYXRpb25OYW1lLCBsb29wKVxuICAgIHtcblx0XHR2YXIgYW5pbWF0aW9uID0gdGhpcy5kYXRhLnNrZWxldG9uRGF0YS5maW5kQW5pbWF0aW9uKGFuaW1hdGlvbk5hbWUpO1xuXHRcdGlmICghYW5pbWF0aW9uKSB0aHJvdyBcIkFuaW1hdGlvbiBub3QgZm91bmQ6IFwiICsgYW5pbWF0aW9uTmFtZTtcblx0XHRyZXR1cm4gdGhpcy5zZXRBbmltYXRpb24odHJhY2tJbmRleCwgYW5pbWF0aW9uLCBsb29wKTtcblx0fSxcblx0LyoqIFNldCB0aGUgY3VycmVudCBhbmltYXRpb24uIEFueSBxdWV1ZWQgYW5pbWF0aW9ucyBhcmUgY2xlYXJlZC4gKi9cbiAgICBzZXRBbmltYXRpb246IGZ1bmN0aW9uICh0cmFja0luZGV4LCBhbmltYXRpb24sIGxvb3ApXG4gICAge1xuXHRcdHZhciBlbnRyeSA9IG5ldyBzcGluZS5UcmFja0VudHJ5KCk7XG5cdFx0ZW50cnkuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuXHRcdGVudHJ5Lmxvb3AgPSBsb29wO1xuXHRcdGVudHJ5LmVuZFRpbWUgPSBhbmltYXRpb24uZHVyYXRpb247XG5cdFx0dGhpcy5zZXRDdXJyZW50KHRyYWNrSW5kZXgsIGVudHJ5KTtcblx0XHRyZXR1cm4gZW50cnk7XG5cdH0sXG4gICAgYWRkQW5pbWF0aW9uQnlOYW1lOiBmdW5jdGlvbiAodHJhY2tJbmRleCwgYW5pbWF0aW9uTmFtZSwgbG9vcCwgZGVsYXkpXG4gICAge1xuXHRcdHZhciBhbmltYXRpb24gPSB0aGlzLmRhdGEuc2tlbGV0b25EYXRhLmZpbmRBbmltYXRpb24oYW5pbWF0aW9uTmFtZSk7XG5cdFx0aWYgKCFhbmltYXRpb24pIHRocm93IFwiQW5pbWF0aW9uIG5vdCBmb3VuZDogXCIgKyBhbmltYXRpb25OYW1lO1xuXHRcdHJldHVybiB0aGlzLmFkZEFuaW1hdGlvbih0cmFja0luZGV4LCBhbmltYXRpb24sIGxvb3AsIGRlbGF5KTtcblx0fSxcblx0LyoqIEFkZHMgYW4gYW5pbWF0aW9uIHRvIGJlIHBsYXllZCBkZWxheSBzZWNvbmRzIGFmdGVyIHRoZSBjdXJyZW50IG9yIGxhc3QgcXVldWVkIGFuaW1hdGlvbi5cblx0ICogQHBhcmFtIGRlbGF5IE1heSBiZSA8PSAwIHRvIHVzZSBkdXJhdGlvbiBvZiBwcmV2aW91cyBhbmltYXRpb24gbWludXMgYW55IG1peCBkdXJhdGlvbiBwbHVzIHRoZSBuZWdhdGl2ZSBkZWxheS4gKi9cbiAgICBhZGRBbmltYXRpb246IGZ1bmN0aW9uICh0cmFja0luZGV4LCBhbmltYXRpb24sIGxvb3AsIGRlbGF5KVxuICAgIHtcblx0XHR2YXIgZW50cnkgPSBuZXcgc3BpbmUuVHJhY2tFbnRyeSgpO1xuXHRcdGVudHJ5LmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcblx0XHRlbnRyeS5sb29wID0gbG9vcDtcblx0XHRlbnRyeS5lbmRUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG5cdFx0dmFyIGxhc3QgPSB0aGlzLl9leHBhbmRUb0luZGV4KHRyYWNrSW5kZXgpO1xuICAgICAgICBpZiAobGFzdClcbiAgICAgICAge1xuXHRcdFx0d2hpbGUgKGxhc3QubmV4dClcblx0XHRcdFx0bGFzdCA9IGxhc3QubmV4dDtcblx0XHRcdGxhc3QubmV4dCA9IGVudHJ5O1xuXHRcdH0gZWxzZVxuXHRcdFx0dGhpcy50cmFja3NbdHJhY2tJbmRleF0gPSBlbnRyeTtcblxuICAgICAgICBpZiAoZGVsYXkgPD0gMClcbiAgICAgICAge1xuXHRcdFx0aWYgKGxhc3QpXG5cdFx0XHRcdGRlbGF5ICs9IGxhc3QuZW5kVGltZSAtIHRoaXMuZGF0YS5nZXRNaXgobGFzdC5hbmltYXRpb24sIGFuaW1hdGlvbik7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGRlbGF5ID0gMDtcblx0XHR9XG5cdFx0ZW50cnkuZGVsYXkgPSBkZWxheTtcblxuXHRcdHJldHVybiBlbnRyeTtcblx0fSxcblx0LyoqIE1heSBiZSBudWxsLiAqL1xuICAgIGdldEN1cnJlbnQ6IGZ1bmN0aW9uICh0cmFja0luZGV4KVxuICAgIHtcblx0XHRpZiAodHJhY2tJbmRleCA+PSB0aGlzLnRyYWNrcy5sZW5ndGgpIHJldHVybiBudWxsO1xuXHRcdHJldHVybiB0aGlzLnRyYWNrc1t0cmFja0luZGV4XTtcblx0fVxufTtcblxuc3BpbmUuU2tlbGV0b25Kc29uUGFyc2VyID0gZnVuY3Rpb24gKGF0dGFjaG1lbnRMb2FkZXIpXG57XG5cdHRoaXMuYXR0YWNobWVudExvYWRlciA9IGF0dGFjaG1lbnRMb2FkZXI7XG59O1xuc3BpbmUuU2tlbGV0b25Kc29uUGFyc2VyLnByb3RvdHlwZSA9IHtcblx0c2NhbGU6IDEsXG4gICAgcmVhZFNrZWxldG9uRGF0YTogZnVuY3Rpb24gKHJvb3QsIG5hbWUpXG4gICAge1xuXHRcdHZhciBza2VsZXRvbkRhdGEgPSBuZXcgc3BpbmUuU2tlbGV0b25EYXRhKCk7XG5cdFx0c2tlbGV0b25EYXRhLm5hbWUgPSBuYW1lO1xuXG5cdFx0Ly8gU2tlbGV0b24uXG5cdFx0dmFyIHNrZWxldG9uTWFwID0gcm9vdFtcInNrZWxldG9uXCJdO1xuICAgICAgICBpZiAoc2tlbGV0b25NYXApXG4gICAgICAgIHtcblx0XHRcdHNrZWxldG9uRGF0YS5oYXNoID0gc2tlbGV0b25NYXBbXCJoYXNoXCJdO1xuXHRcdFx0c2tlbGV0b25EYXRhLnZlcnNpb24gPSBza2VsZXRvbk1hcFtcInNwaW5lXCJdO1xuXHRcdFx0c2tlbGV0b25EYXRhLndpZHRoID0gc2tlbGV0b25NYXBbXCJ3aWR0aFwiXSB8fCAwO1xuXHRcdFx0c2tlbGV0b25EYXRhLmhlaWdodCA9IHNrZWxldG9uTWFwW1wiaGVpZ2h0XCJdIHx8IDA7XG5cdFx0fVxuXG5cdFx0Ly8gQm9uZXMuXG5cdFx0dmFyIGJvbmVzID0gcm9vdFtcImJvbmVzXCJdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvbmVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAge1xuXHRcdFx0dmFyIGJvbmVNYXAgPSBib25lc1tpXTtcblx0XHRcdHZhciBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGJvbmVNYXBbXCJwYXJlbnRcIl0pXG4gICAgICAgICAgICB7XG5cdFx0XHRcdHBhcmVudCA9IHNrZWxldG9uRGF0YS5maW5kQm9uZShib25lTWFwW1wicGFyZW50XCJdKTtcblx0XHRcdFx0aWYgKCFwYXJlbnQpIHRocm93IFwiUGFyZW50IGJvbmUgbm90IGZvdW5kOiBcIiArIGJvbmVNYXBbXCJwYXJlbnRcIl07XG5cdFx0XHR9XG5cdFx0XHR2YXIgYm9uZURhdGEgPSBuZXcgc3BpbmUuQm9uZURhdGEoYm9uZU1hcFtcIm5hbWVcIl0sIHBhcmVudCk7XG5cdFx0XHRib25lRGF0YS5sZW5ndGggPSAoYm9uZU1hcFtcImxlbmd0aFwiXSB8fCAwKSAqIHRoaXMuc2NhbGU7XG5cdFx0XHRib25lRGF0YS54ID0gKGJvbmVNYXBbXCJ4XCJdIHx8IDApICogdGhpcy5zY2FsZTtcblx0XHRcdGJvbmVEYXRhLnkgPSAoYm9uZU1hcFtcInlcIl0gfHwgMCkgKiB0aGlzLnNjYWxlO1xuXHRcdFx0Ym9uZURhdGEucm90YXRpb24gPSAoYm9uZU1hcFtcInJvdGF0aW9uXCJdIHx8IDApO1xuXHRcdFx0Ym9uZURhdGEuc2NhbGVYID0gYm9uZU1hcC5oYXNPd25Qcm9wZXJ0eShcInNjYWxlWFwiKSA/IGJvbmVNYXBbXCJzY2FsZVhcIl0gOiAxO1xuXHRcdFx0Ym9uZURhdGEuc2NhbGVZID0gYm9uZU1hcC5oYXNPd25Qcm9wZXJ0eShcInNjYWxlWVwiKSA/IGJvbmVNYXBbXCJzY2FsZVlcIl0gOiAxO1xuXHRcdFx0Ym9uZURhdGEuaW5oZXJpdFNjYWxlID0gYm9uZU1hcC5oYXNPd25Qcm9wZXJ0eShcImluaGVyaXRTY2FsZVwiKSA/IGJvbmVNYXBbXCJpbmhlcml0U2NhbGVcIl0gOiB0cnVlO1xuXHRcdFx0Ym9uZURhdGEuaW5oZXJpdFJvdGF0aW9uID0gYm9uZU1hcC5oYXNPd25Qcm9wZXJ0eShcImluaGVyaXRSb3RhdGlvblwiKSA/IGJvbmVNYXBbXCJpbmhlcml0Um90YXRpb25cIl0gOiB0cnVlO1xuXHRcdFx0c2tlbGV0b25EYXRhLmJvbmVzLnB1c2goYm9uZURhdGEpO1xuXHRcdH1cblxuXHRcdC8vIElLIGNvbnN0cmFpbnRzLlxuXHRcdHZhciBpayA9IHJvb3RbXCJpa1wiXTtcbiAgICAgICAgaWYgKGlrKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGlrLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgIHtcblx0XHRcdFx0dmFyIGlrTWFwID0gaWtbaV07XG5cdFx0XHRcdHZhciBpa0NvbnN0cmFpbnREYXRhID0gbmV3IHNwaW5lLklrQ29uc3RyYWludERhdGEoaWtNYXBbXCJuYW1lXCJdKTtcblxuXHRcdFx0XHR2YXIgYm9uZXMgPSBpa01hcFtcImJvbmVzXCJdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMCwgbm4gPSBib25lcy5sZW5ndGg7IGlpIDwgbm47IGlpKyspXG4gICAgICAgICAgICAgICAge1xuXHRcdFx0XHRcdHZhciBib25lID0gc2tlbGV0b25EYXRhLmZpbmRCb25lKGJvbmVzW2lpXSk7XG5cdFx0XHRcdFx0aWYgKCFib25lKSB0aHJvdyBcIklLIGJvbmUgbm90IGZvdW5kOiBcIiArIGJvbmVzW2lpXTtcblx0XHRcdFx0XHRpa0NvbnN0cmFpbnREYXRhLmJvbmVzLnB1c2goYm9uZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpa0NvbnN0cmFpbnREYXRhLnRhcmdldCA9IHNrZWxldG9uRGF0YS5maW5kQm9uZShpa01hcFtcInRhcmdldFwiXSk7XG5cdFx0XHRcdGlmICghaWtDb25zdHJhaW50RGF0YS50YXJnZXQpIHRocm93IFwiVGFyZ2V0IGJvbmUgbm90IGZvdW5kOiBcIiArIGlrTWFwW1widGFyZ2V0XCJdO1xuXG5cdFx0XHRcdGlrQ29uc3RyYWludERhdGEuYmVuZERpcmVjdGlvbiA9ICghaWtNYXAuaGFzT3duUHJvcGVydHkoXCJiZW5kUG9zaXRpdmVcIikgfHwgaWtNYXBbXCJiZW5kUG9zaXRpdmVcIl0pID8gMSA6IC0xO1xuXHRcdFx0XHRpa0NvbnN0cmFpbnREYXRhLm1peCA9IGlrTWFwLmhhc093blByb3BlcnR5KFwibWl4XCIpID8gaWtNYXBbXCJtaXhcIl0gOiAxO1xuXG5cdFx0XHRcdHNrZWxldG9uRGF0YS5pa0NvbnN0cmFpbnRzLnB1c2goaWtDb25zdHJhaW50RGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2xvdHMuXG5cdFx0dmFyIHNsb3RzID0gcm9vdFtcInNsb3RzXCJdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNsb3RzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAge1xuXHRcdFx0dmFyIHNsb3RNYXAgPSBzbG90c1tpXTtcblx0XHRcdHZhciBib25lRGF0YSA9IHNrZWxldG9uRGF0YS5maW5kQm9uZShzbG90TWFwW1wiYm9uZVwiXSk7XG5cdFx0XHRpZiAoIWJvbmVEYXRhKSB0aHJvdyBcIlNsb3QgYm9uZSBub3QgZm91bmQ6IFwiICsgc2xvdE1hcFtcImJvbmVcIl07XG5cdFx0XHR2YXIgc2xvdERhdGEgPSBuZXcgc3BpbmUuU2xvdERhdGEoc2xvdE1hcFtcIm5hbWVcIl0sIGJvbmVEYXRhKTtcblxuXHRcdFx0dmFyIGNvbG9yID0gc2xvdE1hcFtcImNvbG9yXCJdO1xuICAgICAgICAgICAgaWYgKGNvbG9yKVxuICAgICAgICAgICAge1xuXHRcdFx0XHRzbG90RGF0YS5yID0gdGhpcy50b0NvbG9yKGNvbG9yLCAwKTtcblx0XHRcdFx0c2xvdERhdGEuZyA9IHRoaXMudG9Db2xvcihjb2xvciwgMSk7XG5cdFx0XHRcdHNsb3REYXRhLmIgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDIpO1xuXHRcdFx0XHRzbG90RGF0YS5hID0gdGhpcy50b0NvbG9yKGNvbG9yLCAzKTtcblx0XHRcdH1cblxuXHRcdFx0c2xvdERhdGEuYXR0YWNobWVudE5hbWUgPSBzbG90TWFwW1wiYXR0YWNobWVudFwiXTtcblx0XHRcdHNsb3REYXRhLmFkZGl0aXZlQmxlbmRpbmcgPSBzbG90TWFwW1wiYWRkaXRpdmVcIl0gJiYgc2xvdE1hcFtcImFkZGl0aXZlXCJdID09IFwidHJ1ZVwiO1xuXG5cdFx0XHRza2VsZXRvbkRhdGEuc2xvdHMucHVzaChzbG90RGF0YSk7XG5cdFx0fVxuXG5cdFx0Ly8gU2tpbnMuXG5cdFx0dmFyIHNraW5zID0gcm9vdFtcInNraW5zXCJdO1xuICAgICAgICBmb3IgKHZhciBza2luTmFtZSBpbiBza2lucylcbiAgICAgICAge1xuXHRcdFx0aWYgKCFza2lucy5oYXNPd25Qcm9wZXJ0eShza2luTmFtZSkpIGNvbnRpbnVlO1xuXHRcdFx0dmFyIHNraW5NYXAgPSBza2luc1tza2luTmFtZV07XG5cdFx0XHR2YXIgc2tpbiA9IG5ldyBzcGluZS5Ta2luKHNraW5OYW1lKTtcbiAgICAgICAgICAgIGZvciAodmFyIHNsb3ROYW1lIGluIHNraW5NYXApXG4gICAgICAgICAgICB7XG5cdFx0XHRcdGlmICghc2tpbk1hcC5oYXNPd25Qcm9wZXJ0eShzbG90TmFtZSkpIGNvbnRpbnVlO1xuXHRcdFx0XHR2YXIgc2xvdEluZGV4ID0gc2tlbGV0b25EYXRhLmZpbmRTbG90SW5kZXgoc2xvdE5hbWUpO1xuXHRcdFx0XHR2YXIgc2xvdEVudHJ5ID0gc2tpbk1hcFtzbG90TmFtZV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0YWNobWVudE5hbWUgaW4gc2xvdEVudHJ5KVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHRpZiAoIXNsb3RFbnRyeS5oYXNPd25Qcm9wZXJ0eShhdHRhY2htZW50TmFtZSkpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdHZhciBhdHRhY2htZW50ID0gdGhpcy5yZWFkQXR0YWNobWVudChza2luLCBhdHRhY2htZW50TmFtZSwgc2xvdEVudHJ5W2F0dGFjaG1lbnROYW1lXSk7XG5cdFx0XHRcdFx0aWYgKGF0dGFjaG1lbnQpIHNraW4uYWRkQXR0YWNobWVudChzbG90SW5kZXgsIGF0dGFjaG1lbnROYW1lLCBhdHRhY2htZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2tlbGV0b25EYXRhLnNraW5zLnB1c2goc2tpbik7XG5cdFx0XHRpZiAoc2tpbi5uYW1lID09IFwiZGVmYXVsdFwiKSBza2VsZXRvbkRhdGEuZGVmYXVsdFNraW4gPSBza2luO1xuXHRcdH1cblxuXHRcdC8vIEV2ZW50cy5cblx0XHR2YXIgZXZlbnRzID0gcm9vdFtcImV2ZW50c1wiXTtcbiAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50cylcbiAgICAgICAge1xuXHRcdFx0aWYgKCFldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkgY29udGludWU7XG5cdFx0XHR2YXIgZXZlbnRNYXAgPSBldmVudHNbZXZlbnROYW1lXTtcblx0XHRcdHZhciBldmVudERhdGEgPSBuZXcgc3BpbmUuRXZlbnREYXRhKGV2ZW50TmFtZSk7XG5cdFx0XHRldmVudERhdGEuaW50VmFsdWUgPSBldmVudE1hcFtcImludFwiXSB8fCAwO1xuXHRcdFx0ZXZlbnREYXRhLmZsb2F0VmFsdWUgPSBldmVudE1hcFtcImZsb2F0XCJdIHx8IDA7XG5cdFx0XHRldmVudERhdGEuc3RyaW5nVmFsdWUgPSBldmVudE1hcFtcInN0cmluZ1wiXSB8fCBudWxsO1xuXHRcdFx0c2tlbGV0b25EYXRhLmV2ZW50cy5wdXNoKGV2ZW50RGF0YSk7XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0aW9ucy5cblx0XHR2YXIgYW5pbWF0aW9ucyA9IHJvb3RbXCJhbmltYXRpb25zXCJdO1xuICAgICAgICBmb3IgKHZhciBhbmltYXRpb25OYW1lIGluIGFuaW1hdGlvbnMpXG4gICAgICAgIHtcblx0XHRcdGlmICghYW5pbWF0aW9ucy5oYXNPd25Qcm9wZXJ0eShhbmltYXRpb25OYW1lKSkgY29udGludWU7XG5cdFx0XHR0aGlzLnJlYWRBbmltYXRpb24oYW5pbWF0aW9uTmFtZSwgYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXSwgc2tlbGV0b25EYXRhKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2tlbGV0b25EYXRhO1xuXHR9LFxuICAgIHJlYWRBdHRhY2htZW50OiBmdW5jdGlvbiAoc2tpbiwgbmFtZSwgbWFwKVxuICAgIHtcblx0XHRuYW1lID0gbWFwW1wibmFtZVwiXSB8fCBuYW1lO1xuXG5cdFx0dmFyIHR5cGUgPSBzcGluZS5BdHRhY2htZW50VHlwZVttYXBbXCJ0eXBlXCJdIHx8IFwicmVnaW9uXCJdO1xuXHRcdHZhciBwYXRoID0gbWFwW1wicGF0aFwiXSB8fCBuYW1lO1xuXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgaWYgKHR5cGUgPT0gc3BpbmUuQXR0YWNobWVudFR5cGUucmVnaW9uKVxuICAgICAgICB7XG5cdFx0XHR2YXIgcmVnaW9uID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld1JlZ2lvbkF0dGFjaG1lbnQoc2tpbiwgbmFtZSwgcGF0aCk7XG5cdFx0XHRpZiAoIXJlZ2lvbikgcmV0dXJuIG51bGw7XG5cdFx0XHRyZWdpb24ucGF0aCA9IHBhdGg7XG5cdFx0XHRyZWdpb24ueCA9IChtYXBbXCJ4XCJdIHx8IDApICogc2NhbGU7XG5cdFx0XHRyZWdpb24ueSA9IChtYXBbXCJ5XCJdIHx8IDApICogc2NhbGU7XG5cdFx0XHRyZWdpb24uc2NhbGVYID0gbWFwLmhhc093blByb3BlcnR5KFwic2NhbGVYXCIpID8gbWFwW1wic2NhbGVYXCJdIDogMTtcblx0XHRcdHJlZ2lvbi5zY2FsZVkgPSBtYXAuaGFzT3duUHJvcGVydHkoXCJzY2FsZVlcIikgPyBtYXBbXCJzY2FsZVlcIl0gOiAxO1xuXHRcdFx0cmVnaW9uLnJvdGF0aW9uID0gbWFwW1wicm90YXRpb25cIl0gfHwgMDtcblx0XHRcdHJlZ2lvbi53aWR0aCA9IChtYXBbXCJ3aWR0aFwiXSB8fCAwKSAqIHNjYWxlO1xuXHRcdFx0cmVnaW9uLmhlaWdodCA9IChtYXBbXCJoZWlnaHRcIl0gfHwgMCkgKiBzY2FsZTtcblxuXHRcdFx0dmFyIGNvbG9yID0gbWFwW1wiY29sb3JcIl07XG4gICAgICAgICAgICBpZiAoY29sb3IpXG4gICAgICAgICAgICB7XG5cdFx0XHRcdHJlZ2lvbi5yID0gdGhpcy50b0NvbG9yKGNvbG9yLCAwKTtcblx0XHRcdFx0cmVnaW9uLmcgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDEpO1xuXHRcdFx0XHRyZWdpb24uYiA9IHRoaXMudG9Db2xvcihjb2xvciwgMik7XG5cdFx0XHRcdHJlZ2lvbi5hID0gdGhpcy50b0NvbG9yKGNvbG9yLCAzKTtcblx0XHRcdH1cblxuXHRcdFx0cmVnaW9uLnVwZGF0ZU9mZnNldCgpO1xuXHRcdFx0cmV0dXJuIHJlZ2lvbjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IHNwaW5lLkF0dGFjaG1lbnRUeXBlLm1lc2gpXG4gICAgICAgIHtcblx0XHRcdHZhciBtZXNoID0gdGhpcy5hdHRhY2htZW50TG9hZGVyLm5ld01lc2hBdHRhY2htZW50KHNraW4sIG5hbWUsIHBhdGgpO1xuXHRcdFx0aWYgKCFtZXNoKSByZXR1cm4gbnVsbDtcblx0XHRcdG1lc2gucGF0aCA9IHBhdGg7XG5cdFx0XHRtZXNoLnZlcnRpY2VzID0gdGhpcy5nZXRGbG9hdEFycmF5KG1hcCwgXCJ2ZXJ0aWNlc1wiLCBzY2FsZSk7XG5cdFx0XHRtZXNoLnRyaWFuZ2xlcyA9IHRoaXMuZ2V0SW50QXJyYXkobWFwLCBcInRyaWFuZ2xlc1wiKTtcblx0XHRcdG1lc2gucmVnaW9uVVZzID0gdGhpcy5nZXRGbG9hdEFycmF5KG1hcCwgXCJ1dnNcIiwgMSk7XG5cdFx0XHRtZXNoLnVwZGF0ZVVWcygpO1xuXG5cdFx0XHRjb2xvciA9IG1hcFtcImNvbG9yXCJdO1xuICAgICAgICAgICAgaWYgKGNvbG9yKVxuICAgICAgICAgICAge1xuXHRcdFx0XHRtZXNoLnIgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDApO1xuXHRcdFx0XHRtZXNoLmcgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDEpO1xuXHRcdFx0XHRtZXNoLmIgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDIpO1xuXHRcdFx0XHRtZXNoLmEgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDMpO1xuXHRcdFx0fVxuXG5cdFx0XHRtZXNoLmh1bGxMZW5ndGggPSAobWFwW1wiaHVsbFwiXSB8fCAwKSAqIDI7XG5cdFx0XHRpZiAobWFwW1wiZWRnZXNcIl0pIG1lc2guZWRnZXMgPSB0aGlzLmdldEludEFycmF5KG1hcCwgXCJlZGdlc1wiKTtcblx0XHRcdG1lc2gud2lkdGggPSAobWFwW1wid2lkdGhcIl0gfHwgMCkgKiBzY2FsZTtcblx0XHRcdG1lc2guaGVpZ2h0ID0gKG1hcFtcImhlaWdodFwiXSB8fCAwKSAqIHNjYWxlO1xuXHRcdFx0cmV0dXJuIG1lc2g7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBzcGluZS5BdHRhY2htZW50VHlwZS5za2lubmVkbWVzaClcbiAgICAgICAge1xuXHRcdFx0dmFyIG1lc2ggPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3U2tpbm5lZE1lc2hBdHRhY2htZW50KHNraW4sIG5hbWUsIHBhdGgpO1xuXHRcdFx0aWYgKCFtZXNoKSByZXR1cm4gbnVsbDtcblx0XHRcdG1lc2gucGF0aCA9IHBhdGg7XG5cblx0XHRcdHZhciB1dnMgPSB0aGlzLmdldEZsb2F0QXJyYXkobWFwLCBcInV2c1wiLCAxKTtcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2V0RmxvYXRBcnJheShtYXAsIFwidmVydGljZXNcIiwgMSk7XG5cdFx0XHR2YXIgd2VpZ2h0cyA9IFtdO1xuXHRcdFx0dmFyIGJvbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IG47IClcbiAgICAgICAgICAgIHtcblx0XHRcdFx0dmFyIGJvbmVDb3VudCA9IHZlcnRpY2VzW2krK10gfCAwO1xuXHRcdFx0XHRib25lc1tib25lcy5sZW5ndGhdID0gYm9uZUNvdW50O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5uID0gaSArIGJvbmVDb3VudCAqIDQ7IGkgPCBubjsgKVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHRib25lc1tib25lcy5sZW5ndGhdID0gdmVydGljZXNbaV07XG5cdFx0XHRcdFx0d2VpZ2h0c1t3ZWlnaHRzLmxlbmd0aF0gPSB2ZXJ0aWNlc1tpICsgMV0gKiBzY2FsZTtcblx0XHRcdFx0XHR3ZWlnaHRzW3dlaWdodHMubGVuZ3RoXSA9IHZlcnRpY2VzW2kgKyAyXSAqIHNjYWxlO1xuXHRcdFx0XHRcdHdlaWdodHNbd2VpZ2h0cy5sZW5ndGhdID0gdmVydGljZXNbaSArIDNdO1xuXHRcdFx0XHRcdGkgKz0gNDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVzaC5ib25lcyA9IGJvbmVzO1xuXHRcdFx0bWVzaC53ZWlnaHRzID0gd2VpZ2h0cztcblx0XHRcdG1lc2gudHJpYW5nbGVzID0gdGhpcy5nZXRJbnRBcnJheShtYXAsIFwidHJpYW5nbGVzXCIpO1xuXHRcdFx0bWVzaC5yZWdpb25VVnMgPSB1dnM7XG5cdFx0XHRtZXNoLnVwZGF0ZVVWcygpO1xuXG5cdFx0XHRjb2xvciA9IG1hcFtcImNvbG9yXCJdO1xuICAgICAgICAgICAgaWYgKGNvbG9yKVxuICAgICAgICAgICAge1xuXHRcdFx0XHRtZXNoLnIgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDApO1xuXHRcdFx0XHRtZXNoLmcgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDEpO1xuXHRcdFx0XHRtZXNoLmIgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDIpO1xuXHRcdFx0XHRtZXNoLmEgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDMpO1xuXHRcdFx0fVxuXG5cdFx0XHRtZXNoLmh1bGxMZW5ndGggPSAobWFwW1wiaHVsbFwiXSB8fCAwKSAqIDI7XG5cdFx0XHRpZiAobWFwW1wiZWRnZXNcIl0pIG1lc2guZWRnZXMgPSB0aGlzLmdldEludEFycmF5KG1hcCwgXCJlZGdlc1wiKTtcblx0XHRcdG1lc2gud2lkdGggPSAobWFwW1wid2lkdGhcIl0gfHwgMCkgKiBzY2FsZTtcblx0XHRcdG1lc2guaGVpZ2h0ID0gKG1hcFtcImhlaWdodFwiXSB8fCAwKSAqIHNjYWxlO1xuXHRcdFx0cmV0dXJuIG1lc2g7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBzcGluZS5BdHRhY2htZW50VHlwZS5ib3VuZGluZ2JveClcbiAgICAgICAge1xuXHRcdFx0dmFyIGF0dGFjaG1lbnQgPSB0aGlzLmF0dGFjaG1lbnRMb2FkZXIubmV3Qm91bmRpbmdCb3hBdHRhY2htZW50KHNraW4sIG5hbWUpO1xuXHRcdFx0dmFyIHZlcnRpY2VzID0gbWFwW1widmVydGljZXNcIl07XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdFx0YXR0YWNobWVudC52ZXJ0aWNlcy5wdXNoKHZlcnRpY2VzW2ldICogc2NhbGUpO1xuXHRcdFx0cmV0dXJuIGF0dGFjaG1lbnQ7XG5cdFx0fVxuXHRcdHRocm93IFwiVW5rbm93biBhdHRhY2htZW50IHR5cGU6IFwiICsgdHlwZTtcblx0fSxcbiAgICByZWFkQW5pbWF0aW9uOiBmdW5jdGlvbiAobmFtZSwgbWFwLCBza2VsZXRvbkRhdGEpXG4gICAge1xuXHRcdHZhciB0aW1lbGluZXMgPSBbXTtcblx0XHR2YXIgZHVyYXRpb24gPSAwO1xuXG5cdFx0dmFyIHNsb3RzID0gbWFwW1wic2xvdHNcIl07XG4gICAgICAgIGZvciAodmFyIHNsb3ROYW1lIGluIHNsb3RzKVxuICAgICAgICB7XG5cdFx0XHRpZiAoIXNsb3RzLmhhc093blByb3BlcnR5KHNsb3ROYW1lKSkgY29udGludWU7XG5cdFx0XHR2YXIgc2xvdE1hcCA9IHNsb3RzW3Nsb3ROYW1lXTtcblx0XHRcdHZhciBzbG90SW5kZXggPSBza2VsZXRvbkRhdGEuZmluZFNsb3RJbmRleChzbG90TmFtZSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHRpbWVsaW5lTmFtZSBpbiBzbG90TWFwKVxuICAgICAgICAgICAge1xuXHRcdFx0XHRpZiAoIXNsb3RNYXAuaGFzT3duUHJvcGVydHkodGltZWxpbmVOYW1lKSkgY29udGludWU7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBzbG90TWFwW3RpbWVsaW5lTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lTmFtZSA9PSBcImNvbG9yXCIpXG4gICAgICAgICAgICAgICAge1xuXHRcdFx0XHRcdHZhciB0aW1lbGluZSA9IG5ldyBzcGluZS5Db2xvclRpbWVsaW5lKHZhbHVlcy5sZW5ndGgpO1xuXHRcdFx0XHRcdHRpbWVsaW5lLnNsb3RJbmRleCA9IHNsb3RJbmRleDtcblxuXHRcdFx0XHRcdHZhciBmcmFtZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVNYXAgPSB2YWx1ZXNbaV07XG5cdFx0XHRcdFx0XHR2YXIgY29sb3IgPSB2YWx1ZU1hcFtcImNvbG9yXCJdO1xuXHRcdFx0XHRcdFx0dmFyIHIgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDApO1xuXHRcdFx0XHRcdFx0dmFyIGcgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDEpO1xuXHRcdFx0XHRcdFx0dmFyIGIgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDIpO1xuXHRcdFx0XHRcdFx0dmFyIGEgPSB0aGlzLnRvQ29sb3IoY29sb3IsIDMpO1xuXHRcdFx0XHRcdFx0dGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdmFsdWVNYXBbXCJ0aW1lXCJdLCByLCBnLCBiLCBhKTtcblx0XHRcdFx0XHRcdHRoaXMucmVhZEN1cnZlKHRpbWVsaW5lLCBmcmFtZUluZGV4LCB2YWx1ZU1hcCk7XG5cdFx0XHRcdFx0XHRmcmFtZUluZGV4Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcblx0XHRcdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbdGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpICogNSAtIDVdKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZWxpbmVOYW1lID09IFwiYXR0YWNobWVudFwiKVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHR2YXIgdGltZWxpbmUgPSBuZXcgc3BpbmUuQXR0YWNobWVudFRpbWVsaW5lKHZhbHVlcy5sZW5ndGgpO1xuXHRcdFx0XHRcdHRpbWVsaW5lLnNsb3RJbmRleCA9IHNsb3RJbmRleDtcblxuXHRcdFx0XHRcdHZhciBmcmFtZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVNYXAgPSB2YWx1ZXNbaV07XG5cdFx0XHRcdFx0XHR0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4KyssIHZhbHVlTWFwW1widGltZVwiXSwgdmFsdWVNYXBbXCJuYW1lXCJdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xuXHRcdFx0XHRcdGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgLSAxXSk7XG5cblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0dGhyb3cgXCJJbnZhbGlkIHRpbWVsaW5lIHR5cGUgZm9yIGEgc2xvdDogXCIgKyB0aW1lbGluZU5hbWUgKyBcIiAoXCIgKyBzbG90TmFtZSArIFwiKVwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBib25lcyA9IG1hcFtcImJvbmVzXCJdO1xuICAgICAgICBmb3IgKHZhciBib25lTmFtZSBpbiBib25lcylcbiAgICAgICAge1xuXHRcdFx0aWYgKCFib25lcy5oYXNPd25Qcm9wZXJ0eShib25lTmFtZSkpIGNvbnRpbnVlO1xuXHRcdFx0dmFyIGJvbmVJbmRleCA9IHNrZWxldG9uRGF0YS5maW5kQm9uZUluZGV4KGJvbmVOYW1lKTtcblx0XHRcdGlmIChib25lSW5kZXggPT0gLTEpIHRocm93IFwiQm9uZSBub3QgZm91bmQ6IFwiICsgYm9uZU5hbWU7XG5cdFx0XHR2YXIgYm9uZU1hcCA9IGJvbmVzW2JvbmVOYW1lXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgdGltZWxpbmVOYW1lIGluIGJvbmVNYXApXG4gICAgICAgICAgICB7XG5cdFx0XHRcdGlmICghYm9uZU1hcC5oYXNPd25Qcm9wZXJ0eSh0aW1lbGluZU5hbWUpKSBjb250aW51ZTtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IGJvbmVNYXBbdGltZWxpbmVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodGltZWxpbmVOYW1lID09IFwicm90YXRlXCIpXG4gICAgICAgICAgICAgICAge1xuXHRcdFx0XHRcdHZhciB0aW1lbGluZSA9IG5ldyBzcGluZS5Sb3RhdGVUaW1lbGluZSh2YWx1ZXMubGVuZ3RoKTtcblx0XHRcdFx0XHR0aW1lbGluZS5ib25lSW5kZXggPSBib25lSW5kZXg7XG5cblx0XHRcdFx0XHR2YXIgZnJhbWVJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgICAgICAgICAge1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlTWFwID0gdmFsdWVzW2ldO1xuXHRcdFx0XHRcdFx0dGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdmFsdWVNYXBbXCJ0aW1lXCJdLCB2YWx1ZU1hcFtcImFuZ2xlXCJdKTtcblx0XHRcdFx0XHRcdHRoaXMucmVhZEN1cnZlKHRpbWVsaW5lLCBmcmFtZUluZGV4LCB2YWx1ZU1hcCk7XG5cdFx0XHRcdFx0XHRmcmFtZUluZGV4Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcblx0XHRcdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbdGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpICogMiAtIDJdKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZWxpbmVOYW1lID09IFwidHJhbnNsYXRlXCIgfHwgdGltZWxpbmVOYW1lID09IFwic2NhbGVcIilcbiAgICAgICAgICAgICAgICB7XG5cdFx0XHRcdFx0dmFyIHRpbWVsaW5lO1xuXHRcdFx0XHRcdHZhciB0aW1lbGluZVNjYWxlID0gMTtcblx0XHRcdFx0XHRpZiAodGltZWxpbmVOYW1lID09IFwic2NhbGVcIilcblx0XHRcdFx0XHRcdHRpbWVsaW5lID0gbmV3IHNwaW5lLlNjYWxlVGltZWxpbmUodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuXHRcdFx0XHRcdFx0dGltZWxpbmUgPSBuZXcgc3BpbmUuVHJhbnNsYXRlVGltZWxpbmUodmFsdWVzLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHR0aW1lbGluZVNjYWxlID0gdGhpcy5zY2FsZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZWxpbmUuYm9uZUluZGV4ID0gYm9uZUluZGV4O1xuXG5cdFx0XHRcdFx0dmFyIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZU1hcCA9IHZhbHVlc1tpXTtcblx0XHRcdFx0XHRcdHZhciB4ID0gKHZhbHVlTWFwW1wieFwiXSB8fCAwKSAqIHRpbWVsaW5lU2NhbGU7XG5cdFx0XHRcdFx0XHR2YXIgeSA9ICh2YWx1ZU1hcFtcInlcIl0gfHwgMCkgKiB0aW1lbGluZVNjYWxlO1xuXHRcdFx0XHRcdFx0dGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdmFsdWVNYXBbXCJ0aW1lXCJdLCB4LCB5KTtcblx0XHRcdFx0XHRcdHRoaXMucmVhZEN1cnZlKHRpbWVsaW5lLCBmcmFtZUluZGV4LCB2YWx1ZU1hcCk7XG5cdFx0XHRcdFx0XHRmcmFtZUluZGV4Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcblx0XHRcdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbdGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpICogMyAtIDNdKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZWxpbmVOYW1lID09IFwiZmxpcFhcIiB8fCB0aW1lbGluZU5hbWUgPT0gXCJmbGlwWVwiKVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHR2YXIgeCA9IHRpbWVsaW5lTmFtZSA9PSBcImZsaXBYXCI7XG5cdFx0XHRcdFx0dmFyIHRpbWVsaW5lID0geCA/IG5ldyBzcGluZS5GbGlwWFRpbWVsaW5lKHZhbHVlcy5sZW5ndGgpIDogbmV3IHNwaW5lLkZsaXBZVGltZWxpbmUodmFsdWVzLmxlbmd0aCk7XG5cdFx0XHRcdFx0dGltZWxpbmUuYm9uZUluZGV4ID0gYm9uZUluZGV4O1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0geCA/IFwieFwiIDogXCJ5XCI7XG5cdFx0XHRcdFx0dmFyIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZU1hcCA9IHZhbHVlc1tpXTtcblx0XHRcdFx0XHRcdHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgsIHZhbHVlTWFwW1widGltZVwiXSwgdmFsdWVNYXBbZmllbGRdIHx8IGZhbHNlKTtcblx0XHRcdFx0XHRcdGZyYW1lSW5kZXgrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xuXHRcdFx0XHRcdGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5nZXRGcmFtZUNvdW50KCkgKiAyIC0gMl0pO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHR0aHJvdyBcIkludmFsaWQgdGltZWxpbmUgdHlwZSBmb3IgYSBib25lOiBcIiArIHRpbWVsaW5lTmFtZSArIFwiIChcIiArIGJvbmVOYW1lICsgXCIpXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGlrTWFwID0gbWFwW1wiaWtcIl07XG4gICAgICAgIGZvciAodmFyIGlrQ29uc3RyYWludE5hbWUgaW4gaWtNYXApXG4gICAgICAgIHtcblx0XHRcdGlmICghaWtNYXAuaGFzT3duUHJvcGVydHkoaWtDb25zdHJhaW50TmFtZSkpIGNvbnRpbnVlO1xuXHRcdFx0dmFyIGlrQ29uc3RyYWludCA9IHNrZWxldG9uRGF0YS5maW5kSWtDb25zdHJhaW50KGlrQ29uc3RyYWludE5hbWUpO1xuXHRcdFx0dmFyIHZhbHVlcyA9IGlrTWFwW2lrQ29uc3RyYWludE5hbWVdO1xuXHRcdFx0dmFyIHRpbWVsaW5lID0gbmV3IHNwaW5lLklrQ29uc3RyYWludFRpbWVsaW5lKHZhbHVlcy5sZW5ndGgpO1xuXHRcdFx0dGltZWxpbmUuaWtDb25zdHJhaW50SW5kZXggPSBza2VsZXRvbkRhdGEuaWtDb25zdHJhaW50cy5pbmRleE9mKGlrQ29uc3RyYWludCk7XG5cdFx0XHR2YXIgZnJhbWVJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICB7XG5cdFx0XHRcdHZhciB2YWx1ZU1hcCA9IHZhbHVlc1tpXTtcblx0XHRcdFx0dmFyIG1peCA9IHZhbHVlTWFwLmhhc093blByb3BlcnR5KFwibWl4XCIpID8gdmFsdWVNYXBbXCJtaXhcIl0gOiAxO1xuXHRcdFx0XHR2YXIgYmVuZERpcmVjdGlvbiA9ICghdmFsdWVNYXAuaGFzT3duUHJvcGVydHkoXCJiZW5kUG9zaXRpdmVcIikgfHwgdmFsdWVNYXBbXCJiZW5kUG9zaXRpdmVcIl0pID8gMSA6IC0xO1xuXHRcdFx0XHR0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4LCB2YWx1ZU1hcFtcInRpbWVcIl0sIG1peCwgYmVuZERpcmVjdGlvbik7XG5cdFx0XHRcdHRoaXMucmVhZEN1cnZlKHRpbWVsaW5lLCBmcmFtZUluZGV4LCB2YWx1ZU1hcCk7XG5cdFx0XHRcdGZyYW1lSW5kZXgrKztcblx0XHRcdH1cblx0XHRcdHRpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcblx0XHRcdGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRpbWVsaW5lLmZyYW1lc1t0aW1lbGluZS5mcmFtZUNvdW50ICogMyAtIDNdKTtcblx0XHR9XG5cblx0XHR2YXIgZmZkID0gbWFwW1wiZmZkXCJdO1xuICAgICAgICBmb3IgKHZhciBza2luTmFtZSBpbiBmZmQpXG4gICAgICAgIHtcblx0XHRcdHZhciBza2luID0gc2tlbGV0b25EYXRhLmZpbmRTa2luKHNraW5OYW1lKTtcblx0XHRcdHZhciBzbG90TWFwID0gZmZkW3NraW5OYW1lXTtcbiAgICAgICAgICAgIGZvciAoc2xvdE5hbWUgaW4gc2xvdE1hcClcbiAgICAgICAgICAgIHtcblx0XHRcdFx0dmFyIHNsb3RJbmRleCA9IHNrZWxldG9uRGF0YS5maW5kU2xvdEluZGV4KHNsb3ROYW1lKTtcblx0XHRcdFx0dmFyIG1lc2hNYXAgPSBzbG90TWFwW3Nsb3ROYW1lXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtZXNoTmFtZSBpbiBtZXNoTWFwKVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHR2YXIgdmFsdWVzID0gbWVzaE1hcFttZXNoTmFtZV07XG5cdFx0XHRcdFx0dmFyIHRpbWVsaW5lID0gbmV3IHNwaW5lLkZmZFRpbWVsaW5lKHZhbHVlcy5sZW5ndGgpO1xuXHRcdFx0XHRcdHZhciBhdHRhY2htZW50ID0gc2tpbi5nZXRBdHRhY2htZW50KHNsb3RJbmRleCwgbWVzaE5hbWUpO1xuXHRcdFx0XHRcdGlmICghYXR0YWNobWVudCkgdGhyb3cgXCJGRkQgYXR0YWNobWVudCBub3QgZm91bmQ6IFwiICsgbWVzaE5hbWU7XG5cdFx0XHRcdFx0dGltZWxpbmUuc2xvdEluZGV4ID0gc2xvdEluZGV4O1xuXHRcdFx0XHRcdHRpbWVsaW5lLmF0dGFjaG1lbnQgPSBhdHRhY2htZW50O1xuXG5cdFx0XHRcdFx0dmFyIGlzTWVzaCA9IGF0dGFjaG1lbnQudHlwZSA9PSBzcGluZS5BdHRhY2htZW50VHlwZS5tZXNoO1xuXHRcdFx0XHRcdHZhciB2ZXJ0ZXhDb3VudDtcblx0XHRcdFx0XHRpZiAoaXNNZXNoKVxuXHRcdFx0XHRcdFx0dmVydGV4Q291bnQgPSBhdHRhY2htZW50LnZlcnRpY2VzLmxlbmd0aDtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHR2ZXJ0ZXhDb3VudCA9IGF0dGFjaG1lbnQud2VpZ2h0cy5sZW5ndGggLyAzICogMjtcblxuXHRcdFx0XHRcdHZhciBmcmFtZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVNYXAgPSB2YWx1ZXNbaV07XG5cdFx0XHRcdFx0XHR2YXIgdmVydGljZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlTWFwW1widmVydGljZXNcIl0pXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG5cdFx0XHRcdFx0XHRcdGlmIChpc01lc2gpXG5cdFx0XHRcdFx0XHRcdFx0dmVydGljZXMgPSBhdHRhY2htZW50LnZlcnRpY2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG5cdFx0XHRcdFx0XHRcdFx0dmVydGljZXMgPSBbXTtcblx0XHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5sZW5ndGggPSB2ZXJ0ZXhDb3VudDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZlcnRpY2VzVmFsdWUgPSB2YWx1ZU1hcFtcInZlcnRpY2VzXCJdO1xuXHRcdFx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSBbXTtcblx0XHRcdFx0XHRcdFx0dmVydGljZXMubGVuZ3RoID0gdmVydGV4Q291bnQ7XG5cdFx0XHRcdFx0XHRcdHZhciBzdGFydCA9IHZhbHVlTWFwW1wib2Zmc2V0XCJdIHx8IDA7XG5cdFx0XHRcdFx0XHRcdHZhciBubiA9IHZlcnRpY2VzVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYWxlID09IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGlpID0gMDsgaWkgPCBubjsgaWkrKylcblx0XHRcdFx0XHRcdFx0XHRcdHZlcnRpY2VzW2lpICsgc3RhcnRdID0gdmVydGljZXNWYWx1ZVtpaV07XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaWkgPSAwOyBpaSA8IG5uOyBpaSsrKVxuXHRcdFx0XHRcdFx0XHRcdFx0dmVydGljZXNbaWkgKyBzdGFydF0gPSB2ZXJ0aWNlc1ZhbHVlW2lpXSAqIHRoaXMuc2NhbGU7XG5cdFx0XHRcdFx0XHRcdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNZXNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgbWVzaFZlcnRpY2VzID0gYXR0YWNobWVudC52ZXJ0aWNlcztcblx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpaSA9IDAsIG5uID0gdmVydGljZXMubGVuZ3RoOyBpaSA8IG5uOyBpaSsrKVxuXHRcdFx0XHRcdFx0XHRcdFx0dmVydGljZXNbaWldICs9IG1lc2hWZXJ0aWNlc1tpaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGltZWxpbmUuc2V0RnJhbWUoZnJhbWVJbmRleCwgdmFsdWVNYXBbXCJ0aW1lXCJdLCB2ZXJ0aWNlcyk7XG5cdFx0XHRcdFx0XHR0aGlzLnJlYWRDdXJ2ZSh0aW1lbGluZSwgZnJhbWVJbmRleCwgdmFsdWVNYXApO1xuXHRcdFx0XHRcdFx0ZnJhbWVJbmRleCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aW1lbGluZXNbdGltZWxpbmVzLmxlbmd0aF0gPSB0aW1lbGluZTtcblx0XHRcdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbdGltZWxpbmUuZnJhbWVDb3VudCAtIDFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBkcmF3T3JkZXJWYWx1ZXMgPSBtYXBbXCJkcmF3T3JkZXJcIl07XG5cdFx0aWYgKCFkcmF3T3JkZXJWYWx1ZXMpIGRyYXdPcmRlclZhbHVlcyA9IG1hcFtcImRyYXdvcmRlclwiXTtcbiAgICAgICAgaWYgKGRyYXdPcmRlclZhbHVlcylcbiAgICAgICAge1xuXHRcdFx0dmFyIHRpbWVsaW5lID0gbmV3IHNwaW5lLkRyYXdPcmRlclRpbWVsaW5lKGRyYXdPcmRlclZhbHVlcy5sZW5ndGgpO1xuXHRcdFx0dmFyIHNsb3RDb3VudCA9IHNrZWxldG9uRGF0YS5zbG90cy5sZW5ndGg7XG5cdFx0XHR2YXIgZnJhbWVJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGRyYXdPcmRlclZhbHVlcy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICB7XG5cdFx0XHRcdHZhciBkcmF3T3JkZXJNYXAgPSBkcmF3T3JkZXJWYWx1ZXNbaV07XG5cdFx0XHRcdHZhciBkcmF3T3JkZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChkcmF3T3JkZXJNYXBbXCJvZmZzZXRzXCJdKVxuICAgICAgICAgICAgICAgIHtcblx0XHRcdFx0XHRkcmF3T3JkZXIgPSBbXTtcblx0XHRcdFx0XHRkcmF3T3JkZXIubGVuZ3RoID0gc2xvdENvdW50O1xuXHRcdFx0XHRcdGZvciAodmFyIGlpID0gc2xvdENvdW50IC0gMTsgaWkgPj0gMDsgaWktLSlcblx0XHRcdFx0XHRcdGRyYXdPcmRlcltpaV0gPSAtMTtcblx0XHRcdFx0XHR2YXIgb2Zmc2V0cyA9IGRyYXdPcmRlck1hcFtcIm9mZnNldHNcIl07XG5cdFx0XHRcdFx0dmFyIHVuY2hhbmdlZCA9IFtdO1xuXHRcdFx0XHRcdHVuY2hhbmdlZC5sZW5ndGggPSBzbG90Q291bnQgLSBvZmZzZXRzLmxlbmd0aDtcblx0XHRcdFx0XHR2YXIgb3JpZ2luYWxJbmRleCA9IDAsIHVuY2hhbmdlZEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwLCBubiA9IG9mZnNldHMubGVuZ3RoOyBpaSA8IG5uOyBpaSsrKVxuICAgICAgICAgICAgICAgICAgICB7XG5cdFx0XHRcdFx0XHR2YXIgb2Zmc2V0TWFwID0gb2Zmc2V0c1tpaV07XG5cdFx0XHRcdFx0XHR2YXIgc2xvdEluZGV4ID0gc2tlbGV0b25EYXRhLmZpbmRTbG90SW5kZXgob2Zmc2V0TWFwW1wic2xvdFwiXSk7XG5cdFx0XHRcdFx0XHRpZiAoc2xvdEluZGV4ID09IC0xKSB0aHJvdyBcIlNsb3Qgbm90IGZvdW5kOiBcIiArIG9mZnNldE1hcFtcInNsb3RcIl07XG5cdFx0XHRcdFx0XHQvLyBDb2xsZWN0IHVuY2hhbmdlZCBpdGVtcy5cblx0XHRcdFx0XHRcdHdoaWxlIChvcmlnaW5hbEluZGV4ICE9IHNsb3RJbmRleClcblx0XHRcdFx0XHRcdFx0dW5jaGFuZ2VkW3VuY2hhbmdlZEluZGV4KytdID0gb3JpZ2luYWxJbmRleCsrO1xuXHRcdFx0XHRcdFx0Ly8gU2V0IGNoYW5nZWQgaXRlbXMuXG5cdFx0XHRcdFx0XHRkcmF3T3JkZXJbb3JpZ2luYWxJbmRleCArIG9mZnNldE1hcFtcIm9mZnNldFwiXV0gPSBvcmlnaW5hbEluZGV4Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIENvbGxlY3QgcmVtYWluaW5nIHVuY2hhbmdlZCBpdGVtcy5cblx0XHRcdFx0XHR3aGlsZSAob3JpZ2luYWxJbmRleCA8IHNsb3RDb3VudClcblx0XHRcdFx0XHRcdHVuY2hhbmdlZFt1bmNoYW5nZWRJbmRleCsrXSA9IG9yaWdpbmFsSW5kZXgrKztcblx0XHRcdFx0XHQvLyBGaWxsIGluIHVuY2hhbmdlZCBpdGVtcy5cblx0XHRcdFx0XHRmb3IgKHZhciBpaSA9IHNsb3RDb3VudCAtIDE7IGlpID49IDA7IGlpLS0pXG5cdFx0XHRcdFx0XHRpZiAoZHJhd09yZGVyW2lpXSA9PSAtMSkgZHJhd09yZGVyW2lpXSA9IHVuY2hhbmdlZFstLXVuY2hhbmdlZEluZGV4XTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aW1lbGluZS5zZXRGcmFtZShmcmFtZUluZGV4KyssIGRyYXdPcmRlck1hcFtcInRpbWVcIl0sIGRyYXdPcmRlcik7XG5cdFx0XHR9XG5cdFx0XHR0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XG5cdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbdGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpIC0gMV0pO1xuXHRcdH1cblxuXHRcdHZhciBldmVudHMgPSBtYXBbXCJldmVudHNcIl07XG4gICAgICAgIGlmIChldmVudHMpXG4gICAgICAgIHtcblx0XHRcdHZhciB0aW1lbGluZSA9IG5ldyBzcGluZS5FdmVudFRpbWVsaW5lKGV2ZW50cy5sZW5ndGgpO1xuXHRcdFx0dmFyIGZyYW1lSW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBldmVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuICAgICAgICAgICAge1xuXHRcdFx0XHR2YXIgZXZlbnRNYXAgPSBldmVudHNbaV07XG5cdFx0XHRcdHZhciBldmVudERhdGEgPSBza2VsZXRvbkRhdGEuZmluZEV2ZW50KGV2ZW50TWFwW1wibmFtZVwiXSk7XG5cdFx0XHRcdGlmICghZXZlbnREYXRhKSB0aHJvdyBcIkV2ZW50IG5vdCBmb3VuZDogXCIgKyBldmVudE1hcFtcIm5hbWVcIl07XG5cdFx0XHRcdHZhciBldmVudCA9IG5ldyBzcGluZS5FdmVudChldmVudERhdGEpO1xuXHRcdFx0XHRldmVudC5pbnRWYWx1ZSA9IGV2ZW50TWFwLmhhc093blByb3BlcnR5KFwiaW50XCIpID8gZXZlbnRNYXBbXCJpbnRcIl0gOiBldmVudERhdGEuaW50VmFsdWU7XG5cdFx0XHRcdGV2ZW50LmZsb2F0VmFsdWUgPSBldmVudE1hcC5oYXNPd25Qcm9wZXJ0eShcImZsb2F0XCIpID8gZXZlbnRNYXBbXCJmbG9hdFwiXSA6IGV2ZW50RGF0YS5mbG9hdFZhbHVlO1xuXHRcdFx0XHRldmVudC5zdHJpbmdWYWx1ZSA9IGV2ZW50TWFwLmhhc093blByb3BlcnR5KFwic3RyaW5nXCIpID8gZXZlbnRNYXBbXCJzdHJpbmdcIl0gOiBldmVudERhdGEuc3RyaW5nVmFsdWU7XG5cdFx0XHRcdHRpbWVsaW5lLnNldEZyYW1lKGZyYW1lSW5kZXgrKywgZXZlbnRNYXBbXCJ0aW1lXCJdLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0XHR0aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XG5cdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCB0aW1lbGluZS5mcmFtZXNbdGltZWxpbmUuZ2V0RnJhbWVDb3VudCgpIC0gMV0pO1xuXHRcdH1cblxuXHRcdHNrZWxldG9uRGF0YS5hbmltYXRpb25zLnB1c2gobmV3IHNwaW5lLkFuaW1hdGlvbihuYW1lLCB0aW1lbGluZXMsIGR1cmF0aW9uKSk7XG5cdH0sXG4gICAgcmVhZEN1cnZlOiBmdW5jdGlvbiAodGltZWxpbmUsIGZyYW1lSW5kZXgsIHZhbHVlTWFwKVxuICAgIHtcblx0XHR2YXIgY3VydmUgPSB2YWx1ZU1hcFtcImN1cnZlXCJdO1xuXHRcdGlmICghY3VydmUpXG5cdFx0XHR0aW1lbGluZS5jdXJ2ZXMuc2V0TGluZWFyKGZyYW1lSW5kZXgpO1xuXHRcdGVsc2UgaWYgKGN1cnZlID09IFwic3RlcHBlZFwiKVxuXHRcdFx0dGltZWxpbmUuY3VydmVzLnNldFN0ZXBwZWQoZnJhbWVJbmRleCk7XG5cdFx0ZWxzZSBpZiAoY3VydmUgaW5zdGFuY2VvZiBBcnJheSlcblx0XHRcdHRpbWVsaW5lLmN1cnZlcy5zZXRDdXJ2ZShmcmFtZUluZGV4LCBjdXJ2ZVswXSwgY3VydmVbMV0sIGN1cnZlWzJdLCBjdXJ2ZVszXSk7XG5cdH0sXG4gICAgdG9Db2xvcjogZnVuY3Rpb24gKGhleFN0cmluZywgY29sb3JJbmRleClcbiAgICB7XG5cdFx0aWYgKGhleFN0cmluZy5sZW5ndGggIT0gOCkgdGhyb3cgXCJDb2xvciBoZXhpZGVjaW1hbCBsZW5ndGggbXVzdCBiZSA4LCByZWNpZXZlZDogXCIgKyBoZXhTdHJpbmc7XG5cdFx0cmV0dXJuIHBhcnNlSW50KGhleFN0cmluZy5zdWJzdHJpbmcoY29sb3JJbmRleCAqIDIsIChjb2xvckluZGV4ICogMikgKyAyKSwgMTYpIC8gMjU1O1xuXHR9LFxuICAgIGdldEZsb2F0QXJyYXk6IGZ1bmN0aW9uIChtYXAsIG5hbWUsIHNjYWxlKVxuICAgIHtcblx0XHR2YXIgbGlzdCA9IG1hcFtuYW1lXTtcblx0XHR2YXIgdmFsdWVzID0gbmV3IHNwaW5lLkZsb2F0MzJBcnJheShsaXN0Lmxlbmd0aCk7XG5cdFx0dmFyIGkgPSAwLCBuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIGlmIChzY2FsZSA9PSAxKVxuICAgICAgICB7XG5cdFx0XHRmb3IgKDsgaSA8IG47IGkrKylcblx0XHRcdFx0dmFsdWVzW2ldID0gbGlzdFtpXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICg7IGkgPCBuOyBpKyspXG5cdFx0XHRcdHZhbHVlc1tpXSA9IGxpc3RbaV0gKiBzY2FsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcbiAgICBnZXRJbnRBcnJheTogZnVuY3Rpb24gKG1hcCwgbmFtZSlcbiAgICB7XG5cdFx0dmFyIGxpc3QgPSBtYXBbbmFtZV07XG5cdFx0dmFyIHZhbHVlcyA9IG5ldyBzcGluZS5VaW50MTZBcnJheShsaXN0Lmxlbmd0aCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSBsaXN0Lmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdHZhbHVlc1tpXSA9IGxpc3RbaV0gfCAwO1xuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH1cbn07XG5cbnNwaW5lLkF0bGFzID0gZnVuY3Rpb24gKGF0bGFzVGV4dCwgYmFzZVVybCwgY3Jvc3NPcmlnaW4pXG57XG4gICAgaWYgKGJhc2VVcmwgJiYgYmFzZVVybC5pbmRleE9mKCcvJykgIT09IGJhc2VVcmwubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgYmFzZVVybCArPSAnLyc7XG4gICAgfVxuXG5cdHRoaXMucGFnZXMgPSBbXTtcblx0dGhpcy5yZWdpb25zID0gW107XG5cbiAgICB0aGlzLnRleHR1cmVzTG9hZGluZyA9IDA7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0dmFyIHJlYWRlciA9IG5ldyBzcGluZS5BdGxhc1JlYWRlcihhdGxhc1RleHQpO1xuXHR2YXIgdHVwbGUgPSBbXTtcblx0dHVwbGUubGVuZ3RoID0gNDtcblx0dmFyIHBhZ2UgPSBudWxsO1xuICAgIHdoaWxlICh0cnVlKVxuICAgIHtcblx0XHR2YXIgbGluZSA9IHJlYWRlci5yZWFkTGluZSgpO1xuXHRcdGlmIChsaW5lID09PSBudWxsKSBicmVhaztcblx0XHRsaW5lID0gcmVhZGVyLnRyaW0obGluZSk7XG5cdFx0aWYgKCFsaW5lLmxlbmd0aClcblx0XHRcdHBhZ2UgPSBudWxsO1xuICAgICAgICBlbHNlIGlmICghcGFnZSlcbiAgICAgICAge1xuXHRcdFx0cGFnZSA9IG5ldyBzcGluZS5BdGxhc1BhZ2UoKTtcblx0XHRcdHBhZ2UubmFtZSA9IGxpbmU7XG5cbiAgICAgICAgICAgIGlmIChyZWFkZXIucmVhZFR1cGxlKHR1cGxlKSA9PSAyKVxuICAgICAgICAgICAgeyAvLyBzaXplIGlzIG9ubHkgb3B0aW9uYWwgZm9yIGFuIGF0bGFzIHBhY2tlZCB3aXRoIGFuIG9sZCBUZXh0dXJlUGFja2VyLlxuXHRcdFx0XHRwYWdlLndpZHRoID0gcGFyc2VJbnQodHVwbGVbMF0pO1xuXHRcdFx0XHRwYWdlLmhlaWdodCA9IHBhcnNlSW50KHR1cGxlWzFdKTtcblx0XHRcdFx0cmVhZGVyLnJlYWRUdXBsZSh0dXBsZSk7XG5cdFx0XHR9XG5cdFx0XHRwYWdlLmZvcm1hdCA9IHNwaW5lLkF0bGFzLkZvcm1hdFt0dXBsZVswXV07XG5cblx0XHRcdHJlYWRlci5yZWFkVHVwbGUodHVwbGUpO1xuXHRcdFx0cGFnZS5taW5GaWx0ZXIgPSBzcGluZS5BdGxhcy5UZXh0dXJlRmlsdGVyW3R1cGxlWzBdXTtcblx0XHRcdHBhZ2UubWFnRmlsdGVyID0gc3BpbmUuQXRsYXMuVGV4dHVyZUZpbHRlclt0dXBsZVsxXV07XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSByZWFkZXIucmVhZFZhbHVlKCk7XG5cdFx0XHRwYWdlLnVXcmFwID0gc3BpbmUuQXRsYXMuVGV4dHVyZVdyYXAuY2xhbXBUb0VkZ2U7XG5cdFx0XHRwYWdlLnZXcmFwID0gc3BpbmUuQXRsYXMuVGV4dHVyZVdyYXAuY2xhbXBUb0VkZ2U7XG5cdFx0XHRpZiAoZGlyZWN0aW9uID09IFwieFwiKVxuXHRcdFx0XHRwYWdlLnVXcmFwID0gc3BpbmUuQXRsYXMuVGV4dHVyZVdyYXAucmVwZWF0O1xuXHRcdFx0ZWxzZSBpZiAoZGlyZWN0aW9uID09IFwieVwiKVxuXHRcdFx0XHRwYWdlLnZXcmFwID0gc3BpbmUuQXRsYXMuVGV4dHVyZVdyYXAucmVwZWF0O1xuXHRcdFx0ZWxzZSBpZiAoZGlyZWN0aW9uID09IFwieHlcIilcblx0XHRcdFx0cGFnZS51V3JhcCA9IHBhZ2UudldyYXAgPSBzcGluZS5BdGxhcy5UZXh0dXJlV3JhcC5yZXBlYXQ7XG5cbiAgICAgICAgICAgIHBhZ2UucmVuZGVyZXJPYmplY3QgPSBjb3JlLkJhc2VUZXh0dXJlLmZyb21JbWFnZShiYXNlVXJsICsgbGluZSwgY3Jvc3NPcmlnaW4pO1xuXG5cdFx0XHR0aGlzLnBhZ2VzLnB1c2gocGFnZSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHJlZ2lvbiA9IG5ldyBzcGluZS5BdGxhc1JlZ2lvbigpO1xuXHRcdFx0cmVnaW9uLm5hbWUgPSBsaW5lO1xuXHRcdFx0cmVnaW9uLnBhZ2UgPSBwYWdlO1xuXG5cdFx0XHRyZWdpb24ucm90YXRlID0gcmVhZGVyLnJlYWRWYWx1ZSgpID09IFwidHJ1ZVwiO1xuXG5cdFx0XHRyZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcblx0XHRcdHZhciB4ID0gcGFyc2VJbnQodHVwbGVbMF0pO1xuXHRcdFx0dmFyIHkgPSBwYXJzZUludCh0dXBsZVsxXSk7XG5cblx0XHRcdHJlYWRlci5yZWFkVHVwbGUodHVwbGUpO1xuXHRcdFx0dmFyIHdpZHRoID0gcGFyc2VJbnQodHVwbGVbMF0pO1xuXHRcdFx0dmFyIGhlaWdodCA9IHBhcnNlSW50KHR1cGxlWzFdKTtcblxuXHRcdFx0cmVnaW9uLnUgPSB4IC8gcGFnZS53aWR0aDtcblx0XHRcdHJlZ2lvbi52ID0geSAvIHBhZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHJlZ2lvbi5yb3RhdGUpXG4gICAgICAgICAgICB7XG5cdFx0XHRcdHJlZ2lvbi51MiA9ICh4ICsgaGVpZ2h0KSAvIHBhZ2Uud2lkdGg7XG5cdFx0XHRcdHJlZ2lvbi52MiA9ICh5ICsgd2lkdGgpIC8gcGFnZS5oZWlnaHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZWdpb24udTIgPSAoeCArIHdpZHRoKSAvIHBhZ2Uud2lkdGg7XG5cdFx0XHRcdHJlZ2lvbi52MiA9ICh5ICsgaGVpZ2h0KSAvIHBhZ2UuaGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0cmVnaW9uLnggPSB4O1xuXHRcdFx0cmVnaW9uLnkgPSB5O1xuXHRcdFx0cmVnaW9uLndpZHRoID0gTWF0aC5hYnMod2lkdGgpO1xuXHRcdFx0cmVnaW9uLmhlaWdodCA9IE1hdGguYWJzKGhlaWdodCk7XG5cbiAgICAgICAgICAgIGlmIChyZWFkZXIucmVhZFR1cGxlKHR1cGxlKSA9PSA0KVxuICAgICAgICAgICAgeyAvLyBzcGxpdCBpcyBvcHRpb25hbFxuXHRcdFx0XHRyZWdpb24uc3BsaXRzID0gW3BhcnNlSW50KHR1cGxlWzBdKSwgcGFyc2VJbnQodHVwbGVbMV0pLCBwYXJzZUludCh0dXBsZVsyXSksIHBhcnNlSW50KHR1cGxlWzNdKV07XG5cbiAgICAgICAgICAgICAgICBpZiAocmVhZGVyLnJlYWRUdXBsZSh0dXBsZSkgPT0gNClcbiAgICAgICAgICAgICAgICB7IC8vIHBhZCBpcyBvcHRpb25hbCwgYnV0IG9ubHkgcHJlc2VudCB3aXRoIHNwbGl0c1xuXHRcdFx0XHRcdHJlZ2lvbi5wYWRzID0gW3BhcnNlSW50KHR1cGxlWzBdKSwgcGFyc2VJbnQodHVwbGVbMV0pLCBwYXJzZUludCh0dXBsZVsyXSksIHBhcnNlSW50KHR1cGxlWzNdKV07XG5cblx0XHRcdFx0XHRyZWFkZXIucmVhZFR1cGxlKHR1cGxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZWdpb24ub3JpZ2luYWxXaWR0aCA9IHBhcnNlSW50KHR1cGxlWzBdKTtcblx0XHRcdHJlZ2lvbi5vcmlnaW5hbEhlaWdodCA9IHBhcnNlSW50KHR1cGxlWzFdKTtcblxuXHRcdFx0cmVhZGVyLnJlYWRUdXBsZSh0dXBsZSk7XG5cdFx0XHRyZWdpb24ub2Zmc2V0WCA9IHBhcnNlSW50KHR1cGxlWzBdKTtcblx0XHRcdHJlZ2lvbi5vZmZzZXRZID0gcGFyc2VJbnQodHVwbGVbMV0pO1xuXG5cdFx0XHRyZWdpb24uaW5kZXggPSBwYXJzZUludChyZWFkZXIucmVhZFZhbHVlKCkpO1xuXG5cdFx0XHR0aGlzLnJlZ2lvbnMucHVzaChyZWdpb24pO1xuXHRcdH1cblx0fVxufTtcbnNwaW5lLkF0bGFzLnByb3RvdHlwZSA9IHtcbiAgICBmaW5kUmVnaW9uOiBmdW5jdGlvbiAobmFtZSlcbiAgICB7XG5cdFx0dmFyIHJlZ2lvbnMgPSB0aGlzLnJlZ2lvbnM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIG4gPSByZWdpb25zLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdGlmIChyZWdpb25zW2ldLm5hbWUgPT0gbmFtZSkgcmV0dXJuIHJlZ2lvbnNbaV07XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKClcbiAgICB7XG5cdFx0dmFyIHBhZ2VzID0gdGhpcy5wYWdlcztcblx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHBhZ2VzLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdHBhZ2VzW2ldLnJlbmRlcmVyT2JqZWN0LmRlc3Ryb3kodHJ1ZSk7XG5cdH0sXG4gICAgdXBkYXRlVVZzOiBmdW5jdGlvbiAocGFnZSlcbiAgICB7XG5cdFx0dmFyIHJlZ2lvbnMgPSB0aGlzLnJlZ2lvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcmVnaW9ucy5sZW5ndGg7IGkgPCBuOyBpKyspXG4gICAgICAgIHtcblx0XHRcdHZhciByZWdpb24gPSByZWdpb25zW2ldO1xuXHRcdFx0aWYgKHJlZ2lvbi5wYWdlICE9IHBhZ2UpIGNvbnRpbnVlO1xuXHRcdFx0cmVnaW9uLnUgPSByZWdpb24ueCAvIHBhZ2Uud2lkdGg7XG5cdFx0XHRyZWdpb24udiA9IHJlZ2lvbi55IC8gcGFnZS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAocmVnaW9uLnJvdGF0ZSlcbiAgICAgICAgICAgIHtcblx0XHRcdFx0cmVnaW9uLnUyID0gKHJlZ2lvbi54ICsgcmVnaW9uLmhlaWdodCkgLyBwYWdlLndpZHRoO1xuXHRcdFx0XHRyZWdpb24udjIgPSAocmVnaW9uLnkgKyByZWdpb24ud2lkdGgpIC8gcGFnZS5oZWlnaHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZWdpb24udTIgPSAocmVnaW9uLnggKyByZWdpb24ud2lkdGgpIC8gcGFnZS53aWR0aDtcblx0XHRcdFx0cmVnaW9uLnYyID0gKHJlZ2lvbi55ICsgcmVnaW9uLmhlaWdodCkgLyBwYWdlLmhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbnNwaW5lLkF0bGFzLkZvcm1hdCA9IHtcblx0YWxwaGE6IDAsXG5cdGludGVuc2l0eTogMSxcblx0bHVtaW5hbmNlQWxwaGE6IDIsXG5cdHJnYjU2NTogMyxcblx0cmdiYTQ0NDQ6IDQsXG5cdHJnYjg4ODogNSxcblx0cmdiYTg4ODg6IDZcbn07XG5cbnNwaW5lLkF0bGFzLlRleHR1cmVGaWx0ZXIgPSB7XG5cdG5lYXJlc3Q6IDAsXG5cdGxpbmVhcjogMSxcblx0bWlwTWFwOiAyLFxuXHRtaXBNYXBOZWFyZXN0TmVhcmVzdDogMyxcblx0bWlwTWFwTGluZWFyTmVhcmVzdDogNCxcblx0bWlwTWFwTmVhcmVzdExpbmVhcjogNSxcblx0bWlwTWFwTGluZWFyTGluZWFyOiA2XG59O1xuXG5zcGluZS5BdGxhcy5UZXh0dXJlV3JhcCA9IHtcblx0bWlycm9yZWRSZXBlYXQ6IDAsXG5cdGNsYW1wVG9FZGdlOiAxLFxuXHRyZXBlYXQ6IDJcbn07XG5cbnNwaW5lLkF0bGFzUGFnZSA9IGZ1bmN0aW9uICgpXG57fTtcbnNwaW5lLkF0bGFzUGFnZS5wcm90b3R5cGUgPSB7XG5cdG5hbWU6IG51bGwsXG5cdGZvcm1hdDogbnVsbCxcblx0bWluRmlsdGVyOiBudWxsLFxuXHRtYWdGaWx0ZXI6IG51bGwsXG5cdHVXcmFwOiBudWxsLFxuXHR2V3JhcDogbnVsbCxcblx0cmVuZGVyZXJPYmplY3Q6IG51bGwsXG5cdHdpZHRoOiAwLFxuXHRoZWlnaHQ6IDBcbn07XG5cbnNwaW5lLkF0bGFzUmVnaW9uID0gZnVuY3Rpb24gKClcbnt9O1xuc3BpbmUuQXRsYXNSZWdpb24ucHJvdG90eXBlID0ge1xuXHRwYWdlOiBudWxsLFxuXHRuYW1lOiBudWxsLFxuXHR4OiAwLCB5OiAwLFxuXHR3aWR0aDogMCwgaGVpZ2h0OiAwLFxuXHR1OiAwLCB2OiAwLCB1MjogMCwgdjI6IDAsXG5cdG9mZnNldFg6IDAsIG9mZnNldFk6IDAsXG5cdG9yaWdpbmFsV2lkdGg6IDAsIG9yaWdpbmFsSGVpZ2h0OiAwLFxuXHRpbmRleDogMCxcblx0cm90YXRlOiBmYWxzZSxcblx0c3BsaXRzOiBudWxsLFxuXHRwYWRzOiBudWxsXG59O1xuXG5zcGluZS5BdGxhc1JlYWRlciA9IGZ1bmN0aW9uICh0ZXh0KVxue1xuXHR0aGlzLmxpbmVzID0gdGV4dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcbn07XG5zcGluZS5BdGxhc1JlYWRlci5wcm90b3R5cGUgPSB7XG5cdGluZGV4OiAwLFxuICAgIHRyaW06IGZ1bmN0aW9uICh2YWx1ZSlcbiAgICB7XG5cdFx0cmV0dXJuIHZhbHVlLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xuXHR9LFxuICAgIHJlYWRMaW5lOiBmdW5jdGlvbiAoKVxuICAgIHtcblx0XHRpZiAodGhpcy5pbmRleCA+PSB0aGlzLmxpbmVzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cdFx0cmV0dXJuIHRoaXMubGluZXNbdGhpcy5pbmRleCsrXTtcblx0fSxcbiAgICByZWFkVmFsdWU6IGZ1bmN0aW9uICgpXG4gICAge1xuXHRcdHZhciBsaW5lID0gdGhpcy5yZWFkTGluZSgpO1xuXHRcdHZhciBjb2xvbiA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG5cdFx0aWYgKGNvbG9uID09IC0xKSB0aHJvdyBcIkludmFsaWQgbGluZTogXCIgKyBsaW5lO1xuXHRcdHJldHVybiB0aGlzLnRyaW0obGluZS5zdWJzdHJpbmcoY29sb24gKyAxKSk7XG5cdH0sXG5cdC8qKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdHVwbGUgdmFsdWVzIHJlYWQgKDEsIDIgb3IgNCkuICovXG4gICAgcmVhZFR1cGxlOiBmdW5jdGlvbiAodHVwbGUpXG4gICAge1xuXHRcdHZhciBsaW5lID0gdGhpcy5yZWFkTGluZSgpO1xuXHRcdHZhciBjb2xvbiA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG5cdFx0aWYgKGNvbG9uID09IC0xKSB0aHJvdyBcIkludmFsaWQgbGluZTogXCIgKyBsaW5lO1xuXHRcdHZhciBpID0gMCwgbGFzdE1hdGNoID0gY29sb24gKyAxO1xuICAgICAgICBmb3IgKDsgaSA8IDM7IGkrKylcbiAgICAgICAge1xuXHRcdFx0dmFyIGNvbW1hID0gbGluZS5pbmRleE9mKFwiLFwiLCBsYXN0TWF0Y2gpO1xuXHRcdFx0aWYgKGNvbW1hID09IC0xKSBicmVhaztcblx0XHRcdHR1cGxlW2ldID0gdGhpcy50cmltKGxpbmUuc3Vic3RyKGxhc3RNYXRjaCwgY29tbWEgLSBsYXN0TWF0Y2gpKTtcblx0XHRcdGxhc3RNYXRjaCA9IGNvbW1hICsgMTtcblx0XHR9XG5cdFx0dHVwbGVbaV0gPSB0aGlzLnRyaW0obGluZS5zdWJzdHJpbmcobGFzdE1hdGNoKSk7XG5cdFx0cmV0dXJuIGkgKyAxO1xuXHR9XG59O1xuXG5zcGluZS5BdGxhc0F0dGFjaG1lbnRQYXJzZXIgPSBmdW5jdGlvbiAoYXRsYXMpXG57XG5cdHRoaXMuYXRsYXMgPSBhdGxhcztcbn07XG5zcGluZS5BdGxhc0F0dGFjaG1lbnRQYXJzZXIucHJvdG90eXBlID0ge1xuICAgIG5ld1JlZ2lvbkF0dGFjaG1lbnQ6IGZ1bmN0aW9uIChza2luLCBuYW1lLCBwYXRoKVxuICAgIHtcblx0XHR2YXIgcmVnaW9uID0gdGhpcy5hdGxhcy5maW5kUmVnaW9uKHBhdGgpO1xuXHRcdGlmICghcmVnaW9uKSB0aHJvdyBcIlJlZ2lvbiBub3QgZm91bmQgaW4gYXRsYXM6IFwiICsgcGF0aCArIFwiIChyZWdpb24gYXR0YWNobWVudDogXCIgKyBuYW1lICsgXCIpXCI7XG5cdFx0dmFyIGF0dGFjaG1lbnQgPSBuZXcgc3BpbmUuUmVnaW9uQXR0YWNobWVudChuYW1lKTtcblx0XHRhdHRhY2htZW50LnJlbmRlcmVyT2JqZWN0ID0gcmVnaW9uO1xuXHRcdGF0dGFjaG1lbnQuc2V0VVZzKHJlZ2lvbi51LCByZWdpb24udiwgcmVnaW9uLnUyLCByZWdpb24udjIsIHJlZ2lvbi5yb3RhdGUpO1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uT2Zmc2V0WCA9IHJlZ2lvbi5vZmZzZXRYO1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uT2Zmc2V0WSA9IHJlZ2lvbi5vZmZzZXRZO1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uV2lkdGggPSByZWdpb24ud2lkdGg7XG5cdFx0YXR0YWNobWVudC5yZWdpb25IZWlnaHQgPSByZWdpb24uaGVpZ2h0O1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uT3JpZ2luYWxXaWR0aCA9IHJlZ2lvbi5vcmlnaW5hbFdpZHRoO1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uT3JpZ2luYWxIZWlnaHQgPSByZWdpb24ub3JpZ2luYWxIZWlnaHQ7XG5cdFx0cmV0dXJuIGF0dGFjaG1lbnQ7XG5cdH0sXG4gICAgbmV3TWVzaEF0dGFjaG1lbnQ6IGZ1bmN0aW9uIChza2luLCBuYW1lLCBwYXRoKVxuICAgIHtcblx0XHR2YXIgcmVnaW9uID0gdGhpcy5hdGxhcy5maW5kUmVnaW9uKHBhdGgpO1xuXHRcdGlmICghcmVnaW9uKSB0aHJvdyBcIlJlZ2lvbiBub3QgZm91bmQgaW4gYXRsYXM6IFwiICsgcGF0aCArIFwiIChtZXNoIGF0dGFjaG1lbnQ6IFwiICsgbmFtZSArIFwiKVwiO1xuXHRcdHZhciBhdHRhY2htZW50ID0gbmV3IHNwaW5lLk1lc2hBdHRhY2htZW50KG5hbWUpO1xuXHRcdGF0dGFjaG1lbnQucmVuZGVyZXJPYmplY3QgPSByZWdpb247XG5cdFx0YXR0YWNobWVudC5yZWdpb25VID0gcmVnaW9uLnU7XG5cdFx0YXR0YWNobWVudC5yZWdpb25WID0gcmVnaW9uLnY7XG5cdFx0YXR0YWNobWVudC5yZWdpb25VMiA9IHJlZ2lvbi51Mjtcblx0XHRhdHRhY2htZW50LnJlZ2lvblYyID0gcmVnaW9uLnYyO1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uUm90YXRlID0gcmVnaW9uLnJvdGF0ZTtcblx0XHRhdHRhY2htZW50LnJlZ2lvbk9mZnNldFggPSByZWdpb24ub2Zmc2V0WDtcblx0XHRhdHRhY2htZW50LnJlZ2lvbk9mZnNldFkgPSByZWdpb24ub2Zmc2V0WTtcblx0XHRhdHRhY2htZW50LnJlZ2lvbldpZHRoID0gcmVnaW9uLndpZHRoO1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uSGVpZ2h0ID0gcmVnaW9uLmhlaWdodDtcblx0XHRhdHRhY2htZW50LnJlZ2lvbk9yaWdpbmFsV2lkdGggPSByZWdpb24ub3JpZ2luYWxXaWR0aDtcblx0XHRhdHRhY2htZW50LnJlZ2lvbk9yaWdpbmFsSGVpZ2h0ID0gcmVnaW9uLm9yaWdpbmFsSGVpZ2h0O1xuXHRcdHJldHVybiBhdHRhY2htZW50O1xuXHR9LFxuICAgIG5ld1NraW5uZWRNZXNoQXR0YWNobWVudDogZnVuY3Rpb24gKHNraW4sIG5hbWUsIHBhdGgpXG4gICAge1xuXHRcdHZhciByZWdpb24gPSB0aGlzLmF0bGFzLmZpbmRSZWdpb24ocGF0aCk7XG5cdFx0aWYgKCFyZWdpb24pIHRocm93IFwiUmVnaW9uIG5vdCBmb3VuZCBpbiBhdGxhczogXCIgKyBwYXRoICsgXCIgKHNraW5uZWQgbWVzaCBhdHRhY2htZW50OiBcIiArIG5hbWUgKyBcIilcIjtcblx0XHR2YXIgYXR0YWNobWVudCA9IG5ldyBzcGluZS5Ta2lubmVkTWVzaEF0dGFjaG1lbnQobmFtZSk7XG5cdFx0YXR0YWNobWVudC5yZW5kZXJlck9iamVjdCA9IHJlZ2lvbjtcblx0XHRhdHRhY2htZW50LnJlZ2lvblUgPSByZWdpb24udTtcblx0XHRhdHRhY2htZW50LnJlZ2lvblYgPSByZWdpb24udjtcblx0XHRhdHRhY2htZW50LnJlZ2lvblUyID0gcmVnaW9uLnUyO1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uVjIgPSByZWdpb24udjI7XG5cdFx0YXR0YWNobWVudC5yZWdpb25Sb3RhdGUgPSByZWdpb24ucm90YXRlO1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uT2Zmc2V0WCA9IHJlZ2lvbi5vZmZzZXRYO1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uT2Zmc2V0WSA9IHJlZ2lvbi5vZmZzZXRZO1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uV2lkdGggPSByZWdpb24ud2lkdGg7XG5cdFx0YXR0YWNobWVudC5yZWdpb25IZWlnaHQgPSByZWdpb24uaGVpZ2h0O1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uT3JpZ2luYWxXaWR0aCA9IHJlZ2lvbi5vcmlnaW5hbFdpZHRoO1xuXHRcdGF0dGFjaG1lbnQucmVnaW9uT3JpZ2luYWxIZWlnaHQgPSByZWdpb24ub3JpZ2luYWxIZWlnaHQ7XG5cdFx0cmV0dXJuIGF0dGFjaG1lbnQ7XG5cdH0sXG4gICAgbmV3Qm91bmRpbmdCb3hBdHRhY2htZW50OiBmdW5jdGlvbiAoc2tpbiwgbmFtZSlcbiAgICB7XG5cdFx0cmV0dXJuIG5ldyBzcGluZS5Cb3VuZGluZ0JveEF0dGFjaG1lbnQobmFtZSk7XG5cdH1cbn07XG5cbnNwaW5lLlNrZWxldG9uQm91bmRzID0gZnVuY3Rpb24gKClcbntcblx0dGhpcy5wb2x5Z29uUG9vbCA9IFtdO1xuXHR0aGlzLnBvbHlnb25zID0gW107XG5cdHRoaXMuYm91bmRpbmdCb3hlcyA9IFtdO1xufTtcbnNwaW5lLlNrZWxldG9uQm91bmRzLnByb3RvdHlwZSA9IHtcblx0bWluWDogMCwgbWluWTogMCwgbWF4WDogMCwgbWF4WTogMCxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChza2VsZXRvbiwgdXBkYXRlQWFiYilcbiAgICB7XG5cdFx0dmFyIHNsb3RzID0gc2tlbGV0b24uc2xvdHM7XG5cdFx0dmFyIHNsb3RDb3VudCA9IHNsb3RzLmxlbmd0aDtcblx0XHR2YXIgeCA9IHNrZWxldG9uLngsIHkgPSBza2VsZXRvbi55O1xuXHRcdHZhciBib3VuZGluZ0JveGVzID0gdGhpcy5ib3VuZGluZ0JveGVzO1xuXHRcdHZhciBwb2x5Z29uUG9vbCA9IHRoaXMucG9seWdvblBvb2w7XG5cdFx0dmFyIHBvbHlnb25zID0gdGhpcy5wb2x5Z29ucztcblxuXHRcdGJvdW5kaW5nQm94ZXMubGVuZ3RoID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb25zLmxlbmd0aDsgaSA8IG47IGkrKylcblx0XHRcdHBvbHlnb25Qb29sLnB1c2gocG9seWdvbnNbaV0pO1xuXHRcdHBvbHlnb25zLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbG90Q291bnQ7IGkrKylcbiAgICAgICAge1xuXHRcdFx0dmFyIHNsb3QgPSBzbG90c1tpXTtcblx0XHRcdHZhciBib3VuZGluZ0JveCA9IHNsb3QuYXR0YWNobWVudDtcblx0XHRcdGlmIChib3VuZGluZ0JveC50eXBlICE9IHNwaW5lLkF0dGFjaG1lbnRUeXBlLmJvdW5kaW5nYm94KSBjb250aW51ZTtcblx0XHRcdGJvdW5kaW5nQm94ZXMucHVzaChib3VuZGluZ0JveCk7XG5cblx0XHRcdHZhciBwb29sQ291bnQgPSBwb2x5Z29uUG9vbC5sZW5ndGgsIHBvbHlnb247XG4gICAgICAgICAgICBpZiAocG9vbENvdW50ID4gMClcbiAgICAgICAgICAgIHtcblx0XHRcdFx0cG9seWdvbiA9IHBvbHlnb25Qb29sW3Bvb2xDb3VudCAtIDFdO1xuXHRcdFx0XHRwb2x5Z29uUG9vbC5zcGxpY2UocG9vbENvdW50IC0gMSwgMSk7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0cG9seWdvbiA9IFtdO1xuXHRcdFx0cG9seWdvbnMucHVzaChwb2x5Z29uKTtcblxuXHRcdFx0cG9seWdvbi5sZW5ndGggPSBib3VuZGluZ0JveC52ZXJ0aWNlcy5sZW5ndGg7XG5cdFx0XHRib3VuZGluZ0JveC5jb21wdXRlV29ybGRWZXJ0aWNlcyh4LCB5LCBzbG90LmJvbmUsIHBvbHlnb24pO1xuXHRcdH1cblxuXHRcdGlmICh1cGRhdGVBYWJiKSB0aGlzLmFhYmJDb21wdXRlKCk7XG5cdH0sXG4gICAgYWFiYkNvbXB1dGU6IGZ1bmN0aW9uICgpXG4gICAge1xuXHRcdHZhciBwb2x5Z29ucyA9IHRoaXMucG9seWdvbnM7XG5cdFx0dmFyIG1pblggPSBOdW1iZXIuTUFYX1ZBTFVFLCBtaW5ZID0gTnVtYmVyLk1BWF9WQUxVRSwgbWF4WCA9IE51bWJlci5NSU5fVkFMVUUsIG1heFkgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb25zLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAge1xuXHRcdFx0dmFyIHZlcnRpY2VzID0gcG9seWdvbnNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBpaSA9IDAsIG5uID0gdmVydGljZXMubGVuZ3RoOyBpaSA8IG5uOyBpaSArPSAyKVxuICAgICAgICAgICAge1xuXHRcdFx0XHR2YXIgeCA9IHZlcnRpY2VzW2lpXTtcblx0XHRcdFx0dmFyIHkgPSB2ZXJ0aWNlc1tpaSArIDFdO1xuXHRcdFx0XHRtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG5cdFx0XHRcdG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcblx0XHRcdFx0bWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuXHRcdFx0XHRtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMubWluWCA9IG1pblg7XG5cdFx0dGhpcy5taW5ZID0gbWluWTtcblx0XHR0aGlzLm1heFggPSBtYXhYO1xuXHRcdHRoaXMubWF4WSA9IG1heFk7XG5cdH0sXG5cdC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggY29udGFpbnMgdGhlIHBvaW50LiAqL1xuICAgIGFhYmJDb250YWluc1BvaW50OiBmdW5jdGlvbiAoeCwgeSlcbiAgICB7XG5cdFx0cmV0dXJuIHggPj0gdGhpcy5taW5YICYmIHggPD0gdGhpcy5tYXhYICYmIHkgPj0gdGhpcy5taW5ZICYmIHkgPD0gdGhpcy5tYXhZO1xuXHR9LFxuXHQvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGludGVyc2VjdHMgdGhlIGxpbmUgc2VnbWVudC4gKi9cbiAgICBhYWJiSW50ZXJzZWN0c1NlZ21lbnQ6IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MilcbiAgICB7XG5cdFx0dmFyIG1pblggPSB0aGlzLm1pblgsIG1pblkgPSB0aGlzLm1pblksIG1heFggPSB0aGlzLm1heFgsIG1heFkgPSB0aGlzLm1heFk7XG5cdFx0aWYgKCh4MSA8PSBtaW5YICYmIHgyIDw9IG1pblgpIHx8ICh5MSA8PSBtaW5ZICYmIHkyIDw9IG1pblkpIHx8ICh4MSA+PSBtYXhYICYmIHgyID49IG1heFgpIHx8ICh5MSA+PSBtYXhZICYmIHkyID49IG1heFkpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBtID0gKHkyIC0geTEpIC8gKHgyIC0geDEpO1xuXHRcdHZhciB5ID0gbSAqIChtaW5YIC0geDEpICsgeTE7XG5cdFx0aWYgKHkgPiBtaW5ZICYmIHkgPCBtYXhZKSByZXR1cm4gdHJ1ZTtcblx0XHR5ID0gbSAqIChtYXhYIC0geDEpICsgeTE7XG5cdFx0aWYgKHkgPiBtaW5ZICYmIHkgPCBtYXhZKSByZXR1cm4gdHJ1ZTtcblx0XHR2YXIgeCA9IChtaW5ZIC0geTEpIC8gbSArIHgxO1xuXHRcdGlmICh4ID4gbWluWCAmJiB4IDwgbWF4WCkgcmV0dXJuIHRydWU7XG5cdFx0eCA9IChtYXhZIC0geTEpIC8gbSArIHgxO1xuXHRcdGlmICh4ID4gbWluWCAmJiB4IDwgbWF4WCkgcmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHQvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGludGVyc2VjdHMgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggb2YgdGhlIHNwZWNpZmllZCBib3VuZHMuICovXG4gICAgYWFiYkludGVyc2VjdHNTa2VsZXRvbjogZnVuY3Rpb24gKGJvdW5kcylcbiAgICB7XG5cdFx0cmV0dXJuIHRoaXMubWluWCA8IGJvdW5kcy5tYXhYICYmIHRoaXMubWF4WCA+IGJvdW5kcy5taW5YICYmIHRoaXMubWluWSA8IGJvdW5kcy5tYXhZICYmIHRoaXMubWF4WSA+IGJvdW5kcy5taW5ZO1xuXHR9LFxuXHQvKiogUmV0dXJucyB0aGUgZmlyc3QgYm91bmRpbmcgYm94IGF0dGFjaG1lbnQgdGhhdCBjb250YWlucyB0aGUgcG9pbnQsIG9yIG51bGwuIFdoZW4gZG9pbmcgbWFueSBjaGVja3MsIGl0IGlzIHVzdWFsbHkgbW9yZVxuXHQgKiBlZmZpY2llbnQgdG8gb25seSBjYWxsIHRoaXMgbWV0aG9kIGlmIHtAbGluayAjYWFiYkNvbnRhaW5zUG9pbnQoZmxvYXQsIGZsb2F0KX0gcmV0dXJucyB0cnVlLiAqL1xuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICh4LCB5KVxuICAgIHtcblx0XHR2YXIgcG9seWdvbnMgPSB0aGlzLnBvbHlnb25zO1xuXHRcdGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0aWYgKHRoaXMucG9seWdvbkNvbnRhaW5zUG9pbnQocG9seWdvbnNbaV0sIHgsIHkpKSByZXR1cm4gdGhpcy5ib3VuZGluZ0JveGVzW2ldO1xuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXHQvKiogUmV0dXJucyB0aGUgZmlyc3QgYm91bmRpbmcgYm94IGF0dGFjaG1lbnQgdGhhdCBjb250YWlucyB0aGUgbGluZSBzZWdtZW50LCBvciBudWxsLiBXaGVuIGRvaW5nIG1hbnkgY2hlY2tzLCBpdCBpcyB1c3VhbGx5XG5cdCAqIG1vcmUgZWZmaWNpZW50IHRvIG9ubHkgY2FsbCB0aGlzIG1ldGhvZCBpZiB7QGxpbmsgI2FhYmJJbnRlcnNlY3RzU2VnbWVudChmbG9hdCwgZmxvYXQsIGZsb2F0LCBmbG9hdCl9IHJldHVybnMgdHJ1ZS4gKi9cbiAgICBpbnRlcnNlY3RzU2VnbWVudDogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKVxuICAgIHtcblx0XHR2YXIgcG9seWdvbnMgPSB0aGlzLnBvbHlnb25zO1xuXHRcdGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKVxuXHRcdFx0aWYgKHBvbHlnb25zW2ldLmludGVyc2VjdHNTZWdtZW50KHgxLCB5MSwgeDIsIHkyKSkgcmV0dXJuIHRoaXMuYm91bmRpbmdCb3hlc1tpXTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblx0LyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9seWdvbiBjb250YWlucyB0aGUgcG9pbnQuICovXG4gICAgcG9seWdvbkNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwb2x5Z29uLCB4LCB5KVxuICAgIHtcblx0XHR2YXIgbm4gPSBwb2x5Z29uLmxlbmd0aDtcblx0XHR2YXIgcHJldkluZGV4ID0gbm4gLSAyO1xuXHRcdHZhciBpbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5uOyBpaSArPSAyKVxuICAgICAgICB7XG5cdFx0XHR2YXIgdmVydGV4WSA9IHBvbHlnb25baWkgKyAxXTtcblx0XHRcdHZhciBwcmV2WSA9IHBvbHlnb25bcHJldkluZGV4ICsgMV07XG4gICAgICAgICAgICBpZiAoKHZlcnRleFkgPCB5ICYmIHByZXZZID49IHkpIHx8IChwcmV2WSA8IHkgJiYgdmVydGV4WSA+PSB5KSlcbiAgICAgICAgICAgIHtcblx0XHRcdFx0dmFyIHZlcnRleFggPSBwb2x5Z29uW2lpXTtcblx0XHRcdFx0aWYgKHZlcnRleFggKyAoeSAtIHZlcnRleFkpIC8gKHByZXZZIC0gdmVydGV4WSkgKiAocG9seWdvbltwcmV2SW5kZXhdIC0gdmVydGV4WCkgPCB4KSBpbnNpZGUgPSAhaW5zaWRlO1xuXHRcdFx0fVxuXHRcdFx0cHJldkluZGV4ID0gaWk7XG5cdFx0fVxuXHRcdHJldHVybiBpbnNpZGU7XG5cdH0sXG5cdC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvbHlnb24gY29udGFpbnMgdGhlIGxpbmUgc2VnbWVudC4gKi9cbiAgICBwb2x5Z29uSW50ZXJzZWN0c1NlZ21lbnQ6IGZ1bmN0aW9uIChwb2x5Z29uLCB4MSwgeTEsIHgyLCB5MilcbiAgICB7XG5cdFx0dmFyIG5uID0gcG9seWdvbi5sZW5ndGg7XG5cdFx0dmFyIHdpZHRoMTIgPSB4MSAtIHgyLCBoZWlnaHQxMiA9IHkxIC0geTI7XG5cdFx0dmFyIGRldDEgPSB4MSAqIHkyIC0geTEgKiB4Mjtcblx0XHR2YXIgeDMgPSBwb2x5Z29uW25uIC0gMl0sIHkzID0gcG9seWdvbltubiAtIDFdO1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbm47IGlpICs9IDIpXG4gICAgICAgIHtcblx0XHRcdHZhciB4NCA9IHBvbHlnb25baWldLCB5NCA9IHBvbHlnb25baWkgKyAxXTtcblx0XHRcdHZhciBkZXQyID0geDMgKiB5NCAtIHkzICogeDQ7XG5cdFx0XHR2YXIgd2lkdGgzNCA9IHgzIC0geDQsIGhlaWdodDM0ID0geTMgLSB5NDtcblx0XHRcdHZhciBkZXQzID0gd2lkdGgxMiAqIGhlaWdodDM0IC0gaGVpZ2h0MTIgKiB3aWR0aDM0O1xuXHRcdFx0dmFyIHggPSAoZGV0MSAqIHdpZHRoMzQgLSB3aWR0aDEyICogZGV0MikgLyBkZXQzO1xuICAgICAgICAgICAgaWYgKCgoeCA+PSB4MyAmJiB4IDw9IHg0KSB8fCAoeCA+PSB4NCAmJiB4IDw9IHgzKSkgJiYgKCh4ID49IHgxICYmIHggPD0geDIpIHx8ICh4ID49IHgyICYmIHggPD0geDEpKSlcbiAgICAgICAgICAgIHtcblx0XHRcdFx0dmFyIHkgPSAoZGV0MSAqIGhlaWdodDM0IC0gaGVpZ2h0MTIgKiBkZXQyKSAvIGRldDM7XG5cdFx0XHRcdGlmICgoKHkgPj0geTMgJiYgeSA8PSB5NCkgfHwgKHkgPj0geTQgJiYgeSA8PSB5MykpICYmICgoeSA+PSB5MSAmJiB5IDw9IHkyKSB8fCAoeSA+PSB5MiAmJiB5IDw9IHkxKSkpIHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0eDMgPSB4NDtcblx0XHRcdHkzID0geTQ7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcbiAgICBnZXRQb2x5Z29uOiBmdW5jdGlvbiAoYXR0YWNobWVudClcbiAgICB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5ib3VuZGluZ0JveGVzLmluZGV4T2YoYXR0YWNobWVudCk7XG5cdFx0cmV0dXJuIGluZGV4ID09IC0xID8gbnVsbCA6IHRoaXMucG9seWdvbnNbaW5kZXhdO1xuXHR9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoKVxuICAgIHtcblx0XHRyZXR1cm4gdGhpcy5tYXhYIC0gdGhpcy5taW5YO1xuXHR9LFxuICAgIGdldEhlaWdodDogZnVuY3Rpb24gKClcbiAgICB7XG5cdFx0cmV0dXJuIHRoaXMubWF4WSAtIHRoaXMubWluWTtcblx0fVxufTtcbiIsIi8qKlxuICogQGZpbGUgICAgICAgIE1haW4gZXhwb3J0IG9mIHRoZSBQSVhJIHNwaW5lIGxpYnJhcnlcbiAqIEBhdXRob3IgICAgICBNYXQgR3JvdmVzIDxtYXRAZ29vZGJveWRpZ2l0YWwuY29tPlxuICogQGNvcHlyaWdodCAgIDIwMTMtMjAxNSBHb29kQm95RGlnaXRhbFxuICogQGxpY2Vuc2UgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vR29vZEJveURpZ2l0YWwvcGl4aS5qcy9ibG9iL21hc3Rlci9MSUNFTlNFfE1JVCBMaWNlbnNlfVxuICovXG5cbi8qKlxuICogQG5hbWVzcGFjZSBQSVhJLnNwaW5lXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFNwaW5lOiAgICAgIHJlcXVpcmUoJy4vU3BpbmUnKSxcbiAgICBTcGluZVJ1bnRpbWU6ICAgIHJlcXVpcmUoJy4vU3BpbmVSdW50aW1lJylcbn07XG4iLCJDb3JlID0gcmVxdWlyZSAnc2hpcC9Db3JlJ1xuRW50aXR5ID0gcmVxdWlyZSAnRW50aXR5J1xuSHVsbCA9IHJlcXVpcmUgJ3NoaXAvSHVsbCdcbkludGVyaW9yID0gcmVxdWlyZSAnc2hpcC9JbnRlcmlvcidcbklPID0gcmVxdWlyZSAnSU8nXG5QaXhpID0gcmVxdWlyZSAncGl4aS5qcydcblRocnVzdGVyID0gcmVxdWlyZSAnc2hpcC9UaHJ1c3RlcidcblV0aWwgPSByZXF1aXJlICd1dGlsL1V0aWwnXG5cbmNsYXNzIFBhcnRMYWJlbCBleHRlbmRzIEVudGl0eVxuICBjb25zdHJ1Y3RvcjogKCkgLT5cbiAgICBAbGF5ZXIgPSAnaHVkJ1xuICAgIEBzcHJpdGUgPSBuZXcgUGl4aS5UZXh0KCdwYXJ0Jywge1xuICAgICAgZm9udDogJzIwcHggQXJpYWwnXG4gICAgICBmaWxsOiAnI0ZGRkZGRidcbiAgICB9KVxuXG4jIEEgc2NyZWVuIHRvIGVkaXQgYmx1ZXByaW50c1xuY2xhc3MgQmx1ZXByaW50RWRpdG9yIGV4dGVuZHMgRW50aXR5XG4gICMgS0VZU1xuICBLX05FWFRfUEFSVCA9IDgxICMgcVxuICBLX1BSRVZJT1VTX1BBUlQgPSA2OSAjIGVcbiAgS19ST1RBVEVfTEVGVCA9IDY1ICMgYVxuICBLX1JPVEFURV9SSUdIVCA9IDY4ICMgZFxuICBLX0NMT1NFID0gMzIgIyBzcGFjZVxuICAjIEtfQ0xPU0UgPSAxMyAjIGVudGVyXG5cbiAgY29uc3RydWN0b3I6IChAYmx1ZXByaW50LCBAb25jbG9zZSA9IG51bGwpIC0+XG4gICAgQHNwcml0ZSA9IG5ldyBQaXhpLkNvbnRhaW5lcigpXG4gICAgQGxheWVyID0gJ3dvcmxkJ1xuICAgIEBiYWNrZ3JvdW5kID0gbmV3IFBpeGkuR3JhcGhpY3MoKVxuICAgIEBiYWNrZ3JvdW5kLmJlZ2luRmlsbCgweDExMTcxMSlcbiAgICBAYmFja2dyb3VuZC5lbmRGaWxsKClcblxuICAgIEBzcHJpdGUuYWRkQ2hpbGQoQGJhY2tncm91bmQpXG4gICAgQHNwcml0ZS5hZGRDaGlsZChAYmx1ZXByaW50LnNwcml0ZSlcblxuICAgIEBzZWxlY3RvciA9IG5ldyBQaXhpLkdyYXBoaWNzKClcbiAgICBAc3ByaXRlLmFkZENoaWxkKEBzZWxlY3RvcilcblxuICAgIEBwYXJ0TGFiZWwgPSBuZXcgUGFydExhYmVsKClcblxuICAgIEBkaXJlY3Rpb24gPSAwXG4gICAgQHBhcnRDbGFzc2VzID0gW0h1bGwsIFRocnVzdGVyLCBJbnRlcmlvcl1cbiAgICBAcGFydEluZGV4ID0gMFxuICAgIEBuZXh0UGFydCgwKVxuXG4gIGFkZGVkOiAoKSA9PlxuICAgIEBnYW1lLmFkZEVudGl0eShAcGFydExhYmVsKVxuXG4gICMgUmV0dXJuIHRoZSBncmlkIGNvb3JkaW5hdGVzIG9mIHRoZSBzcXVhcmUgdGhlIG1vdXNlIGlzIG92ZXJcbiAgZ2V0SG92ZXJTcXVhcmU6ICgpID0+XG4gICAgcmV0dXJuIEBnYW1lLmNhbWVyYS50b1dvcmxkKEBnYW1lLmlvLm1vdXNlUG9zaXRpb24pLm1hcChNYXRoLnJvdW5kKVxuICBcbiAgcmVuZGVyOiAoKSA9PlxuICAgIEBzZWxlY3Rvci5jbGVhcigpXG4gICAgc3F1cmVQb3MgPSBAZ2V0SG92ZXJTcXVhcmUoKVxuICAgIGhvdmVyUGFydCA9IEBibHVlcHJpbnQucGFydEdyaWQuZ2V0KHNxdXJlUG9zKVxuICAgIGlmIG5vdCBob3ZlclBhcnQ/XG4gICAgICBAc2VsZWN0b3IuYmVnaW5GaWxsKEBQYXJ0LnR5cGUuY29sb3IpXG4gICAgICBAc2VsZWN0b3IuZHJhd1JlY3QoLTAuNSwgLTAuNSwgMSwgMSlcbiAgICAgIEBzZWxlY3Rvci5lbmRGaWxsKClcbiAgICBcbiAgICBjYW5BZGQgPSAhaG92ZXJQYXJ0XG4gICAgaWYgaG92ZXJQYXJ0P1xuICAgICAgY29sb3IgPSAweEZGRkZGRlxuICAgIGVsc2UgaWYgY2FuQWRkXG4gICAgICBjb2xvciA9IDB4MzNGRjMzXG4gICAgZWxzZVxuICAgICAgY29sb3IgPSAweEZGMzMzM1xuXG4gICAgQHNlbGVjdG9yLmxpbmVTdHlsZSgwLjA1LCBjb2xvcilcbiAgICBAc2VsZWN0b3IuZHJhd1JlY3QoLTEsIC0xLCAxLCAxKVxuXG4gICAgaWYgQFBhcnQudHlwZS5kaXJlY3Rpb25hbFxuICAgICAgQHNlbGVjdG9yLmxpbmVTdHlsZSgwLjA1LCAweEZGRkZGRiwgMC41KVxuICAgICAgQHNlbGVjdG9yLm1vdmVUbygtMC41LCAtMC41KSAjIGZvciBzb21lIHJlYXNvbiB0aGlzIGhhcyB0byBoYXZlIHRoaXMgb2Zmc2V0XG4gICAgICBhbmdsZSA9IChAZGlyZWN0aW9uICsgMykgKiBNYXRoLlBJIC8gMlxuICAgICAgQHNlbGVjdG9yLmxpbmVUbyhNYXRoLmNvcyhhbmdsZSkgKiAwLjUgLSAwLjUsIE1hdGguc2luKGFuZ2xlKSAqIDAuNSAtIDAuNSlcblxuICAgIGlmIGdhbWUuaW8uYnV0dG9uc1swXVxuICAgICAgQG9uQ2xpY2soKVxuXG4gICAgaWYgZ2FtZS5pby5idXR0b25zWzJdXG4gICAgICBAb25SaWdodENsaWNrKClcblxuICAgIFtAc2VsZWN0b3IueCwgQHNlbGVjdG9yLnldID0gc3F1cmVQb3NcblxuICAjIEFkZCBwYXJ0cyBvbiBjbGlja1xuICBvbkNsaWNrOiAobW91c2VQb3NpdGlvbikgPT5cbiAgICBbeCwgeV0gPSBAZ2V0SG92ZXJTcXVhcmUoKVxuICAgIGlmIG5vdCBAYmx1ZXByaW50LnBhcnRHcmlkLmdldChbeCwgeV0pP1xuICAgICAgYXJncyA9IFt4LCB5XVxuICAgICAgaWYgQFBhcnQudHlwZS5kaXJlY3Rpb25hbFxuICAgICAgICBhcmdzLnB1c2goQGRpcmVjdGlvbilcbiAgICAgIHBhcnQgPSBuZXcgQFBhcnQoYXJncy4uLilcbiAgICAgIEBibHVlcHJpbnQuYWRkUGFydChwYXJ0KVxuXG4gICMgUmVtb3ZlIHBhcnRzIG9uIHJpZ2h0IGNsaWNrXG4gIG9uUmlnaHRDbGljazogKG1vdXNlUG9zaXRpb24pID0+XG4gICAgcGFydCA9IEBibHVlcHJpbnQucGFydEdyaWQuZ2V0KEBnZXRIb3ZlclNxdWFyZSgpKVxuICAgIGlmIHBhcnQ/IGFuZCBwYXJ0LnR5cGUgaXNudCBDb3JlLnR5cGVcbiAgICAgIEBibHVlcHJpbnQucmVtb3ZlUGFydChwYXJ0KVxuXG4gICMgU2VsZWN0IHRoZSBuZXh0IHBhcnQuXG4gIG5leHRQYXJ0OiAoaT0xKSA9PlxuICAgIEBwYXJ0SW5kZXggPSBVdGlsLm1vZChAcGFydEluZGV4ICsgaSwgQHBhcnRDbGFzc2VzLmxlbmd0aClcbiAgICBAUGFydCA9IEBwYXJ0Q2xhc3Nlc1tAcGFydEluZGV4XVxuICAgIEBwYXJ0TGFiZWwuc3ByaXRlLnRleHQgPSBAUGFydC50eXBlLm5hbWVcblxuICAjIFJvdGF0ZSB0aGUgY3VycmVudCBkaXJlY3Rpb25cbiAgcm90YXRlOiAoaT0xKSA9PlxuICAgIEBkaXJlY3Rpb24gPSBVdGlsLm1vZChAZGlyZWN0aW9uICsgaSwgNClcbiAgXG4gICMgSGFuZGxlIGtleSBwcmVzc2VzXG4gIG9uS2V5RG93bjogKGtleSkgPT5cbiAgICBzd2l0Y2gga2V5XG4gICAgICB3aGVuIEtfQ0xPU0UgdGhlbiBAZGVzdHJveSgpXG4gICAgICB3aGVuIEtfTkVYVF9QQVJUIHRoZW4gQG5leHRQYXJ0KDEpXG4gICAgICB3aGVuIEtfUFJFVklPVVNfUEFSVCB0aGVuIEBuZXh0UGFydCgtMSlcbiAgICAgIHdoZW4gS19ST1RBVEVfTEVGVCB0aGVuIEByb3RhdGUoLTEpXG4gICAgICB3aGVuIEtfUk9UQVRFX1JJR0hUIHRoZW4gQHJvdGF0ZSgxKVxuXG4gIGRlc3Ryb3llZDogKCkgPT5cbiAgICBAcGFydExhYmVsLmRlc3Ryb3koKVxuICAgIGlmIEBvbmNsb3NlP1xuICAgICAgQG9uY2xvc2UoQGJsdWVwcmludClcbiAgXG5cblxubW9kdWxlLmV4cG9ydHMgPSBCbHVlcHJpbnRFZGl0b3IiLCJQaXhpID0gcmVxdWlyZSAncGl4aS5qcydcbk1hdHJpeCA9IFBpeGkuTWF0cml4XG5Qb2ludCA9IFBpeGkuUG9pbnRcblxuIyBDb250cm9scyB0aGUgdmlld3BvcnRcbmNsYXNzIENhbWVyYVxuICBjb25zdHJ1Y3RvcjogKEByZW5kZXJlciwgQHggPSAwLCBAeSA9IDAsIEB6ID0gMzAuMCwgQGFuZ2xlID0gMCkgLT5cbiAgICBAZm9sbG93aW5nID0gbnVsbFxuXG4gICMgTWFrZSB0aGUgY2FtZXJhIGNlbnRlciBvbiB0aGlzIHRoaW5nIGV2ZXJ5IGZyYW1lXG4gIGZvbGxvdzogKHRoaW5nKSA9PlxuICAgIEBmb2xsb3dpbmcgPSB0aGluZ1xuXG4gIHRpY2s6ID0+XG4gICAgaWYgQGZvbGxvd2luZz9cbiAgICAgIFtAeCwgQHldID0gQGZvbGxvd2luZy5wb3NpdGlvblxuICAgICAgIyBjb25zb2xlLmxvZyBbQHgsIEB5XVxuXG4gICMgUmV0dXJucyBbd2lkdGgsIGhlaWdodF0gb2YgdGhlIHZpZXdwb3J0XG4gIGdldFZpZXdwb3J0U2l6ZTogPT5cbiAgICByZXR1cm4gW0ByZW5kZXJlci5waXhpUmVuZGVyZXIud2lkdGgsIEByZW5kZXJlci5waXhpUmVuZGVyZXIuaGVpZ2h0XVxuXG4gICMgQ29udmVydCBzY3JlZW4gY29vcmRpbmF0ZXMgdG8gd29ybGQgY29vcmRpbmF0ZXNcbiAgdG9Xb3JsZDogKFt4LCB5XSwgZGVwdGggPSAxLjApID0+XG4gICAgW3csIGhdID0gQGdldFZpZXdwb3J0U2l6ZSgpXG4gICAgcCA9IG5ldyBQb2ludCh4LCB5KVxuICAgIHAgPSBAZ2V0TWF0cml4KGRlcHRoKS5hcHBseUludmVyc2UocCwgcClcbiAgICByZXR1cm4gW3AueCwgcC55XVxuXG4gICMgQ29udmVydCB3b3JsZCBjb29yZGluYXRlcyB0byBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgdG9TY3JlZW46IChbeCwgeV0sIGRlcHRoID0gMS4wKSA9PlxuICAgIFt3LCBoXSA9IEBnZXRWaWV3cG9ydFNpemUoKVxuICAgIHAgPSBuZXcgUG9pbnQoeCwgeSlcbiAgICBwID0gQGdldE1hdHJpeChkZXB0aCkuYXBwbHkocCwgcClcbiAgICByZXR1cm4gW3AueCwgcC55XVxuXG4gICMgQ3JlYXRlcyBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byBnbyBmcm9tIHNjcmVlbiB3b3JsZCBzcGFjZSB0byBzY3JlZW4gc3BhY2UuXG4gIGdldE1hdHJpeDogKGRlcHRoID0gMS4wKSA9PlxuICAgIFt3LCBoXSA9IEBnZXRWaWV3cG9ydFNpemUoKVxuICAgIG0gPSBuZXcgTWF0cml4KClcbiAgICBtLnRyYW5zbGF0ZSgtQHggKiBkZXB0aCwgLUB5ICogZGVwdGgpXG4gICAgbS5zY2FsZShAeiAqIGRlcHRoLCBAeiAqIGRlcHRoKVxuICAgIG0ucm90YXRlKEBhbmdsZSlcbiAgICBtLnRyYW5zbGF0ZSh3IC8gMiwgaCAvIDIpXG4gICAgcmV0dXJuIG1cblxuICAjIFVwZGF0ZSB0aGUgcHJvcGVydGllcyBvZiBhIHJlbmRlcmVyIGxheWVyIHRvIG1hdGNoIHRoaXMgY2FtZXJhXG4gIHVwZGF0ZUxheWVyOiAobGF5ZXJJbmZvKSA9PlxuICAgIHNjcm9sbCA9IGxheWVySW5mby5zY3JvbGxcbiAgICBpZiBzY3JvbGwgIT0gMFxuICAgICAgbGF5ZXIgPSBsYXllckluZm8ubGF5ZXJcbiAgICAgIFt3LCBoXSA9IEBnZXRWaWV3cG9ydFNpemUoKVxuICAgICAgW2xheWVyLngsIGxheWVyLnldID0gQHRvU2NyZWVuKFswLCAwXSlcbiAgICAgIGxheWVyLnJvdGF0aW9uID0gQGFuZ2xlXG4gICAgICBsYXllci5zY2FsZS5zZXQoQHosIEB6KVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhbWVyYVxuIiwiZ3JvdXAgPSAoZ3JvdXBzLi4uKSAtPlxuICBtYXNrID0gMFxuICBmb3IgaSBpbiBncm91cHNcbiAgICBtYXNrIHw9IE1hdGgucG93KDIsIGkpXG4gIGNvbnNvbGUubG9nIFwibWFzazogI3ttYXNrfSBmb3IgZ3JvdXBzICN7Z3JvdXBzfVwiXG4gIHJldHVybiBtYXNrXG5cbmNsYXNzIENvbGxpc2lvbkdyb3Vwc1xuICBAU0hJUF9FWFRFUklPUiA9IGdyb3VwIDBcbiAgQFNISVBfSU5URVJJT1IgPSBncm91cCAxXG4gIEBQRVJTT04gPSBncm91cCAyXG4gIEBBTEwgPSBncm91cCBbMC4uLjE2XS4uLlxuICBAT0JTVEFDTEVTID0gQEFMTCBeIEBTSElQX0lOVEVSSU9SXG5cbmNvbnNvbGUubG9nIENvbGxpc2lvbkdyb3Vwcy5PQlNUQUNMRVNcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsaXNpb25Hcm91cHMiLCIjIEJhc2UgY2xhc3MgZm9yIGxvdHMgb2Ygc3R1ZmYgaW4gdGhlIGdhbWVcbiNcbiMgQG1ldGhvZCAjYWRkZWQoKVxuIyAgIENhbGxlZCByaWdodCBiZWZvcmUgYmVpbmcgYWRkZWQgdG8gdGhlIGdhbWVcbiNcbiMgQG1ldGhvZCAjcmVuZGVyKClcbiMgICBDYWxsZWQgYmVmb3JlIHJlbmRlcmluZ1xuI1xuIyBAbWV0aG9kICN0aWNrKClcbiMgICBDYWxsZWQgcmlnaHQgYmVmb3JlIHBoeXNpY3NcbiNcbiMgQG1ldGhvZCAjYmVmb3JlVGljaygpXG4jICAgQ2FsbGVkIGJlZm9yZSBub3JtYWwgdGlja1xuI1xuIyBAbWV0aG9kICNhZnRlclRpY2soKVxuIyAgIENhbGxlZCBhZnRlciB1cGRhdGluZ1xuI1xuIyBAbWV0aG9kICNhZnRlckFkZGVkXG4jICAgQ2FsbGVkIGFmdGVyIGJlaW5nIGFkZGVkXG4jXG4jIEBtZXRob2QgI2Rlc3Ryb2VkKClcbiMgICBDYWxsZWQgYWZ0ZXIgYmVpbmcgcmVtb3ZlZCBmcm9tIHRoZSBnYW1lXG4jICAgXG5jbGFzcyBFbnRpdHlcbiAgZGVzdHJveTogKCkgPT5cbiAgICBAZ2FtZS5yZW1vdmVFbnRpdHkodGhpcylcblxuICAjIyMgT1BUSU9OQUwgUEFSQU1FVEVSUyAjIyNcbiAgIyBzcHJpdGUgW1BpeGkuRGlzcGxheU9iamVjdF1cbiAgIyAgIGFkZGVkIHRvIHJlbmRlcmVyIHdoZW4gYWRkZWQgdG8gZ2FtZS5cbiAgIyAgIERvIE5PVCBjaGFuZ2Ugb25jZSBhZGRlZCB0byBnYW1lXG5cbiAgIyBsYXllciBbUGl4aS5EaXNwbGF5T2JqZWN0XVxuICAjICAgcmVuZGVyZXIgbGF5ZXIgdG8gYWRkIHNwcml0ZSB0b1xuICAjICAgRG8gTk9UIGNoYW5nZSBvbmNlIGFkZGVkIHRvIGdhbWVcblxubW9kdWxlLmV4cG9ydHMgPSBFbnRpdHlcbiIsIkdhbWVSZW5kZXJlciA9IHJlcXVpcmUgJ0dhbWVSZW5kZXJlcidcbklPID0gcmVxdWlyZSAnSU8nXG5wMiA9IHJlcXVpcmUgJ3AyJ1xuXG4jIFRvcCBMZXZlbCBjb250cm9sIHN0cnVjdHVyZVxuY2xhc3MgR2FtZVxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICBAZW50aXRpZXMgPSB7XG4gICAgICBhbGw6IFtdXG4gICAgICByZW5kZXI6IFtdXG4gICAgICB0aWNrOiBbXVxuICAgICAgYmVmb3JlVGljazogW11cbiAgICAgIGFmdGVyVGljazogW11cbiAgICAgIHRvUmVtb3ZlOiBbXVxuICAgIH1cbiAgICBAcmVuZGVyZXIgPSBuZXcgR2FtZVJlbmRlcmVyKClcbiAgICBAY2FtZXJhID0gQHJlbmRlcmVyLmNhbWVyYVxuICAgIEB3b3JsZCA9IG5ldyBwMi5Xb3JsZCh7XG4gICAgICBncmF2aXR5OiBbMCwgMF1cbiAgICB9KVxuICAgIEBpbyA9IG5ldyBJTyhAcmVuZGVyZXIucGl4aVJlbmRlcmVyLnZpZXcpXG5cbiAgIyBCZWdpbiBldmVyeXRoaW5nXG4gIHN0YXJ0OiA9PlxuICAgIGNvbnNvbGUubG9nIFwiR2FtZSBTdGFydGVkXCJcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEBsb29wKVxuICBcbiAgbG9vcDogKCkgPT5cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEBsb29wKVxuICAgIEB0aWNrKClcbiAgICBAd29ybGQuc3RlcCgxIC8gNjApXG4gICAgQHJlbmRlcigpXG4gICAgQHJlbmRlcmVyLnJlbmRlcigpXG4gICAgQGFmdGVyVGljaygpXG5cbiAgIyBBZGQgYW4gZW50aXR5IHRvIHRoZSBnYW1lXG4gIGFkZEVudGl0eTogKGVudGl0eSkgPT5cbiAgICBlbnRpdHkuZ2FtZSA9IHRoaXNcbiAgICBpZiBlbnRpdHkuYWRkZWQ/IHRoZW4gZW50aXR5LmFkZGVkKHRoaXMpXG4gICAgQGVudGl0aWVzLmFsbC5wdXNoKGVudGl0eSlcbiAgICBpZiBlbnRpdHkucmVuZGVyPyB0aGVuIEBlbnRpdGllcy5yZW5kZXIucHVzaChlbnRpdHkpXG4gICAgaWYgZW50aXR5LmJlZm9yZVRpY2s/IHRoZW4gQGVudGl0aWVzLmJlZm9yZVRpY2sucHVzaChlbnRpdHkpXG4gICAgaWYgZW50aXR5LnRpY2s/IHRoZW4gQGVudGl0aWVzLnRpY2sucHVzaChlbnRpdHkpXG4gICAgaWYgZW50aXR5LmFmdGVyVGljaz8gdGhlbiBAZW50aXRpZXMuYWZ0ZXJUaWNrLnB1c2goZW50aXR5KVxuICAgIGlmIGVudGl0eS5zcHJpdGU/IHRoZW4gQHJlbmRlcmVyLmFkZChlbnRpdHkuc3ByaXRlLCBlbnRpdHkubGF5ZXIpXG4gICAgaWYgZW50aXR5LmJvZHk/IHRoZW4gQHdvcmxkLmFkZEJvZHkoZW50aXR5LmJvZHkpXG4gICAgXG4gICAgaWYgZW50aXR5Lm9uQ2xpY2s/IHRoZW4gQGlvLm9uKElPLkNMSUNLLCBlbnRpdHkub25DbGljaylcbiAgICBpZiBlbnRpdHkub25Nb3VzZURvd24/IHRoZW4gQGlvLm9uKElPLk1PVVNFX0RPV04sIGVudGl0eS5vbk1vdXNlRG93bilcbiAgICBpZiBlbnRpdHkub25Nb3VzZVVwPyB0aGVuIEBpby5vbihJTy5NT1VTRV9VUCwgZW50aXR5Lm9uTW91c2VVcClcbiAgICBpZiBlbnRpdHkub25SaWdodENsaWNrPyB0aGVuIEBpby5vbihJTy5SSUdIVF9DTElDSywgZW50aXR5Lm9uUmlnaHRDbGljaylcbiAgICBpZiBlbnRpdHkub25SaWdodERvd24/IHRoZW4gQGlvLm9uKElPLlJJR0hUX0RPV04sIGVudGl0eS5vblJpZ2h0RG93bilcbiAgICBpZiBlbnRpdHkub25SaWdodFVwPyB0aGVuIEBpby5vbihJTy5SSUdIVF9VUCwgZW50aXR5Lm9uUmlnaHRVcClcbiAgICBpZiBlbnRpdHkub25LZXlEb3duPyB0aGVuIEBpby5vbihJTy5LRVlfRE9XTiwgZW50aXR5Lm9uS2V5RG93bilcblxuICAgIGlmIGVudGl0eS5hZnRlckFkZGVkPyB0aGVuIGVudGl0eS5hZnRlckFkZGVkKHRoaXMpXG5cbiAgIyBTbGF0ZXMgYW4gZW50aXR5IGZvciByZW1vdmFsXG4gIHJlbW92ZUVudGl0eTogKGVudGl0eSkgPT5cbiAgICBAZW50aXRpZXMudG9SZW1vdmUucHVzaChlbnRpdHkpXG4gIFxuICAjIEFjdHVhbGx5IHJlbW92ZXMgcmVmZXJlbmNlcyB0byB0aGUgZW50aXRpZXMgc2xhdGVkIGZvciByZW1vdmFsXG4gIGNsZWFudXBFbnRpdGllczogPT5cbiAgICAjIFRPRE86IERvIHdlIHJlYWxseSBuZWVkIGEgc2VwYXJhdGUgcmVtb3ZhbCBwYXNzP1xuICAgIHdoaWxlIEBlbnRpdGllcy50b1JlbW92ZS5sZW5ndGhcbiAgICAgIGVudGl0eSA9IEBlbnRpdGllcy50b1JlbW92ZS5wb3AoKVxuICAgICAgQGVudGl0aWVzLmFsbC5zcGxpY2UoQGVudGl0aWVzLmFsbC5pbmRleE9mKGVudGl0eSksIDEpXG4gICAgICBpZiBlbnRpdHkucmVuZGVyP1xuICAgICAgICBAZW50aXRpZXMucmVuZGVyLnNwbGljZShAZW50aXRpZXMucmVuZGVyLmluZGV4T2YoZW50aXR5KSwgMSlcbiAgICAgIGlmIGVudGl0eS50aWNrP1xuICAgICAgICBAZW50aXRpZXMudGljay5zcGxpY2UoQGVudGl0aWVzLnRpY2suaW5kZXhPZihlbnRpdHkpLCAxKVxuICAgICAgaWYgZW50aXR5LmFmdGVyVGljaz9cbiAgICAgICAgQGVudGl0aWVzLmFmdGVyVGljay5zcGxpY2UoQGVudGl0aWVzLmFmdGVyVGljay5pbmRleE9mKGVudGl0eSksIDEpXG4gICAgICBcbiAgICAgIGlmIGVudGl0eS5zcHJpdGU/XG4gICAgICAgIEByZW5kZXJlci5yZW1vdmUoZW50aXR5LnNwcml0ZSwgZW50aXR5LmxheWVyKVxuICAgICAgaWYgZW50aXR5LmJvZHk/XG4gICAgICAgIEB3b3JsZC5yZW1vdmVCb2R5KGVudGl0eS5ib2R5KVxuXG4gICAgICBpZiBlbnRpdHkub25DbGljaz8gdGhlbiBAaW8ub2ZmKElPLkNMSUNLLCBlbnRpdHkub25DbGljaylcbiAgICAgIGlmIGVudGl0eS5vbk1vdXNlRG93bj8gdGhlbiBAaW8ub2ZmKElPLk1PVVNFX0RPV04sIGVudGl0eS5vbk1vdXNlRG93bilcbiAgICAgIGlmIGVudGl0eS5vbk1vdXNlVXA/IHRoZW4gQGlvLm9mZihJTy5NT1VTRV9VUCwgZW50aXR5Lm9uTW91c2VVcClcbiAgICAgIGlmIGVudGl0eS5vblJpZ2h0Q2xpY2s/IHRoZW4gQGlvLm9mZihJTy5SSUdIVF9DTElDSywgZW50aXR5Lm9uUmlnaHRDbGljaylcbiAgICAgIGlmIGVudGl0eS5vblJpZ2h0RG93bj8gdGhlbiBAaW8ub2ZmKElPLlJJR0hUX0RPV04sIGVudGl0eS5vblJpZ2h0RG93bilcbiAgICAgIGlmIGVudGl0eS5vblJpZ2h0VXA/IHRoZW4gQGlvLm9mZihJTy5SSUdIVF9VUCwgZW50aXR5Lm9uUmlnaHRVcClcbiAgICAgIGlmIGVudGl0eS5vbktleURvd24/IHRoZW4gQGlvLm9mZihJTy5LRVlfRE9XTiwgZW50aXR5Lm9uS2V5RG93bilcbiAgICAgIFxuICAgICAgaWYgZW50aXR5LmRlc3Ryb3llZD9cbiAgICAgICAgZW50aXR5LmRlc3Ryb3llZCh0aGlzKVxuICAgICAgZW50aXR5LmdhbWUgPSBudWxsXG5cbiAgIyBDYWxsZWQgYmVmb3JlIHBoeXNpY3NcbiAgdGljazogPT5cbiAgICBAY2xlYW51cEVudGl0aWVzKClcbiAgICBmb3IgZW50aXR5IGluIEBlbnRpdGllcy5iZWZvcmVUaWNrXG4gICAgICBlbnRpdHkuYmVmb3JlVGljaygpXG4gICAgQGNsZWFudXBFbnRpdGllcygpXG4gICAgZm9yIGVudGl0eSBpbiBAZW50aXRpZXMudGlja1xuICAgICAgZW50aXR5LnRpY2soKVxuXG4gICMgQ2FsbGVkIGFmdGVyIGV2ZXJ5dGhpbmdcbiAgYWZ0ZXJUaWNrOiA9PlxuICAgIEBjbGVhbnVwRW50aXRpZXMoKVxuICAgIGZvciBlbnRpdHkgaW4gQGVudGl0aWVzLmFmdGVyVGlja1xuICAgICAgZW50aXR5LmFmdGVyVGljaygpXG4gIFxuICAjIENhbGxlZCBiZWZvcmUgcmVuZGVyaW5nXG4gIHJlbmRlcjogPT5cbiAgICBAY2xlYW51cEVudGl0aWVzKClcbiAgICBmb3IgZW50aXR5IGluIEBlbnRpdGllcy5yZW5kZXJcbiAgICAgIGVudGl0eS5yZW5kZXIoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWUiLCJQaXhpID0gcmVxdWlyZSAncGl4aS5qcydcbkNhbWVyYSA9IHJlcXVpcmUgJ0NhbWVyYSdcblxuIyBUaGUgYmFzZSByZW5kZXJlci4gSGFuZGxlcyBsYXllcnMgYW5kIGNhbWVyYSBtb3ZlbWVudC5cbmNsYXNzIEdhbWVSZW5kZXJlclxuICBcbiAgIyBDcmVhdGUgYSBuZXcgR2FtZVJlbmRlcmVyXG4gIGNvbnN0cnVjdG9yOiAtPlxuICAgIFt3LCBoXSA9IFt3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0XVxuICAgIEBwaXhpUmVuZGVyZXIgPSBQaXhpLmF1dG9EZXRlY3RSZW5kZXJlcih3LCBoLCB7YW50aWFsaWFzOiBmYWxzZX0pXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChAcGl4aVJlbmRlcmVyLnZpZXcpXG4gICAgQHN0YWdlID0gbmV3IFBpeGkuQ29udGFpbmVyKClcbiAgICBAY2FtZXJhID0gbmV3IENhbWVyYSh0aGlzKVxuXG4gICAgQGxheWVySW5mb3MgPSB7fVxuICAgIEBsYXllckluZm9zWydtZW51J10gPSB7IHNjcm9sbDogMCB9XG4gICAgQGxheWVySW5mb3NbJ2h1ZCddID0geyBzY3JvbGw6IDAgfVxuICAgIEBsYXllckluZm9zWyd3b3JsZF9vdmVybGF5J10gPSB7IHNjcm9sbDogMSB9XG4gICAgQGxheWVySW5mb3NbJ3dvcmxkX2Zyb250J10gPSB7IHNjcm9sbDogMSB9XG4gICAgQGxheWVySW5mb3NbJ3dvcmxkJ10gPSB7IHNjcm9sbDogMSB9XG4gICAgQGxheWVySW5mb3NbJ3dvcmxkX2JhY2snXSA9IHsgc2Nyb2xsOiAxIH1cblxuICAgIG9yZGVyID0gWydtZW51JywgJ2h1ZCcsICd3b3JsZF9vdmVybGF5JywgJ3dvcmxkX2Zyb250JywgJ3dvcmxkJywgJ3dvcmxkX2JhY2snXVxuICAgIGZvciBuYW1lLCBpIGluIG9yZGVyXG4gICAgICBsYXllckluZm8gPSBAbGF5ZXJJbmZvc1tuYW1lXVxuICAgICAgbGF5ZXJJbmZvLm5hbWUgPSBuYW1lXG4gICAgICBsYXllciA9IG5ldyBQaXhpLkNvbnRhaW5lcigpXG4gICAgICBsYXllckluZm8uaW5kZXggPSBpXG4gICAgICBsYXllckluZm8ubGF5ZXIgPSBsYXllclxuICAgICAgQHN0YWdlLmFkZENoaWxkQXQobGF5ZXIsIGkpXG5cbiAgIyBSZW5kZXIgdGhlIGN1cnJlbnQgZnJhbWUuXG4gIHJlbmRlcjogKGVuZ2luZSkgPT5cbiAgICBAY2FtZXJhLnRpY2soKSAjIFRPRE86IFNob3VsZCB0aGlzIGJlIHNvbWV3aGVyZSBlbHNlP1xuICAgIGZvciBuYW1lLCBpbmZvIG9mIEBsYXllckluZm9zXG4gICAgICBAY2FtZXJhLnVwZGF0ZUxheWVyKGluZm8pXG4gICAgXG4gICAgQHBpeGlSZW5kZXJlci5yZW5kZXIoQHN0YWdlKVxuXG4gICMgQWRkIGEgY2hpbGQgdG8gYSBzcGVjaWZpYyBsYXllci5cbiAgYWRkOiAoc3ByaXRlLCBsYXllcj0nd29ybGQnKSA9PlxuICAgIEBsYXllckluZm9zW2xheWVyLnRvTG93ZXJDYXNlKCldLmxheWVyLmFkZENoaWxkKHNwcml0ZSlcblxuICAjIFJlbW92ZSBhIGNoaWxkIGZyb20gYSBzcGVjaWZpYyBsYXllci5cbiAgcmVtb3ZlOiAoc3ByaXRlLCBsYXllcj0nd29ybGQnKSA9PlxuICAgIEBsYXllckluZm9zW2xheWVyLnRvTG93ZXJDYXNlKCldLmxheWVyLnJlbW92ZUNoaWxkKHNwcml0ZSlcblxubW9kdWxlLmV4cG9ydHMgPSBHYW1lUmVuZGVyZXJcbiIsIlxuIyBNYW5hZ2VzIFxuY2xhc3MgSU9cbiAgQExNQiA9IExNQiA9IDBcbiAgQFJNQiA9IFJNQiA9IDJcbiAgQE1NQiA9IE1NQiA9IDFcblxuICBARVNDQVBFID0gMjdcbiAgQFNQQUNFID0gMzJcblxuICBATU9VU0VfTU9WRSA9IE1PVVNFX01PVkUgPSAnbW91c2Vtb3ZlJ1xuICBAQ0xJQ0sgPSBDTElDSyA9ICdjbGljaydcbiAgQFJJR0hUX0NMSUNLID0gUklHSFRfQ0xJQ0sgPSAncmlnaHRjbGljaydcbiAgQFJJR0hUX1VQID0gUklHSFRfVVAgPSAncmlnaHR1cCdcbiAgQFJJR0hUX0RPV04gPSBSSUdIVF9ET1dOID0gJ3JpZ2h0ZG93bidcbiAgQE1PVVNFX1VQID0gTU9VU0VfVVAgPSAnbW91c2V1cCdcbiAgQE1PVVNFX0RPV04gPSBNT1VTRV9ET1dOID0gJ21vdXNlZG93bidcbiAgQE1PVVNFX01PVkUgPSBNT1VTRV9NT1ZFID0gJ21vdXNlbW92ZSdcbiAgQEtFWV9ET1dOID0gS0VZX0RPV04gPSAna2V5ZG93bidcbiAgQEtFWV9VUCA9IEtFWV9VUCA9ICdrZXl1cCdcblxuICBjb25zdHJ1Y3RvcjogKEB2aWV3KSAtPlxuICAgIEB2aWV3Lm9uY2xpY2sgPSBAY2xpY2tcbiAgICBAdmlldy5vbm1vdXNlZG93biA9IEBtb3VzZWRvd25cbiAgICBAdmlldy5vbm1vdXNldXAgPSBAbW91c2V1cFxuICAgIEB2aWV3Lm9ubW91c2Vtb3ZlID0gQG1vdXNlbW92ZVxuICAgIEB2aWV3Lm9ubW91c2Vtb3ZlID0gQG1vdXNlbW92ZVxuICAgIGRvY3VtZW50Lm9ua2V5ZG93biA9IEBrZXlkb3duXG4gICAgZG9jdW1lbnQub25rZXl1cCA9IEBrZXl1cFxuICAgIEB2aWV3Lm9uY29udGV4dG1lbnUgPSAoZSkgPT5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgQGNsaWNrKGUpXG4gICAgICBmYWxzZVxuXG4gICAgQGtleXMgPSBbXVxuICAgIGZvciBpIGluIFswLi4yNTZdXG4gICAgICBAa2V5cy5wdXNoKGZhbHNlKVxuXG4gICAgQG1vdXNlUG9zaXRpb24gPSBbMCwgMF1cblxuICAgIEBjYWxsYmFja3MgPSB7fVxuICAgIEBjYWxsYmFja3NbQ0xJQ0tdID0gW11cbiAgICBAY2FsbGJhY2tzW1JJR0hUX0NMSUNLXSA9IFtdXG4gICAgQGNhbGxiYWNrc1tSSUdIVF9VUF0gPSBbXVxuICAgIEBjYWxsYmFja3NbUklHSFRfRE9XTl0gPSBbXVxuICAgIEBjYWxsYmFja3NbTU9VU0VfVVBdID0gW11cbiAgICBAY2FsbGJhY2tzW01PVVNFX0RPV05dID0gW11cbiAgICBAY2FsbGJhY2tzW01PVVNFX01PVkVdID0gW11cbiAgICBAY2FsbGJhY2tzW0tFWV9ET1dOXSA9IFtdXG4gICAgQGNhbGxiYWNrc1tLRVlfVVBdID0gW11cblxuICAgIEBidXR0b25zID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSAsZmFsc2VdXG5cbiAgIyBBZGQgYW4gZXZlbnQgaGFuZGxlclxuICBvbjogKGUsIGNhbGxiYWNrKSA9PlxuICAgIEBjYWxsYmFja3NbZV0gPz0gW11cbiAgICBAY2FsbGJhY2tzW2VdLnB1c2goY2FsbGJhY2spXG5cbiAgIyBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlclxuICBvZmY6IChlLCBjYWxsYmFjaykgPT5cbiAgICBAY2FsbGJhY2tzW2VdLnNwbGljZShAY2FsbGJhY2tzW2VdLmluZGV4T2YoY2FsbGJhY2spLCAxKVxuXG4gICMgVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgbW91c2Vtb3ZlOiAoZSkgPT5cbiAgICBAbW91c2VQb3NpdGlvbiA9IFtlLmNsaWVudFgsIGUuY2xpZW50WV1cbiAgICBmb3IgY2FsbGJhY2sgaW4gQGNhbGxiYWNrc1tNT1VTRV9NT1ZFXVxuICAgICAgY2FsbGJhY2soQG1vdXNlUG9zaXRpb24pXG5cbiAgIyBDYWxsIGFsbCBjbGljayBoYW5kbGVyc1xuICBjbGljazogKGUpID0+XG4gICAgQG1vdXNlUG9zaXRpb24gPSBbZS5jbGllbnRYLCBlLmNsaWVudFldXG4gICAgc3dpdGNoIGUuYnV0dG9uXG4gICAgICB3aGVuIExNQlxuICAgICAgICBmb3IgY2FsbGJhY2sgaW4gQGNhbGxiYWNrc1tDTElDS11cbiAgICAgICAgICBjYWxsYmFjayhAbW91c2VQb3NpdGlvbilcbiAgICAgIHdoZW4gUk1CXG4gICAgICAgIGZvciBjYWxsYmFjayBpbiBAY2FsbGJhY2tzW1JJR0hUX0NMSUNLXVxuICAgICAgICAgIGNhbGxiYWNrKEBtb3VzZVBvc2l0aW9uKVxuXG4gICMgQ2FsbCBhbGwgbW91c2Vkb3duIGhhbmRsZXJzXG4gIG1vdXNlZG93bjogKGUpID0+XG4gICAgQG1vdXNlUG9zaXRpb24gPSBbZS5jbGllbnRYLCBlLmNsaWVudFldXG4gICAgQGJ1dHRvbnNbZS5idXR0b25dID0gdHJ1ZVxuICAgIHN3aXRjaCBlLmJ1dHRvblxuICAgICAgd2hlbiBMTUJcbiAgICAgICAgZm9yIGNhbGxiYWNrIGluIEBjYWxsYmFja3NbTU9VU0VfVVBdXG4gICAgICAgICAgY2FsbGJhY2soQG1vdXNlUG9zaXRpb24pXG4gICAgICB3aGVuIFJNQlxuICAgICAgICBmb3IgY2FsbGJhY2sgaW4gQGNhbGxiYWNrc1tSSUdIVF9VUF1cbiAgICAgICAgICBjYWxsYmFjayhAbW91c2VQb3NpdGlvbilcblxuICAjIENhbGwgYWxsIG1vdXNldXAgaGFuZGxlcnNcbiAgbW91c2V1cDogKGUpID0+XG4gICAgQG1vdXNlUG9zaXRpb24gPSBbZS5jbGllbnRYLCBlLmNsaWVudFldXG4gICAgQGJ1dHRvbnNbZS5idXR0b25dID0gZmFsc2VcbiAgICBzd2l0Y2ggZS5idXR0b25cbiAgICAgIHdoZW4gTE1CXG4gICAgICAgIGZvciBjYWxsYmFjayBpbiBAY2FsbGJhY2tzW01PVVNFX0RPV05dXG4gICAgICAgICAgY2FsbGJhY2soQG1vdXNlUG9zaXRpb24pXG4gICAgICB3aGVuIFJNQlxuICAgICAgICBmb3IgY2FsbGJhY2sgaW4gQGNhbGxiYWNrc1tSSUdIVF9ET1dOXVxuICAgICAgICAgIGNhbGxiYWNrKEBtb3VzZVBvc2l0aW9uKVxuXG4gICMgSGFuZGxlIGtleSBkb3duXG4gIGtleWRvd246IChlKSA9PlxuICAgIGtleSA9IGUud2hpY2hcbiAgICB3YXNQcmVzc2VkID0gQGtleXNba2V5XVxuICAgIEBrZXlzW2tleV0gPSB0cnVlXG4gICAgaWYgbm90IHdhc1ByZXNzZWRcbiAgICAgIGZvciBjYWxsYmFjayBpbiBAY2FsbGJhY2tzW0tFWV9ET1dOXVxuICAgICAgICBjYWxsYmFjayhrZXkpXG5cbiAgIyBIYW5kbGUga2V5IHVwXG4gIGtleXVwOiAoZSkgPT5cbiAgICBrZXkgPSBlLndoaWNoXG4gICAgQGtleXNba2V5XSA9IGZhbHNlXG4gICAgZm9yIGNhbGxiYWNrIGluIEBjYWxsYmFja3NbS0VZX1VQXVxuICAgICAgY2FsbGJhY2soa2V5KVxuXG5cbm1vZHVsZS5leHBvcnRzID0gSU8iLCJDb2xsaXNpb25Hcm91cHMgPSByZXF1aXJlICdDb2xsaXNpb25Hcm91cHMnXG5FbnRpdHkgPSByZXF1aXJlICdFbnRpdHknXG5wMiA9IHJlcXVpcmUgJ3AyJ1xuUGl4aSA9IHJlcXVpcmUgJ3BpeGkuanMnXG5cbiMgQSBwZXJzb25cbmNsYXNzIFBlcnNvbiBleHRlbmRzIEVudGl0eVxuICBSQURJVVMgPSAwLjFcbiAgV0FMS19GT1JDRSA9IDVcbiAgSkVUUEFDS19GT1JDRSA9IDAuM1xuICBNQVhJTVVNX0ZSSUNUSU9OID0gMTBcblxuICBjb25zdHJ1Y3RvcjogKHg9MCwgeT0wLCBzaGlwPW51bGwpIC0+XG4gICAgQGJvZHkgPSBuZXcgcDIuQm9keSh7XG4gICAgICBwb3NpdGlvbjogW3gsIHldXG4gICAgICBtYXNzOiAwLjFcbiAgICAgIGFuZ3VsYXJEYW1waW5nOiAwLjAxXG4gICAgICBkYW1waW5nOiAwXG4gICAgfSlcbiAgICBzaGFwZSA9IG5ldyBwMi5DaXJjbGUoUkFESVVTKVxuICAgIHNoYXBlLmNvbGxpc2lvbkdyb3VwID0gQ29sbGlzaW9uR3JvdXBzLlBFUlNPTlxuICAgIHNoYXBlLmNvbGxpc2lvbk1hc2sgPSBDb2xsaXNpb25Hcm91cHMuT0JTVEFDTEVTXG4gICAgQGJvZHkuYWRkU2hhcGUoc2hhcGUpXG5cbiAgICBAc3ByaXRlID0gbmV3IFBpeGkuR3JhcGhpY3MoKVxuICAgIEBzcHJpdGUuYmVnaW5GaWxsKDB4MDBGRjAwKVxuICAgIEBzcHJpdGUuZHJhd0NpcmNsZSgwLCAwLCBSQURJVVMpXG4gICAgQHNwcml0ZS5lbmRGaWxsKClcblxuICAgIEBib2FyZChzaGlwKVxuXG4gIEBwcm9wZXJ0eSAncG9zaXRpb24nLFxuICAgIGdldDogLT5cbiAgICAgIHJldHVybiBAYm9keS5wb3NpdGlvblxuXG4gIGJvYXJkOiAoc2hpcCkgPT5cbiAgICBAc2hpcCA9IHNoaXBcbiAgICBpZiBzaGlwP1xuICAgICAgQHNoaXBQb3NpdGlvbiA9IEBzaGlwLndvcmxkVG9Mb2NhbChAYm9keS5wb3NpdGlvbilcbiAgICBlbHNlXG4gICAgICBAc2hpcFBvc2l0aW9uID0gbnVsbFxuXG4gIG1vdmU6IChbeCwgeV0pID0+XG4gICAgc3BlZWQgPSBpZiBAc2hpcD8gdGhlbiBXQUxLX0ZPUkNFIGVsc2UgSkVUUEFDS19GT1JDRVxuICAgIEBib2R5LmZvcmNlWzBdICs9IHggKiBzcGVlZFxuICAgIEBib2R5LmZvcmNlWzFdICs9IHkgKiBzcGVlZFxuXG4gIHJlbmRlcjogKCkgPT5cbiAgICBbQHNwcml0ZS54LCBAc3ByaXRlLnldID0gQGJvZHkucG9zaXRpb25cblxuICB0aWNrOiAoKSA9PlxuICAgIGlmIEBzaGlwP1xuICAgICAgc2hpcFZlbG9jaXR5ID0gQHNoaXAudmVsb2NpdHlBdFdvcmxkUG9pbnQoQHBvc2l0aW9uKVxuXG4gICAgICBkeCA9IHNoaXBWZWxvY2l0eVswXSAtIEBib2R5LnZlbG9jaXR5WzBdXG4gICAgICBkeSA9IHNoaXBWZWxvY2l0eVsxXSAtIEBib2R5LnZlbG9jaXR5WzFdXG5cbiAgICAgIGR4ICo9IDAuNVxuICAgICAgZHkgKj0gMC41XG5cbiAgICAgIG1hZ25pdHVkZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbiAgICAgIGlmIG1hZ25pdHVkZSA+IE1BWElNVU1fRlJJQ1RJT05cbiAgICAgICAgZHggKj0gTUFYSU1VTV9GUklDVElPTiAvIG1hZ25pdHVkZVxuICAgICAgICBkeSAqPSBNQVhJTVVNX0ZSSUNUSU9OIC8gbWFnbml0dWRlXG5cbiAgICAgIEBib2R5LmZvcmNlWzBdICs9IGR4IC8gQGJvZHkubWFzc1xuICAgICAgQGJvZHkuZm9yY2VbMV0gKz0gZHkgLyBAYm9keS5tYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gUGVyc29uXG4iLCJFbnRpdHkgPSByZXF1aXJlICdFbnRpdHknXG5cbmNsYXNzIFBsYXllclBlcnNvbkNvbnRyb2xsZXIgZXh0ZW5kcyBFbnRpdHlcbiAgS19GT1JXQVJEID0gODcgIyB3XG4gIEtfQkFDS1dBUkQgPSA4MyAjIHNcbiAgS19MRUZUID0gNjUgIyBhXG4gIEtfUklHSFQgPSA2OCAjIGRcbiAgS19XQUxLID0gMTYgIyBzaGlmdFxuICBcbiAgY29uc3RydWN0b3I6IChAcGVyc29uKSAtPlxuXG4gIGJlZm9yZVRpY2s6ICgpID0+XG4gICAgbW9kaWZpZXIgPSBpZiBAZ2FtZS5pby5rZXlzW0tfV0FMS10gdGhlbiAwLjQgZWxzZSAxXG4gICAgeCA9IChAZ2FtZS5pby5rZXlzW0tfUklHSFRdIC0gQGdhbWUuaW8ua2V5c1tLX0xFRlRdKSAqIG1vZGlmaWVyXG4gICAgeSA9IC0oQGdhbWUuaW8ua2V5c1tLX0ZPUldBUkRdIC0gQGdhbWUuaW8ua2V5c1tLX0JBQ0tXQVJEXSkgKiBtb2RpZmllclxuICAgIEBwZXJzb24ubW92ZShbeCwgeV0pXG5cblxubW9kdWxlLmV4cG9ydHMgPSBQbGF5ZXJQZXJzb25Db250cm9sbGVyIiwiRW50aXR5ID0gcmVxdWlyZSAnRW50aXR5J1xuVXRpbCA9IHJlcXVpcmUgJ3V0aWwvVXRpbCdcblxubm9ybWFsaXplID0gKHZhbHVlKSAtPlxuICBlcHNpbG9uID0gMC4wNVxuICBpZiB2YWx1ZSA+IGVwc2lsb25cbiAgICByZXR1cm4gdmFsdWUgLSBlcHNpbG9uXG4gIGlmIHZhbHVlIDwgLTEgKiBlcHNpbG9uXG4gICAgcmV0dXJuIHZhbHVlICsgZXBzaWxvblxuICByZXR1cm4gMFxuXG4jIENvbnRyb2xzIGEgc2hpcFxuY2xhc3MgUGxheWVyU2hpcENvbnRyb2xsZXIgZXh0ZW5kcyBFbnRpdHlcbiAgS19GT1JXQVJEID0gODcgIyB3XG4gIEtfQkFDS1dBUkQgPSA4MyAjIHNcbiAgS19MRUZUID0gNjUgIyBhXG4gIEtfUklHSFQgPSA2OCAjIGRcbiAgS19UVVJOX0xFRlQgPSA4MSAjIHFcbiAgS19UVVJOX1JJR0hUID0gNjkgIyBlXG4gIEtfU1RBQklMSVpFID0gMTYgIyBzaGlmdFxuXG4gIGNvbnN0cnVjdG9yOiAoQHNoaXApIC0+XG5cblxuICBiZWZvcmVUaWNrOiAoKSA9PlxuICAgIGZvcndhcmQgPSBAZ2FtZS5pby5rZXlzW0tfRk9SV0FSRF0gLSBAZ2FtZS5pby5rZXlzW0tfQkFDS1dBUkRdXG4gICAgc2lkZSA9IEBnYW1lLmlvLmtleXNbS19SSUdIVF0gLSBAZ2FtZS5pby5rZXlzW0tfTEVGVF1cbiAgICB0dXJuID0gQGdhbWUuaW8ua2V5c1tLX1RVUk5fUklHSFRdIC0gQGdhbWUuaW8ua2V5c1tLX1RVUk5fTEVGVF1cbiAgICBcbiAgICBpZiBAZ2FtZS5pby5rZXlzW0tfU1RBQklMSVpFXVxuICAgICAgdHVybiArPSBVdGlsLmNsYW1wKC1Ac2hpcC5ib2R5LmFuZ3VsYXJWZWxvY2l0eSAqIDIpXG4gICAgICAjIFRPRE86IExpbmVhciBTdGFiaWxpemF0aW9uXG5cbiAgICAjIGdhbWVwYWQgPSBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKVswXVxuICAgICMgaWYgZ2FtZXBhZD9cbiAgICAjICAgY29uc29sZS5sb2cgZ2FtZXBhZFxuICAgICMgICBzaWRlICs9IG5vcm1hbGl6ZShnYW1lcGFkLmF4ZXNbMF0pICNsZWZ0IHhcbiAgICAjICAgZm9yd2FyZCArPSAtbm9ybWFsaXplKGdhbWVwYWQuYXhlc1sxXSkgI2xlZnQgeVxuICAgICMgICB0dXJuICs9IG5vcm1hbGl6ZShnYW1lcGFkLmF4ZXNbMl0pICNyaWdodCB4XG4gICAgIyAgICMgZ2FtZXBhZC5heGVzWzNdICNyaWdodCB5XG5cbiAgICBmb3J3YXJkID0gVXRpbC5jbGFtcChmb3J3YXJkKVxuICAgIHNpZGUgPSBVdGlsLmNsYW1wKHNpZGUpXG4gICAgdHVybiA9IFV0aWwuY2xhbXAodHVybilcblxuICAgIEBzaGlwLnRocnVzdEJhbGFuY2VyLmJhbGFuY2UoZm9yd2FyZCwgc2lkZSwgdHVybilcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYXllclNoaXBDb250cm9sbGVyIiwiRW50aXR5ID0gcmVxdWlyZSAnRW50aXR5J1xuUGl4aSA9IHJlcXVpcmUgJ3BpeGkuanMnXG5cbiMgVGhlIEhVRCBkcmF3biB3aGlsZSBpbiBhIHNoaXBcbmNsYXNzIFNoaXBIdWQgZXh0ZW5kcyBFbnRpdHlcbiAgY29uc3RydWN0b3I6IChAc2hpcCkgLT5cbiAgICBAc3ByaXRlID0gbmV3IFBpeGkuQ29udGFpbmVyKClcbiAgICBAbGF5ZXIgPSAnaHVkJ1xuICAgIEB0ZXh0ID0gbmV3IFBpeGkuVGV4dCgnJywge1xuICAgICAgZm9udDogJzIwcHggQXJpYWwnXG4gICAgICBmaWxsOiAnI0ZGRkZGRidcbiAgICB9KVxuICAgIEBzcHJpdGUuYWRkQ2hpbGQoQHRleHQpXG5cbiAgYWRkZWQ6ICgpID0+XG4gICAgY29uc29sZS5sb2cgJ2FkZGVkJ1xuXG4gICMgTWFrZSB0aGUgc3RyaW5nIHRvIGJlIGRpc3BsYXllZCBieSB0aGUgaHVkXG4gIG1ha2VUZXh0OiAoKSA9PlxuICAgIHZlbG9jaXR5ID0gQHNoaXAuYm9keS52ZWxvY2l0eVxuICAgIHhzcGVlZCA9IE1hdGgucm91bmQodmVsb2NpdHlbMF0pXG4gICAgeXNwZWVkID0gTWF0aC5yb3VuZCh2ZWxvY2l0eVsxXSlcbiAgICByZXR1cm4gXCJWZWxvY2l0eTogPCN7eHNwZWVkfSwgI3t5c3BlZWR9PlwiXG5cbiAgcmVuZGVyOiA9PlxuICAgIEB0ZXh0LnRleHQgPSBAbWFrZVRleHQoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoaXBIdWQiLCJDb3JlID0gcmVxdWlyZSAnc2hpcC9Db3JlJ1xuRW50aXR5ID0gcmVxdWlyZSAnRW50aXR5J1xuR3JpZCA9IHJlcXVpcmUgJ3V0aWwvR3JpZCdcblBpeGkgPSByZXF1aXJlICdwaXhpLmpzJ1xuXG4jIEEgYmx1ZXByaW50IGZvciB0aGUgbGF5b3V0IG9mIHBhcnRzIG9uIGEgc2hpcFxuY2xhc3MgQmx1ZXByaW50IGV4dGVuZHMgRW50aXR5XG4gIEJBU0VfTUFTUyA9IDAuMVxuXG4gIGNvbnN0cnVjdG9yOiAoeCA9IDAsIHkgPSAwKSAtPlxuICAgIEBzcHJpdGUgPSBuZXcgUGl4aS5HcmFwaGljcygpXG4gICAgQGxheWVyID0gJ3dvcmxkJ1xuICAgIEBwYXJ0cyA9IFtdXG4gICAgQHBhcnRHcmlkID0gbmV3IEdyaWQoKVxuICAgIEBjb3JlID0gQGFkZFBhcnQobmV3IENvcmUoKSlcblxuICAjIEFkZCBhIFBhcnQgdG8gdGhpcyBibHVlcHJpbnRcbiAgYWRkUGFydDogKHBhcnQpID0+XG4gICAgQHBhcnRzLnB1c2gocGFydClcbiAgICBhbmdsZSA9IGlmIHBhcnQuZGlyZWN0aW9uPyB0aGVuIE1hdGguUEkgLyAyICogcGFydC5kaXJlY3Rpb24gZWxzZSAwXG4gICAgaWYgcGFydC5zcHJpdGU/XG4gICAgICBAc3ByaXRlLmFkZENoaWxkKHBhcnQuc3ByaXRlKVxuXG4gICAgQHBhcnRHcmlkLnNldChbcGFydC54LCBwYXJ0LnldLCBwYXJ0KVxuICAgIHJldHVybiBwYXJ0XG4gIFxuICAjIFRha2UgYSBwYXJ0IG9mZiB0aGlzIGJsdWVwcmludFxuICByZW1vdmVQYXJ0OiAocGFydCkgPT5cbiAgICBAcGFydHMuc3BsaWNlKEBwYXJ0cy5pbmRleE9mKHBhcnQpLCAxKVxuICAgIGlmIHBhcnQuc3ByaXRlP1xuICAgICAgQHNwcml0ZS5yZW1vdmVDaGlsZChwYXJ0LnNwcml0ZSlcbiAgICBcbiAgICBAcGFydEdyaWQucmVtb3ZlKFtwYXJ0LngsIHBhcnQueV0pXG5cbiAgICByZXR1cm4gcGFydFxuXG5tb2R1bGUuZXhwb3J0cyA9IEJsdWVwcmludCIsIlBhcnQgPSByZXF1aXJlICdzaGlwL1BhcnQnXG5cbiMgVGhlIGNvcmUgb2YgZXZlcnkgc2hpcC4gVGhpcyBzaG91bGQgbmV2ZXIgYmUgZGVzdHJveWVkLlxuY2xhc3MgQ29yZSBleHRlbmRzIFBhcnRcbiAgQHR5cGUgPSB0eXBlID0gbmV3IFBhcnQuVHlwZSgnQ29yZScsIDEsIDEsIDB4NTVBQUZGLCAxMDAwKVxuICBcbiAgY29uc3RydWN0b3I6ICh4PTAsIHk9MCkgLT5cbiAgICBzdXBlcih4LCB5LCB0eXBlKVxuXG4gIGNsb25lOiAoKSA9PlxuICAgIHJldHVybiBuZXcgQ29yZShAeCwgQHkpXG5cbm1vZHVsZS5leHBvcnRzID0gQ29yZSIsIlBhcnQgPSByZXF1aXJlICdzaGlwL1BhcnQnXG5cbiMgQmFzaWMgYnVpbGRpbmcgYmxvY2tcbmNsYXNzIEh1bGwgZXh0ZW5kcyBQYXJ0XG4gIEB0eXBlID0gdHlwZSA9IG5ldyBQYXJ0LlR5cGUoJ0h1bGwnLCAxLCAxLCAweEJCQkJCQiwgMzAwKVxuICBcbiAgY29uc3RydWN0b3I6ICh4LCB5KSAtPlxuICAgIHN1cGVyKHgsIHksIHR5cGUpXG5cbiAgY2xvbmU6ICgpID0+XG4gICAgcmV0dXJuIG5ldyBIdWxsKEB4LCBAeSlcblxubW9kdWxlLmV4cG9ydHMgPSBIdWxsIiwiUGFydCA9IHJlcXVpcmUgXCJzaGlwL1BhcnRcIlxuXG4jIEJhc2ljIGludGVyaW9yIGJsb2NrXG5jbGFzcyBJbnRlcmlvciBleHRlbmRzIFBhcnRcbiAgQHR5cGUgPSB0eXBlID0gbmV3IFBhcnQuVHlwZSgnSW50ZXJpb3InLCAxLCAxLCAweERERERERCwgODApXG4gIHR5cGUuaW50ZXJpb3IgPSB0cnVlXG5cbiAgY29uc3RydWN0b3I6ICh4LCB5KSAtPlxuICAgIHN1cGVyKHgsIHksIHR5cGUpXG5cbiAgY2xvbmU6ICgpID0+XG4gICAgcmV0dXJuIG5ldyBJbnRlcmlvcihAeCwgQHkpXG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJpb3JcbiIsInAyID0gcmVxdWlyZSAncDInXG5QaXhpID0gcmVxdWlyZSAncGl4aS5qcydcbkNvbGxpc2lvbkdyb3VwcyA9IHJlcXVpcmUgJ0NvbGxpc2lvbkdyb3VwcydcblxuIyBCYXNlIGNsYXNzIGZvciBhbGwgc2hpcCBwYXJ0c1xuY2xhc3MgUGFydFxuICBjb25zdHJ1Y3RvcjogKEB4LCBAeSwgQHR5cGUpIC0+XG4gICAgQHNoYXBlID0gQG1ha2VTaGFwZSgpXG4gICAgQHNoYXBlLm93bmVyID0gdGhpc1xuICAgIEBzcHJpdGUgPSBAbWFrZVNwcml0ZSgpXG4gICAgQHNwcml0ZS54ID0gQHhcbiAgICBAc3ByaXRlLnkgPSBAeVxuICAgIEBoZWFsdGggPSBAbWF4SGVhbHRoXG5cbiAgIyBFeHBvc2UgZmllbGRzIGZyb20gdGhlIHR5cGVcbiAgWydtYXNzJywgJ3dpZHRoJywgJ2hlaWdodCcsICdtYXhIZWFsdGgnXS5mb3JFYWNoIChmaWVsZCkgLT5cbiAgICBQYXJ0LnByb3BlcnR5IGZpZWxkLFxuICAgICAgZ2V0OiAtPlxuICAgICAgICByZXR1cm4gQHR5cGVbZmllbGRdXG4gIFxuICBtYWtlU2hhcGU6ICgpID0+XG4gICAgc2hhcGUgPSBuZXcgcDIuUmVjdGFuZ2xlKEB3aWR0aCwgQGhlaWdodClcbiAgICBpZiBAdHlwZS5pbnRlcmlvclxuICAgICAgY29uc29sZS5sb2cgXCJpbnRlcmlvciBwYXJ0XCJcbiAgICAgIHNoYXBlLmNvbGxpc2lvbkdyb3VwID0gQ29sbGlzaW9uR3JvdXBzLlNISVBfSU5URVJJT1JcbiAgICBlbHNlXG4gICAgICBjb25zb2xlLmxvZyBcImV4dGVyaW9yIHBhcnRcIlxuICAgICAgc2hhcGUuY29sbGlzaW9uR3JvdXAgPSBDb2xsaXNpb25Hcm91cHMuU0hJUF9FWFRFUklPUlxuICAgIHNoYXBlLmNvbGxpc2lvbk1hc2sgPSBDb2xsaXNpb25Hcm91cHMuQUxMXG4gICAgcmV0dXJuIHNoYXBlXG5cbiAgbWFrZVNwcml0ZTogKCkgPT5cbiAgICBzcHJpdGUgPSBuZXcgUGl4aS5HcmFwaGljcygpXG4gICAgc3ByaXRlLmJlZ2luRmlsbChAdHlwZS5jb2xvcilcbiAgICBzcHJpdGUuZHJhd1JlY3QoLTAuNSAqIEB3aWR0aCwgLTAuNSAqIEBoZWlnaHQsIEB3aWR0aCwgQGhlaWdodClcbiAgICBzcHJpdGUuZW5kRmlsbCgpXG4gICAgcmV0dXJuIHNwcml0ZVxuXG4gIGNsb25lOiAoKSA9PlxuICAgIHJldHVybiBuZXcgUGFydChAeCwgQHksIEB0eXBlKVxuXG4gIHRvU3RyaW5nOiAoKSA9PlxuICAgIHJldHVybiBcIjwje0B0eXBlfSBhdCAoI3tAeH0sI3tAeX0pPlwiXG5cblxuIyBDb250YWlucyBkYXRhIGFib3V0IGFsbCBwYXJ0cyBvZiB0aGUgc2FtZSB0eXBlXG4jIFRPRE86IFJlZmFjdG9yIHRoaXMgc28gdGhhdCBhIHNlcGFyYXRlIFR5cGUgY2xhc3MgaXMgbm90IG5lZWRlZC5cbmNsYXNzIFBhcnQuVHlwZVxuICBjb25zdHJ1Y3RvcjogKEBuYW1lLCBAd2lkdGg9MSwgQGhlaWdodD0xLCBAY29sb3I9MHhCQkJCQkIsIEBtYXhIZWFsdGg9MTAwKSAtPlxuICAgIEBtYXNzID0gQHdpZHRoICogQGhlaWdodFxuXG4gIHRvU3RyaW5nOiAoKSA9PlxuICAgIHJldHVybiBAbmFtZVxuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFydCIsIkJsdWVwcmludCA9IHJlcXVpcmUgJ3NoaXAvQmx1ZXByaW50J1xuRW50aXR5ID0gcmVxdWlyZSAnRW50aXR5J1xuSHVsbCA9IHJlcXVpcmUgJ3NoaXAvSHVsbCdcbnAyID0gcmVxdWlyZSAncDInXG5QaXhpID0gcmVxdWlyZSAncGl4aS5qcydcblRocnVzdEJhbGFuY2VyID0gcmVxdWlyZSAnc2hpcC9UaHJ1c3RCYWxhbmNlcidcblRocnVzdGVyID0gcmVxdWlyZSAnc2hpcC9UaHJ1c3RlcidcblV0aWwgPSByZXF1aXJlICd1dGlsL1V0aWwnXG5cbiMgQSBzcGFjZSBzaGlwXG5jbGFzcyBTaGlwIGV4dGVuZHMgRW50aXR5XG4gIEJBU0VfTUFTUyA9IDAuMVxuXG4gIGNvbnN0cnVjdG9yOiAoQGJsdWVwcmludCwgeCA9IDAsIHkgPSAwKSAtPlxuICAgIEBibHVlcHJpbnQgPz0gbmV3IEJsdWVwcmludCgpXG4gICAgQHNwcml0ZSA9IG5ldyBQaXhpLkdyYXBoaWNzKClcbiAgICBAbGF5ZXIgPSAnd29ybGQnXG4gICAgQHBhcnRzID0gW11cbiAgICAjIFRPRE86IFBhcnRzIEdyaWQgLSBwYXJ0IGxvY2F0aW9uc1xuICAgICMgVE9ETzogUGFydCBjb25uZWN0aW9uc1xuICAgIEB0aWNrYWJsZVBhcnRzID0gW11cbiAgICBAdGhydXN0QmFsYW5jZXIgPSBuZXcgVGhydXN0QmFsYW5jZXIodGhpcylcblxuICAgICMgbG9jYWwgdmVjdG9yIGZyb20gY2VudGVyIG9mIG1hc3MgdG8gY2VudGVyIG9mIGdyaWRcbiAgICBAb2Zmc2V0ID0gWzAsIDBdXG5cbiAgICBAYm9keSA9IG5ldyBwMi5Cb2R5KHtcbiAgICAgIHBvc2l0aW9uOiBbeCwgeV1cbiAgICAgIG1hc3M6IEJBU0VfTUFTU1xuICAgICAgYW5ndWxhckRhbXBpbmc6IDAuMDFcbiAgICAgIGRhbXBpbmc6IDAuMFxuICAgIH0pXG5cbiAgICBmb3IgcGFydCBpbiBAYmx1ZXByaW50LnBhcnRzXG4gICAgICBAYWRkUGFydChwYXJ0LmNsb25lKCkpXG5cbiAgQHByb3BlcnR5ICdwb3NpdGlvbicsXG4gICAgZ2V0OiAtPlxuICAgICAgcmV0dXJuIEBib2R5LnBvc2l0aW9uXG4gIFxuICByZW5kZXI6ICgpID0+XG4gICAgQHNwcml0ZS5jbGVhcigpXG4gICAgQHNwcml0ZS5iZWdpbkZpbGwoMHgwMEZGRkYpXG4gICAgQHNwcml0ZS5kcmF3Q2lyY2xlKC1Ab2Zmc2V0WzBdLCAtQG9mZnNldFsxXSwgMC4xKVxuICAgIEBzcHJpdGUuZW5kRmlsbCgpXG5cbiAgICBbQHNwcml0ZS54LCBAc3ByaXRlLnldID0gQGdyaWRUb1dvcmxkKFswLCAwXSlcbiAgICBAc3ByaXRlLnJvdGF0aW9uID0gQGJvZHkuYW5nbGVcblxuICB0aWNrOiAoKSA9PlxuICAgIGZvciBwYXJ0IGluIEB0aWNrYWJsZVBhcnRzXG4gICAgICBwYXJ0LnRpY2sodGhpcylcblxuICAjIEFkZCBhIFBhcnQgdG8gdGhpcyBzaGlwXG4gIGFkZFBhcnQ6IChwYXJ0KSA9PlxuICAgIEBwYXJ0cy5wdXNoKHBhcnQpXG4gICAgaWYgcGFydC50aWNrP1xuICAgICAgQHRpY2thYmxlUGFydHMucHVzaChwYXJ0KVxuICAgIFxuICAgIGFuZ2xlID0gaWYgcGFydC5kaXJlY3Rpb24/IHRoZW4gTWF0aC5QSSAvIDIgKiBwYXJ0LmRpcmVjdGlvbiBlbHNlIDBcbiAgICBcbiAgICBpZiBwYXJ0LnNwcml0ZT9cbiAgICAgIEBzcHJpdGUuYWRkQ2hpbGQocGFydC5zcHJpdGUpXG4gICAgICBAc3ByaXRlLnJvdGF0aW9uID0gYW5nbGVcbiAgICBcbiAgICBpZiBwYXJ0LnNoYXBlP1xuICAgICAgc2hhcGVQb3NpdGlvbiA9IFtwYXJ0LnggKyBAb2Zmc2V0WzBdLCBwYXJ0LnkgKyBAb2Zmc2V0WzFdXVxuICAgICAgQGJvZHkuYWRkU2hhcGUocGFydC5zaGFwZSwgc2hhcGVQb3NpdGlvbiwgYW5nbGUpXG4gICAgICBAYm9keS5tYXNzICs9IHBhcnQubWFzc1xuICAgICAgQHJlY2VudGVyKClcblxuICAgIGlmIHBhcnQudHlwZS50aHJ1c3RlclxuICAgICAgQHRocnVzdEJhbGFuY2VyLmFkZFRocnVzdGVyKHBhcnQpXG5cbiAgcmVtb3ZlUGFydDogKHBhcnQpID0+XG4gICAgQHBhcnRzLnNwbGljZShAcGFydHMuaW5kZXhPZihwYXJ0KSwgMSlcbiAgICBpZiBwYXJ0LnRpY2s/XG4gICAgICBAdGlja2FibGVQYXJ0cy5zcGxpY2UoQHRpY2thYmxlUGFydHMuaW5kZXhPZihwYXJ0KSwgMSlcbiAgICBpZiBwYXJ0LnNwcml0ZT9cbiAgICAgIEBzcHJpdGUucmVtb3ZlQ2hpbGQocGFydC5zcHJpdGUpXG4gICAgaWYgcGFydC5zaGFwZT9cbiAgICAgIEBib2R5LnJlbW92ZVNoYXBlKHBhcnQuc2hhcGUpXG4gICAgaWYgcGFydC50eXBlLnRocnVzdGVyXG4gICAgICBAdGhydXN0QmFsYW5jZXIucmVtb3ZlVGhydXN0ZXIocGFydClcbiAgICBAYm9keS5tYXNzIC09IHBhcnQubWFzc1xuICAgIEByZWNlbnRlcigpXG5cbiAgIyBSZWNhbGN1bGF0ZSB0aGUgY2VudGVyIG9mIG1hc3NcbiAgcmVjZW50ZXI6ID0+XG4gICAgYmVmb3JlID0gW0Bib2R5LnBvc2l0aW9uWzBdLCBAYm9keS5wb3NpdGlvblsxXV1cbiAgICBAYm9keS5hZGp1c3RDZW50ZXJPZk1hc3MoKVxuICAgIGR4ID0gQGJvZHkucG9zaXRpb25bMF0gLSBiZWZvcmVbMF1cbiAgICBkeSA9IEBib2R5LnBvc2l0aW9uWzFdIC0gYmVmb3JlWzFdXG4gICAgYmVmb3JlTG9jYWwgPSBAd29ybGRUb0xvY2FsKGJlZm9yZSlcbiAgICBAb2Zmc2V0WzBdICs9IGJlZm9yZUxvY2FsWzBdXG4gICAgQG9mZnNldFsxXSArPSBiZWZvcmVMb2NhbFsxXVxuICAgIGNvbnNvbGUubG9nIFwicmVjZW50ZXJlZDogI3tiZWZvcmVMb2NhbFswXX0sICN7YmVmb3JlTG9jYWxbMV19XCJcblxuICAjIENvbnZlcnQgZ3JpZCBjb29yZGluYXRlcyB0byBsb2NhbCBwaHlzaWNzIGNvb3JkaW5hdGVzXG4gIGdyaWRUb0xvY2FsOiAocG9pbnQpID0+XG4gICAgcmV0dXJuIFtwb2ludFswXSArIEBvZmZzZXRbMF0sIHBvaW50WzFdICsgQG9mZnNldFsxXV1cblxuICAjIENvbnZlcnQgbG9jYWwgcGh5c2ljcyBjb29yZGluYXRlcyB0byB3b3JsZCBjb29yZGluYXRlc1xuICBsb2NhbFRvV29ybGQ6IChwb2ludCkgPT5cbiAgICB3b3JsZCA9IFswLCAwXVxuICAgIEBib2R5LnRvV29ybGRGcmFtZSh3b3JsZCwgcG9pbnQpXG4gICAgcmV0dXJuIHdvcmxkXG5cbiAgIyBDb252ZXJ0IHdvcmxkIGNvb3JkaW5hdGVzIHRvIGxvY2FsIHBoeXNpY3MgY29vcmRpbmF0ZXNcbiAgd29ybGRUb0xvY2FsOiAocG9pbnQpID0+XG4gICAgbG9jYWwgPSBbMCwgMF1cbiAgICBAYm9keS50b0xvY2FsRnJhbWUobG9jYWwsIHBvaW50KVxuICAgIHJldHVybiBsb2NhbFxuXG4gICMgQ29udmVydCBzaGlwIGdyaWQgY29vcmRpbmF0ZXMgdG8gd29ybGQgY29vcmRpbmF0ZXNcbiAgZ3JpZFRvV29ybGQ6IChwb2ludCkgPT5cbiAgICByZXR1cm4gQGxvY2FsVG9Xb3JsZChAZ3JpZFRvTG9jYWwocG9pbnQpKVxuXG4gICMgUmV0dXJuIHRoZSB2ZWxvY2l0eSBvZiB0aGUgc2hpcCBhdCBhIHdvcmxkIHBvaW50XG4gIHZlbG9jaXR5QXRXb3JsZFBvaW50OiAocG9pbnQpID0+XG4gICAgIyBiYXNlIGxpbmVhciB2ZWxvY2l0eVxuICAgIFt4bCwgeWxdID0gQGJvZHkudmVsb2NpdHlcblxuICAgICMgcmVsYXRpdmUgcG9zaXRpb25cbiAgICB4ID0gcG9pbnRbMF0gLSBAYm9keS5wb3NpdGlvblswXVxuICAgIHkgPSBwb2ludFsxXSAtIEBib2R5LnBvc2l0aW9uWzFdXG5cbiAgICAjIHJlbGF0aXZlIGFuZ2xlXG4gICAgdGhldGEgPSBNYXRoLmF0YW4yKHksIHgpICsgTWF0aC5QSSAvIDJcblxuICAgICMgdGFuZ2VudGlhbCB2ZWxvY2l0eVxuICAgIHIgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSlcbiAgICB0YW5nZW50aWFsU3BlZWQgPSBAYm9keS5hbmd1bGFyVmVsb2NpdHkgKiByXG4gICAgeHQgPSBNYXRoLmNvcyh0aGV0YSkgKiB0YW5nZW50aWFsU3BlZWRcbiAgICB5dCA9IE1hdGguc2luKHRoZXRhKSAqIHRhbmdlbnRpYWxTcGVlZFxuXG4gICAgcmV0dXJuIFt4bCArIHh0LCB5bCArIHl0XVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoaXAiLCJVdGlsID0gcmVxdWlyZSAndXRpbC9VdGlsJ1xuXG4jIENvbnRyb2xzIHRoZSB0aHJ1c3RlcnNcbmNsYXNzIFRocnVzdEJhbGFuY2VyXG4gIGNvbnN0cnVjdG9yOiAoQHNoaXApIC0+XG4gICAgQHRocnVzdGVycyA9IFtdXG5cbiAgIyBBZGQgYW4gZW5naW5lIHRvIGJlIGNvbnRyb2xsZWQgYnkgdGhpcyB0aHJ1c3QgYmFsYW5jZXJcbiAgYWRkVGhydXN0ZXI6ICh0aHJ1c3RlcikgPT5cbiAgICBjb25zb2xlLmxvZyBcInRocnVzdGVyIGFkZGVkXCJcbiAgICBAdGhydXN0ZXJzLnB1c2godGhydXN0ZXIpXG5cbiAgIyBSZWxpbnF1aXNoIHRocm90dGxlIGNvbnRyb2wgb2YgYW4gZW5naW5lXG4gIHJlbW92ZVRocnVzdGVyOiAodGhydXN0ZXIpID0+XG4gICAgQHRocnVzdGVycy5zcGxpY2UoQHRocnVzdGVycy5pbmRleE9mKHRocnVzdGVyKSwgMSlcblxuICAjIFNldCB0aGUgdGhyb3R0bGVzIG9mIHRoZSBlbmdpbmVzXG4gIGJhbGFuY2U6IChmb3J3YXJkPTAsIHNpZGU9MCwgdHVybj0wKSA9PlxuICAgICMgVE9ETzogQWN0dWFsbHkgbWFrZSBzdXJlIHRoZXJlIGlzIG5vIHdlaXJkIHVuYmFsYW5jZWQgc3Bpbm5pbmdcbiAgICBmb3IgdGhydXN0ZXIgaW4gQHRocnVzdGVyc1xuICAgICAgdGhyb3R0bGUgPSAwXG4gICAgICB4ID0gdGhydXN0ZXIueCAtIEBzaGlwLm9mZnNldFswXVxuICAgICAgeSA9IHRocnVzdGVyLnkgLSBAc2hpcC5vZmZzZXRbMV1cblxuICAgICAgc3dpdGNoIHRocnVzdGVyLmRpcmVjdGlvblxuICAgICAgICB3aGVuIDAgIyBmb3J3YXJkXG4gICAgICAgICAgaWYgZm9yd2FyZCA+IDBcbiAgICAgICAgICAgIHRocm90dGxlICs9IGZvcndhcmRcbiAgICAgICAgICBpZiB0dXJuID4gMCBhbmQgeCA8IDBcbiAgICAgICAgICAgIHRocm90dGxlICs9IHR1cm5cbiAgICAgICAgICBpZiB0dXJuIDwgMCBhbmQgeCA+IDBcbiAgICAgICAgICAgIHRocm90dGxlICs9IC10dXJuXG4gICAgICAgIHdoZW4gMSAjIHJpZ2h0P1xuICAgICAgICAgIGlmIHNpZGUgPiAwXG4gICAgICAgICAgICB0aHJvdHRsZSArPSBzaWRlXG4gICAgICAgICAgaWYgdHVybiA+IDAgYW5kIHkgPCAwXG4gICAgICAgICAgICB0aHJvdHRsZSArPSB0dXJuXG4gICAgICAgICAgaWYgdHVybiA8IDAgYW5kIHkgPiAwXG4gICAgICAgICAgICB0aHJvdHRsZSArPSAtdHVyblxuICAgICAgICB3aGVuIDIgIyBiYWNrd2FyZFxuICAgICAgICAgIGlmIGZvcndhcmQgPCAwXG4gICAgICAgICAgICB0aHJvdHRsZSArPSAtZm9yd2FyZFxuICAgICAgICAgIGlmIHR1cm4gPiAwIGFuZCB4ID4gMFxuICAgICAgICAgICAgdGhyb3R0bGUgKz0gdHVyblxuICAgICAgICAgIGlmIHR1cm4gPCAwIGFuZCB4IDwgMFxuICAgICAgICAgICAgdGhyb3R0bGUgKz0gLXR1cm5cbiAgICAgICAgd2hlbiAzICMgbGVmdD9cbiAgICAgICAgICBpZiBzaWRlIDwgMFxuICAgICAgICAgICAgdGhyb3R0bGUgKz0gLXNpZGVcbiAgICAgICAgICBpZiB0dXJuID4gMCBhbmQgeSA8IDBcbiAgICAgICAgICAgIHRocm90dGxlICs9IHR1cm5cbiAgICAgICAgICBpZiB0dXJuIDwgMCBhbmQgeSA+IDBcbiAgICAgICAgICAgIHRocm90dGxlICs9IC10dXJuXG4gICAgICB0aHJvdHRsZSA9IFV0aWwuY2xhbXAodGhyb3R0bGUpXG4gICAgICB0aHJ1c3Rlci5zZXRUaHJvdHRsZSh0aHJvdHRsZSlcblxubW9kdWxlLmV4cG9ydHMgPSBUaHJ1c3RCYWxhbmNlclxuIiwiUGFydCA9IHJlcXVpcmUgJ3NoaXAvUGFydCdcblxudHlwZSA9IG5ldyBQYXJ0LlR5cGUoJ1RocnVzdGVyJywgMSwgMSwgMHg2NjY2NjYpXG50eXBlLmRpcmVjdGlvbmFsID0gdHJ1ZVxudHlwZS50aHJ1c3RlciA9IHRydWVcblxuIyBQcm92aWRlcyB0aHJ1c3RcbmNsYXNzIFRocnVzdGVyIGV4dGVuZHMgUGFydFxuICBAdHlwZSA9IHR5cGVcblxuICBjb25zdHJ1Y3RvcjogKHgsIHksIEBkaXJlY3Rpb249MCkgLT5cbiAgICBzdXBlcih4LCB5LCB0eXBlKVxuICAgIEB0aHJvdHRsZSA9IDBcbiAgICBAbWF4VGhydXN0ID0gMjAwXG5cbiAgbWFrZVNwcml0ZTogKCkgPT5cbiAgICBzcHJpdGUgPSBzdXBlcigpXG4gICAgc3ByaXRlLmxpbmVTdHlsZSgwLjA4LCAweEZGQUEwMClcbiAgICBzcHJpdGUubW92ZVRvKC0xLCAtMSlcbiAgICBzcHJpdGUubGluZVRvKDAsIC0xKVxuICAgIHNwcml0ZS5yb3RhdGlvbiA9IChAZGlyZWN0aW9uICsgMikgKiBNYXRoLlBJIC8gMlxuICAgIHJldHVybiBzcHJpdGVcblxuICBzZXRUaHJvdHRsZTogKHZhbHVlKSA9PlxuICAgIEB0aHJvdHRsZSA9IHZhbHVlXG5cbiAgdGljazogKHNoaXApID0+XG4gICAgd29ybGQgPSBzaGlwLmdyaWRUb1dvcmxkKFtAeCwgQHldKVxuICAgIGFuZ2xlID0gc2hpcC5ib2R5LmFuZ2xlICsgKEBkaXJlY3Rpb24gKyAzKSAqIE1hdGguUEkgLyAyXG4gICAgcG93ZXIgPSBAdGhyb3R0bGUgKiBAbWF4VGhydXN0XG4gICAgZm9yY2UgPSBbTWF0aC5jb3MoYW5nbGUpICogcG93ZXIsIE1hdGguc2luKGFuZ2xlKSAqIHBvd2VyXVxuICAgIHNoaXAuYm9keS5hcHBseUZvcmNlKGZvcmNlLCB3b3JsZClcblxuICBjbG9uZTogKCkgPT5cbiAgICByZXR1cm4gbmV3IFRocnVzdGVyKEB4LCBAeSwgQGRpcmVjdGlvbilcblxubW9kdWxlLmV4cG9ydHMgPSBUaHJ1c3RlciIsIkVudGl0eSA9IHJlcXVpcmUgJ0VudGl0eSdcblxuIyBVdGlsaXR5IGNsYXNzIHRoYXQgbG9ncyB0aGUgZnJhbWVyYXRlIGV2ZXJ5IDMwIGZyYW1lc1xuY2xhc3MgRlBTQ291bnRlciBleHRlbmRzIEVudGl0eVxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICBAZnJhbWUgPSAwXG4gICAgQGxhc3RUaWNrID0gRGF0ZS5ub3coKVxuICAgIEBmcHMgPSA2MFxuXG4gIHRpY2s6ICgpID0+XG4gICAgQGZyYW1lKytcbiAgICBub3cgPSBEYXRlLm5vdygpXG4gICAgQGZwcyA9IDAuOSAqIEBmcHMgKyAwLjEgKiAoMTAwMCAvIChub3cgLSBAbGFzdFRpY2spKVxuICAgIEBsYXN0VGljayA9IG5vd1xuXG4gICAgaWYgQGZyYW1lICUgNjAgPT0gMFxuICAgICAgY29uc29sZS5sb2cgTWF0aC5yb3VuZChAZnBzKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZQU0NvdW50ZXJcbiIsIlxuIyBBIDIgZGltZW5zaW9uYWwgbWFwXG5jbGFzcyBHcmlkXG4gIGNvbnN0cnVjdG9yOiAtPlxuICAgIEBkYXRhID0ge31cblxuICAjIFNldCBhIHZhbHVlIGF0IGEgbG9jYXRpb25cbiAgc2V0OiAoW3gsIHldLCB2YWx1ZSkgPT5cbiAgICBAZGF0YVt4XSA/PSB7fVxuICAgIEBkYXRhW3hdW3ldID0gdmFsdWVcblxuICAjIEdldCBhIHZhbHVlIGF0IGEgbG9jYXRpb24gb3IgdW5kZWZpbmVkLlxuICBnZXQ6IChbeCwgeV0pID0+XG4gICAgQGRhdGFbeF0gPz0ge31cbiAgICByZXR1cm4gQGRhdGFbeF1beV1cblxuICAjIERlbGV0ZSB0aGUgdmFsdWUgYXQgYSBsb2NhdGlvblxuICByZW1vdmU6IChbeCwgeV0pID0+XG4gICAgQGRhdGFbeF0gPz0ge31cbiAgICBkZWxldGUgQGRhdGFbeF1beV1cbiAgICBcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkIiwiXG5cblV0aWwgPSB7XG4gIG1vZDogKGEsIGIpIC0+XG4gICAgcmV0dXJuICgoYSAlIGIpICsgYikgJSBiXG5cbiAgY2xhbXA6ICh2YWx1ZSwgbWluPS0xLCBtYXg9MSkgLT5cbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVdGlsIl19
